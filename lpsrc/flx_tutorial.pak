@set_title('Felix Tutorial')
@tdir = 'tut/examples/'
@head(1,'Preface: Authors note')
This document is literate programmed using interscript.
Although it is primarily designed
as a tutorial, almost all the code examples are complete
executable programs. This is partly so readers can run
the examples as written, but there is another purpose:
tutorial examples are expected to provide coverage
of basic language features with a graded increase
in complexity, which makes the examples excellent
regression tests. And unlike other tests, the purpose
of the examples is usually well documented.
@p()
There is another role of the tutorial during development:
it provides an excellent way to check the usability
of the language and tools: issues of ease of comprehension
and use arise more easily than when working on 
the compiler itself. Development of tutorial material
in parallel with the language specification, implementation,
hard core unit tests, and reference manual, can be seen
as a form of 'Extreme Programming', but it is better
understood as the central paradigm of 'Literate Programming'.
@p()
There is no requirement to use literate programming tools like
interscript when developing Felix code. Or any
other code. But I strongly
recommend it be considered for larger projects, 
expecially libraries. The strong integration 
provided by LP is likely to challange corporate 
procedures. And they surely need it.

@head(1,'Basic Felix 101')
This section deals with the basic concepts in Felix.

@head(2,'Hello Felix')
There is no better introduction to a programming
language than the infamous hello-world program.

@select(tangler(tdir+'tut101.flx'))
#include <std.flx>
print "Hello World\n";
@doc()
and the Felix version is simplicity itself.
The first line includes the standard library,
and the second prints the hello world message.
You'll notice that the argument to print is not
enclosed in backets.  We'll learn more about
this shortly.
@p()
To run the example, make sure you are in the
directory containing the Felix demo package,
then type:
@begin_displayed_code()
  bin/flx tut/examples/tut101
@end_displayed_code()
This produces three files:
@begin_displayed_code()
  tut/examples/tut101.hpp
  tut/examples/tut101.cpp
  tut/examples/tut101.so
@end_displayed_code()
We'll learn more about their structure later.

@head(2,'Overloading')
Felix supports overloading. To demonstrate this,
we'll make a small modification to the hello
world program. You can compile and run the
program as before, just change the example number.
@select(tangler(tdir+'tut102.flx'))
#include <std.flx>
print "Hello World ";
print 42;
print "\n";
@doc()
Here you can see that there are two procedures,
one to print strings, and one to print ints,
but they're both called 'print'.
@p()
Felix allows procedures and functions to be 
overloaded, as does C++. However, unlike C++,
Felix has no automatic conversions, and
overload matching must be exact.

@head(2,'Value declaration')
Felix allows values to be declared using the 'val'
keyword.
@select(tangler(tdir+'tut103.flx'))
#include <std.flx>
val i = 40;
val j = 2;
val k = i + j;
print k; print "\n";
@doc()
There are three values declared here, 'i','j', and 'k'.
The first two have the type 'int', because '40' and '2'
have the type int, whilst 'k' has the type 'int'
because the addition function which takes as
an argument a pair of 'int', returns an 'int'.
@p()
Notice you did not have to declare the type of
the values. This is called 'type inference':
the compiler works out the type from the initial
value for you. You can declare the type of a variable
if you want: the following program is equivalent
to the one above:
@select(tangler(tdir+'tut104.flx'))
#include <std.flx>
val i : int = 40;
val j : int = 2;
val k : int = i + j;
print k; print "\n";
@doc()
but it is never necessary for values: an initialiser
must always be given. If you do declare the type,
Felix will still deduce the type from the initialiser,
and issue an error message if the types don't agree.
@p()
Values are constants: they cannot be modified,
and, as we will see later, they cannot be addressed.

@head(2,'Variable declaration')
Felix also support mutable variables, which are
declared with the 'var' keyword.
@select(tangler(tdir+'tut105.flx'))
#include <std.flx>
var i = 1;
var j : int;
while (i < 10) 
{
  j = i + i;
  print j; print "\n";
  ++i;
};
@doc()
Like value declarations, the type of a variable
does not need to be declared if it is initialised.
However, as you can see uninitialised variables
are also permitted, and in this case the type
must be given.
@p()
You will notice the assignment in the line:
@begin_displayed_code()
  j = i + i;
@end_displayed_code()
Naturally, variables must be initialised
or assigned to before they are used, as in C.
@p()
You will also have noticed the 'while' loop,
one of the control structures Felix provides:
it appears to work the same way as a 'while' loop in C,
except that a trailing ; is strangely required.
We'll find out why later.

@head(2,'Functions')
Felix allows you to define functions,
although the syntax is different from C.
Here is an example:
@select(tangler(tdir+'tut106.flx'))
#include <std.flx>
fun mid(a:int, b:int):int =
{
  val c = (a + b) / 2;
  return c;
}
print (mid(2,4)); print "\n";
@doc()
It is clear that mid returns an int,
and you might think that 'mid' has two arguments.
This is not so. All functions in Felix have
exactly one argument. Well, almost all of them :-)
I'll explain this in the next example.

@head(2,'Tuples')
As you might guess from the title, Felix has
tuples. A tuple is a value consisting of an ordered sequence of 
two or more values, not necessarily of the same type.
Here are some examples of tuples:
@begin_displayed_code()
  1,2
  "Hello", "World"
  (1, 2.7, "Hello")
  ()
@end_displayed_code()
The comma operator constructs tuples.
While brackets are not always necessary, the comma
operator has a low precedence so tuples usually
appear in brackets. Notice there is a special
unique empty tuple '()'. There are no tuples
with one component: for all values 'a', '(a)' is 
equivalent.
@p()
Now perhaps you have guessed what I mean earlier
when I said the function mid only had a single
argument. If not, you get another chance,
studying this example, which is equivalent
to example 6.
@select(tangler(tdir+'tut107.flx'))
#include <std.flx>
fun mid(a:int, b:int):int =
{
  val c = (a + b) / 2;
  return c;
}
val x = (2,4);
print (mid x); print "\n";
@doc()
Here you can see that mid takes a single
argument which is a tuple of two ints.
@p()
A tuple is a product type: you may be
familiar with the Cartesian product of sets.
The notation for tuple types is the same,
except of course we use '*' instead of
a multiply sign: here is the declaration
of x with a type annotation:
@begin_displayed_code()
  val x : int * int = (2,4);
@end_displayed_code()
You should note that tuple construction
is not associative. Here are three
tuple value declarations with type annotations:
@begin_displayed_code()
  val x : int * int * int = (1,2,3);
  val y : (int * int) * int = ((1,2),3);
  val z : int * (int * int) = (1,(2,3));
@end_displayed_code()
These three tuples have distinct types and
values. The first has three components,
each of type int. The other two have two
components each: an int and a pair of ints,
in the two possible orderings.
@p()
The type of the empty tuple '()' is called
'unit'.
@p()
I said before that 'almost' all functions in
Felix have one argument. The tuple constructor
is the exception.
@p()
You can get at tuple components using a suffixed
dot followed a zero origin integer in brackets:
@select(tangler(tdir+'tut108.flx'))
#include <std.flx>
val x = (0,1,(3,4));
print x.(0); print " ";
print x.(1); print " ";
print x.(2).(0); print " ";
print x.(2).(1); print "\n";
@doc()
The brackets are needed so the lexer
doesn't get confused with floating point.

@head(2,'Procedures')
Felix allows you define procedures.
They're like functions, but they can't return values.
On the other hand, procedures may have side effects,
and they may read input from the driver's message
dispatch queue.
@p()
Here is an example of a procedure definition
and use:
@select(tangler(tdir+'tut109.flx'))
#include <std.flx>
proc print_newline (a:int)
{
  print a;
  print "\n";
}
print_newline 1;
@doc()
There is a special short cut for calling procedures
with unit argument: if the procedure is called
by its name, the () can be elided:
@select(tangler(tdir+'tut110.flx'))
#include <std.flx>
print 1; endl();
print 2; endl;
@doc()
There's another special shortcut, but we'll meet it later.

@head(2,'Structs')
Felix supports C like structs. A struct, like a tuple,
is a categorical product type. Unlike a tuple,
a struct is named, its members are named, and 
its members are mutable. 
@p()
Struct members can be used with C style dot notation.
Here is an example:
@select(tangler(tdir+'tut111.flx'))
#include <std.flx>

struct XY {
  x : int;
  y : int;
}

var xy : XY;
xy.x = 1;
xy.y = 2;
print xy.x; endl;
print xy.y;  endl;
@doc()
The name of a struct is also the name of a function
which constructs an object of the struct type
from a tuple consisting of values to initialise
the members in sequence. For example:
@select(tangler(tdir+'tut112.flx'))
#include <std.flx>

struct XY = {
  x : int;
  y : int;
}

val xy = XY(1,2);
print xy.x; endl;
print xy.y;  endl;

@head(2,'Unions')
Felix supports unions, but they are a bit
different to C unions. A union is a way
of merging a finite set of types into
a single type. An object of a union type
consists of a tag, identifying what type
the component has, and the actual component.
Here are some examples of unions.
@select(tangler(tdir+'tut113.flx'))
#include <std.flx>

union parity =
  | Odd
  | Even
;

union int_option =
  | Some of int
  | None
;

val x = Odd;
val y = Some 1;

@doc()
We'll see how to actually use unions in the
next section. But note first that the parity
example is very similar to a C enumeration.
The names of the union components are
called constructors by convention.
They have two roles: they represent the
constant value of the tag indicating 
which component we're talking about:
tags values are assigned sequentially,
starting at 0.
@p()
In their second role, the constructors
are considered functions, so that
Some is a function with type:
@begin_displayed_code()
  int -> int_option
@end_displayed_code()
It is important to note that the constructor
names are visible in the enclosing space,
unlike struct component names.

@head(2,'Pattern Matching Unions')
The only way to get at the current component
of a union is by pattern matching. Here is an example: 
@select(tangler(tdir+'tut114.flx'))
#include <std.flx>
union int_option =
  | Some of int
  | None
;

val y = Some 1;

match (y) with 
  | Some ?i =>
    {
      print "Some "; 
      print i; 
    };
  | None =>
    {
      print "None"; 
    };
endmatch;
endl;

@doc()
Notice that the value 'i' in the line
@begin_displayed_code()
  | Some ?i:
@end_displayed_code()
can be used in the handler for that case.
This is how we get the 'int' out of the Some option.
The 'i' is scoped so it can only be seen inside
the handler for the Some case. Also note that
there is no need to 'break' at the end of a 
case handler: control jumps to the end of the
match statement when the handler is finished,
it never falls through.
@p()
The question mark is used to indicate a pattern
variable.
@head(2,'Pattern Matching Tuples')
It is also possible to match tuples.
Here is an example:
@select(tangler(tdir+'tut115.flx'))
#include <std.flx>
val x = 1,2,(3,4);
match (x) with
  | (?x,_,?z) =>
  {
    print x; 
    print ", ";
    match (z) with
      | (?a,?b) =>
      {
        print "(";
        print a; 
        print ", ";
        print b; 
        print ")";
      };
    endmatch;
  };
endmatch;
endl;
@doc()
Notice the use of the special pattern '_', which matches
something without naming it.

@head(2,'Basic Bindings')
In the previous examples, we've use the Felix standard
library. It's time to look at how it works.
@p()
The Felix language is somewhat novel in that there
are no primitive data types, not even bool.
Instead, Felix uses binding definitions to declare
abstract primitive data types, and bind them to
concrete C++ data type.
@p()
Here is an example of a binding. 
@select(tangler(tdir+'tut116.flx'))
#include <std.flx>
header """
// This is C++ code!
class gauss;

struct gauss {
  int x;
  int y;

  gauss() : x(0), y(0) {}
  gauss(int _x, int _y) : x(_x), y(_y) {}

  gauss operator +(gauss z) const 
  {
    return gauss(x+z.x, y+z.y);
  }
  gauss operator *(gauss z) const
  {
    return gauss (x *z.x - y*z.y, x*z.y + y*z.x);
  }
};
""";

// Now the Felix binding
type gauss = "gauss";
proc set : &gauss * gauss = "*$1 = $2;";
fun add: gauss * gauss -> gauss = "$1 + $2";
fun mul: gauss * gauss -> gauss = "$1 * $2";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";
fun real: gauss -> int = "$1.x";
fun imag: gauss -> int = "$1.y";

// Now a pure Felix procedure
proc print(z:gauss) { 
  print "(";
  print (real z);
  print ", ";
  print (imag z);
  print ")";
}

// And two pure Felix functions
fun sqr(z:gauss):gauss = {
  return z * z;
}

fun norm(z:gauss): int = {
  return 
    real z * real z + imag z * imag z
  ;
}

// Finally, some test code
val z1 = mkgauss(1,2);
val z2 = z1 + z1;
val z3 = sqr z2;
val n = norm z3;
print z1; endl;
print z2; endl;
print z3; endl;
print n; endl;

@doc()
There are lots of things to note here.
@p()
First, the header command 

@begin_displayed_code()
  header """ .... """
@end_displayed_code()

specifies text to
be emitted literally in the generated C++.
In this case, we emit a C++ class defining
a basic gaussian integer type.
@p()
Next, we define the felix type gauss.

@begin_displayed_code()
  type gauss = "gauss";
@end_displayed_code()

The definition specifies the Felix name, gauss,
and then the C++ name, which also happens to be
gauss.
@p()
Then we define the semantics of our new primitive
by primitive functions and procedures which allow
us to manipulate it. Theses consists of a function
or procedure name, a type, and the C++ code to
generate when the function or procedure is called.

@begin_displayed_code()
proc set : &gauss * gauss = "*$1 = $2;";
fun add: gauss * gauss -> gauss = "$1 + $2";
fun mul: gauss * gauss -> gauss = "$1 * $2";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";
fun real: gauss -> int = "$1.x";
fun imag: gauss -> int = "$1.y";
@end_displayed_code()

In the definition string, $1 means the first argument
of the argument tuple, and $2 means the second, etc.
@p()
If the type of an argument component is prefixed
by a &, this means that a pointer is passed.
@p()
You should note that there is a predefined
correspondence between Felix operators and certain
function or procedure names. The ones we have
used here are:
@begin_displayed_code()
  Operator  Name
  =         set
  +         add
  *         mul
  ==        eq
@end_displayed_code()
@p()
Finally, note carefully that functions bind to C++
expressions, whilst procedures bind to C++ statements.
This is why the set procedure binding contains
a ; inside the string, as well as after it.
You can use a compound statement as well.

@head(2,'Seamless Binding')
Felix purports to support a property called seamless binding.
What this means is that the boundary between C++ and Felix
code is fluid. To illustrate this, lets consider
a version of the above code written entirely in Felix.

@select(tangler(tdir+'tut117.flx'))
#include <std.flx>
struct gauss = {
  x : int;
  y : int;
}

proc set ( lhs: &gauss, rhs: gauss )
{
  (*lhs).x = rhs.x;
  (*lhs).y = rhs.y;
}

fun add (a:gauss, b:gauss): gauss = {
  return gauss(a.x+b.x, a.y+b.y);
}

fun mul (a:gauss, b:gauss): gauss = {
  return gauss(a.x+b.x - a.y+b.y, a.x*b.y + a.y*b.x);
}

fun mkgauss (a:int,b:int):gauss = { return gauss(a,b); }
fun real (z:gauss):int = { return z.x; } 
fun imag (z:gauss):int = { return z.y; }

proc print(z:gauss) { 
  print "(";
  print (real z);
  print ", ";
  print (imag z);
  print ")";
}

fun sqr(z:gauss):gauss = {
  return z * z;
}

fun norm(z:gauss): int = {
  return 
    real z * real z + imag z * imag z
  ;
}

val z1 = mkgauss(1,2);
val z2 = z1 + z1;
val z3 = sqr z2;
val n = norm z3;
print z1; endl;
print z2; endl;
print z3; endl;
print n; endl;

@doc()
The difference between these two programs is that
in the second one, gauss is a concrete 
non-primitive Felix data type.
In the first program, gauss is an abstract 
data type, together with a binding specifying
the semantics in C++.
@p()
As you can guess, the whole of the program
could have been written in C++ rather than 
Felix.
@p()
It's up to you to choose what parts of your Felix
program are written directly in C++, and which parts
are written in Felix: since Felix is a C++ code generator,
it all ends up as C++ anyhow.
@p()
Usually, you'll write Felix, except when you have 
an existing code base containing useful types
you need to work with. 

@head(2,'Operator dot')
It may look as if Felix knows how to access
the components of a Felix struct value using
operator dot. Strangely enough, this is not the
case! When you write:
@begin_displayed_code()
  expr.name
@end_displayed_code()
in a value context, it is translated to the
function application:
@begin_displayed_code()
  get_name expr
@end_displayed_code()
To illustrate this is really the case,
consider the following example.

@select(tangler(tdir+'tut118.flx'))
#include <std.flx>

// part 1
header """
struct gauss 
{ 
  int x; 
  int y; 
  gauss() : x(0), y(0) {}
  gauss(int _x, int _y) : x(_x), y(_y) {}

};
""";

type gauss = "gauss";
fun get_x: gauss -> int = "$1.x";
fun get_y: gauss -> int = "$1.y";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";

val z = mkgauss(1,2);
print z.x;
print ", ";
print z.y;
endl;

// part 2
struct X {
  x : int;
}
val i = X(1);
print (get_x i);
endl;

@doc()
In part 1, the functions get_x and get_y
are defined by binding, but the dot notation
is used to call them.
@p()
In part 2, the functions get_x and get_y are
defined by defining a struct, and they're
called directly, without the dot notation.
@p()
The dot notation is just syntactic sugar for
calling a get function.
@p()
What is more, the struct definition is just
syntactic sugar for defining an abstract type
with some get functions (as well as a 
constructor).
@p()
What this means is that for an arbitrary C++ type,
you can create an abstract binding, and define
get methods which can be called using dot notation.
Just name the methods 'get_' something.
@p()
It is also possible to access a Felix struct from
C++, although we'll defer disucssion of the C++
representation of Felix data structures until later.
[The C++ name of the struct type is not the same
as the Felix name]

@head(2,'Inductive types')
Felix supports inductive types such as lists.
Here is a list of ints.

@select(tangler(tdir+'tut119.flx'))
#include <std.flx>

union float_list =
  | Empty
  | Cons of double * float_list
;

val t0 = Empty;
val nxt = (100.1,t0);
val t1 = Cons nxt;
val t2 = Cons (200.2,t1);

proc print (a: float_list) 
{
  match a with 
  | Empty => print "[]";
  | Cons (?i, ?tail) =>
    {
      print i; 
      print " "; 
      print tail;
    };
  endmatch;
}

print t2; endl;

@doc()
A more interesting example is now given.
Here, we use a recursive routine to build the list,
and an iterative routine to reverse it.

@select(tangler(tdir+'tut120.flx'))
#include <std.flx>

union int_list =
  | Empty
  | Cons of int * int_list
;

proc print (a: int_list) 
{
  match a with
  | Empty => print "[]";
  | Cons (?i,?tail) =>
    {
      print i; 
      print " "; 
      print tail;
    };
  endmatch;
}

fun mk(i: int, tl:int_list):int_list =
{
  if(i>0) then
    return mk(i-1,Cons(i,tl));
  else return tl;
  endif;
}

val a = mk(10,Empty);
print "List= "; print a; endl;

fun rev(lst:int_list):int_list =
{
  var result = Empty;
  proc aux(lst:int_list)
  {
    match lst with
    | Empty => {} ;
    | Cons (?head,?tail) =>
      {
        result = Cons(head,result); 
        aux(tail);
      };
    endmatch;
  }
  aux(lst);
  return result;
}

print "Reversed= "; print (rev a); endl;

@head(2,'Higher order Functions')
In Felix, functions and procedures are first class:
they may accept functions or procedures as arguments,
functions may return them, and you can have variables
of function or procedure type.
@p()
In particular, a function or procedure may be
defined inside another function or procedure,
and it may still use any values or variables
defined in that function or procedure, even when
it is returned by it.
@p()
Note that when the returned function or procedure
is called later, the values of variables may have
changed since the time that it was passed.
@p()
Here is an example, beware this example
contains quite a lot of subtle features!

@select(tangler(tdir+'tut121.flx'))
#include <std.flx>

var j = 2;

fun get_printer(i:int): unit->void  = {
  proc print() { print (i+j); }
  return print of (unit);
}

val print_i = get_printer(40);
print_i(); endl;
j = 3;
print_i(); endl;

@doc()
There are a couple of things to notice.
The function return type is given as

@begin_displayed_code()
  unit->void
@end_displayed_code()

This is the notation for a procedure type accepting
a unit argument. 
@p()
Notice also that the return value is

@begin_displayed_code()
  print of (unit)
@end_displayed_code()

This is the name of the function called 'print' 
which accepts a unit argument. Felix can perform
overload resolution when a function name is applied
to an argument, by inspecting the type of the argument.
@p()
In other circumstances, you have to specify the type
of the argument.
@p()
There is a subtle point of the overloading system
here. The procedure 'print of (unit)' actually
calls the procedure 'print of (int)'. Now if you are
used to C++, you may wonder how this would work:
the search for 'print of (int)' stats by finding
'print of (unit)', and in C++ it would stop right there
and report an error. In Felix, if overload resolution
for an unqualified function or procedure name fails,
the enclosing scope is examined. This 'overloading
across scopes' is allows you to extend an overload
set locally. The special rule does not apply
to qualified names (where the name must be found
in the designated scope). [I may change this!]
@p()
Another thing to notice is that
the call to print_i cannot be abbreviated by leaving
the () off. This is because print_i is a function
value, not the name of a function. 
@p()
More precisely, the function specification for p of (unit)
is used to build a function closure: this consists of the
code body of the function, together with the environment
at the point of definition and the time the closure
is created: it binds to the current 'activation record'
or 'stack frame' of the enclosing function 'get_printer'.
And because that environment contains the value 'i'
initialised to 30, and the variable 'j', it will
print 40 + j as an answer when called. This is 42
the first time, since at that time j is 2, and 43 the
second time, since j is then 3.

@head(2,'Currying')
Consider the following example:
@select(tangler(tdir+'tut122.flx'))
#include <std.flx>

fun f4(i4:int): int->int->int->int = {
  fun f3(i3:int): int->int->int = {
    fun f2(i2:int): int->int = {
      fun f1(i1:int): int = {
        return i1+i2+i3+i4;
      }
      return f1 of (int);
    }
    return f2 of (int);
  }
  return f3 of (int);
}

print (f4 1 2 3 4); endl;
print ((f4 1 2 3) 4); endl;
print ((f4 1 2) 3 4); endl;
print ((f4 1) 2 3 4); endl;
print (((f4 1) 2 3) 4); endl;
print (((f4 1 2) 3) 4); endl;

val curry = f4 1 2;
print (curry 3 4); endl;

@doc()
You should note that -> is right associative,
so that

@begin_displayed_code()
  int->int->int->int
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  int->(int->(int->int))
@end_displayed_code()
On the other hand, application is left associative,
so that
@begin_displayed_code()
  f4 1 2 3 4
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  (((f4 1) 2) 3) 4
@end_displayed_code()

Note that the 'partial' applications such as
shown by the brackets, are of course closures
of the inner functions, and you can use them
to initialise values, assign them to variables
or pass them to functions. Such 'partial'
application is called currying (after the mathematician
Howard Curry, who invented the lambda calculus).
@p()
While this is a perfectly good defintion,
but there is a lot of housekeeping going on.
Felix provides syntactic sugar that makes it easier
to declare functions suitable for currying.
Here is the equivalent code, using this sugar:

@select(tangler(tdir+'tut123.flx'))
#include <std.flx>

fun f4(i4:int) (i3:int) (i2:int) (i1:int): int = {
  return i1+i2+i3+i4;
}

print (f4 1 2 3 4); endl;
print ((f4 1 2 3) 4); endl;
print ((f4 1 2) 3 4); endl;
print ((f4 1) 2 3 4); endl;
print (((f4 1) 2 3) 4); endl;
print (((f4 1 2) 3) 4); endl;

val curry = f4 1 2;
print (curry 3 4); endl;

@doc()
You may remember eariler I said that
all Felix accepted exactly one argument,
with one exception: tuple constructors.
@p()
It is conventional to say that a function like
'f4' above has 4 arguments. Of course,
you know that this isn't the case: it really
has one argument and returns a function.
It is also sometimes said that f4 has arity 4,
meaning you can chain applications 4 times,
until you get a non-function result.
@p()
Note that the notation above can be used for
procedures as well: of course, all the partial
applications except the last return functions,
and the last one returns a procedure.
@p()
It is a matter of style whether you write
functions in the curried form or not.
Any function accepting a tuple can be changed
to a currified function accepting the components
in sequence. This is conventional in some
functional programming languages (like Ocaml),
but is less heavily used in others (like SML).
@p()
In the current implementation of Felix, currified
functions are more expensive than ones accepting
tuples, but the currified version is easier to
curry :-)
@p()
As an exercise, write a function that given an
arbitrary function f accepting a tuple of 3 ints,
returns an equivalent currified version of it
that accepts 3 arguments.
@p()
What you have done is called eta-expansion.
It is necessary even for currified functions
if you want to fix the second argument, but
leave the first free.

@# @head(2,'Regular expressions')
@# The standard library contains types and functions
@# for regular expression matching. Here's an example:
@# 
@# @select(tangler(tdir+'tut124.flx'))
@# #include <std.flx>
@# #include <boost.flx>
@# 
@# val rex = regex_of_string("(a|b)*abb");
@# val matched = regex_match(rex,"aabbabababb");
@# print matched; endl;
@# 
@# @doc()
@# Note that to make this work, you must edit the
@# bin/flx script so that the directory containing
@# the boost library is set correctly. The binary
@# package provided with this demo uses boost_1_22_0,
@# you must use that version of boost. You must build
@# the shared version of the regex library using
@# @begin_displayed_code()
@#   cd boost_1_22_0/libs/regex/build/
@#   make -f gcc-shared.mak
@# @end_displayed_code()
@# 
@# Now you've got that to work, lets look at currying.
@# There is a currified version of regex_match in the boost
@# library. Here's why it is useful:
@# 
@# @select(tangler(tdir+'tut125.flx'))
@# #include <std.flx>
@# #include <boost.flx>
@# 
@# val rex = regex_of_string("(a|b)*abb");
@# val matchit = regex_match(rex);
@# print (matchit "ababababb"); endl;
@# print (matchit "No match"); endl;
@# 
@# proc print_if_matches(matcher:string->bool) (s:string)
@# {
@#   if (matcher s) then 
@#   {
@#     print s; endl;
@#   };
@#   endif;
@# }
@# 
@# val p = print_if_matches matchit;
@# p "Hello";
@# p "ababa";
@# p "abbabbabb";
@# p "ababababb";
@# 
@# @doc()
@# As you can see, matchit matches a particular 
@# regular expression, so you don't have to keep
@# specifying it. You can also pass it to a function
@# that needs a string matcher, hiding the method by which
@# the matching is done. We pass it to print_if_matches,
@# which again partially applied to define the new function p.
@# @p()
@# I hope you can see uses for the combination of power
@# obtained by treating functions as first class citizens,
@# and by use of currying. The technique is used extensively
@# in functional programming languages.
@# 
@# @head(2,'More on regular expressions')
@# Sick of writing doubled up sloshes in regular expressions?
@# Felix provides Python style string literals, including
@# raw strings. Strings prefixed by an r are called raw strings,
@# slosh escapes are not processed. This makes it easier
@# to define regular expressions. For example:
@# 
@# @select(tangler(tdir+'tut126.flx'))
@# #include <std.flx>
@# #include <boost.flx>
@# val rex = regex_of_string("\\A(\\d{3,4})[- ]?(\\d{4})[- ]?(\\d{4})[- ]?(\\d{4})\\z");
@# val machine_format = merge_pattern_of_string ("\\1\\2\\3\\4");
@# val human_format = merge_pattern_of_string("\\1-\\2-\\3-\\4");
@# val credit_no_1 = "1234-5678-9012-3456";
@# val credit_no_2 = "6676688-7765-1111";
@# val bad_no = "XYZ";
@# 
@# print (regex_merge rex machine_format credit_no_1); endl;
@# print (regex_merge rex human_format credit_no_1); endl;
@# print (regex_merge rex machine_format credit_no_2); endl;
@# print (regex_merge rex human_format credit_no_2); endl;
@# print (regex_merge rex human_format bad_no); endl;
@# 
@# // again, using raw strings:
@# 
@# val rex1 = regex_of_string(r"\A(\d{3,4})[- ]?(\d{4})[- ]?(\d{4})[- ]?(\d{4})\z");
@# val machine_format1 = merge_pattern_of_string (r"\1\2\3\4");
@# val human_format1 = merge_pattern_of_string(r"\1-\2-\3-\4");
@# 
@# print (regex_merge rex1 machine_format1 credit_no_1); endl;
@# print (regex_merge rex1 human_format1 credit_no_1); endl;
@# print (regex_merge rex1 machine_format1 credit_no_2); endl;
@# print (regex_merge rex1 human_format1 credit_no_2); endl;
@# print (regex_merge rex1 human_format1 credit_no_2); endl;
@# 

@head(2,'Modules')
Most modern languages support packaging of related
specifications into some kind of module, and Felix
is no exception. Basic module use is quite simple:
@select(tangler(tdir+'tut127.flx'))
#include <std.flx>
val top = 1;
module A {
  val a = top + 1;
  module B {
    val b = a + 1;
  }
}

print top; endl;
print root::top; endl;
print A::a; endl;
print A::B::b; endl;
@doc()

This example illustrates the simple use of modules,
including module nesting, and use of qualified names
to access module components.
@p()
You can put anything except export declarations in 
modules that you can put at the top level, and for a
very simple reason: the top level is, in fact,
a module itself.
@p()
When qualified name is used, the qualifier specifies
the module in which the next name must be found.
Qualification inhibits upscope overloading.
@p()
Note the keyword 'root' is used to name the top-level
module.
@p()
Finally, it is vital to understand that Felix
scopes act like sets of names. Names are always defined
in parallel, and visible to all definitions in the scope,
so that all definitions are mutually recursive.
For this reason, forward declarations are never needed.
The following example is quite legal:

@begin_displayed_code()
  x = 1;
  y = x;
  var y:int;
  var x:int;
@end_displayed_code()

This is much like the 'rewriting rule' for C++ class member
functions. Note, however, that executable code
is still sequential! Thus, the order of value and variable
definition does matter: initialisations are executed
in order of writing. 

@head(2,'Koenig Lookup')
Consider the following example:
@select(tangler(tdir+'tut128.flx'))
#include <std.flx>

module A {
  struct X {
    x: int;
  }
}
val e = A::X(5);
print e.x; endl;
@doc()

There is a subtle point here in this code.
(Isn't there always?) Recall that
@begin_displayed_code()
  e.x
@end_displayed_code()
is transformed by desugaring to the function application
@begin_displayed_code()
  get_x e
@end_displayed_code()
If that is so, how is it that the get_x of (A::X)
is found, when it is not visible in the top level scope?
The answer is that I told a white lie before.
@p()
What really happens is that e.x is transformed
into a method application. This is exactly the
same as a function application, except that
overloading uses a special kind of lookup
for the method name, called Koenig Lookup,
after its inventor, Andrew Koenig.
@p()
Koenig lookup works by searching the module
in which the type of the expression e is 
defined: in Felix the type must be generative,
which means it must be a declared type
such as a named struct or union
and not an implicitly defined type like a tuple,
pointer, or function type.
@p()
In the example, 'get_x' is defined in the module X,
because A is defined in the module X, and since
e has type 'A', Felix looks in module X for 'get_x'.
@p()
Koenig lookup only works for method calls, that is,
when you use the syntax e.x.

@head(2,'Dynamic modules')
Modules can contain executable code, not just declarations.
The executable code of a module is wrapped in an
initialisation function. This function is called
automatically by Felix, when the enclosing
scope is initialised. The top level module's
initialisation routine must be called manually
by the driver program.
@p()
Modules can be nested in functions or procedures. 
In this case the data lives in the function
or procedure stack frame, and the module is
initialised every time the function is called.
@p()
[Add more later as features are implemented]

@head(2,'Pointers')
Felix supports pointers. The type of a pointer to T is
denoted:
@begin_displayed_code()
  &T
@end_displayed_code()
A pointer can be created by addressing a variable
using the notation:
@begin_displayed_code()
  &v
@end_displayed_code()
Pointers can be dereferenced using the usual syntax:
@begin_displayed_code()
  *p
@end_displayed_code()
and there is the usual arrow notation:
@begin_displayed_code()
  p->x
@end_displayed_code()
which means the same as
@begin_displayed_code()
  (*p).x
@end_displayed_code()
@p()
Only variables, not values, are addressable.
Pointers are used to implement assignment.
You have seen many examples of assignment:
@begin_displayed_code()
  var v : T;
  v = e;
@end_displayed_code()
What you didn't know was that the assignment
operator is just syntactic sugar for
the procedure call:
@begin_displayed_code()
  set(&v,e);
@end_displayed_code()
This procedure is defined automatically
for structs, unions, and function and procedure
closures, that is, for Felix types; but you must
define it manually for abstract types including
primitives. The usual definition is:
@begin_displayed_code()
  type T = "T";
  proc set: &T * t = "*$1=$2;"
@end_displayed_code()
Note that all Felix primitives must be C++ assignable
and implicitly default constructible,
since in the generated code all values and variables 
are first declared without an initialiser and 
then assigned to. A Felix set function, however,
is not required, and its absence can be used
to prevent assignment to variables of a Felix type.
@p()
It is important to note that in Felix,
you can take the address of any variable,
and safely pass the pointer around, without
fear it will dangle: this includes pointers
to function and procedure local variables.
@p()
This all works because Felix uses a garbage collector,
but you should note that because the frame containing
an object must be kept alive if there is a pointer into
it, returning a pointer to a function local variable
may prevent other local variables in the same
frame from being destroyed.
@p()
Here is an example:

@select(tangler(tdir+'tut129.flx'))
#include <std.flx>

fun pone (): &int = 
{
  var x : int = 1;
  return &x;
}

var p1 = pone();
print (*p1); endl;
*p1 = 2;

print (*p1); endl;

@doc()
You should note that Felix pointers consist
of two C pointers: a pointer to the variable,
and a pointer to the frame containing the variable.
It is this frame pointer which the garbage collector
tracks. Although Felix pointers do not have to
be initialised, the frame pointer component
of the representation is always initialised to NULL
so that the garbage collector doesn't chase off into
the wild blue yonder.

@head(2,'The ubiquitous goto')
Felix allows statements to be labelled,
and provides a goto statement.

@select(tangler(tdir+'tut130.flx'))
#include <std.flx>
print "start"; endl;
var i = 1;
start_loop:>
  if (not (i<10)) then goto end_loop; endif;
  print i; endl;
  i++;
  goto start_loop;
end_loop:>
  print "finished"; endl;
  
@doc()
Note that labels require a terminating :> rather
that C's plain :. 
@p()
The above code is rougly
what felix generates for the equivalent while loop.
Goto is not recommended programming style,
but it is an essential primitive, and it is used
by the Felix compiler when desugaring control
structures. 
@p()
It is also useful for inventing your own
control structures: together with higher
order functions and currying, you can do
this quite easily in Felix, as we shall soon see.
@p()
But first consider the following example:

@select(tangler(tdir+'tut131.flx'))
#include <std.flx>

var x = 1;
proc run()
{
  proc check()
  {
    if(x!=1) then goto bad_x; endif;
  }
  check();
  print "good x"; endl;
  x = 2;
  check();
  print "good x"; endl;
  goto finished;

bad_x:>
  print "bad_x"; endl;

finished:>
  print "finished"; endl;
}
run();

@doc()
In this example, you see what is called a non-local
goto: a jump into an enclosing procedure. Such jumps
are quite OK.
@p()
What you can't do is jump out of a function,
that is, across a function boundary. 
[the reason will become clear much later]
@p()
There is another interesting fact. A procedure
nested in a module, including the top level,
cannot jump to a label in the module.
The reason is that executable code in a module,
including any labels, are wrapped in an initialisation
procedure, which is called where the module
is defined. That initialisation procedure does not
have the procedures defined in the module nested in it,
instead, they're at the same level as the initialisation
procedure. You can't jump into the initialisation procedure
because it mightn't be active at the time the other
procedure is called.

@p()
[This may change: a better model would be a that a 
module returns the enities exported
from it as a tuple: the procedures would
then be nested in the initialisation routine.
This would also make modules first class objects,
with a type described more or less as a tuple.
In turn this allows dynamic binding.]

@head(2,'Dynamic exception handling using goto')
Non local gotos are very useful for a form of
exception handling. Consider the following example:

@select(tangler(tdir+'tut132.flx'))
#include <std.flx>

proc bad_calc(err: int -> void) 
{
  // do some work, detect an error
  err 1; // throw exception
}

proc main
{
  proc err(errno:int) 
  {
    print "error "; print errno;
    print " -- aborting"; endl;
    goto resume;
  }
  bad_calc err of (int);
  print "no error"; endl;
resume:>
  print "error handled, continuing"; endl;
}
main;

@doc()
Here, we establish a handler for an error,
which is effectively established at the
label resume: the handler is passed explicitly
to the routine which may 'raise' it.


@head(2,'Static exception handling using goto')
Non local gotos are very useful for another form of
exception handling. Consider the following example:

@select(tangler(tdir+'tut133.flx'))
#include <std.flx>

proc main
{
  // do something

  // raise err1
  err 1; goto resume;
 
  // do something else

  // exception handlers
  proc err(errno:int)
  {
    print "error "; print errno;
    print " -- aborting"; endl;
    goto resume;
  }
resume:>
  print "error handled, continuing"; endl;
}

@head(2,'Exceptions')
I've shown you static exception handling using goto
for a reason: Felix provides syntactic sugar for this.
Here is the same program, using the sugar:

@select(tangler(tdir+'tut134.flx'))
#include <std.flx>

proc main
{
  attempt
  {
    // do something

    raise err 1;
   
    // do something else

  };
  exceptions
  {
    err(errno:int)
    {
      print "error "; print errno;
      print " -- aborting"; endl;
    }
  }
  endattempt;
  print "error handled, continuing"; endl;
}
main;

@doc()
There's no goto visible, nor a resume label,
but the effect is the same. It looks like
exception handling, but its really a kind
of labelled break. The key difference between
static and dynamic exception handling is that
static handlers are bound at compile time:
no run time type information is required.
@p()
Dynamic exception handling is better done using
the idiom shown earlier in which the handlers
are passed explicitly.
@p()
Naturally, because this is just sugar, you can
deduce that it is possible to pass arguments
to handlers, and indeed to overload them,
indeed it is possible to raise an exception
which is handled several levels away,
skipping past exception blocks which do not
contain a matching handler: the resume point
is always after the block exceptions block
containing the handler.
@p()
A key property of static exceptions is that
if there is no matching handler, a compile
time error resuts, and the handler will always
be found in a scope enclosing the raise statement,
or, the exception list following the attempt
immediately enclosing it: in other words,
the handler is always 'nearby'.

@head(2,'Procedure Values Again')
We've seen the advantages of higher order 
functions and procedures. It is possible
to define anonymous procedure and function values
literally, as in the next example,
they're called lambdas, after the lambda calculus:

@select(tangler(tdir+'tut135.flx'))
#include <std.flx>
val f = fun(a:int):int = { return a * a; };

print (f 1); 
endl;

print 
(
  (fun(a:int):int = { return a * a; })
  1
); 
endl;

proc thrice(p:unit->void) { p(); p(); p(); }
thrice ( proc() { print 3; endl; } );
thrice ( proc   { print 3; endl; } );
thrice          { print 3; endl; };
{ print "finished"; endl; };

@doc()
Mickey Mouse! Checkout the shortcut on the
second last line. You can just write
statements in curly brackets for an
anonymous procedure taking unit argument,
you can leave off the
@begin_displayed_code()
  proc() // or
  proc
@end_displayed_code()
But why does the last line work?
The answer is: this is a special shortcut.
A statement consisting of an anonymous
procedure taking unit, and a semicolon ;
is a shortcut for a call:
@begin_displayed_code()
  { print 1; }; // is a shortcut for ..
  { print 1; } (); 
@end_displayed_code()
much the same as
@begin_displayed_code()
  endl; // is a shortcut for ..
  endl (); 
@end_displayed_code()
Now, remember those ugly semicolons at the end
of the while statement? Are you getting a glimmer?
Hint: Felix doesn't have a while statement.
It's a library routine!

@head(2,'Lazy Evaluation')
To define the while loop, we need lazy evaluation.
Lets try to define it:
@select(tangler(tdir+'tut136.flx'))
#include <std.flx>
proc While (cond: unit->bool) (body:unit->void)
{
  repeat:>
    if (not(cond())) then goto finished; endif;
    body();
    goto repeat;
  finished:>
}

var i = 0;
While (fun():bool= { return i < 10; })
{
  print i; endl;
  i++;
};

@doc()
Well that works fine, except for the ugly lambda.
Here's the first shortcut:
@select(tangler(tdir+'tut137.flx'))
#include <std.flx>
proc While (cond: unit->bool) (body:unit->void)
{
  repeat:>
    if (not(cond())) then goto finished; endif;
    body();
    goto repeat;
  finished:>
}

var i = 0;
val x : unit -> int = lazy (i+1);
print (x());
While (lazy ( i < 10))
{
  print i; endl;
  i++;
};

@doc()
The keyword lazy denotes a lazy expression:
@begin_displayed_code()
  lazy (expr)
@end_displayed_code()
means exactly the same as
@begin_displayed_code()
  fun():T { return expr; }
@end_displayed_code()
where T is the type of the expression expr.
Well, we're not quite there syntactically!

@head(2,'Numeric Lexemes')
Here is a more comprehensive set of examples
of Felix numeric lexicology.
@select(tangler(tdir+'tut138.flx'))
#include <std.flx>
//#include <boost.flx>

// radix
{
  val i1 = 999;      // decimal
  val i2 = 0b1111;   // binary
  val i3 = 0o7777;   // octal
  val i4 = 0d9999;   // decimal
  val i5 = 0xF1_F2;  // hex
};

// underscores
{
  val i1 = 123_456; 
  val i2 = 0x_FF_FFu;
};

// normal signed integers
{
  val i1 : tiny = 1t;
  val i2 : short = 1s;       
  val i3 : int = 1; // default
  val i4 : int = 1i;
  val i5 : long = 1l;
  val i6 : vlong = 1ll;
};

// normal unsigned integers
{
  val i1 : utiny = 1tu;
  val i2 : utiny = 1ut; // u may be first or last
  val i3 : ushort = 1su;
  val i4 : uint = 1u; // default
  val i5 : uint = 1iu;
  val i6 : ulong = 1lu;
  val i7 : uvlong = 1vu;
  val i8 : uvlong = 1llu; // alternate
};

// exact signed integers
{
  val i1 : int8 = 1i8;
  val i2 : int16 = 1i16;       
  val i3 : int32 = 1i32;
  val i4 : int64 = 1i64;
};

// exact unsigned integers
{
  val i1 : uint8 = 1u8; // 1iu8 not allowed
  val i2 : uint16 = 1u16;       
  val i3 : uint32 = 1u32;
  val i4 : uint64 = 1u64;
};

// floats obey C99 rules, except we allow underscores
{
  val x1 : float = 2.2f;
  val x2 : double = 2.2;
  val x3 : ldouble = 2.2l;
  val x4 : double = 22_345.78;
  // val x5 : float = 0xFFFF.FFp4f; // doesn't work on g++ 2.95.3
  val x6 : double = 2.2e4;
  val x7 : float = 2.2e4f;
};

@head(2,'Floating matches')
Felix provides special matching for
floating point. Here are some examples:
@select(tangler(tdir+'tut139.flx'))
#include <std.flx>

match (1.0) with
  | NaN => print "Not a Number";
  | -inf .. -0.999 => print "lt -1";
  | -1.001 .. 1.001 => print "Unit circle";
  | 0.999 .. inf => print "Greater than 1";
endmatch;
endl;

match (1.0) with 
  | 0.999 .. 1.001 => print "one";
endmatch;
endl;

match (1.0/3.0) with
 | 0.3333 .. 0.3334 => print "One third";
endmatch;

@doc()
Things to note are: if there is NaN test,
it must be the first test. If there is
a test -inf .. inf, it tests for a non-NaN,
and must be the last test. A NaN will fail
all tests other than a test for NaN.
@p()
A range test is neither inclusive nor exclusive!
That's why there is no test for a particular float,
and why the ranges above overlap.
Welcome to constructive mathematics!
@p()
Note that _floating_ point provides exact
comparisons, however, the patterns above
apply to constructive reals. The last
example explains this best: you can't do
non-constructive matches. [Use IEEE type
for exact FP?]

@head(2,'Identifiers')
Felix identifiers consists of a string of
characters. The first character must be a letter
or underscore, subsequent characters may be one of a
letter, underscore, apostrophe or digit.
@p()
Certain identifiers are reserved as keywords.
Identifiers beginning with an underscore are 
reserved to Felix. Identifiers containing
more than one underscore in a row are
reserved to Felix. Reserved identifiers may
be used by progrogrammers, but not defined.
@p()
The letters referred to consist of the usual
A-Z and a-z, but also include any Unicode/ISO10646
code point recommended as a letter for the purpose
of use in identifiers of programming languages
by ISO/IEC PDTR 10176, as adopted by ISO C++.
A full table can be found in the reference manual,
Felix Standard, and source code.
@p()
These code points must be represented using UTF-8,
or by embedded Universal Character Names (ucns).
These consist of a \uXXXX or \UXXXXXXXX where the
X's are hex digits. Felix normalises all such
encodings so identifiers match properly.

@select(tangler(tdir+'tut140.flx'))
#include <std.flx>

val x_y_7' = 1;
val Y_can't_U_do_this_in_C'' : double = 2.0;
val x\u05d0= 1; // x,Hebrew  aleph
val zz = x\U000005D0; // x,Hebrew aleph

@head(1,'Intermediate Felix 201')
This section mainly deals with the Felix module system.

@head(2,'Module Interfaces')
Felix allows you to specify the interface
of a module with an interface specification.
You can constrain access to the module with
an interface. The module must match the
interface, more precisely, the module's
default interface must be subtype of the
specified interface. Here's an example.
@select(tangler(tdir+'tut201.flx'))
#include <std.flx>

interface group
{
  type t;
  proc print: t;
  fun add: t * t -> t;
  fun neg: t -> t;
  val zero:t;
}

module number {
  typedef t = int;
  fun add(a:t, b:t):t = { return Int::add(a,b); }
  fun neg(a:t):t = { return Int::neg a; }
  val zero = 0;
  proc print (a:int) { Int::print a; }
}

module NUMBER = number : group;

val zero = NUMBER::zero;
NUMBER::print zero; endl;
val one = 1 : NUMBER::t;
NUMBER::print one; endl;
NUMBER::print (NUMBER::add(one,one)); endl;

@doc()
Note that the representation of t by an int
is hidden by the interface: you can't
multiply these numbers.

@head(2,'Coercions')
In the previous example, in the line

@begin_displayed_code()
module NUMBER = number : group;
@end_displayed_code()

the expression on right hand side is a 
called a module coercion, and the module
on the left hand side is known as a bound 
module. A bound module is view of a module,
as seen through an interface.
@p()
Felix provides syntact sugar which allows
you to define a module and bind it to
an interface in the same definition:
@select(tangler(tdir+'tut202.flx'))
#include <std.flx>
interface group
{
  type t;
  proc print: t;
  fun add: t * t -> t;
  fun neg: t -> t;
  val zero:t;
}

module NUMBER: group = {
  typedef t = int;
  fun add(a:t, b:t):t = { return Int::add(a, b); }
  fun neg(a:t):t = { return -a; }
  val zero = 0;
  proc print (a:int) { Int::print a; }
}

val zero = NUMBER::zero;
NUMBER::print zero; endl;
val one = 1 : NUMBER::t;
NUMBER::print one; endl;
NUMBER::print (NUMBER::add(one,one)); endl;
@doc()
Note also the coercion

@begin_displayed_code()
val one = 1 : NUMBER::t;
@end_displayed_code()

which is required to 'cast' the int 1 to the bound
type t/int.

@head(2,'Functors')
You may have been wondering how Felix handles
genericity. 
Felix supports modules which
can be parameterized by other modules.
Lets look at an example.

@select(tangler(tdir+'tut203.flx'))
#include <std.flx>

interface list_req
{
  type element;
  proc print_element: element;
}

functor List (req:list_req)
{
  union list =
    | Empty
    | Cons of req::element * list
  ;
  proc print (a: list) 
  {
    match (a) with
    | Empty => print "[]";
    | Cons (?i, ?tail) =>
      {
        req::print_element i; 
        print " "; 
        print tail;
      };
    endmatch;
  }
}

module Integer 
{ 
  typedef element = int;
  proc print_element (a:int) { print a; }
}

module Int_req = Integer : list_req;

module int_list = List Int_req;

val t0 = int_list::Empty;
val nxt = (100 : Int_req::element, t0);
val t1 = int_list::Cons nxt;
val t2 = int_list::Cons (200 : Int_req::element, t1);
int_list::print t2; endl;


@doc()
The first thing we do is define an interface
which specifies the requirements for a list:

@begin_displayed_code()
interface list_req
{
  type element;
  proc print_element: element;
}
@end_displayed_code()

A list is built of elements of some type,
a routine to print an element is required.
@p()
Next, the functor specified a list: the union

@begin_displayed_code()
  union list =
    | Empty
    | Cons of req::element * list
  ;
@end_displayed_code()

defines the structure of a list inductively,
and the print routine prints it recursively.
@p()
To instantiate the functor, we must supply
a module bound by the interface list_req.
First we specify a suitable module for
a list of int:

@begin_displayed_code()
module Int 
{ 
  typedef element = int;
  proc print_element (a:int) { print a; }
}
@end_displayed_code()

This module has the correct structure
to use with the functor, but it must be explicitly
constrained by the interface:

@begin_displayed_code()
module Int_req = Int : list_req;
@end_displayed_code()

because functors can be overloaded, and an 
exact match is required.
@p()
Finally, we instantiate the functor:

@begin_displayed_code()
module int_list = List Int_req;
@end_displayed_code()

and the result is a module. Note that to use the module,
at the moment, we not only have to qualify all
the names, but we also must coerce each int to
the type Int_req::element.

@head(2,'Nested functors')
It is, of course, possible to nest functors.

@select(tangler(tdir+'tut204.flx'))
#include <std.flx>
interface I 
{ 
  type t; 
  proc print: t; 
}

module M 
{ 
  typedef t = int; 
  proc print (a:int) { Int::print a; } 
}
module B = M:I;

functor F(i:I) 
{
  functor G(j:I)
  {
    fun swap (a: i::t, b: j::t): j::t * i::t =
    { 
      return (b,a);
    }
    proc print (b: j::t, a: i::t)
    {
      j::print b; print ","; i::print a; endl;
    }
  }
}

module K = F B;
module H = K::G B;
val z = H::swap (1: B::t, 2: B::t);
H::print z;

@head(2,'The open directive')
It's really boring writing qualified names all
the time. Felix provides the open directive
to allow you to open a module so its contents
can be accesses without using qualified names.
Here's a simple example:

@select(tangler(tdir+'tut205.flx'))
#include <std.flx>
module X {
  proc print_endl (a:int) { print a; endl; }
  fun square (a:int):int = { return a * a; }
}

open X;
print_endl (square 2);

@doc()
Note that the open directive only affects lookup
of unqualified names, or the first component of
a qualified name. Lookup proceeds first in the
current scope, before considering opened modules;
then opened modules are considered, then the
parent scope, then opened modules in the parent,
etc.
@p()
The name of the module
to be opened is not looked up in the modules
opened by open directives in the same module
as itself. Open directives in containing modules
are, however, examined.
@p()
The reason for this last rule is as follows:
open directives, like Felix declarations,
are all considered in parallel; that is,
their order of writing is irrelevant;
hence, open directives are considered in a
context in which none of the open directives
have been applied.
@p()
It is not an error to open modules containing
conflicting definitions, however, it is an error
to refer to a name with conflicting definitions.
@p()
Functions with the same name in opened modules
are overloaded. If two functions have the same
signature, a reference will lead to an ambiguity.
Such an ambiguity can be resolved by hiding
such definitions in opened modules by providing
a definition in the module containing the
open directives. Alternatively, you can use
a qualified name.

@select(tangler(tdir+'tut206.flx'))
#include <std.flx>
module X1 {
  proc printme() { print "X1"; endl; }
}
module X2 {
  proc printme() { print "X2"; endl; }
}
open X1;
open X2;
proc printme() { print "top level"; endl; }

X1::printme();
X2::printme();
printme();

@doc()
Finally note that the effect of opening a module
named X which contains an entity named X is well
defined: the contained X will not be seen
by other open directives, whereas the module X
will not be seen by any declarations and definitions
in the body of the containing scope.

@head(2,'Numbered unions')
We'll take a break from the module system to 
consider numbered sums. A numbered union is
to a named unions, as a tuple is to a struct:
its an anonymous non-generative type with
non-negative case tags deduced positionally
from the type. The infix + is used non-associatively
to specify numbered unions.

@select(tangler(tdir+'tut207.flx'))
#include <std.flx>
open Long;
typedef three = unit +  unit + unit;
typedef four = 4;
typedef nu = int + int + long;

val x1 = case 2 of (1+1+1);
val x2 = case 2 of 3;
val x3 = (case 3 of nu) 33L;

proc g(x:three) {
  print "Case ";
  match x with
  | case 1 => { print 1; };
  | case 2 => { print 2; };
  | case 3 => { print 3; };
  endmatch;
  print " of three\n";
}

g (case 3 of three);

proc f(x:nu) {
  match x with
  | case 1 ?z => { print "case 1 "; print z; };
  | case 2 ?z => { print "case 2 "; print z; };
  | case 3 ?z => { print "case 3 "; print z; };
  endmatch;
  print "\n";
}
 
f x3;

