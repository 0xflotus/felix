@head(1,"Inlining")
To make this work, we need a theorem.
First, the call rule is:
@begin_displayed_code()
A procedure may only call a child of an ancestor.
@end_displayed_code()
Note an ancestor is itself or a parent
of any ancestor: that is, a procedure
is an ancestor of itself. A parentless toplevel
procedure is considered a child of a dummy root
to make this simple formulation work.
@p()
It is clear we can inline any sibling
by copying its body, and duplicating
any children -- variables and nested
procedures included. This is because
any references to its parent will
go through from the caller, since
they have the same parent.
@p()
Clearly this result extends to any
child of any parent.

@h = tangler("src/flx_inline.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_call

val heavy_inlining:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  fully_bound_symbol_table_t

val descendants:
  (bid_t, bid_t list) Hashtbl.t ->
  bid_t ->
  IntSet.t
  
@h = tangler("src/flx_inline.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use

module BidSet = IntSet

let string_of_vs vs =
  "[" ^ catmap "," (fun (s,i)->s^"<"^si i^">") vs ^ "]"

(* closure of index with respect to children, EXCLUDES self *)
let rec descendants child_map index =
  let d = ref IntSet.empty in
  let children = try Hashtbl.find child_map index with Not_found -> [] in
  iter
  (fun i -> 
    if not (IntSet.mem i !d) then
    begin
      d := IntSet.add i !d;
      d := IntSet.union !d (descendants child_map i)
    end
  )
  children
  ;
  !d

let mk_remap counter d =
  let m = Hashtbl.create 97 in
  IntSet.iter
  (fun i -> 
    let n = !counter in 
    incr counter; 
    Hashtbl.add m i n
  )
  d
  ;
  m

(* varmap is the *typevariable* remapper, 
 revariable remaps indices
*)
let remap_expr syms varmap revariable caller_vars callee_vs_len e = 
  let splice ts = (* replace callee type variables with callers *)
    let rec aux lst n =  (* elide first n elements *)
      if n = 0 then lst 
      else aux (tl lst) (n-1) 
    in
    (*
    print_endline ("SPLICING ts=" ^ catmap "," (sbt syms.dfns) ts);
    print_endline ("Strip off first Callee_vs_len = " ^ si callee_vs_len);
    print_endline ("Prepend caller vs: " ^ catmap "," (sbt syms.dfns) caller_vars);
    *)
    caller_vars @ aux ts callee_vs_len 
  in

  (*
  print_endline ("REMAP expr = " ^ sbe syms.dfns e);
  *)
  let auxt t = varmap_subst varmap t in
  let fixup i ts = 
    let ts = map auxt ts in
    try 
      let j= Hashtbl.find revariable i in 
      j, splice ts
    with Not_found -> i,ts
  in
  let rec aux e = match map_tbexpr aux auxt e with
  | `BEXPR_name (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_name (i,ts), auxt t

  | `BEXPR_ref (i,ts) as x,t ->
    let i,ts = fixup i ts in
    `BEXPR_ref (i,ts), auxt t

  | `BEXPR_closure (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_closure (i,ts), auxt t

  | `BEXPR_apply_direct (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_direct (i,ts,aux e), auxt t

  | `BEXPR_apply_stack (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_stack (i,ts,aux e), auxt t

  | `BEXPR_apply_prim (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_prim (i,ts,aux e), auxt t

  | x -> x
  in
    let a = aux e in
    (*
    print_endline ("replace " ^ sbe syms.dfns e ^ "-->" ^ sbe syms.dfns a);
    *)
    a


let remap_exe syms relabel varmap revariable caller_vars callee_vs_len exe =
  let ge e = remap_expr syms varmap revariable caller_vars callee_vs_len e in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let splice ts = (* replace callee type variables with callers *)
        let rec aux lst n =  (* elide first n elements *)
          if n = 0 then lst 
          else aux (tl lst) (n-1) 
        in
        caller_vars @ aux ts callee_vs_len 
      in

      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, splice ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_prim (sr,i,ts, ge e2)

  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let splice ts = (* replace callee type variables with callers *)
        let rec aux lst n =  (* elide first n elements *)
          if n = 0 then lst 
          else aux (tl lst) (n-1) 
        in
        caller_vars @ aux ts callee_vs_len 
      in

      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, splice ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_direct (sr,i,ts, ge e2)

  | `BEXE_call_stack (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let splice ts = (* replace callee type variables with callers *)
        let rec aux lst n =  (* elide first n elements *)
          if n = 0 then lst 
          else aux (tl lst) (n-1) 
        in
        caller_vars @ aux ts callee_vs_len 
      in

      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, splice ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_stack (sr,i,ts, ge e2)

  | `BEXE_call (sr,e1,e2)  -> `BEXE_call (sr,ge e1, ge e2)
  | `BEXE_jump (sr,e1,e2)  -> `BEXE_jump (sr,ge e1, ge e2)
  | `BEXE_loop (sr,i,e) -> failwith "[opt3:remap] Can't handle loop"
  | `BEXE_ifgoto (sr,e,lab) -> `BEXE_ifgoto (sr,ge e, relab lab)
  | `BEXE_ifnotgoto (sr,e,lab) -> `BEXE_ifnotgoto (sr,ge e, relab lab)
  | `BEXE_fun_return (sr,e) -> `BEXE_fun_return (sr, ge e)
  | `BEXE_assign (sr,e1,e2) -> `BEXE_assign (sr, ge e1, ge e2)
  | `BEXE_init (sr,i,e) -> `BEXE_init (sr,revar i, ge e)
  | `BEXE_read (sr,i)  -> `BEXE_read (sr, revar i)

  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    `BEXE_regmatch (sr, ge e,(a,sc,h',tr))
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    `BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))

  | `BEXE_code (sr,s)  as x -> x
  | `BEXE_goto (sr,lab) as x -> `BEXE_goto (sr,relab lab) 
  | `BEXE_proc_return sr as x -> x
  | `BEXE_comment (sr,s) as x -> x
  | `BEXE_nop (sr,s) as x -> x
  | `BEXE_label (sr,lab) as x -> `BEXE_label (sr,relab lab) 

let remap_exes syms relabel varmap revariable caller_vars callee_vs_len exes =
  map (remap_exe syms relabel varmap revariable caller_vars callee_vs_len) exes

let reparent1 syms bbdfns bbdfns2 
  relabel varmap revariable 
  vs' callee_vs_len index parent
=
  let splice vs = (* replace callee type variables with callers *)
    let rec aux lst n =  (* elide first n elements *)
      if n = 0 then lst 
      else aux (tl lst) (n-1) 
    in
    vs' @ aux vs callee_vs_len
  in
  let sop = function
    | None -> "NONE?" 
    | Some i -> si i
  in
  let caller_vars = map (fun (s,i) -> `BTYP_var i) vs' in

  let auxt t = varmap_subst varmap t in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let remap_ps ps = map (fun (id,(i,t)) -> id,(revar i,auxt t)) ps in

  let k = Hashtbl.find revariable index in
  let id,old_parent,sr,entry = Hashtbl.find bbdfns index in
  (*
  print_endline 
  (
    "COPYING " ^ id ^ " index " ^ si index ^ " with old parent " ^
    sop old_parent ^ " to index " ^ si k ^ " with new parent " ^
    sop parent
  );
  *)

  match entry with
  | `BBDCL_procedure (props,vs,ps,exes) ->
    let exes = remap_exes syms relabel varmap revariable caller_vars callee_vs_len exes in
    let ps = remap_ps ps in
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_procedure (props,splice vs,ps,exes))
    
  | `BBDCL_function (props, vs, ps, ret, exes) ->
    let ps = remap_ps ps in
    let exes = remap_exes syms relabel varmap revariable caller_vars callee_vs_len exes in
    let ret = auxt ret in
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_function (props,splice vs,ps,ret,exes))

  | `BBDCL_var (vs,t) ->
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_var (splice vs,auxt t))

  | `BBDCL_val (vs,t) ->
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_val (splice vs,auxt t))

  | _ -> assert false

(* make a copy all the descendants of i, changing any
  parent which is i to the given new parent
*)

let reparent_children syms (child_map,bbdfns) bbdfns2 
  vs' callee_vs_len index parent relabel varmap 
=
 let pp p = match p with None -> "NONE" | Some i -> si i in
 (*
 print_endline ("Renesting children of callee " ^ si index ^ " to caller " ^ pp parent);
 *)
 let closure = descendants child_map index in
 let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
 (*
 print_endline ("Closure is " ^ catmap " " si !cl);
 *)
 let revariable = mk_remap syms.counter closure in
 IntSet.iter
 (fun i -> 
   let old_parent = 
     match Hashtbl.find bbdfns i with id,oldp,_,_ -> oldp
   in
   let new_parent: bid_t option =
     match old_parent with
     | None -> assert false
     | Some p ->
       if p = index then parent
       else Some (Hashtbl.find revariable p)
   in
   reparent1 syms bbdfns bbdfns2 relabel varmap revariable 
   vs' callee_vs_len i new_parent
 )
 closure
 ;
 revariable
 

 
exception Found
let has_nested_funs (child_map,bbdfns) i =
  let children = try Hashtbl.find child_map i with Not_found -> [] in
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_procedure _ 
      | `BBDCL_function _  -> raise Found
      | _ -> ()
    )
    children
    ;
    false
  with Found -> true
    
(* Heavy inlining routine. This routine can inline
any procedure. The basic operation is emit the body
of the target procedure. We have to do the following to
make it all work.

(1) Each declared label is replaced by a fresh one,
and all jumps to these labels modified accordingly.

(2) Variables are replaced by fresh ones. This requires
making additions to the output bound tables. References
to the variables are modified. Note the parent is the
caller now.

(3) Paremeters are replaced like variables, initialised
by the arguments.

(4) Any type variables instantiated by the call must
also be instantiated in body expressions, as well as
the typing of any generated variables.

(5) If the procedure has any nested procedures, they
also must be replaced in toto by fresh ones, reparented
to the caller so that any calls to them will access
the fresh variables in the caller.

Note that the cache of children of the caller will
be wrong after the inlining (it may have acquired new
variables or procedure children).

Note that this inlining procedure is NOT recursive!
Its a flat one level inlining. This ensures recursive
calls don't cause an infinite unrolling, and hopefully
prevent gross bloat.
*)

let mk_label_map syms exes = 
  let h = Hashtbl.create 97 in
  let aux = function
  | `BEXE_label (sr,s) -> 
    let n = !(syms.counter) in
    incr syms.counter;
    let s' =  "_" ^ si n in
    Hashtbl.add h s s'
  | _ -> ()
  in
    iter aux exes;
    h
    
let mk_tvar_map vs ts =
  let varmap = Hashtbl.create 97 in (* type variable assignments *)
  iter2
  (fun (_,i) t -> Hashtbl.add varmap i t)
  vs ts
  ;
  varmap

(* NOTE: result is in reversed order *)
let gen_body syms bbdfns bbdfns2 id 
  varmap ps relabel revariable exes argument 
  sr caller callee vs callee_vs_len
=
  (*
  print_endline ("INLINING " ^ id ^ " into " ^ si caller ^ " .. INPUT:");
  iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) exes;
  *)
  let paramtype  =
    let pt = 
      let pts = map (fun (_,(_,t)) -> t) ps in
      match pts with
      | [x] -> x
      | x -> `BTYP_tuple x
    in
      varmap_subst varmap pt
  in
 
  let caller_vars = map (fun (s,i) -> `BTYP_var i) vs in
  let ge e = remap_expr syms varmap revariable caller_vars callee_vs_len e in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let self_loop = ref false in
  let end_label_used = ref false in

  (* create a variable for the parameter *)
  let parameter = !(syms.counter) in 
  incr syms.counter; 
  (*
  print_endline ("Parameter assigned index " ^ si parameter);
  *)

  (* create an end label using the parameter index as id *)
  let end_label = "_end_" ^ (si parameter) in 

  (* create variables for parameter components *)
  if length ps > 1 then 
  for i = 1 to length ps do incr syms.counter done;
  
  (* create a possible label for a tail call *)
  let loop_start = 
    let n = !(syms.counter) in 
    incr syms.counter;
    "loop_" ^ si n 
  in
  let remap: bexe_t -> bexe_t list =  function
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let splice ts = (* replace callee type variables with callers *)
        let rec aux lst n =  (* elide first n elements *)
          if n = 0 then lst 
          else aux (tl lst) (n-1) 
        in
        caller_vars @ aux ts callee_vs_len 
      in

      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, splice ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_prim (sr,i,ts, ge e2)]
  
  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let splice ts = (* replace callee type variables with callers *)
        let rec aux lst n =  (* elide first n elements *)
          if n = 0 then lst 
          else aux (tl lst) (n-1) 
        in
        caller_vars @ aux ts callee_vs_len 
      in

      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, splice ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_direct (sr,i,ts, ge e2)]

  | `BEXE_call_stack (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let splice ts = (* replace callee type variables with callers *)
        let rec aux lst n =  (* elide first n elements *)
          if n = 0 then lst 
          else aux (tl lst) (n-1) 
        in
        caller_vars @ aux ts callee_vs_len 
      in

      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, splice ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_stack (sr,i,ts, ge e2)]
    
  | `BEXE_call (sr,e1,e2)  -> [`BEXE_call (sr,ge e1, ge e2)]
  | `BEXE_jump (sr,e1,e2)  -> 
    end_label_used := true;
    [
      (let e = ge e1 in
      match e with
      | `BEXPR_closure (i,ts),_ ->
        `BEXE_call_direct (sr,i,ts, ge e2)
      | _ ->
        `BEXE_call (sr,e, ge e2)
      )
      ;
      `BEXE_goto (sr,end_label)
    ]
  | `BEXE_loop (sr,i,e) -> 
    (* SPECIAL HANDLING OF LOOP REQUIRED *)
    if i = callee then begin
      self_loop := true;
      match length ps with
      | 0 -> [`BEXE_goto (sr,loop_start)]
      | 1 ->
        let (_,(k,_)) = hd ps in
        [
          `BEXE_init (sr,revar k,ge e);
          `BEXE_goto (sr,loop_start)
        ]
      | _ ->
        [
          `BEXE_init (sr,parameter,ge e);
          `BEXE_goto (sr,loop_start)
        ]
    end
    else 
    begin
      failwith "Loop to non-self unimplemented in inliner";
      (* this is probably right sometimes .. need to check *)
      [`BEXE_loop (sr,i,ge e)]
    end

  | `BEXE_ifgoto (sr,e,lab) -> [`BEXE_ifgoto (sr,ge e, relab lab)]
  | `BEXE_ifnotgoto (sr,e,lab) -> [`BEXE_ifnotgoto (sr,ge e, relab lab)]
  | `BEXE_fun_return (sr,e) -> [`BEXE_fun_return (sr, ge e)]
  | `BEXE_assign (sr,e1,e2) -> [`BEXE_assign (sr, ge e1, ge e2)]
  | `BEXE_init (sr,i,e) -> [`BEXE_init (sr,revar i, ge e)]
  | `BEXE_read (sr,i)  -> [`BEXE_read (sr, revar i)]

  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_regmatch (sr, ge e,(a,sc,h',tr))]
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))]

  | `BEXE_code (sr,s)  as x -> [x]
  | `BEXE_goto (sr,lab) -> [`BEXE_goto (sr, relab lab)]
  | `BEXE_proc_return sr as x -> 
    end_label_used := true;
    [`BEXE_goto (sr,end_label)]

  | `BEXE_comment (sr,s) as x -> [x]
  | `BEXE_nop (sr,s) as x -> [x]
  | `BEXE_label (sr,lab) -> [`BEXE_label (sr, relab lab)]
  in
    let b = ref [`BEXE_comment (sr,("Inline call to " ^ id))] in

    (* Initialise parameter to argument, but only if
       the argument is not unit
    *)
    if length ps > 0 then
    begin
      let x = 
        if length ps > 1
        then begin
          let entry = `BBDCL_var (vs,paramtype) in
          Hashtbl.add bbdfns2 parameter (id,Some caller,sr,entry);
          `BEXE_init (sr,parameter,argument)
        end
        else 
          let vid,(k,_) = hd ps in
          let index = revar k in
          `BEXE_init (sr,index,argument)
      in
      b := x :: !b;
     
      (* unpack argument *)
      if length ps > 1 then
      let p = `BEXPR_name (parameter,[]),paramtype in  
      let n = ref 0 in
      iter 
      (fun (vid,(ix,prjt)) ->
        let prjt = varmap_subst varmap prjt in
        let prj = `BEXPR_get_n (!n,p),prjt in
        let index = revar ix in
        let x = `BEXE_init (sr,index,prj) in
        b := x :: !b;
        incr n
      )
      ps
    end
    ;
    (* If we loop with a tail call, 
      we need to make an entry point for the jump,
      make it anyhow because it goes at the wrong
      end of the list .. 
    *)
    let x = `BEXE_label (sr,loop_start) in
    b := x :: !b;
    ;
    iter
    (fun exe -> 
      iter 
      (fun x -> b := x :: !b) 
      (remap exe)
    )
    exes
    ;
    if !end_label_used then 
      b := (`BEXE_label (sr,end_label)) :: !b
    ;
    (*
    print_endline ("INLINING " ^ id ^ " into " ^ si caller ^ " .. OUTPUT:");
    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) !b;
    *)
    !b


(* CALL LIFTING. What this does is transform a call:

  call (f a) arg

  by replacing it with the body of f,
  in which every 
  
  return x 
  
  is replaced by 
  
  call x arguemnt

  This converts  f from a function returning
  a procedure, to a procedure which executes that
  procedure.

*)

let call_lifting syms (child_map,bbdfns) bbdfns2 caller vs' callee ts a argument =
  (*
  print_endline "DOING CALL LIFTING";
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_tvar_map vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (child_map,bbdfns) bbdfns2  
      vs' callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms bbdfns bbdfns2 id varmap ps relabel revariable 
      exes a sr caller callee vs' callee_vs_len
    in

    (* replace all function returns with tailed calls *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_call_lift_" ^ si n in
    body2 := `BEXE_label (sr,end_label) :: !body2;
    iter
      (function 
      | `BEXE_fun_return (sr,e) ->
        (* NOTE REVERSED ORDER *)
        let call_instr = 
          (match e with
          | `BEXPR_closure (i,ts),_ -> 
            `BEXE_call_direct (sr,i,ts,argument)
          | _ ->
            `BEXE_call (sr,e,argument)
          )
        in
        body2 := `BEXE_goto (sr,end_label) :: !body2;
        body2 := call_instr :: !body2;
      | x -> body2 := x::!body2
      )
      body
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    rev !body2

  | _ -> assert false

let heavy_inline_call syms (child_map,bbdfns) bbdfns2 
  caller vs' callee ts argument 
=
  (*
  print_endline ("Examining call to " ^ si callee);
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_procedure (props,vs,ps,exes) ->
    (*
    print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs vs');
    print_endline ("Callee is " ^ id ^ "<"^si callee ^ "> with ts = " ^ catmap "," (sbt syms.dfns) ts);
    print_endline ("Callee vs=" ^ string_of_vs vs);
    *)
    let caller_vs_len = length vs' in
    let callee_vs_len = length vs in
    (*
    print_endline ("In the callee and its children,");
    print_endline ("The callee vs are elided and replaced by the caller vs");
    print_endline ("ELIDE: first " ^ si callee_vs_len ^ ", PREPEND " ^ si caller_vs_len);
    print_endline ("This works by instantiating the callee vs with the calls ts");
    *)
    assert(length vs = length ts);
    
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_tvar_map vs ts in
    let revariable = reparent_children 
      syms (child_map,bbdfns) bbdfns2 
      vs' callee_vs_len callee (Some caller) relabel varmap
    in
    gen_body syms bbdfns bbdfns2 id 
      varmap ps relabel revariable exes 
      argument sr caller callee vs' callee_vs_len

  | _ -> assert false
  

let heavy_inline_calls syms (child_map,bbdfns) bbdfns2 vs' exes caller =
  let exes' = ref [] in
  iter
  (fun exe -> 
  match exe with
  | `BEXE_call_stack (sr,callee,ts,argument) -> assert false
  | `BEXE_call (sr,(`BEXPR_closure (callee,ts),_),argument) -> assert false
  | `BEXE_jump _ -> assert false

  | `BEXE_call_direct (sr,callee,ts,argument) ->
    let id,parent,sr,entry = Hashtbl.find bbdfns callee in
    begin match entry with
    | `BBDCL_procedure _ ->
      (*
      print_endline "INLINE CANDIDATE DETECTED - CALL";
      print_endline (string_of_bexe syms.dfns 0 x);
      *)
      let xs = 
        heavy_inline_call syms (child_map,bbdfns) bbdfns2 caller vs' callee ts argument
      in 
        exes' := xs @ !exes'

    | _ ->  exes' := exe :: !exes'
    end

  | `BEXE_call (sr,(`BEXPR_apply((`BEXPR_closure (callee,ts),_),a),_),argument) -> assert false

  | `BEXE_call (sr,(`BEXPR_apply_stack (callee,ts,a),_),argument)
  | `BEXE_call (sr,(`BEXPR_apply_direct (callee,ts,a),_),argument)
    ->
    (*
    print_endline "DETECTED CANDIDATE FOR CALL LIFTING ";
    print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs vs');
    print_endline (string_of_bexe syms.dfns 0 exe);
    print_endline ("Callee is " ^ si callee ^ " with ts = " ^ catmap "," (sbt syms.dfns) ts);
    *)
    begin try
      let xs = 
       call_lifting syms (child_map,bbdfns) bbdfns2 caller vs' callee ts a argument
      in 
        exes' := xs @ !exes'
    with _ ->
      exes' := exe :: !exes'
    end

  | x -> exes' := x :: !exes'
  )
  exes
  ;
  rev !exes' 
  
let heavily_inline_bbdcl syms (child_map,bbdfns) bbdfns2 i =
  let data =
    match Hashtbl.find bbdfns i with
    | id,parent,sr,`BBDCL_procedure (props,vs,p,exes) ->
      (*
      print_endline ("Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      *)
      let exes = heavy_inline_calls syms (child_map,bbdfns) bbdfns2 vs exes i in
      id,parent,sr,`BBDCL_procedure (props,vs,p,exes)

    | id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) ->
      (*
      print_endline ("Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      *)
      let exes = heavy_inline_calls syms (child_map,bbdfns) bbdfns2 vs exes i in
      id,parent,sr,`BBDCL_function (props,vs,p,ret,exes)
    | x -> x
  in
    Hashtbl.add bbdfns2 i data

let heavy_inlining syms  
  (child_map,bbdfns)
  (root:bid_t) 
  (bifaces:biface_t list) 
=
  (* make set of used things, initially empty *)
  let used = ref BidSet.empty in

  (* make a list of the root and all exported functions,
  add exported types and components thereof into the used
  set now too
  *)
  let roots = ref [root] in
  iter
  (function
     | `BIFACE_export_fun (_,x,_) -> roots := x :: !roots
     | `BIFACE_export_type (_,t,_) -> 
        uses_type syms used (child_map,bbdfns) t
  )
  bifaces
  ;
  let uses i = uses syms used (child_map,bbdfns) i in

  (* add root items to set, then add items it uses *)
  iter uses !roots
  ;
  (* copy used things *)
  let bbdfns2 = Hashtbl.create 97 in
  let usage = Flx_call.call_data bbdfns in
  BidSet.iter (heavily_inline_bbdcl syms (child_map,bbdfns) bbdfns2) !used
  ;
  (* copy all header and body specs, they're always considered used *)
  Hashtbl.iter
  (fun i b -> match b with
    | _,_,_,`BBDCL_header _
    | _,_,_,`BBDCL_body _ -> Hashtbl.add bbdfns2 i b
    | _ -> ()
  )
  bbdfns
  ;
  bbdfns2

