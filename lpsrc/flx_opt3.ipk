@head(1,"Inlining")
To make this work, we need a theorem.
First, the call rule is:
@begin_displayed_code()
A procedure may only call a child of an ancestor.
@end_displayed_code()
Note an ancestor is itself or a parent
of any ancestor: that is, a procedure
is an ancestor of itself. A parentless toplevel
procedure is considered a child of a dummy root
to make this simple formulation work.
@p()
It is clear we can inline any sibling
by copying its body, and duplicating
any children -- variables and nested
procedures included. This is because
any references to its parent will
go through from the caller, since
they have the same parent.
@p()
Clearly this result extends to any
child of any parent.

@h = tangler("src/flx_inline.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_call

val heavy_inlining:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  unit

val descendants:
  (bid_t, bid_t list) Hashtbl.t ->
  bid_t ->
  IntSet.t
  
@h = tangler("src/flx_inline.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use

module BidSet = IntSet

let string_of_vs vs =
  "[" ^ catmap "," (fun (s,i)->s^"<"^si i^">") vs ^ "]"

(* closure of index with respect to children, EXCLUDES self *)
let rec descendants child_map index =
  let d = ref IntSet.empty in
  let children = try Hashtbl.find child_map index with Not_found -> [] in
  iter
  (fun i -> 
    if not (IntSet.mem i !d) then
    begin
      d := IntSet.add i !d;
      d := IntSet.union !d (descendants child_map i)
    end
  )
  children
  ;
  !d

let mk_remap counter d =
  let m = Hashtbl.create 97 in
  IntSet.iter
  (fun i -> 
    let n = !counter in 
    incr counter; 
    Hashtbl.add m i n
  )
  d
  ;
  m

(* replace callee type variables with callers *)
let vsplice caller_vars callee_vs_len ts = 
  if not (callee_vs_len <= length ts)
  then failwith 
  (
    "Callee_vs_len = " ^ 
    si callee_vs_len ^ 
    ", len vs/ts= " ^ 
    si (length ts) ^
    ", length caller_vars = " ^
    si (length caller_vars)
  )
  ;
  let rec aux lst n =  (* elide first n elements *)
    if n = 0 then lst 
    else aux (tl lst) (n-1) 
  in
  caller_vars @ aux ts callee_vs_len 


(* varmap is the *typevariable* remapper, 
 revariable remaps indices
*)
let remap_expr syms varmap revariable caller_vars callee_vs_len e = 
  let auxt t = varmap_subst varmap t in
  let fixup i ts = 
    let ts = map auxt ts in
    try 
      let j= Hashtbl.find revariable i in 
      j, vsplice caller_vars callee_vs_len ts
    with Not_found -> i,ts
  in
  let rec aux e = match map_tbexpr aux auxt e with
  | `BEXPR_name (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_name (i,ts), auxt t

  | `BEXPR_ref (i,ts) as x,t ->
    let i,ts = fixup i ts in
    `BEXPR_ref (i,ts), auxt t

  | `BEXPR_closure (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_closure (i,ts), auxt t

  | `BEXPR_apply_direct (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_direct (i,ts,aux e), auxt t

  | `BEXPR_apply_stack (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_stack (i,ts,aux e), auxt t

  | `BEXPR_apply_prim (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_prim (i,ts,aux e), auxt t

  | x -> x
  in
    let a = aux e in
    (*
    print_endline ("replace " ^ sbe syms.dfns e ^ "-->" ^ sbe syms.dfns a);
    *)
    a

let remap_exe syms relabel varmap revariable caller_vars callee_vs_len exe =
  (*
  print_endline ("remap_exe " ^ string_of_bexe syms.dfns 0 exe);
  *)
  let ge e = remap_expr syms varmap revariable caller_vars callee_vs_len e in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_prim (sr,i,ts, ge e2)

  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_direct (sr,i,ts, ge e2)

  | `BEXE_call_stack (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_stack (sr,i,ts, ge e2)

  | `BEXE_call (sr,e1,e2)  -> `BEXE_call (sr,ge e1, ge e2)
  | `BEXE_jump (sr,e1,e2)  -> `BEXE_jump (sr,ge e1, ge e2)
  | `BEXE_loop (sr,i,e) -> failwith "[opt3:remap] Can't handle loop"
  | `BEXE_ifgoto (sr,e,lab) -> `BEXE_ifgoto (sr,ge e, relab lab)
  | `BEXE_ifnotgoto (sr,e,lab) -> `BEXE_ifnotgoto (sr,ge e, relab lab)
  | `BEXE_fun_return (sr,e) -> `BEXE_fun_return (sr, ge e)
  | `BEXE_assign (sr,e1,e2) -> `BEXE_assign (sr, ge e1, ge e2)
  | `BEXE_init (sr,i,e) -> `BEXE_init (sr,revar i, ge e)
  | `BEXE_read (sr,i)  -> `BEXE_read (sr, revar i)

  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    `BEXE_regmatch (sr, ge e,(a,sc,h',tr))
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    `BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))

  | `BEXE_code (sr,s)  as x -> x
  | `BEXE_goto (sr,lab) as x -> `BEXE_goto (sr,relab lab) 
  | `BEXE_proc_return sr as x -> x
  | `BEXE_comment (sr,s) as x -> x
  | `BEXE_nop (sr,s) as x -> x
  | `BEXE_label (sr,lab) as x -> `BEXE_label (sr,relab lab) 

let remap_exes syms relabel varmap revariable caller_vars callee_vs_len exes =
  map (remap_exe syms relabel varmap revariable caller_vars callee_vs_len) exes

let reparent1 syms (child_map,bbdfns )
  relabel varmap revariable 
  caller_vs callee_vs_len index parent
=
  let splice vs = (* replace callee type variables with callers *)
    vsplice caller_vs callee_vs_len vs 
  in
  let sop = function
    | None -> "NONE?" 
    | Some i -> si i
  in
  let caller_vars = map (fun (s,i) -> `BTYP_var i) caller_vs in

  let auxt t = varmap_subst varmap t in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let remap_ps ps = map (fun (id,(i,t)) -> id,(revar i,auxt t)) ps in

  let k = Hashtbl.find revariable index in
  let id,old_parent,sr,entry = Hashtbl.find bbdfns index in
  (*
  print_endline 
  (
    "COPYING " ^ id ^ " index " ^ si index ^ " with old parent " ^
    sop old_parent ^ " to index " ^ si k ^ " with new parent " ^
    sop parent
  );
  *)
  begin match parent with
  | Some p ->
    let old_kids = try Hashtbl.find child_map p with Not_found -> [] in
    Hashtbl.replace child_map p (k::old_kids)
  | None -> ()
  end
  ;
  match entry with
  | `BBDCL_procedure (props,vs,ps,exes) ->
    let exes = remap_exes syms relabel varmap revariable caller_vars callee_vs_len exes in
    let ps = remap_ps ps in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_procedure (props,splice vs,ps,exes))
    
  | `BBDCL_function (props, vs, ps, ret, exes) ->
    let ps = remap_ps ps in
    let exes = remap_exes syms relabel varmap revariable caller_vars callee_vs_len exes in
    let ret = auxt ret in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_function (props,splice vs,ps,ret,exes))

  | `BBDCL_var (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_var (splice vs,auxt t))

  | `BBDCL_val (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_val (splice vs,auxt t))

  | _ -> assert false

(* make a copy all the descendants of i, changing any
  parent which is i to the given new parent
*)

let reparent_children syms (child_map,bbdfns) 
  caller_vs callee_vs_len index parent relabel varmap 
=
 let pp p = match p with None -> "NONE" | Some i -> si i in
 (*
 print_endline 
 (
   "Renesting children of callee " ^ si index ^ 
   " to caller " ^ pp parent ^
    "\n  -- Caller vs len = " ^ si (length caller_vs) ^
    "\n  -- Callee vs len = " ^ si (callee_vs_len)
 );
 *)
 let closure = descendants child_map index in
 let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
 (*
 print_endline ("Closure is " ^ catmap " " si !cl);
 *)
 let revariable = mk_remap syms.counter closure in
 IntSet.iter
 (fun i -> 
   let old_parent = 
     match Hashtbl.find bbdfns i with id,oldp,_,_ -> oldp
   in
   let new_parent: bid_t option =
     match old_parent with
     | None -> assert false
     | Some p ->
       if p = index then parent
       else Some (Hashtbl.find revariable p)
   in
   reparent1 syms (child_map,bbdfns) relabel varmap revariable 
   caller_vs callee_vs_len i new_parent
 )
 closure
 ;
 revariable
 

 
(* Heavy inlining routine. This routine can inline
any procedure. The basic operation is emit the body
of the target procedure. We have to do the following to
make it all work.

(1) Each declared label is replaced by a fresh one,
and all jumps to these labels modified accordingly.

(2) Variables are replaced by fresh ones. This requires
making additions to the output bound tables. References
to the variables are modified. Note the parent is the
caller now.

(3) Paremeters are replaced like variables, initialised
by the arguments.

(4) Any type variables instantiated by the call must
also be instantiated in body expressions, as well as
the typing of any generated variables.

(5) If the procedure has any nested procedures, they
also must be replaced in toto by fresh ones, reparented
to the caller so that any calls to them will access
the fresh variables in the caller.

Note that the cache of children of the caller will
be wrong after the inlining (it may have acquired new
variables or procedure children).

Note that this inlining procedure is NOT recursive!
Its a flat one level inlining. This ensures recursive
calls don't cause an infinite unrolling, and hopefully
prevent gross bloat.
*)

let mk_label_map syms exes = 
  let h = Hashtbl.create 97 in
  let aux = function
  | `BEXE_label (sr,s) -> 
    let n = !(syms.counter) in
    incr syms.counter;
    let s' =  "_" ^ si n in
    Hashtbl.add h s s'
  | _ -> ()
  in
    iter aux exes;
    h
    
let mk_tvar_map vs ts =
  let varmap = Hashtbl.create 97 in (* type variable assignments *)
  iter2
  (fun (_,i) t -> Hashtbl.add varmap i t)
  vs ts
  ;
  varmap

(* NOTE: result is in reversed order *)
let gen_body syms (child_map,bbdfns) id 
  varmap ps relabel revariable exes argument 
  sr caller callee vs callee_vs_len
=
  (*
  print_endline ("INLINING " ^ id ^ " into " ^ si caller ^ " .. INPUT:");
  iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) exes;
  *)
  let paramtype  =
    let pt = 
      let pts = map (fun (_,(_,t)) -> t) ps in
      match pts with
      | [x] -> x
      | x -> `BTYP_tuple x
    in
      varmap_subst varmap pt
  in
 
  let caller_vars = map (fun (s,i) -> `BTYP_var i) vs in
  let ge e = remap_expr syms varmap revariable caller_vars callee_vs_len e in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let self_loop = ref false in
  let end_label_used = ref false in

  (* create a variable for the parameter *)
  let parameter = !(syms.counter) in 
  incr syms.counter; 
  (*
  print_endline ("Parameter assigned index " ^ si parameter);
  *)

  (* create an end label using the parameter index as id *)
  let end_label = "_end_" ^ (si parameter) in 

  (* create variables for parameter components *)
  if length ps > 1 then 
  for i = 1 to length ps do incr syms.counter done;
  
  (* create a possible label for a tail call *)
  let loop_start = 
    let n = !(syms.counter) in 
    incr syms.counter;
    "loop_" ^ si n 
  in
  let remap: bexe_t -> bexe_t list =  fun exe ->
  match exe with
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_prim (sr,i,ts, ge e2)]
  
  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_direct (sr,i,ts, ge e2)]

  | `BEXE_call_stack (sr,i,ts,e2)  -> assert false
    
  | `BEXE_call (sr,e1,e2)  -> [`BEXE_call (sr,ge e1, ge e2)]
  | `BEXE_jump (sr,e1,e2)  -> assert false
    (*
    end_label_used := true;
    [
      (let e = ge e1 in
      match e with
      | `BEXPR_closure (i,ts),_ ->
        `BEXE_call_direct (sr,i,ts, ge e2)
      | _ ->
        `BEXE_call (sr,e, ge e2)
      )
      ;
      `BEXE_goto (sr,end_label)
    ]
    *)

  | `BEXE_loop (sr,i,e) -> 
    (* SPECIAL HANDLING OF LOOP REQUIRED *)
    if i = callee then begin
      self_loop := true;
      match length ps with
      | 0 -> [`BEXE_goto (sr,loop_start)]
      | 1 ->
        let (_,(k,_)) = hd ps in
        [
          `BEXE_init (sr,revar k,ge e);
          `BEXE_goto (sr,loop_start)
        ]
      | _ ->
        [
          `BEXE_init (sr,parameter,ge e);
          `BEXE_goto (sr,loop_start)
        ]
    end
    else 
    begin
      failwith "Loop to non-self unimplemented in inliner";
      (* this is probably right sometimes .. need to check *)
      [`BEXE_loop (sr,i,ge e)]
    end

  | `BEXE_ifgoto (sr,e,lab) -> [`BEXE_ifgoto (sr,ge e, relab lab)]
  | `BEXE_ifnotgoto (sr,e,lab) -> [`BEXE_ifnotgoto (sr,ge e, relab lab)]
  | `BEXE_fun_return (sr,e) -> [`BEXE_fun_return (sr, ge e)]
  | `BEXE_assign (sr,e1,e2) -> [`BEXE_assign (sr, ge e1, ge e2)]
  | `BEXE_init (sr,i,e) -> [`BEXE_init (sr,revar i, ge e)]
  | `BEXE_read (sr,i)  -> [`BEXE_read (sr, revar i)]

  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_regmatch (sr, ge e,(a,sc,h',tr))]
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))]

  | `BEXE_code (sr,s)  as x -> [x]
  | `BEXE_goto (sr,lab) -> [`BEXE_goto (sr, relab lab)]
  | `BEXE_proc_return sr as x -> 
    end_label_used := true;
    [`BEXE_goto (sr,end_label)]

  | `BEXE_comment (sr,s) as x -> [x]
  | `BEXE_nop (sr,s) as x -> [x]
  | `BEXE_label (sr,lab) -> [`BEXE_label (sr, relab lab)]
  in
    let b = ref [`BEXE_comment (sr,("Inline call to " ^ id))] in

    (* Initialise parameter to argument, but only if
       the argument is not unit
    *)
    if length ps > 0 then
    begin
      let x = 
        if length ps > 1
        then begin
          let entry = `BBDCL_var (vs,paramtype) in
          let kids = 
            try Hashtbl.find child_map caller
            with Not_found -> [] 
          in
          Hashtbl.replace child_map caller (parameter::kids);
          Hashtbl.add bbdfns parameter (id,Some caller,sr,entry);
          `BEXE_init (sr,parameter,argument)
        end
        else 
          let vid,(k,_) = hd ps in
          let index = revar k in
          `BEXE_init (sr,index,argument)
      in
      b := x :: !b;
     
      (* unpack argument *)
      if length ps > 1 then
      let ts = map (fun (_,i) -> `BTYP_var i) vs in
      let p = `BEXPR_name (parameter,ts),paramtype in  
      let n = ref 0 in
      iter 
      (fun (vid,(ix,prjt)) ->
        let prjt = varmap_subst varmap prjt in
        let prj = `BEXPR_get_n (!n,p),prjt in
        let index = revar ix in
        let x = `BEXE_init (sr,index,prj) in
        b := x :: !b;
        incr n
      )
      ps
    end
    ;
    (* If we loop with a tail call, 
      we need to make an entry point for the jump,
      make it anyhow because it goes at the wrong
      end of the list .. 
    *)
    let x = `BEXE_label (sr,loop_start) in
    b := x :: !b;
    ;
    iter
    (fun exe -> 
      iter 
      (fun x -> b := x :: !b) 
      (remap exe)
    )
    exes
    ;
    if !end_label_used then 
      b := (`BEXE_label (sr,end_label)) :: !b
    ;
    (*
    print_endline ("INLINING " ^ id ^ " into " ^ si caller ^ " .. OUTPUT:");
    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev !b);
    print_endline ("END OUTPUT for " ^ id);
    *)
    !b


(* CALL LIFTING. What this does is transform a call:

  call (f a) arg

  by replacing it with the body of f,
  in which every 
  
  return x 
  
  is replaced by 
  
  call x arguemnt

  This converts  f from a function returning
  a procedure, to a procedure which executes that
  procedure.

  NOTE: this is a special case of the distributive law.

  f (if c then a else b) v => if c then f a v else f b v

*)

let call_lifting syms (child_map,bbdfns) caller caller_vs callee ts a argument =
  (*
  print_endline "DOING CALL LIFTING";
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_tvar_map vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len
    in

    (* replace all function returns with tailed calls *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_call_lift_" ^ si n in
    body2 := `BEXE_label (sr,end_label) :: !body2;
    iter
      (function 
      | `BEXE_fun_return (sr,e) ->
        (* NOTE REVERSED ORDER *)
        let call_instr = 
          (match e with
          | `BEXPR_closure (i,ts),_ -> 
            `BEXE_call_direct (sr,i,ts,argument)
          | _ ->
            `BEXE_call (sr,e,argument)
          )
        in
        body2 := `BEXE_goto (sr,end_label) :: !body2;
        body2 := call_instr :: !body2;
      | x -> body2 := x::!body2
      )
      body
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    rev !body2

  | _ -> assert false

let inline_function syms (child_map,bbdfns) caller caller_vs callee ts a varindex =
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    print_endline 
    (
      "Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"^
      "var="^ si varindex
    );
    flush stdout;
    let relabel = mk_label_map syms exes in
    let varmap = mk_tvar_map vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len
    in

    (* replace all function returns with variable initialisations *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_inline_" ^ id ^ "_"^ si n in
    body2 := `BEXE_label (sr,end_label) :: !body2;
    let t = ref None in
    iter
      (function 
      | `BEXE_fun_return (sr,((_,t') as e)) ->
        t := Some t';
        let call_instr = `BEXE_init (sr,varindex,e) in
        body2 := `BEXE_goto (sr,end_label) :: !body2;
        body2 := call_instr :: !body2;
      | x -> body2 := x::!body2
      )
      body
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)

    (* reverse, eliminating trailing "goto x; x:>" *)
    begin 
      match !body2 with
      | `BEXE_label (_,lab1) :: `BEXE_goto (_,lab2) :: t 
        when lab1=lab2 -> rev t
      | b -> rev b
    end

  | _ -> assert false

let ident x = x 

let bunravel syms ts e = 
  let counter = syms.counter in 
  let vars = ref [] in
  let rec urv e = 
    match map_tbexpr urv ident e with
    | (`BEXPR_apply_direct _,t) as x ->
      let n = !counter in incr counter;
      vars := (n,x) :: !vars ;
      `BEXPR_name (n,ts),t
    | x -> x
  in
    let x = urv e in
    x,!vars

(* output in reverse order *)
let xmap_bexe syms (child_map,bbdfns) caller vs exe : bexe_t list = 
  let ts = map (fun (_,i)-> `BTYP_var i) vs in
  let u sr e = 
    let x,xs = bunravel syms ts e in
    iter 
    (fun (i,((x,t) as e)) -> 
      let id = "_urv_" ^ si i  in
      (*
      print_endline (id ^ "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
      *)
      let entry = `BBDCL_val (vs,t) in
      Hashtbl.add bbdfns i (id,Some caller,sr,entry);
      let kids = 
        try Hashtbl.find child_map caller
        with Not_found -> [] 
      in
      Hashtbl.replace child_map caller (i::kids)
    )
    xs
    ;
    let inits = map (fun (i,e)->`BEXE_init (sr,i,e)) xs in
    x,inits
  in
  let x = 
    match exe with
    | `BEXE_call_prim (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_prim (sr,i,ts,e) :: xs

    | `BEXE_call_stack (sr,i,ts,e2) -> assert false

    | `BEXE_call_direct (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_direct (sr,i,ts,e) :: xs
   
    | `BEXE_assign (sr,e1,e2) ->
      let e,xs = u sr e2 in
      `BEXE_assign (sr,e1,e) :: xs

    | `BEXE_call (sr,e1,e2) ->
      (* DUBIOUS...screws up call lifting?? *)
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call (sr,e1,e2) :: xs2 @ xs1

    | `BEXE_jump (sr,e1,e2) -> assert false
   
    | `BEXE_loop (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_loop (sr,i,e) :: xs
   
    | `BEXE_ifgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifgoto (sr,e,lab) :: xs

    | `BEXE_ifnotgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifnotgoto (sr,e,lab) :: xs
   
   
    | `BEXE_fun_return (sr,e) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,e) :: xs
   
    | `BEXE_init (sr,i,e) ->
      (* NOTE: will generate gratuitous variable .. *)
      let e,xs = u sr e in
      `BEXE_init (sr,i,e) :: xs
    
    | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
      let e,xs = u sr e in
      `BEXE_regmatch (sr,e,(a,sc,h,tr)) :: xs
   
    | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
      let p1,xs1 = u sr p1 in
      let p2,xs2 = u sr p2 in
      `BEXE_reglex(sr,p1,p2,(a,sc,h,tr)) :: xs1 @ xs2
    
    | `BEXE_read _
    | `BEXE_label _
    | `BEXE_goto _
    | `BEXE_code _
    | `BEXE_proc_return _
    | `BEXE_comment _
    | `BEXE_nop _
      -> [exe]
  in
    rev x

let heavy_inline_call syms (child_map,bbdfns) 
  caller caller_vs callee ts argument id sr (props, vs, ps, exes)
=
  (*
  print_endline ("Examining call to " ^ si callee);
  *)
  (*
  print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
  print_endline ("Callee is " ^ id ^ "<"^si callee ^ "> with ts = " ^ catmap "," (sbt syms.dfns) ts);
  print_endline ("Callee vs=" ^ string_of_vs vs);
  *)
  let caller_vs_len = length caller_vs in
  let callee_vs_len = length vs in
  (*
  print_endline ("In the callee and its children,");
  print_endline ("The callee vs are elided and replaced by the caller vs");
  print_endline ("ELIDE: first " ^ si callee_vs_len ^ ", PREPEND " ^ si caller_vs_len);
  print_endline ("This works by instantiating the callee vs with the calls ts");
  *)
  assert(length vs = length ts);
  
  (*
  print_endline ("Found procedure "^id^": Inline it!");
  *)
  let relabel = mk_label_map syms exes in
  let varmap = mk_tvar_map vs ts in
  let revariable = reparent_children 
    syms (child_map,bbdfns) 
    caller_vs callee_vs_len callee (Some caller) relabel varmap
  in
  gen_body syms (child_map,bbdfns) id 
    varmap ps relabel revariable exes 
    argument sr caller callee caller_vs callee_vs_len

let rec heavy_inline_calls
  syms (child_map,bbdfns)
  caller_vs caller excludes exes 
=
  let hic callee exes = 
    heavy_inline_calls syms (child_map,bbdfns) 
    caller_vs caller (callee::excludes) (rev exes) 
  in
  let exes' = ref [] in (* reverse order *)
  iter 
  (fun exe -> 
    match exe with
    | `BEXE_call_direct (sr,callee,ts,argument) 
      when not (mem callee excludes)
      ->
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_procedure (props,vs,ps,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then begin
          (*
          print_endline "INLINE CANDIDATE DETECTED - CALL";
          *)
          let xs = 
            heavy_inline_call syms (child_map,bbdfns) 
            caller caller_vs callee ts argument id sr (props,vs,ps,exes)
          in 
            exes' := hic callee xs @ !exes'
        end
        else
          exes' := exe :: !exes'

      | _ ->  exes' := exe :: !exes'
      end

    | `BEXE_call (sr,(`BEXPR_apply((`BEXPR_closure (callee,ts),_),a),_),argument) -> assert false
    | `BEXE_call (sr,(`BEXPR_apply_stack (callee,ts,a),_),argument) -> assert false

    | `BEXE_call (sr,(`BEXPR_apply_direct (callee,ts,a),_),argument)
      when not (mem callee excludes)
      ->
      (*
      print_endline "DETECTED CANDIDATE FOR CALL LIFTING ";
      print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
      print_endline (string_of_bexe syms.dfns 0 exe);
      print_endline ("Callee is " ^ si callee ^ " with ts = " ^ catmap "," (sbt syms.dfns) ts);
      *)
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             call_lifting syms (child_map,bbdfns) caller caller_vs callee ts a argument
          in 
            exes' := hic callee xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_init (sr,i,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_function syms (child_map,bbdfns) caller caller_vs callee ts a i
          in 
            exes' := hic callee xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | _ -> exes' := exe :: !exes'
  )
  exes
  ;
  !exes'
   
let tailit syms (child_map,bbdfns) this sr ps vs exes : bexe_t list = 
  let ts' = map (fun (_,i) -> `BTYP_var i) vs in
  let parameter = !(syms.counter) in incr syms.counter;
  let param_used = ref false in
  let start_label = "start_" ^ si parameter in
  let paramtype  =
    match map (fun (_,(_,t)) -> t) ps with
    | [x] -> x
    | x -> `BTYP_tuple x
  in
  let cal_tail_call e = 
    match length ps with
    | 0 -> [`BEXE_goto (sr,start_label)]
    | 1 ->
      let (_,(k,_)) = hd ps in
      [
        `BEXE_goto (sr,start_label);
        `BEXE_init (sr,k,e)
      ]
    | _ ->

      [
        `BEXE_goto (sr,start_label);
        `BEXE_init (sr,parameter,e)
      ]
      @
      begin
        param_used := true;
        let p = `BEXPR_name (parameter,ts'),paramtype in  
        let n = ref 0 in
        map
        (fun (_,(ix,prjt)) ->
          let prj = `BEXPR_get_n (!n,p),prjt in
          incr n;
          `BEXE_init (sr,ix,prj)
        )
        ps
      end
  in
  let rec aux exes res = match exes with
  | `BEXE_call_direct (sr,i,ts,a) :: `BEXE_proc_return _ :: tail 
    when (i,ts)=(this,ts') 
    ->
     print_endline ("--> Tail loop " ^ si this);
     let res = cal_tail_call a @ res
     in aux tail res

  | [] -> rev res
  | h :: t  -> aux t (h::res)
  in 
    let exes = aux exes [] in

    (* if parameter used, create a variable *)
    if !param_used then
    begin
      let entry = `BBDCL_var (vs,paramtype) in
      let kids = 
        try Hashtbl.find child_map this
        with Not_found -> [] 
      in
      Hashtbl.replace child_map this (parameter::kids);
      let id = "_trp_" ^ si  parameter in
      Hashtbl.add bbdfns parameter (id,Some this,sr,entry);
    end
    ;
    (* return with posssible label at start *)
    if !param_used 
    then `BEXE_label (sr,start_label) :: exes
    else exes
  
let tail_bbdcl syms (child_map,bbdfns) i =
  match Hashtbl.find bbdfns i with
  | id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) ->
    let exes = tailit syms (child_map,bbdfns) i sr ps vs exes in
    let data = id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) in
    Hashtbl.replace bbdfns i data

  | id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) ->
    let exes = tailit syms (child_map,bbdfns) i sr ps vs exes in
    let data = id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) in
    Hashtbl.replace bbdfns i data

  | _ -> ()

let heavily_inline_bbdcl syms (child_map,bbdfns) i =
  match Hashtbl.find bbdfns i with
  | id,parent,sr,`BBDCL_procedure (props,vs,p,exes) ->
    (*
    print_endline ("HIB: Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
    print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let exes = heavy_inline_calls syms (child_map,bbdfns) vs i [i] exes in
    let exes = rev exes in
    (*
    print_endline ("Output:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let data = id,parent,sr,`BBDCL_procedure (props,vs,p,exes) in
    Hashtbl.replace bbdfns i data

  | id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) ->
    (*
    print_endline ("HIB:Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
    print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let exes = heavy_inline_calls syms (child_map,bbdfns) vs i [i] exes in
    let exes = rev exes in
    (*
    print_endline ("Output:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let data = id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) in
    Hashtbl.replace bbdfns i data

  | _ -> ()

let unravel_bbdcl syms (child_map,bbdfns) i =
  match Hashtbl.find bbdfns i with
  | id,parent,sr,`BBDCL_procedure (props,vs,p,exes) ->
    (*
    print_endline ("UNRAVEL:Examining procedure " ^ id ^ "<"^ si i ^ "> for unravelling");
    print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let exes = concat ( map (xmap_bexe syms (child_map,bbdfns) i vs) exes) in
    (*
    print_endline ("Output:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let data = id,parent,sr,`BBDCL_procedure (props,vs,p,exes) in
    Hashtbl.replace bbdfns i data

  | id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) ->
    (*
    print_endline ("UNRAVEL:Examining function " ^ id ^"<" ^ si i ^ "> for unravelling");
    print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let exes = concat ( map (xmap_bexe syms (child_map,bbdfns) i vs) exes) in
    (*
    print_endline ("Output:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
    *)
    let data = id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) in
    Hashtbl.replace bbdfns i data

  | _ -> ()

let heavy_inlining syms  
  (child_map,bbdfns)
  (root:bid_t) 
  (bifaces:biface_t list) 
=
  (* make set of used things, initially empty *)
  let used = ref BidSet.empty in

  (* make a list of the root and all exported functions,
  add exported types and components thereof into the used
  set now too
  *)
  let roots = ref (BidSet.singleton root) in
  iter
  (function
     | `BIFACE_export_fun (_,x,_) -> roots := BidSet.add x !roots
     | _ -> ()
  )
  bifaces
  ;
  let uses i = Flx_use.uses syms used (child_map,bbdfns) i in

  (* add root items to set, then add items it uses *)
  BidSet.iter uses !roots
  ;
  
  (*
  print_endline "Inlining heavy pass1";
  *)
  BidSet.iter (tail_bbdcl syms (child_map,bbdfns)) !used;
  BidSet.iter (heavily_inline_bbdcl syms (child_map,bbdfns)) !used;
  (*
  print_endline "Unravelling";
  *)
  BidSet.iter (unravel_bbdcl syms (child_map,bbdfns)) !used;
  (*
  print_endline "Inlining heavy pass2";
  *)
  BidSet.iter (heavily_inline_bbdcl syms (child_map,bbdfns)) !used;
  (*
  print_endline "Inlining done"
  *)
