@head(1,"Inlining")
To make this work, we need a theorem.
First, the call rule is:
@begin_displayed_code()
A procedure may only call a child of an ancestor.
@end_displayed_code()
Note an ancestor is itself or a parent
of any ancestor: that is, a procedure
is an ancestor of itself. A parentless toplevel
procedure is considered a child of a dummy root
to make this simple formulation work.
@p()
It is clear we can inline any sibling
by copying its body, and duplicating
any children -- variables and nested
procedures included. This is because
any references to its parent will
go through from the caller, since
they have the same parent.
@p()
Clearly this result extends to any
child of any parent.

@h = tangler("src/flx_inline.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes

val heavy_inlining:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  fully_bound_symbol_table_t

val descendants:
  (bid_t, bid_t list) Hashtbl.t ->
  bid_t ->
  PosSet.t
  
@h = tangler("src/flx_inline.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use

module BidSet = PosSet

(* closure of index with respect to children, EXCLUDES self *)
let rec descendants child_map index =
  let d = ref PosSet.empty in
  let children = try Hashtbl.find child_map index with Not_found -> [] in
  iter
  (fun i -> 
    if not (PosSet.mem i !d) then
    begin
      d := PosSet.add i !d;
      d := PosSet.union !d (descendants child_map i)
    end
  )
  children
  ;
  !d

let mk_remap counter d =
  let m = Hashtbl.create 97 in
  PosSet.iter
  (fun i -> 
    let n = !counter in 
    incr counter; 
    Hashtbl.add m i n
  )
  d
  ;
  m

(* varmap is the *typevariable* remapper, 
 revariable remaps indices
*)
let gen_expr syms varmap revariable e = 
  let auxt t = varmap_subst varmap t in
  let rec aux e = match map_tbexpr aux auxt e with
  | `BEXPR_name (i,ts),t ->
    let ts' = map auxt ts in
    let j = try Hashtbl.find revariable i with Not_found -> i in
    `BEXPR_name (j,ts'), auxt t

  | `BEXPR_ref (i,ts) as x,t ->
    let ts' = map auxt ts in
    let j = try Hashtbl.find revariable i with Not_found -> i in
    `BEXPR_ref (j,ts'), auxt t

  | `BEXPR_closure (i,ts),t ->
    let ts' = map auxt ts in
    let j = try Hashtbl.find revariable i with Not_found -> i in
    `BEXPR_closure (j,ts'), auxt t

  | x -> x
  in
    let a = aux e in
    (*
    print_endline ("replace " ^ sbe syms.dfns e ^ "-->" ^ sbe syms.dfns a);
    *)
    a


let remap syms varmap revariable exe =
  let ge e = gen_expr syms varmap revariable e in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  match exe with 
  | `BEXE_call (sr,e1,e2)  -> `BEXE_call (sr,ge e1, ge e2)
  | `BEXE_jump (sr,e1,e2)  -> `BEXE_jump (sr,ge e1, ge e2)
  | `BEXE_loop (sr,i,e) -> failwith "[opt3:remap] Can't handle loop"
  | `BEXE_ifgoto (sr,e,lab) -> `BEXE_ifgoto (sr,ge e, lab)
  | `BEXE_ifnotgoto (sr,e,lab) -> `BEXE_ifnotgoto (sr,ge e, lab)
  | `BEXE_fun_return (sr,e) -> `BEXE_fun_return (sr, ge e)
  | `BEXE_assign (sr,e1,e2) -> `BEXE_assign (sr, ge e1, ge e2)
  | `BEXE_init (sr,i,e) -> `BEXE_init (sr,revar i, ge e)
  | `BEXE_read (sr,i)  -> `BEXE_read (sr, revar i)

  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    `BEXE_regmatch (sr, ge e,(a,sc,h',tr))
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    `BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))

  | `BEXE_code (sr,s)  as x -> x
  | `BEXE_goto (sr,lab) as x -> x
  | `BEXE_proc_return sr as x -> x
  | `BEXE_comment (sr,s) as x -> x
  | `BEXE_nop (sr,s) as x -> x
  | `BEXE_label (sr,lab) as x -> x

let remaps syms varmap revariable exes =
  map (remap syms varmap revariable) exes

let reparent1 syms bbdfns bbdfns2 varmap revariable index parent:unit =
  let k = Hashtbl.find revariable index in
  let id,_,sr,entry = Hashtbl.find bbdfns index in
  match entry with
  | `BBDCL_procedure (props,vs,ps,exes) ->
    let exes = remap syms varmap revariable exes in
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_procedure (props,vs,ps,exes))
    
  | `BBDCL_function (props, vs, ps, ret, exes) ->
    let exes = remap syms varmap revariable exes in
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes))

  | `BBDCL_var (vs,t) ->
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_var (vs,t))

  | `BBDCL_val (vs,t) ->
    Hashtbl.add bbdfns2 k (id,parent,sr,`BBDCL_val (vs,t))

  | _ -> assert false

(* make a copy all the descendants of i, changing any
  parent which is i to the given new parent
*)

let reparent_children syms (child_map,bbdfns) bbdfns2 index parent =
 let varmap = Hashtbl.create 97 in (* DUMMY at the moment *)
 let closure = descendants child_map index in
 let revariable = mk_remap syms.counter closure in
 PosSet.iter
 (fun i -> 
   let old_parent = 
       match Hashtbl.find bbdfns i with id,oldp,_,_ -> oldp
   in
   let new_parent: bid_t option =
     match old_parent with
     | None -> assert false
     | Some p ->
       if p = index then parent
       else Some (Hashtbl.find revariable p)
   in
   reparent1 syms bbdfns bbdfns2 varmap revariable i new_parent
 )
 closure
 

 
exception Found
let has_nested_funs (child_map,bbdfns) i =
  let children = try Hashtbl.find child_map i with Not_found -> [] in
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_procedure _ 
      | `BBDCL_function _  -> raise Found
      | _ -> ()
    )
    children
    ;
    false
  with Found -> true
    
(* Heavy inlining routine. This routine can inline
any procedure. The basic operation is emit the body
of the target procedure. We have to do the following to
make it all work.

(1) Each declared label is replaced by a fresh one,
and all jumps to these labels modified accordingly.

(2) Variables are replaced by fresh ones. This requires
making additions to the output bound tables. References
to the variables are modified. Note the parent is the
caller now.

(3) Paremeters are replaced like variables, initialised
by the arguments.

(4) Any type variables instantiated by the call must
also be instantiated in body expressions, as well as
the typing of any generated variables.

(5) If the procedure has any nested procedures, they
also must be replaced in toto by fresh ones, reparented
to the caller so that any calls to them will access
the fresh variables in the caller.

Note that the cache of children of the caller will
be wrong after the inlining (it may have acquired new
variables or procedure children).

Note that this inlining procedure is NOT recursive!
Its a flat one level inlining. This ensures recursive
calls don't cause an infinite unrolling, and hopefully
prevent gross bloat.
*)

let mk_label_map syms exes = 
  let h = Hashtbl.create 97 in
  let aux = function
  | `BEXE_label (sr,s) -> 
    let n = !(syms.counter) in
    incr syms.counter;
    let s' =  "_" ^ si n in
    Hashtbl.add h s s'
  | _ -> ()
  in
    iter aux exes;
    h
    
let mk_var_map syms varmap new_parent vs' bbdfns bbdfns2 k =
  let h = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i (id,parent,sr,entry) ->
    if parent = Some k then
    match entry with
    | `BBDCL_var (vs,t) 
    | `BBDCL_val (vs,t) ->
      let n = !(syms.counter) in
      incr syms.counter;

      let t = varmap_subst varmap t in
      let entry = match entry with 
        | `BBDCL_var _ -> `BBDCL_var (vs',t) 
        | `BBDCL_val _ -> `BBDCL_val (vs',t) 
        | _ -> assert false
      in
      Hashtbl.add bbdfns2 n (id,Some new_parent,sr,entry);
      Hashtbl.add h i n;

      (* slightly hacky .. *)
      let symdat = Hashtbl.find syms.dfns i in
      let symdat = { symdat with parent = Some new_parent } in
      Hashtbl.add syms.dfns n symdat


    | _ -> ()
  )
  bbdfns
  ;
  h

let mk_tvar_map vs ts =
  let varmap = Hashtbl.create 97 in (* type variable assignments *)
  iter2
  (fun (_,i) t -> Hashtbl.add varmap i t)
  vs ts
  ;
  varmap

(* NOTE: result is in reversed order *)
let gen_body syms bbdfns bbdfns2 id varmap ps relabel revariable exes argument sr caller vs =
  let paramtype  =
    let pt = 
      let pts = map (fun (_,(_,t)) -> t) ps in
      match pts with
      | [x] -> x
      | x -> `BTYP_tuple x
    in
      varmap_subst varmap pt
  in
 
  let ge e = gen_expr syms varmap revariable e in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let self_loop = ref false in
  let end_label_used = ref false in

  (* create a variable for the parameter *)
  let parameter = !(syms.counter) in 
  incr syms.counter; 
  (*
  print_endline ("Parameter assigned index " ^ si parameter);
  *)

  (* create an end label using the parameter index as id *)
  let end_label = "_end_" ^ (si parameter) in 

  (* create variables for parameter components *)
  if length ps > 1 then 
  for i = 1 to length ps do incr syms.counter done;
  
  (* create a possible label for a tail call *)
  let loop_start = 
    let n = !(syms.counter) in 
    incr syms.counter;
    "loop_" ^ si n 
  in
  let remap: bexe_t -> bexe_t list =  function
  | `BEXE_call (sr,e1,e2)  -> [`BEXE_call (sr,ge e1, ge e2)]
  | `BEXE_jump (sr,e1,e2)  -> [`BEXE_jump (sr,ge e1, ge e2)]
  | `BEXE_loop (sr,i,e) -> 
    (* SPECIAL HANDLING OF LOOP REQUIRED *)
    if i = 0 then begin
      self_loop := true;
      match length ps with
      | 0 -> [`BEXE_goto (sr,loop_start)]
      | 1 ->
        let (_,(k,_)) = hd ps in
        [
          `BEXE_init (sr,revar k,ge e);
          `BEXE_goto (sr,loop_start)
        ]
      | _ ->
        [
          `BEXE_init (sr,parameter,ge e);
          `BEXE_goto (sr,loop_start)
        ]
    end
    else 
    begin
      failwith "Loop to non-self unimplemented in inliner";
      (* this is probably right sometimes .. need to check *)
      [`BEXE_loop (sr,i-1,ge e)]
    end

  | `BEXE_ifgoto (sr,e,lab) -> [`BEXE_ifgoto (sr,ge e, relab lab)]
  | `BEXE_ifnotgoto (sr,e,lab) -> [`BEXE_ifnotgoto (sr,ge e, relab lab)]
  | `BEXE_fun_return (sr,e) -> [`BEXE_fun_return (sr, ge e)]
  | `BEXE_assign (sr,e1,e2) -> [`BEXE_assign (sr, ge e1, ge e2)]
  | `BEXE_init (sr,i,e) -> [`BEXE_init (sr,revar i, ge e)]
  | `BEXE_read (sr,i)  -> [`BEXE_read (sr, revar i)]

  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_regmatch (sr, ge e,(a,sc,h',tr))]
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))]

  | `BEXE_code (sr,s)  as x -> [x]
  | `BEXE_goto (sr,lab) -> [`BEXE_goto (sr, relab lab)]
  | `BEXE_proc_return sr as x -> 
    end_label_used := true;
    [`BEXE_goto (sr,end_label)]

  | `BEXE_comment (sr,s) as x -> [x]
  | `BEXE_nop (sr,s) as x -> [x]
  | `BEXE_label (sr,lab) -> [`BEXE_label (sr, relab lab)]
  in
    let b = ref [`BEXE_comment (sr,("Inline call to " ^ id))] in

    (* Initialise parameter to argument, but only if
       the argument is not unit
    *)
    if length ps > 0 then
    begin
      let x = 
        if length ps > 1
        then begin
          let entry = `BBDCL_var (vs,paramtype) in
          Hashtbl.add bbdfns2 parameter (id,Some caller,sr,entry);
          `BEXE_init (sr,parameter,argument)
        end
        else 
          let vid,(k,_) = hd ps in
          let index = revar k in
          `BEXE_init (sr,index,argument)
      in
      b := x :: !b;
     
      (* unpack argument *)
      if length ps > 1 then
      let p = `BEXPR_name (parameter,[]),paramtype in  
      let n = ref 0 in
      iter 
      (fun (vid,(ix,prjt)) ->
        let prjt = varmap_subst varmap prjt in
        let prj = `BEXPR_get_n (!n,p),prjt in
        let index = revar ix in
        let x = `BEXE_init (sr,index,prj) in
        b := x :: !b;
        incr n
      )
      ps
    end
    ;
    (* If we loop with a tail call, 
      we need to make an entry point for the jump,
      make it anyhow because it goes at the wrong
      end of the list .. 
    *)
    let x = `BEXE_label (sr,loop_start) in
    b := x :: !b;
    ;
    iter
    (fun exe -> 
      iter 
      (fun x -> b := x :: !b) 
      (remap exe)
    )
    exes
    ;
    if !end_label_used then 
      b := (`BEXE_label (sr,end_label)) :: !b
    ;
    !b


(* CALL LIFTING. What this does is transform a call:

  call (f a) arg

  by replacing it with the body of f,
  in which every 
  
  return x 
  
  is replaced by 
  
  call x arguemnt

  This converts  f from a function returning
  a procedure, to a procedure which executes that
  procedure.

*)

let call_lifting syms bbdfns bbdfns2 caller vs' callee ts a argument =
  print_endline "DOING CALL LIFTING";
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let label_map = mk_label_map syms exes in
    let varmap = mk_tvar_map vs ts in
    let var_map = mk_var_map syms varmap caller vs' bbdfns bbdfns2 callee in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms bbdfns bbdfns2 id varmap ps label_map var_map 
      exes a sr caller vs
    in

    (* replace all function returns with tail calls *)
    let body =
      rev_map
      (function 
      | `BEXE_fun_return (sr,e) ->
        `BEXE_jump (sr,e,argument) 
      | x -> x
      )
      body
    in
      print_endline (
       catmap "\n" (string_of_bexe syms.dfns 0) body
      )
      ;
      body

  | _ -> assert false

let heavy_inline_call syms bbdfns bbdfns2 caller vs' callee ts argument =
  (*
  print_endline ("Examining call to " ^ si callee);
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_procedure (props,vs,ps,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let label_map = mk_label_map syms exes in
    let varmap = mk_tvar_map vs ts in
    let var_map = mk_var_map syms varmap caller vs' bbdfns bbdfns2 callee in
    gen_body syms bbdfns bbdfns2 id varmap ps label_map var_map exes argument sr caller vs

  | _ -> assert false
  

let heavy_inline_calls syms (child_map,bbdfns) bbdfns2 vs' exes caller =
  let exes' = ref [] in
  iter
  (function 
  | `BEXE_call (sr,(`BEXPR_closure (callee,ts),_),argument) as x ->
     let id,parent,sr,entry = Hashtbl.find bbdfns callee in
     begin match entry with
     | `BBDCL_procedure _ ->
       if not (has_nested_funs (child_map,bbdfns) callee) then
       let xs = 
         heavy_inline_call syms bbdfns bbdfns2 caller vs' callee ts argument
       in 
         exes' := xs @ !exes'
       else
         exes' := x :: !exes'

     | _ ->  exes' := x :: !exes'
     end

  | `BEXE_jump (sr,(`BEXPR_closure (callee,ts),_),argument) as x ->
     let id,parent,sr,entry = Hashtbl.find bbdfns callee in
     begin match entry with
     | `BBDCL_procedure _ ->
       if not (has_nested_funs (child_map,bbdfns) callee) then
       let xs = 
         heavy_inline_call syms bbdfns bbdfns2 caller vs' callee ts argument
       in 
         exes' := xs @ !exes'
       else
         exes' := x :: !exes'

     | _ ->  exes' := x :: !exes'
     end
     ;
     exes' := `BEXE_proc_return sr :: !exes'

  | (`BEXE_call (sr,(`BEXPR_apply((`BEXPR_closure (callee,ts),_),a),_),argument)) as x ->
    print_endline "DETECTED CANDIDATE FOR CALL LIFTING ";
    print_endline (string_of_bexe syms.dfns 0 x);
    begin try
      let xs = 
       call_lifting syms bbdfns bbdfns2 caller vs' callee ts a argument
      in 
        exes' := xs @ !exes'
    with _ ->
      exes' := x :: !exes'
    end

  | x -> exes' := x :: !exes'
  )
  exes
  ;
  rev !exes' 
  
let heavily_inline_bbdcl syms (child_map,bbdfns) bbdfns2 i =
  let data =
    match Hashtbl.find bbdfns i with
    | id,parent,sr,`BBDCL_procedure (props,vs,p,exes) ->
      (*
      print_endline ("Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      *)
      let exes = heavy_inline_calls syms (child_map,bbdfns) bbdfns2 vs exes i in
      id,parent,sr,`BBDCL_procedure (props,vs,p,exes)

    | id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) ->
      (*
      print_endline ("Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      *)
      let exes = heavy_inline_calls syms (child_map,bbdfns) bbdfns2 vs exes i in
      id,parent,sr,`BBDCL_function (props,vs,p,ret,exes)
    | x -> x
  in
    Hashtbl.add bbdfns2 i data

let heavy_inlining syms  
  (child_map,bbdfns)
  (root:bid_t) 
  (bifaces:biface_t list) 
=
  (* make set of used things, initially empty *)
  let used = ref BidSet.empty in

  (* make a list of the root and all exported functions,
  add exported types and components thereof into the used
  set now too
  *)
  let roots = ref [root] in
  iter
  (function
     | `BIFACE_export_fun (_,x,_) -> roots := x :: !roots
     | `BIFACE_export_type (_,t,_) -> 
        uses_type syms used (child_map,bbdfns) t
  )
  bifaces
  ;
  let uses i = uses syms used (child_map,bbdfns) i in

  (* add root items to set, then add items it uses *)
  iter uses !roots
  ;
  (* copy used things *)
  let bbdfns2 = Hashtbl.create 97 in
  BidSet.iter (heavily_inline_bbdcl syms (child_map,bbdfns) bbdfns2) !used
  ;
  (* copy all header and body specs, they're always considered used *)
  Hashtbl.iter
  (fun i b -> match b with
    | _,_,_,`BBDCL_header _
    | _,_,_,`BBDCL_body _ -> Hashtbl.add bbdfns2 i b
    | _ -> ()
  )
  bbdfns
  ;
  bbdfns2

