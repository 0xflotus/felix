@head(1,"Elide unused entries")
Name binding pass 2.

@h = tangler("src/flx_use.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_typing
val instantiate:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  unit

@h = tangler("src/flx_use.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic

module BidSet = PosSet

(* Elide calls to useless procedures. Note we can't simply
elide the procedures, since they might be addressed/passed
as an argument, or be a root [main or exported]. 

Instead we rely on 'elide_useless' to elide procedures 
which are unused, by first eliding the call.
*)

exception Useful
let rec isuseless bbdfns exes = 
  let check i =         
    try 
      match Hashtbl.find bbdfns i with 
      | _,_,`BBDCL_procedure (_,_,exes,_) -> 
        if not (isuseless bbdfns exes) 
        then raise Useful
        else ()
      | _,_,`BBDCL_proc _
      | _,_,`BBDCL_val _
      | _,_,`BBDCL_var _
        -> raise Useful
      | _ -> failwith "[isuseless] Expected procedure type"
    with 
      Not_found -> ()
  in
  try
    List.iter
    (fun x -> match x with
      | `BEXE_call ((`BEXPR_closure (i,_),_),_) 
      | `BEXE_call ((`BEXPR_name i,_),_) 
      | `BEXE_jump ((`BEXPR_closure (i,_),_),_) 
      | `BEXE_jump  ((`BEXPR_name i,_),_) 
        -> 
         check i

      | `BEXE_jump _
      | `BEXE_call _ (* assume useful if not call to named useful proc *)
      | `BEXE_read _ (* useful even if local, due to side effect *)
      | `BEXE_code _ 
      | `BEXE_goto _ (* assume a non-local goto here *)
      | `BEXE_fun_return _ (* returning a value is useful *)
        -> raise Useful 

      (* NOTE: 
        BEXE_init always inits a local variable which isn't useful by itself 
        BEXE_loop isn't useful by itself
      *)
      | _ -> () 
    )
    exes
    ;
    true
  with Useful -> false

let useless_call_elim bbdfns exes =
  let exes' = ref [] in
  List.iter
  (fun x -> match x with
  | `BEXE_call ((`BEXPR_closure (i,_),_),_)
  | `BEXE_call ((`BEXPR_name i,_),_)
    -> (* only keep calls to useful procedures *) 
      begin match Hashtbl.find bbdfns i with
      | id,parent,`BBDCL_procedure (_,ps,exes,nm) ->
        if not (isuseless bbdfns exes) then exes' := x :: !exes'
      | _ -> exes' := x :: !exes'
      end

  | `BEXE_jump ((`BEXPR_closure (i,_),_),_)
  | `BEXE_jump ((`BEXPR_name i,_),_)
    -> (* only keep calls to useful procedures *) 
      begin match Hashtbl.find bbdfns i with
      | id,parent,`BBDCL_procedure (_,ps,exes,nm) ->
        if not (isuseless bbdfns exes) then exes' := x :: !exes'
        else exes' := `BEXE_proc_return :: !exes'
        
      | _ -> exes' := x :: !exes'
      end

  | `BEXE_nop _ 
  | `BEXE_comment _  (* we shouldn't really elide comments .. *)
    -> ()
  | `BEXE_label s -> (* but it makes this test easier *)
    while            (* eliminate jumps to next instruction *)
      match !exes' with
      | (`BEXE_goto s') :: _
      | (`BEXE_ifgoto (_,s')) :: _
      | (`BEXE_ifnotgoto (_,s')) :: _
        -> s = s'
      | _ -> false
    do 
      exes' := List.tl !exes'
    done
    ;
    exes' := x :: !exes'

  | x -> exes' := x :: !exes'
  )
  exes
  ;

  (* replace call/return with jump *)
  let exes'' = ref [] in
  let tack x = exes'' := x :: !exes'' in
  let rec tail_check (lst: bexe_t list) = 
    match lst with
    | [] -> ()
    | `BEXE_proc_return :: `BEXE_proc_return :: t ->
      tail_check (`BEXE_proc_return :: t)
      
    | `BEXE_proc_return :: `BEXE_call (p,a) :: t ->
      begin 
        match p with
        | (`BEXPR_closure (i,_),_) ->
          begin 
            match Hashtbl.find bbdfns i with
            | id,parent,`BBDCL_proc _ ->
              tack `BEXE_proc_return;
              tack (`BEXE_call (p,a));
              tail_check t

            | _ -> 
              tack (`BEXE_jump (p,a));
              tail_check t
          end
        | _ -> 
          tack (`BEXE_jump (p,a)); 
          tail_check t
      end

    | h :: t -> 
      tack h; 
      tail_check t
  in
    tail_check (`BEXE_proc_return :: !exes');
    !exes''

let rec uses_type used bbdfns t = 
  let ut t = uses_type used bbdfns t in
  match t with
  | `BTYP_name i 
    -> uses used bbdfns i

  | `BTYP_inst (i,ts)
    -> 
      uses used bbdfns i;
      List.iter ut ts

  | `BTYP_tuple ts
  | `BTYP_sum ts
  | `BTYP_type_tuple ts
    -> List.iter ut ts

  | `BTYP_function (t1, t2)
  | `BTYP_apply (t1, t2)
  | `BTYP_binding (t1, t2)
    -> ut t1; ut t2
    
  | `BTYP_pointer t -> ut t
  | `BTYP_typefun (ts, t1, t2) 
    ->
      List.iter ut (List.map snd ts);
      ut t1; ut t2
  | _ -> ()

and uses_exes used bbdfns exes =
  List.iter (uses_exe used bbdfns) exes

and uses_exe used bbdfns (exe:bexe_t) =
  let ue e = uses_tbexpr used bbdfns e in
  match exe with
  | `BEXE_call (e1,e2) 
  | `BEXE_jump (e1,e2) 
    -> ue e1; ue e2
    
  | `BEXE_loop (_,e)
  | `BEXE_ifgoto (e,_)
  | `BEXE_ifnotgoto (e,_)
  | `BEXE_fun_return e 
    -> ue e

  | `BEXE_init (i,e) -> uses used bbdfns i; ue e
  | `BEXE_read i -> uses used bbdfns i
  | _ -> ()

and uses_tbexpr used bbdfns (e,t) =
  let ue e = uses_tbexpr used bbdfns e in
  let ut t = uses_type used bbdfns t in
  let ui i = uses used bbdfns i in

  ut t;

  match e with
  | `BEXPR_deref e
  | `BEXPR_get_n (_,e)
  | `BEXPR_match_case (_,e)
  | `BEXPR_case_arg (_,e)
    -> ue e
    
  | `BEXPR_name (i,ts)
    -> ui i; iter ut ts
    
  | `BEXPR_apply (e1,e2) -> ue e1; ue e2
  | `BEXPR_tuple es -> List.iter ue es 
  | `BEXPR_dot (e,i)
     -> ui i; ue e
     
  | `BEXPR_coercion (e,t)
     -> ue e; ut t
     
  | `BEXPR_case (_,t)
    -> ut t

  | `BEXPR_closure (i,ts)
    -> ui i; iter ut ts

  | _ -> ()

and uses used bbdfns i = () (*hack from instantiator .. fix*)

(* put driver loop here .. root following .. *)
