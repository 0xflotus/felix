@head(1,"Code fragment inliner")
@h = tangler('src/flx_csubst.mli')
@select(h)
open Flx_types
open Flx_ast

val csubst:
  range_srcref ->
  range_srcref ->
  string ->
  string list -> (* value arguments as strings *)
  string list -> (* types of value arguments as strings *)
  string ->      (* argument type as string *)
  string ->      (* return type as string *)
  string list -> (* generic arguments as strings *)
  string

@h = tangler('src/flx_csubst.ml')
@select(h)
open Flx_types
open Flx_typing
open List
open Flx_util
open Flx_exceptions

(* substitution encoding:
   $n: n'th component of argument tuple, 1 origin!
   $a: expands to $1, $2, .. $n
   $b: expands to $2, .. $n
   `n: n'th component of argument tuple, reference kind

   #x: expands to #x for all 'x' other than those below

   #n: type of n'th component of argument tuple (1 origin)
   #0: return type
   @n: reference to shape object
   
   $t: pass a tuple argument 'as a tuple'
   $Tn: pass argument n expanded into an argument list (varargs)
   #t: the type of the argument tuple
   @t: the shape of the argument tuple
   
   ??: expands to ?
   ?n: the n'th generic type argument ..
   ?a: expands to ?1,?2, ...

*)

(* finite state machine states *)
@modes = [
  'Normal',
  'CString',
  'CChar',
  'CStringBackslash',
  'CCharBackslash',
  'Dollar',
  'Backquote',
  'Hash',
  'Earhole',
  'Quest',
  'DollarDigits',
  'BackquoteDigits',
  'HashDigits',
  'EarholeDigits',
  'QuestDigits',
  'Varargs',
  'VarargsDigits',
  'DollarDigitsPrec',
 ]

type mode_t = 
@for m in modes: tangle(' | ' + m)

let pr = function 
@for m in modes: tangle(' | ' + m + ' -> "'+m+'"')

let is_idletter ch =
  ch >= '0' && ch <='9' ||
  ch >= 'A' && ch <='Z' ||
  ch >= 'a' && ch <='z' ||
  ch = '_'

(* identifier or integer *)
let is_atomic s =
  try 
    for i = 0 to String.length s - 1 do 
      if not (is_idletter s.[i]) then raise Not_found
    done;
    true
  with Not_found -> false
  
let csubst sr sr2 ct args typs argtyp retyp gargs =
  let n = length args in
  assert (n = length typs); 
  (* print_endline ("SUBST " ^ ct ^ ", count="^string_of_int n); *)
  let len = String.length ct in
  let buf = Buffer.create (n * 2 + 20) in
  let bcat s = Buffer.add_string buf s in
  let chcat c = Buffer.add_char buf c in
  let mode = ref Normal in
  let precname = ref "" in
  let digits = ref 0 in
  let serr i msg = 
    let spc k = String.make k ' ' in
    clierr2 sr sr2
    (
      "[csubst] " ^ msg ^ " in code fragment \n\"" ^ ct ^
       "\"\n" ^ spc (i+1) ^ "^" ^ "\n" ^ "Column " ^ string_of_int (i+1)
    )
  in
  let rec trans i ch =
    match !mode with
    | Normal -> 
      begin match ch with
      | '$' -> mode := Dollar
      | '`' -> mode := Backquote
      | '#' -> mode := Hash
      | '@' -> mode := Earhole
      | '?' -> mode := Quest
      | '\\' -> serr i "Naked \\"
      | '"' -> chcat ch; mode := CString
      | '\'' -> chcat ch; mode := CChar
      | _ -> chcat ch
      end

    | CString ->
      begin match ch with
      | '"' -> chcat ch; mode := Normal
      | '\\' -> chcat ch; mode := CStringBackslash
      | _ -> chcat ch
      end

    | CChar ->
      begin match ch with
      | '\'' -> chcat ch; mode := Normal
      | '\\' -> chcat ch; mode := CCharBackslash
      | _ -> chcat ch
      end

    | CStringBackslash -> 
      chcat ch; 
      mode := CString

    | CCharBackslash -> 
      chcat ch; 
      mode := CChar

    | Dollar ->
      begin match ch with
      | 'a' ->
        bcat (cat ", " args);
        mode := Normal

      | 'b' ->
        bcat (cat ", " (List.tl args));
        mode := Normal

      | 't' ->
        bcat ( argtyp ^ "(" ^ cat "," args ^ ")");
        mode := Normal

      | 'T' ->
        mode := Varargs

      | '0' .. '9' -> 
        digits := Char.code ch - Char.code '0'; 
        mode := DollarDigits

      | _ -> serr i "Expected 't' or digit after $"
      end

    | Varargs ->
      begin match ch with
      | '0' .. '9' -> 
        digits := Char.code ch - Char.code '0'; 
        mode := VarargsDigits

      | _ -> serr i "Expected digits after $T"
      end
      
    | Backquote ->
      begin match ch with
      | '0' .. '9' -> 
        digits := Char.code ch - Char.code '0'; 
        mode := BackquoteDigits

      | _ -> serr i "Expected digit after `"
      end

    | Quest ->
      begin match ch with
      | '?' ->
        chcat '?';
        mode := Normal

      | '0' .. '9' ->
        digits := Char.code ch - Char.code '0'; 
        mode := QuestDigits

      | 'a' ->
        bcat ( cat "," gargs);
        mode := Normal

      | _ -> serr i "Expected '?a' or digit after ?"
      end

    | Earhole ->
      begin match ch with
      | 't' ->
        bcat ( argtyp ^"_ptr_map" );
        mode := Normal

      | '0' .. '9' -> 
        digits := Char.code ch - Char.code '0'; 
        mode := EarholeDigits

      | _ -> serr i "Expected 't' or digit after @"
      end

    | Hash ->
      begin match ch with
      | 't' ->
        bcat argtyp;
        mode := Normal

      | '0' .. '9' -> 
        digits := Char.code ch - Char.code '0'; 
        mode := HashDigits

      | x -> chcat '#'; chcat x; mode:= Normal
      end

    | DollarDigits ->
      begin match ch with
      | '0' .. '9' -> 
        digits := !digits * 10 + Char.code ch - Char.code '0'

      | ':' ->
        precname := "";
        mode := DollarDigitsPrec
        
      | _ -> 
        if !digits> List.length args
        then serr i 
          ("Parameter $" ^ string_of_int !digits ^ " > number of arguments, only got " ^ si (length args))
        else if !digits<=0 then serr i ("Negative $" ^ string_of_int !digits)
        else begin
          let s' = nth args (!digits-1) in
          if is_atomic s' then bcat s'
          else bcat ("(" ^ s' ^ ")");
          mode := Normal;
          trans i ch
        end
      end

    | DollarDigitsPrec ->
      begin match ch with
      | 'a'..'z' -> precname := !precname ^ String.make 1 ch
      | _ -> 
        print_endline ("Got precedence for $" ^ si !digits ^ ":" ^ !precname);
        if !digits> List.length args
        then serr i 
          ("Parameter $" ^ string_of_int !digits ^ " > number of arguments, only got " ^ si (length args))
        else if !digits<=0 then serr i ("Negative $" ^ string_of_int !digits)
        else
          let s' = nth args (!digits-1) in
          if is_atomic s' then bcat s'
          else bcat ("(" ^ s' ^ ")");
          mode := Normal;
          trans i ch
      end

    | VarargsDigits ->
      begin match ch with
      | '0' .. '9' -> 
        digits := !digits * 10 + Char.code ch - Char.code '0'

      | _ -> 
        if !digits> List.length args
        then serr i ("Parameter no $T" ^ string_of_int !digits ^ " too large")
        else if !digits<=0 then serr i ("Arg no " ^ string_of_int !digits ^ " too small")
        else
          let s' = nth args (!digits-1) in
          let n = String.length s' in
          begin 
            try 
              let start = String.index s' '('
              and fin = String.rindex s' ')'
              in 
              let s' = String.sub s' (start+1) (fin-start-1)
              in 
                (* WE SHOULD CHECK THE # of args agrees with
                the type of the tuple .. but there is no
                way to do that since we only get a string
                representation .. this code is unequivocably
                a HACK
                *)
                bcat s';
                mode := Normal;
               trans i ch
            with Not_found -> serr i "Varargs requires  literal tuple"
          end
       end

    | BackquoteDigits ->
      begin match ch with
      | '0' .. '9' -> 
        digits := !digits * 10 + Char.code ch - Char.code '0'

      | _ -> 
        if !digits> List.length args
        then serr i ("Parameter `" ^ string_of_int !digits ^ " too large")
        else if !digits<=0 then serr i ("Arg no " ^ string_of_int !digits ^ " too small")
        else
          let s' = nth args (!digits-1) in
          let t' = nth typs (!digits-1) in
          bcat ("("^t'^"*)(" ^ s' ^ ".data)");
          mode := Normal;
          trans i ch
       end

    | EarholeDigits ->
        if !digits> List.length args
        then serr i ("Parameter @" ^ string_of_int !digits ^ " too large")
        else if !digits<0 then serr i ("Arg no " ^ string_of_int !digits ^ " too small")
        else
          let t = nth typs (!digits-1) in
          bcat (t ^ "_ptr_map");
          mode := Normal;
          trans i ch
            
    | HashDigits ->
        if !digits> List.length args
        then serr i ("Paramater #" ^ string_of_int !digits ^ " too large")
        else if !digits<0 then serr i ("Arg no " ^ string_of_int !digits ^ " too small")
        else
          bcat
          (
            if !digits = 0 
            then retyp
            else nth typs (!digits-1)
          );
          mode := Normal;
          trans i ch

    | QuestDigits ->
        if !digits> List.length gargs
        then serr i ("Generic type parameter ?" ^ string_of_int !digits ^ " too large")
        else if !digits<1 then serr i ("Generic type arg no " ^ string_of_int !digits ^ " too small")
        else
          bcat
          (
            nth gargs (!digits-1)
          );
          mode := Normal;
          trans i ch
in
  for i = 0 to len - 1 do trans i ct.[i] done;
  begin match !mode with
  | CChar
  | Normal -> ()
  | HashDigits
  | EarholeDigits
  | DollarDigits
  | DollarDigitsPrec
  | QuestDigits
    -> trans len ' ' (* hack .. space is harmless *)
  | _ -> serr len ("Unexpected end in mode " ^ pr !mode)
  end;
  Buffer.contents buf


