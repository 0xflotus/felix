@head(1,'SWIG language module')
Felix comes with a language module for the Simplified Wrapper
Interface Generator (SWIG) system:

@cite_url("http://www.swig.org")

@p()
At the time of writing, support requires a yet to be produced 
version of SWIG, at expected to be version 1.1.22, containing
dynamic loading support.
@p()
This subpackage contains the Felix language module codes:
@h = tangler("swig/CONTENTS","data")
@select(h)
felix.cxx -- the C++ code for the Felix language module for swig
felix.swg -- the standard definitions processed before user inputs

swigmain.cxx -- a replacement for Source/Modules/swigmain.cxx
           which works on version 1.1.20 and supports dynamic loading

makefile -- a file to make the felix language module
            this file MUST BE PATCHED BY HAND to locate
            the required include files if you run this makefile
            directly (the location is patched by the master makefile
            if this makefile is run recursively by it). 
            
            These files are available in the 1.1.20 distribution, 
            but they are NOT installed.

preprocessor.patch -- a patch for the 1.1.20 distribution
            preprocessor to fix a serious bug: it doesn't
            concatenate lines ending in \ inside directives.
            You will need to cd into Source/Preprocessor
            to apply the patch.

*.i  --     swig interfaces for various libraries
            you may need to patch the include locations
            to match your system.
@doc()
Here are some notes on installing the Felix module.
@h = tangler("swig/INSTALL","data")
@select(h)
In order to build the felix module for swig 1.1.20,
you must first build swig.

Then set the SWIGDEVDIR
variable in felix/swig/makefile to the top level 
of the swig development tree.

Now you can invoke the makefile with

make dynswig
make felixswig

The executable 'dynswig' uses our swigmain.cxx,
which supports dynamic loading.

The modified code provides an additional command
line option, 

-extend=<shared-lib-name>

which allows a swig extension module to be dynamically
loaded. To use the felix module you must write
something like this:

dynswig \
  -extend=/usr/local/lib/felix/swig/felix.so \
  -felix \
  -I/usr/local/lib/felix/swig \
  -o library.flx \
  library.i

where library.i is the swig library wrapper file.
Loading the extension enables the -felix command
line option and language module.

@h = tangler("swig/makefile","data")
@select(h)
@tangle("SWIGDEVDIR=/usr/local/src/cvsswig/SWIG")
@tangle("Modules=${SWIGDEVDIR}/Source/Modules")
@tangle("CParse=${SWIGDEVDIR}/Source/CParse")
@tangle("Swig=${SWIGDEVDIR}/Source/Swig")
@tangle("DOH=${SWIGDEVDIR}/Source/DOH")
@tangle("Preprocessor=${SWIGDEVDIR}/Source/Preprocessor")
@tangle("")
@tangle("all: dynswig felix.so")
@tangle("")
@tangle("dynswig: swigmain.cxx")
@tangle("\tg++ -rdynamic \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Include \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Include \\")
@tangle("\t-I${SWIGDEVDIR}/Source/DOH \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Preprocessor \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Swig \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Modules  \\")
@tangle("\t-g -O2 -Wall   -o dynswig  \\")
@tangle("\tswigmain.cxx \\")
@tangle("\t${CParse}/cscanner.o ${CParse}/parser.o ${CParse}/templ.o \\")
@tangle("\t${CParse}/util.o ${DOH}/base.o ${DOH}/file.o ${DOH}/fio.o ${DOH}/hash.o \\")
@tangle("\t${DOH}/list.o ${DOH}/memory.o ${DOH}/string.o ${DOH}/void.o ${Modules}/allocate.o \\")
@tangle("\t${Modules}/browser.o ${Modules}/chicken.o ${Modules}/contract.o ${Modules}/csharp.o \\")
@tangle("\t${Modules}/directors.o ${Modules}/emit.o ${Modules}/guile.o \\")
@tangle("\t${Modules}/java.o ${Modules}/lang.o ${Modules}/main.o \\")
@tangle("\t${Modules}/module.o ${Modules}/mzscheme.o ${Modules}/ocaml.o \\")
@tangle("\t${Modules}/overload.o ${Modules}/perl5.o ${Modules}/php4.o ${Modules}/pike.o \\")
@tangle("\t${Modules}/python.o ${Modules}/ruby.o ${Modules}/s-exp.o \\")
@tangle("\t${Modules}/tcl8.o ${Modules}/typepass.o \\")
@tangle("\t${Modules}/utils.o ${Modules}/xml.o ${Preprocessor}/cpp.o \\")
@tangle("\t${Preprocessor}/expr.o ${Swig}/cwrap.o ${Swig}/error.o \\")
@tangle("\t${Swig}/fragment.o ${Swig}/getopt.o ${Swig}/include.o \\")
@tangle("\t${Swig}/misc.o ${Swig}/naming.o ${Swig}/parms.o ${Swig}/scanner.o \\")
@tangle("\t${Swig}/stype.o ${Swig}/symbol.o ${Swig}/tree.o ${Swig}/typeobj.o \\")
@tangle("\t${Swig}/typemap.o ${Swig}/typesys.o ${Swig}/warn.o ${Swig}/wrapfunc.o  \\")
@tangle("\t-ldl")
@tangle("\tcp dynswig ../bin/dynswig")
@tangle("")
@tangle("felix.so: felix.cxx")
@tangle("\tg++ -shared \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Include \\")
@tangle("\t-I${SWIGDEVDIR}/Source/DOH \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Swig \\")
@tangle("\t-I${SWIGDEVDIR}/Source/Modules \\")
@tangle("\t-g -O2 -Wall -o felix.so felix.cxx")


@h = tangler("swig/felixkw.swg","data")
@select(h)
#ifndef __felix_felixkw_swg__
#define __felix_felixkw_swg__

// This file is totally wrong at present
// We need to generate it in the Felix build

/* Warnings for Felix keywords */
#define FELIXKW(x) %namewarn("314:" #x " is a felix keyword")  #x

FELIXKW(and);
FELIXKW(assert);
FELIXKW(break);
FELIXKW(class);
FELIXKW(continue);
FELIXKW(def);
FELIXKW(del);
FELIXKW(elif);
FELIXKW(else);
FELIXKW(except);
FELIXKW(exec);
FELIXKW(finally);
FELIXKW(for);
FELIXKW(from);
FELIXKW(global);
FELIXKW(if);
FELIXKW(import);
FELIXKW(in);
FELIXKW(is);
FELIXKW(lambda);
FELIXKW(not);
FELIXKW(or);
FELIXKW(pass);
FELIXKW(print);
FELIXKW(raise);
FELIXKW(return);
FELIXKW(try);
FELIXKW(while);
FELIXKW(yield);

#undef FELIXKW

#define FELIXBN(x) %namewarn("315:" #x " is a bad name in felix")  #x

/* recurrent built-in functions */
FELIXBN(close);
FELIXBN(float);
FELIXBN(int);
FELIXBN(input);
FELIXBN(open);
FELIXBN(range);
FELIXBN(type);

/* Boolean type */
FELIXBN(true);
FELIXBN(talse);

#undef FELIXBN

#endif //__felix_felixkw_swg__
@h = tangler("swig/felix.swg","data")
@select(h)
// felix names for C++ operators (to be completed)
// these names are currently WRONG, they don't
// agree with the names used in Felix ..
#ifdef __cplusplus
%rename(__add__)      *::operator+;
%rename(__pos__)      *::operator+();
%rename(__pos__)      *::operator+() const;
%rename(__sub__)      *::operator-;
%rename(__neg__)      *::operator-();
%rename(__neg__)      *::operator-() const;
%rename(__mul__)      *::operator*;
%rename(__div__)      *::operator/;
%rename(__mod__)      *::operator%;
%rename(__lshift__)   *::operator<<;
%rename(__rshift__)   *::operator>>;
%rename(__and__)      *::operator&;
%rename(__or__)       *::operator|;
%rename(__xor__)      *::operator^;
%rename(__invert__)   *::operator~;
%rename(__iadd__)     *::operator+=;
%rename(__isub__)     *::operator-=;
%rename(__imul__)     *::operator*=;
%rename(__idiv__)     *::operator/=;
%rename(__imod__)     *::operator%=;
%rename(__ilshift__)  *::operator<<=;
%rename(__irshift__)  *::operator>>=;
%rename(__iand__)     *::operator&=;
%rename(__ior__)      *::operator|=;
%rename(__ixor__)     *::operator^=;
%rename(__lt__)       *::operator<;
%rename(__le__)       *::operator<=;
%rename(__gt__)       *::operator>;
%rename(__ge__)       *::operator>=;
%rename(__eq__)       *::operator==;
%rename(__ne__)       *::operator!=;
 
/* Special cases */
%rename(__call__)     *::operator();
%ignorewarn("362:operator= ignored") operator=;
%ignorewarn("383:operator++ ignored") operator++;
%ignorewarn("384:operator-- ignored") operator--;
%ignorewarn("385:operator! ignored") operator!;
%ignorewarn("381:operator&& ignored") operator&&;
%ignorewarn("382:operator|| ignored") operator||;
%ignorewarn("386:operator->* ignored") operator->*;
%ignorewarn("389:operator[] ignored (consider using %extend)") operator[];
 
#endif 

// felix specific directives
// %header directive inserts C into header statement
//   this is a standard SWIG directive

// %body directive inserts C into body statement

// %felix directive inserts arbitrary felix code inline

// %callback_type(t){n} defines a callback function type
//   with client  data in argument n

// %callback_client(t){m,n} defines a function
//   which accepts a callback argument in argument m,
//   and client data in argument n

// %abstract(x) specifies a type x = 'x'; be generated
//   for a typedef

// %alias(x) species a typedef x = ?; be generated
//   for a typedef

// %bitmask(x) specifies an enum is a bitstring,
//   and generates & | ~ ^ operators for it

#define %body %insert("body")
#define %felix %insert("felix")
#define %bitmask(x) %feature("bitmask") x {}
#define %callback_type(x,y) %feature("callback") x {y}
#define %callback_client(x,y,z) %feature("callback:client") x {y,z}
#define %alias(x) %feature("alias") x {}
#define %abstract(x) %feature("abstract") x {}

@h = tangler("swig/felix.cxx","c++")
@select(h)

#include "swigmod.h"

#ifndef MACSWIG
#include "swigconfig.h"
#endif

extern "C" Language * swig_felix(void);


struct swig_module {
  const char     *name;
  ModuleFactory   fac;
  const char      *help;
};

swig_module swig_modules [] = 
{
  {"-felix",     swig_felix,     "Felix"},
  {NULL, NULL, NULL}
};

// this got left out of the interface somehow
extern  "C" void SwigType_del_array(SwigType *t);

struct std_map_t { char *swig; char *flx; };
static std_map_t std_type_map[] = {
  {"_char", "tiny"},
  {"_signed_char", "tiny"},
  {"_unsigned_char", "utiny"},
  {"_short", "short"},
  {"_unsigned_short", "ushort"},
  {"_int", "int"},
  {"_unsigned_int", "uint"},
  {"_long", "long"},
  {"_unsigned_long", "ulong"},
  {"_float", "float"},
  {"_double", "double"},
  {"_long_double", "ldouble"},
  {"_long_long", "vlong"},
  {"_unsigned_long_long", "uvlong"},
  {"_int8_t", "int8"},
  {"_int16_t", "int16"},
  {"_int32_t", "int32"},
  {"_int64_t", "int64"},
  {"_uint8_t", "uint8"},
  {"_uint16_t", "uint16"},
  {"_uint32_t", "uint32"},
  {"_uint64_t", "uint64"},
  {"_p_void", "address"},
  {0,0}
};

class FELIX: public Language {
protected:
public :
  virtual void main(int, char *argv[]);
  virtual int  top(Node *); 
  virtual int  functionWrapper(Node *);
  virtual int  constantWrapper(Node *);
  virtual int  variableWrapper(Node *);
  virtual int  nativeWrapper(Node *);
  virtual int  membervariableHandler(Node *);
  virtual int  memberconstantHandler(Node *);
  virtual int  memberfunctionHandler(Node *);
  virtual int  constructorHandler(Node *);
  virtual int  destructorHandler(Node *);
  virtual int  classHandler(Node *);
  virtual int  classforwardDeclaration(Node *);
  virtual int  insertDirective(Node *);
  virtual int  importDirective(Node *);
  virtual int  enumDeclaration(Node *);
  virtual int  enumvalueDeclaration(Node *);
  virtual int  typedefHandler(Node *);

  void gen_function(
    File *f, 
    int indent,
    String *name, 
    String *iname, 
    String *r, 
    ParmList *l
  );
  void gen_member_function(
    String *iname, 
    String *name, 
    String *r, 
    String *obj, 
    bool, 
    ParmList *
  );

  void gen_callback_client(
    String *iname, 
    String *name, 
    String *r, 
    ParmList *l,
    int cbpos,
    int cdpos
  );
  String *register_function(String *);
  String *register_array(String *, String *);

  // return true if new registration
  bool register_callback(String *, String *);

  void gen_callback(
    String *name, 
    String *type, 
    String *fun_ptr_type, 
    String *callback
  );

  // Function type registry: table stores mapping
  // of pointer to function types as swigtype -> mangled type name
  // Each function in the registry has had an abstract
  // type binding and a C typedef emitted using the mangled name
  // Call this function to obtain the type name (same name for
  // both C and Felix is used)
  Hash *functions;

  // registry of array types
  Hash *arrays;

  // Callback registry: table stores mapping
  // of mangled function pointer type of a callback
  // to the position of the client data
  Hash *callbacks;

  File *f_wrapper;
  Hash *std_types;
  String *cmdstring;

  String *module_name;
  long counter;

  FELIX() {
    std_types = NewHash();
    functions = NewHash();
    arrays = NewHash();
    callbacks = NewHash();
    counter = 1;
    for(std_map_t *p = std_type_map; p->swig; ++p)
     Setattr(std_types,NewString(p->swig),NewString(p->flx));
  }

  ~FELIX() { // we don't care about leaks here
  }
  
  String *xlat_swig_type(String *x);
  String *xlat(String *x);
  String *flx_callback_function_type(ParmList *parms, String *ret, int flxf);
};

extern "C" Language *
swig_felix(void) {
  return new FELIX();
}

bool FELIX::register_callback(String *name, String *data) {
  if(Getattr(callbacks,name)) return false;
  Setattr(callbacks,name,data);
  return true;
}

String *FELIX::flx_callback_function_type(ParmList *parms, String *ret, int flxf)
{
    int m = ParmList_len(parms);
    assert(m>0);
    String *flx_tname;
    if(m==1) flx_tname = NewString("1");
    else
    {
      flx_tname = NewString("");
      int j = 0;
      int k = 0;
      for(Parm *p = parms; p; p = nextSibling(p))
      {
        ++j;
        if(j!=flxf)
        {
          if(k!=0) Printf(flx_tname," * ");
          k++;
          String *ptype = Getattr(p,"type");
          Printf(flx_tname,"%s",xlat(ptype));
        }
      }
    }
    Printf(flx_tname," -> %s",xlat(ret));
    return flx_tname;
}
 
void FELIX::gen_callback(
  String *name, 
  String *type, 
  String *thetypedef, 
  String *callback
)
{
  int j; 
  int k;
  int flxf; sscanf(Char(callback),"{%d}",&flxf);
  String *func = SwigType_pop_function(type);
  String *tdname = Copy(name);
  ParmList *parms = SwigType_function_parms(func);
  bool isproc = Strcmp(type,"void") == 0;

  String *flx_cb_type = flx_callback_function_type(parms,type,flxf);
  String *cof_flx_cb_type = NewStringf("_flx_%s_t",tdname);
  Printf(f_wrapper,"  //callback wrapper for %s\n",thetypedef);
  Printf(f_wrapper,"  //client data is arg %d\n",flxf);
  Printf(f_wrapper,"  typedef %s = %s;\n",tdname,flx_cb_type);
  Printf(f_wrapper,"  export type (%s) as '%s';\n",tdname,cof_flx_cb_type);
  Printf(f_wrapper,"  body '''\n");
  Printf(f_wrapper,"    %s callback_%s\n    (\n",type,tdname);
  j = 0;
  for(Parm *p = parms; p; p = nextSibling(p))
  {
      if(j!=0) Printf(f_wrapper,",\n");
      j++;
      String *name;
      if(j==flxf) name = NewString("flx_callback");
      else name = NewStringf("arg_%d",j);
      String *ptype = Getattr(p,"type");
      String *cptype = SwigType_str(ptype,name);
      Printf(f_wrapper,"      %s",cptype);
  }
  Printf(f_wrapper,"\n    )\n    {\n");
  if(!isproc)
    Printf(f_wrapper,"      return ((%s)flx_callback)->apply(%s_class::argtype(",cof_flx_cb_type,cof_flx_cb_type);
  else
  {
    Printf(f_wrapper,"       con_t *p = ((%s)flx_callback)->call(0,%s_class::argtype(",cof_flx_cb_type,cof_flx_cb_type);
  }
  j=0; 
  k=0;
  for(Parm *p = parms; p; p = nextSibling(p))
  {
    ++j;
    if(j!=flxf)
    {
      if(k!=0) Printf(f_wrapper,",");
      ++k;
      Printf(f_wrapper,"arg_%d",j);
    }
  }
  Printf(f_wrapper,"));\n");
  if(isproc)
    Printf(f_wrapper,"       while(p)p=p->resume();\n");
  Printf(f_wrapper,"    }\n");
  Printf(f_wrapper,"  ''';\n\n");
}

int FELIX::typedefHandler(Node *n) {
  String *name = Getattr(n,"name");
  String *iname = Getattr(n,"sym:name");
  String *type = Getattr(n,"type");
  String *decl = Getattr(n,"decl");
  String *callback = Getattr(n,"feature:callback");
  String *alias = Getattr(n,"feature:alias");
  String *abstract = Getattr(n,"feature:abstract");

  if(Strncmp(type,"enum $unnamed",13)==0);
  else if(Strncmp(type,"struct $unnamed",15)==0);
  else if(Strncmp(type,"union $unnamed",14)==0);
  else if(Strncmp(type,"struct ",7)==0 && Strcmp(decl,"")==0)
  {
	  Replace(type,"struct ","", DOH_REPLACE_FIRST);
    Printf(f_wrapper,"  typedef %s = %s;//struct hack\n",name,(char*)type);
  }
  else if(Strncmp(type,"union ",6)==0 && Strcmp(decl,"")==0)
  {
	  Replace(type,"union ","", DOH_REPLACE_FIRST);
    Printf(f_wrapper,"  typedef %s = %s;//union hack\n",name,(char*)type);
  }
  else if(callback)
  {
    String *thetypedef = SwigType_str(type,name);
    if (SwigType_ispointer(type))
      SwigType_del_pointer(type);
    if (SwigType_isfunction(type))
    {
      if(register_callback(name,callback))
        gen_callback(name,type,thetypedef,callback);
    }
    else
      Printf(f_wrapper,"//CALLBACK: expected function or pointer to function, got sym=%s, typedef name=%s, type=%s, decl='%s'\n",iname,name,type,decl);
  }
  else if(alias)
    Printf(f_wrapper,"  typedef %s = %s; //alias\n",name,xlat(type));
  else if(abstract)
    Printf(f_wrapper,"  type %s = '%s'; //abstract\n",name,SwigType_str(type,""));
  else
    Printf(f_wrapper,"//typedef name=%s, type=%s, decl='%s'\n",name,type,decl);
  return Language::typedefHandler(n);
}

String *FELIX::xlat_swig_type(String *x) {
  String *y = SwigType_manglestr(x);
  String *z = Getattr(std_types,y);
  if(z) return z;
  else  return x;
}

String *FELIX::register_function(String *k) {
  String *fid= Getattr(functions,k);
  if(!fid)
  {
    fid = NewStringf("%s_fid_%ld",module_name,counter++);
    Setattr(functions,k,fid);
    String *dcl = SwigType_str(k,fid);
    Printf(f_wrapper,"  header 'typedef %s;';\n", dcl);
    Printf(f_wrapper,"  type %s = '%s';\n", fid,fid);
  }
  return fid;
}

// Arrays are tricky. The Felix array type array[t,n]
// is a struct containing a C array t[n]

// When C needs an array, it usually wants a pointer
// to the first element. The felix array contains
// the C array in element 'data', so the cast is:

//   $1.data

// When Felix needs a C array, it has to be cast
// to the wrapping struct to make it first class
// Note that the cast must go like this:

//   *(flx_struct*)c_array

// because the 'c_array' is a pointer

// What we do is: we synthesise a unique name for the array.
// The Felix type of the array is exported as this name.
// We also make that same name a Felix alias for the array
// Note that the C and Felix names then both denote the 
// Felix array type, NOT the C type.

String *FELIX::register_array(String *t, String *n) {
  String *mangled = NewStringf("a(%s).%s",n,t);
  String *aid= Getattr(arrays,mangled);
  if(!aid)
  {
    aid = NewStringf("%s_aid_%ld",module_name,counter++);
    Setattr(arrays,mangled,aid);
    //String *dcl = SwigType_str(mangled,aid);
    Printf(f_wrapper,"  typedef %s = array[%s,%s];\n",aid,t,n);
    Printf(f_wrapper,"  export type (%s) as '%s';\n",aid,aid);
  }
  return aid;
}

static void adjust_type(String *x) {
  while(SwigType_isarray(x)) {
    String *d = SwigType_array_getdim(x,0);
    if(Strcmp(d,"")==0) {
      SwigType_del_array(x);
      SwigType_add_pointer(x);
    }
    else break;
  }
}

String *FELIX::xlat(String *a) {
  String *x = Copy(a);
  if(Strcmp(a,"v(...)")==0)
    return NewString("...");

  adjust_type(x);
  if(SwigType_issimple(x))
    return xlat_swig_type(x);

  else if (SwigType_ispointer(x))
  {
    if(Strcmp(x,"p.void")==0) 
      return NewString("address");
      
    if(Strcmp(x,"p.q(const).void")==0) 
      return NewString("address");

    if(Strcmp(x,"p.char")==0) 
      return NewString("address");

     if(Strcmp(x,"p.q(const).char")==0) 
      return NewString("address");

    SwigType *x2 = Copy(x);
    SwigType_del_pointer(x);
    if(SwigType_isconst(x)) {
      SwigType_pop(x);
      return NewStringf("cptr[%s]",xlat(x));
    }
    else if(SwigType_isfunction(x))
    {
      return register_function(x2);
    }
    else
      return NewStringf("ptr[%s]",xlat(x));
  }
  else if (SwigType_isarray(x))
  {
    String *dimen = SwigType_array_getdim(x,0);
    SwigType_del_array(x);
    return register_array(xlat(x),dimen);
  }
  else
  {
    Printf(stderr,"Warning -- unrecognized type %s\n",x);
    return SwigType_manglestr(x);
  }
}

void FELIX::main(int argc, char *argv[]){ 
//  printf("Generating felix bindings\n");
  
  cmdstring = NewString("");
  for(int i = 0; i < argc; ++i)
    Printf(cmdstring,"%s ",argv[i]);

   /* Set language-specific subdirectory in SWIG library */
   SWIG_library_directory("felix"); 

   /* Set language-specific preprocessing symbol */
   Preprocessor_define("SWIGFELIX 1", 0);
   
   /* Set language-specific configuration file */
   SWIG_config_file("felix.swg");

   /* Set typemap language (historical) .. IS THIS NEEDED? */
   SWIG_typemap_lang("felix");
}

int FELIX::top(Node *n){ 
  /* Get the module name */
  String *module = Getattr(n,"name");  
  Printf(stderr,"Felix module %s\n", module);
  module_name = module;

  /* Get the output file name */
  String *outfile = Getattr(n,"outfile");
  Printf(stderr,"Felix output filename %s\n", outfile);

  /* Initialize I/O (see next section) */
  f_wrapper = NewFile(outfile,"w");
  if (!f_wrapper) {
    Printf(stderr,"*** Can't open '%s'\n", outfile);
    SWIG_exit(EXIT_FAILURE);
  }

  Swig_register_filebyname("wrapper",f_wrapper);
    
  /* Output module initialization code */
  Printf(f_wrapper,"//module %s \n",module);
  Printf(f_wrapper,"//Generated by SWIG: %s\n", cmdstring);
  Printf(f_wrapper,"\n");
  Printf(f_wrapper,"include \"std\";\n");
  Printf(f_wrapper,"open C_hack;\n\n");

  /* Emit code for children */
  Language::top(n); 

  /* Cleanup files */
  Close(f_wrapper);
  Delete(f_wrapper);
  return SWIG_OK; 
} 
  
  
static void print_fun(
  File *f, 
  int indent,
  String *dcl, 
  String *atyp, 
  String *rtyp, 
  String *cspec
)
{
  int col = 0;
  int line = 0;
  String *margin=NewStringf("%*s",indent,"");
  Printf(f,"%s%s:",margin,dcl);
  col += indent + Len(dcl);
  if(col + Len(atyp)>60) { Printf(f,"\n  %s",margin); col = indent+2; ++line; }
  else {Printf(f," "); col++; }
  Printf(f,"%s",atyp); 
  col += Len(atyp);
  if(col + Len(rtyp)>60) { Printf(f,"\n  %s",margin); col = 4; ++line; }
  else {Printf(f," "); col++; }
  Printf(f,"-> %s",rtyp); 
  col += Len(rtyp);
  if(col + Len(cspec)>60) { Printf(f,"\n  %s= ",margin); ++line; }
  else {Printf(f," = "); }
  Printf(f,"'%s';\n",cspec);
  if(line) Printf(f,"\n");
}

#if 0
static void print_flx_fun(
  File *f,
  String *dcl, 
  String *args, 
  String *rtyp, 
  String *body
)
{
  Printf(f,"  %s(",dcl);
  Printf(f,"%s)",args); 
  Printf(f,": %s = {\n",rtyp); 
  Printf(f,"%s",body);
  Printf(f,"  }\n");
}
#endif

static void print_proc(
  File *f, 
  int indent,
  String *dcl, 
  String *atyp, 
  String *cspec
)
{
  // format the output
  int col = 0;
  int line = 0;
  String *margin=NewStringf("%*s",indent,"");
  Printf(f,"%s%s:",margin,dcl);
  col += 2 + Len(dcl);
  if(col + Len(atyp)>60) { Printf(f,"\n  %s",margin); col = 4; ++line; }
  else {Printf(f," "); col++; }
  Printf(f,"%s",atyp); 
  col += Len(atyp);
  if(col + Len(cspec)>60) { Printf(f,"\n  %s= ",margin); ++line; }
  else {Printf(f," = "); }
  Printf(f,"'%s';\n",cspec);
  if(line) Printf(f,"\n");
}

#if 0
static void print_flx_proc(
  File *f, 
  String *dcl, 
  String *args, 
  String *body
)
{
  // format the output
  Printf(f,"  %s(",dcl);
  Printf(f,"%s){\n",args); 
  Printf(f,"%s",body);
  Printf(f,"  }\n");
}
#endif

void FELIX::gen_function(
  File *f,
  int indent,
  String *flx_name, 
  String *cname, 
  String *r, 
  ParmList *l
)
{
  bool isproc = Strcmp(r,"void") == 0;
  String *dcl = NewString(""); 
  String *atyp = NewString(""); 
  String *rtyp = NewString(""); 
  String *cspec= NewString(""); 
  if(isproc) {
    Printf(dcl,"proc %s",flx_name);
    int m = ParmList_len(l);
    int j = 0;
    if(m==0 || m==1 && Getattr(l,"type")=="")
      Printf(atyp,"1");
    else
    for(Parm *p = l; p; p = nextSibling(p)) {
      if(j) Printf(atyp,"*");
      assert(j<m);
      j++;
      SwigType *t = Getattr(p,"type");
      String *ft = xlat(t);
      Printf(atyp,"%s",ft);
    }
    Printf(cspec,"%s(",cname);
    for(j=1;j<=m;++j) {
      if(j>1)Printf(cspec,",");
      Printf(cspec,"$%d",j);
    } 
    Printf(cspec,")");
    print_proc(f,indent,dcl,atyp,cspec);
  }
  else {
    Printf(dcl,"fun %s",flx_name);
    int m = ParmList_len(l);
    int j = 0;
    if(m==0 || m==1 && Getattr(l,"type")=="")
      Printf(atyp,"1");
    else
    for(Parm *p = l; p; p = nextSibling(p)) {
      if(j) Printf(atyp,"*");
      assert(j<m);
      j++;
      SwigType *t = Getattr(p,"type");
      String *ft = xlat(t);
      Printf(atyp,"%s",ft);
    }
    String *rt = xlat(r);
    Printf(rtyp,"%s",rt);
    Printf(cspec,"%s(",cname);
    for(j=1;j<=m;++j) {
      if(j>1)Printf(cspec,",");
      Printf(cspec,"$%d",j);
    } 
    Printf(cspec,")");
    print_fun(f_wrapper,indent,dcl,atyp,rtyp,cspec);
  }
}

void FELIX::gen_member_function(
  String *iname, 
  String *name, 
  String *r, 
  String *object, 
  bool constflag, 
  ParmList *l
)
{
  bool isproc = Strcmp(r,"void") == 0;
  String *dcl= NewString("");
  String *atyp= NewString("");
  String *rtyp= NewString("");
  String *cspec= NewString("");
  if(constflag)
    Printf(atyp, "cptr[%s]",object);
  else
    Printf(atyp, "ptr[%s]",object);
  if(isproc) {
    Printf(dcl,"proc %s",iname);
    int m = ParmList_len(l);
    int j = 0;
    for(Parm *p = l; p; p = nextSibling(p)) {
      Printf(atyp," * ");
      assert(j<m);
      j++;
      SwigType *t = Getattr(p,"type");
      String *ft = xlat(t);
      Printf(atyp,"%s",ft);
    }
    Printf(cspec," = $1->%s(",name);
    for(j=1;j<=m;++j) {
      if(j>1)Printf(cspec,",");
      Printf(cspec,"$%d",j+1);
    } 
    Printf(cspec,")");
    print_proc(f_wrapper,2,dcl,atyp,cspec);
  }
  else {
    Printf(dcl,"fun %s",iname);
    int m = ParmList_len(l);
    int j = 0;
    for(Parm *p = l; p; p = nextSibling(p)) {
      Printf(atyp," * ");
      assert(j<m);
      j++;
      SwigType *t = Getattr(p,"type");
      String *ft = xlat(t);
      Printf(atyp,"%s",ft);
    }
    rtyp = xlat(r);
    Printf(cspec,"%$1->%s(",name);
    for(j=1;j<=m;++j) {
      if(j>1)Printf(cspec,",");
      Printf(cspec,"$%d",j+1);
    } 
    Printf(cspec,")");
    print_fun(f_wrapper,2,dcl,atyp,rtyp,cspec);
  }
}

void FELIX::gen_callback_client(
  String *iname, 
  String *name, 
  String *r, 
  ParmList *l,
  int cbpos,
  int cdpos
)
{
  String *ctype = Copy(r);
  SwigType_add_function(ctype,l);
  String *type = SwigType_str(ctype,"");
  Printf(f_wrapper,"  //callback client %s, type %s\n",name,type);
  Printf(f_wrapper,"  //calback arg=%d, client data arg=%d\n",cbpos,cdpos);
  int k;
  int m;
  int j = 1;
  Parm *p;
  for(p = l; p && j<cbpos; p = nextSibling(p),j++);
  assert(p);
  String *cbtype = Getattr(p,"type");
  //String *c_cbtype = Getattr(callbacks,cbtype);
  Printf(f_wrapper, "  //callback arg type %s\n",cbtype);
  String *callback_name = NewStringf("callback_%s",cbtype);
  bool isproc = Strcmp(r,"void") == 0;
  m = ParmList_len(l);
  j = 0;
  k = 0;
  if(isproc)
    Printf(f_wrapper,"  proc %s:",name);
  else
    Printf(f_wrapper,"  fun %s:",name);
  for(p = l; p; p = nextSibling(p)) {
    if(++k != cdpos) {
      if(j) Printf(f_wrapper," * ");
      assert(j<m);
      j++;
      SwigType *t = Getattr(p,"type");
      String *ft = xlat(t);
      Printf(f_wrapper,"%s",ft);
    }
  }
  if(!isproc)
    Printf(f_wrapper,"->%s",xlat(r));
  Printf(f_wrapper,"='%s(",name);
  k = 0;
  for(j=1;j<=m;++j) {
    if(j>1)Printf(f_wrapper,",");
    if(j==cbpos) Printf(f_wrapper,"%s",callback_name);
    else {
      ++k;
      if(j==cdpos)
        Printf(f_wrapper,"(void*)$%d",k);
      else
        Printf(f_wrapper,"$%d",k);
    }
  }
  if(isproc)
    Printf(f_wrapper,");';\n");
  else
    Printf(f_wrapper,")';\n");
}


int FELIX::functionWrapper(Node *n){ 
  String  *name  = Getattr(n,"name");
  String  *iname = Getattr(n,"sym:name");
  SwigType *r    = Getattr(n,"type");
  ParmList *l    = Getattr(n,"parms");
  String *callback = Getattr(n,"feature:callback:client");
  if(callback)
  {
    int cbpos, cdpos;
    sscanf(Char(callback),"{%d,%d}",&cbpos,&cdpos);
    gen_callback_client(iname,name,r,l,cbpos,cdpos);
  }
  else
    gen_function(f_wrapper,2,iname,name,r,l);
  return SWIG_OK; 
}

// this method handles #defines ONLY
int FELIX::constantWrapper(Node *n){ 
//  String  *name  = Getattr(n,"name");
  String  *iname = Getattr(n,"sym:name");
  SwigType *r    = Getattr(n,"type");
  SwigType *v    = Getattr(n,"value");
// Printf(stderr,"Constant %s[%s] type %s, val=%s\n",iname,name,r,v);
  String *rt = xlat(r);
  Printf(f_wrapper,"  const %s: %s = '%s';\n",iname,rt,v);
  return SWIG_OK; 
}

// this method provides 
// (1) get and set functions for nonconst C variables 
// (2) a const value for const variables
int FELIX::variableWrapper(Node *n){ 
//  String  *name  = Getattr(n,"name");
  String  *iname = Getattr(n,"sym:name");
  SwigType *r    = Getattr(n,"type");
  adjust_type(r);
  SwigType *v    = Getattr(n,"value");
  if(SwigType_isconst(r)) {
    SwigType_pop(r); 
    String *rt = xlat(r);
    if(Len(v) > 0)
      Printf(f_wrapper,"  const %s: %s = '''%s''';\n",iname,rt,v);
    else
      Printf(f_wrapper,"  const %s: %s = '''%s''';\n",iname,rt,iname);
  }
  else {
    String *rt = xlat(r);
    if (SwigType_isarray(r)) {
      // cast the C array type to the struct pointer, then deref
      Printf(f_wrapper,"  fun get_%s: 1-> %s = '''*(%s*)(void*)%s''';\n",iname,rt,rt,iname);
      Printf(f_wrapper,"  proc set_%s: %s = '''*(%s*)(void*)(%s)=$1;''';\n",iname,rt,rt,iname);
    }
    else {
      Printf(f_wrapper,"  fun get_%s: 1-> %s = '''%s''';\n",iname,rt,iname);
      Printf(f_wrapper,"  proc set_%s: %s = '''%s=$1;''';\n",iname,rt,iname);
    }
  }
  return SWIG_OK; 
}

int FELIX::nativeWrapper(Node *){ return SWIG_OK; }

int FELIX::membervariableHandler(Node *n){ 
  String *iname = Getattr(n,"sym:name");
  Node *parent = Getattr(n,"parentNode");
  String *pname = Getattr(parent,"sym:name"); 
  SwigType *r = Getattr(n,"type");
  String *ret = xlat(r);
  String *get_decl;
  String *set_decl;
  adjust_type(r);
  if (SwigType_isarray(r)) {
    // cast the C array type to the struct pointer, then deref
    get_decl = NewStringf("*(%s*)(void*)($1.%s)",ret,iname);
    set_decl = NewStringf("*(%s*)(void*)($1->%s)=$2",ret,iname);
  }
  else {
    get_decl = NewStringf("$1.%s",iname);
    set_decl = NewStringf("$1->%s=$2",iname);
  }
  print_fun(
    f_wrapper,2,
    NewStringf("fun get_%s",iname),
    pname,
    ret,
    get_decl
  );
  print_proc(
    f_wrapper,2,
    NewStringf("proc set_%s",iname),
    NewStringf("ptr[%s] * %s",pname,ret),
    set_decl
  );
  return SWIG_OK; 
}
int FELIX::memberconstantHandler(Node *){ return SWIG_OK; }

int FELIX::memberfunctionHandler(Node *n){ 
  String *iname = Getattr(n,"sym:name");
  String *name = Getattr(n,"name");
  Node *parent = Getattr(n,"parentNode");
  String *pname = Getattr(parent,"sym:name"); 
  String *cdecl = Getattr(n,"decl"); 
  ParmList *l    = Getattr(n,"parms");
  SwigType *r    = Getattr(n,"type");
  bool constflag = SwigType_isconst(cdecl);
  gen_member_function(iname,name,r,pname,constflag,l);
  return SWIG_OK; 
}

int FELIX::constructorHandler(Node *n){ 
  String *r = Getattr(n,"sym:name");
  String *iname = NewString("");
  Printf(iname,"make_%s",r);
  ParmList *l    = Getattr(n,"parms");
  gen_function(f_wrapper,2,iname,r,r,l);
  return SWIG_OK; 
}

int FELIX::destructorHandler(Node *){ return SWIG_OK; }

int FELIX::classHandler(Node *n){ 
  String  *iname = Getattr(n,"sym:name");
  String *tdname = Getattr(n,"tdname");
  String *kind = Getattr(n,"kind");
  if(!tdname) tdname = iname;
  if(Strcmp(iname,tdname))
    Printf(f_wrapper,"\n  //%s %s=%s\n",kind,iname,tdname);
  else
    Printf(f_wrapper,"\n  //%s %s\n",kind,iname,tdname);
  Printf(f_wrapper,"  type %s = '%s';\n",tdname,tdname);
  Language::classHandler(n);
  Printf(f_wrapper,"\n");
  return SWIG_OK; 
}
int FELIX::classforwardDeclaration(Node *){ return SWIG_OK; }

int FELIX::insertDirective(Node *n){ 
  String  *code = Getattr(n,"code");
  String *section = Getattr(n,"section");
  
  // SWIG generated inlines go here, but so do
  // user %{ %} directives .. can't tell them apart
  // use %felix %{ .. %} for felix inserts 
  if(!section) section = NewString("body");
  if(!Strcmp(section,"body"))
    Printf(f_wrapper,"body '''%s''';\n",code);
  if(!Strcmp(section,"header"))
    Printf(f_wrapper,"header '''%s''';\n",code);
  if(!Strcmp(section,"felix"))
    Printf(f_wrapper,"%s",code);
  return SWIG_OK; 
}
int FELIX::importDirective(Node *){ return SWIG_OK; }

int FELIX::enumDeclaration(Node *n) {
  if (!ImportMode) {
    String  *name = Getattr(n,"name");
    String *bitmask = Getattr(n,"feature:bitmask");
    String *kind = NewString(bitmask ? "bitmask" : "enumeration");
    Printf(f_wrapper,"\n  type %s = '%s'; //%s\n",name,name,kind);
    if(bitmask)
    {
      Printf(f_wrapper,"  fun _bnot: %s -> %s = '~$1';\n",name,name);
      Printf(f_wrapper,"  fun _band: %s * %s -> %s = '$1 & $2';\n",name,name,name);
      Printf(f_wrapper,"  fun _bnand: %s * %s -> %s = '~($1 & $2)';\n",name,name,name);
      Printf(f_wrapper,"  fun _bor: %s * %s -> %s = '$1 | $2';\n",name,name,name);
      Printf(f_wrapper,"  fun _bnor: %s * %s -> %s = '~($1 | $2)';\n",name,name,name);
      Printf(f_wrapper,"  fun _bxor: %s * %s -> %s = '$1 ^ $2';\n",name,name,name);
    }
    emit_children(n);
    Printf(f_wrapper,"\n");
  }
  return SWIG_OK;
}

int FELIX::enumvalueDeclaration(Node *n) {
  if (!ImportMode) {
    String  *name = Getattr(n,"name");
    String  *value = Getattr(n,"enumvalue");
    Node *parent = Getattr(n,"parentNode");
    String  *parent_name = Getattr(parent,"name");
    Printf(f_wrapper,"  const %s: %s = '%s'; //%s\n",name,parent_name,name,value);
  }
  return SWIG_OK;
}

@h = tangler("swig/swigmain.cxx","c++")
@select(h)

/*******************************************************************************
 * Simplified Wrapper and Interface Generator  (SWIG)
 *
 * swigmain.cxx
 *
 *     This file is the main entry point to SWIG.  It collects the command
 *     line options, registers built-in language modules, and instantiates 
 *     a module for code generation.   If adding new language modules
 *     to SWIG, you would modify this file.
 *
 * Author : David Beazley
 *
 * Department of Computer Science
 * University of Chicago
 * 1100 E 58th Street
 * Chicago, IL  60637
 * beazley@cs.uchicago.edu
 *
 * Please read the file LICENSE for the copyright and terms by which SWIG
 * can be used and distributed.
 * 
 * MODIFIED BY JOHN SKALLER to support dynamic loading
 *******************************************************************************/

char cvsroot_swigmain_cxx[] = "$Header$";

#ifndef MACSWIG
#include "swigconfig.h"
// THIS MACRO SHOULD BE IN swigconfig.h
#define SWIG_DYNLOAD
#endif

// this should be configured in the config file 
// autoconf defines:
// HAVE_LIBDL
// but in Python we also have
// HAVE_DLOPEN
// HAVE_DLFCN_H
// HAVE_DYNAMIC_LOADING
#if defined(HAVE_LIBDL)
#define HAVE_DLOPEN
#endif
#ifdef HAVE_DLOPEN
#include <dlfcn.h>
#endif

#include "swigmod.h"

/* Module factories.  These functions are used to instantiate 
   the built-in language modules.    If adding a new language
   module to SWIG, place a similar function here. Make sure
   the function has "C" linkage.  This is required so that modules
   can be dynamically loaded in future versions. */

extern "C" {
  Language *swig_tcl(void);
  Language *swig_python(void);
  Language *swig_perl5(void);
  Language *swig_ruby(void);
  Language *swig_felix(void);
  Language *swig_guile(void);
  Language *swig_mzscheme(void);
  Language *swig_java(void);
  Language *swig_php(void);
  Language *swig_ocaml(void);
  Language *swig_pike(void);
  Language *swig_sexp(void);
  Language *swig_xml(void);
  Language *swig_chicken(void);
  Language *swig_csharp(void);
}

struct swig_module {
  const char     *name;
  ModuleFactory   fac;
  const char      *help;
};

/* Association of command line options to language modules.
   Place an entry for new language modules here, keeping the
   list sorted alphabetically. */

swig_module  modules[] = {  
  {"-chicken",   swig_chicken,   "CHICKEN"},
  {"-csharp",    swig_csharp,    "C#"},
//  {"-felix",     swig_felix,     "Felix"},
  {"-guile",     swig_guile,     "Guile"},
  {"-java",      swig_java,      "Java"},
  {"-mzscheme",  swig_mzscheme,  "Mzscheme"},
  {"-ocaml",     swig_ocaml,     "Ocaml"},
  {"-perl",      swig_perl5,     "Perl"},
  {"-perl5",     swig_perl5, 0},
  {"-php",       swig_php,       "PHP"},
  {"-php4",      swig_php, 0},
  {"-pike",      swig_pike,      "Pike"},
  {"-python",    swig_python,    "Python"},
  {"-ruby",      swig_ruby,      "Ruby"},
  {"-sexp",      swig_sexp,      "Lisp S-Expressions"},
  {"-tcl",       swig_tcl,       "Tcl"},
  {"-tcl8",      swig_tcl, 0},
  {"-xml",       swig_xml,       "XML"},
  {NULL, NULL, NULL}
};

#ifdef MACSWIG
#include <console.h>
#include <SIOUX.h>
#endif

#ifndef SWIG_LANG
#define SWIG_LANG "-python"
#endif

//-----------------------------------------------------------------
// main()
//
// Main program.    Initializes the files and starts the parser.
//-----------------------------------------------------------------


int main(int argc, char **argv) {
  int i;
  Language *dl = 0;
  ModuleFactory fac = 0;

  // initialise list of module arrays to builtins
#ifdef MACSWIG
  SIOUXSettings.asktosaveonclose = false;
  argc = ccommand(&argv);
#endif

  /* Register built-in modules */
  for (i = 0; modules[i].name; i++) {
    Swig_register_module(modules[i].name, modules[i].fac);
  }

  Swig_init_args(argc,argv);

  /* Get options */
  for (i = 1; i < argc; i++) {
      if (argv[i]) {
	fac = Swig_find_module(argv[i]);
	if (fac) {
	  dl = (fac)();
	  Swig_mark_arg(i);
	} else if (strcmp(argv[i],"-nolang") == 0) {
	  dl = new Language;
	  Swig_mark_arg(i);
#ifdef SWIG_DYNLOAD
	} else if (strncmp(argv[i],"-extend=",8) == 0) {
#ifdef HAVE_DLOPEN
	  Swig_mark_arg(i);
	  char *filename=argv[i]+8;
	  void *lib = dlopen(filename, RTLD_NOW);
	  if(!lib) {
	    Printf(stderr,"Unable to load extension file %s\n",filename);
      Printf(stderr,"%s\n",dlerror());
	    exit(1);
	  }
	  swig_module *modules = (swig_module*)dlsym(lib,"swig_modules");
	  if(!modules) {
	    Printf(stderr,"Extension file does not contain 'swig_modules' symbol\n");
	    exit(1);
	  }
	  for (int i = 0; modules[i].name; i++) {
	    Swig_register_module(modules[i].name, modules[i].fac);
	  }
#else
	  Printf(stderr,"swig:dynamic loading not supported");
	  exit(1);
#endif
#endif
	} else if ((strcmp(argv[i],"-dnone") == 0) ||
		   (strcmp(argv[i],"-dhtml") == 0) ||
		   (strcmp(argv[i],"-dlatex") == 0) ||
		   (strcmp(argv[i],"-dascii") == 0) ||
		   (strcmp(argv[i],"-stat") == 0))
	  {
	    Printf(stderr,"swig: Warning. %s option deprecated.\n",argv[i]);
	    Swig_mark_arg(i);
	  } else if (strcmp(argv[i],"-help") == 0) {
	    Printf(stderr,"Target Language Options:\n");
	    for (int j = 0; modules[j].name; j++) {
	      if (modules[j].help) {
                Printf(stderr,"     %-15s - Generate %s wrappers\n", modules[j].name, modules[j].help);
	      }
	    }
	    Swig_mark_arg(i);
	  }
      }
  }
  if (!dl) {
    fac = Swig_find_module(SWIG_LANG);
    if (fac) {
      dl = (fac)();
    }
  }
  return SWIG_main(argc,argv,dl);
}

@head(1,'patch for swig 1.1.20')
This patch fixes a bug in the swig 1.1.20 preprocessor
which fails to concatenate lines terminate by \ in 
preprocessor directives. You will need to apply
the patch in directory Source/Preprocessor.

@select(tangler('swig/preprocessor.patch','data'))
*** cpp.c.old   2004-01-01 14:20:58.000000000 +1100
--- cpp.c       2004-01-01 14:26:36.000000000 +1100
***************
*** 1153,1168 ****
        Putc(c,value);
        skip_tochar(s,'\'',value);
        } else {
        Putc(c,value);
-       if (c == '\\') state = 44;
        }
        break;
   
!     case 44:
        if (c == '\n') {
!       Putc(c,value);
!       cpp_lines++;
        } else {
!       Ungetc(c,s);
        }
        state = 43;
--- 1153,1170 ----
        Putc(c,value);
        skip_tochar(s,'\'',value);
+       }       else if (c == '\\') {
+         state = 44;
        } else {
        Putc(c,value);
        }
        break;
   
!     case 44:
!       /* join \ terminated lines or copy \ escapes as is */
        if (c == '\n') {
!       cpp_lines++; /* not sure if this is right .. */
        } else {
!         Putc('\\',value);
!         Putc(c,value);
        }
        state = 43;

