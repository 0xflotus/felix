@execfile('config'+os.sep+'config.py')
@execfile("flxbuild"+os.sep+"iscrutil.py")

@env_faio = setup_test('test/faio/faio-')
@env_win = setup_test('test/faio/win-')
@env_posix = setup_test('test/faio/posix-')

@def kat_faio(code):
  env_faio.kat(get_tangler(),code)

@def kat_win(code):
  env_win.kat(get_tangler(),code)

@def kat_posix(code):
  env_posix.kat(get_tangler(),code)


@head(1,"Faio")
Asynch I/O interface pack.

@h = tangler('config/faio.fpc', 'data')
@select(h)
Name: faio
Description: Asynchronous I/O support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libfaio_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libfaio_static")
 else:
   tangle("provides_dlib: -lfaio_dynamic")
   tangle("provides_slib: -lfaio_static")
Requires: demux

@h = tangler('spkgs/faio.py')
@select(h)
FAIORTL_INTERFACES = [
 'faio/faio_asyncio.hpp',
 'faio/faio_job.hpp',
 'faio/faio_timer.hpp',
 'faio/faio_posixio.hpp',
 'faio/faio_winio.hpp',
]

FAIO_CPPS = [
  "faio/faio_timer",
  "faio/faio_job",
  "faio/faio_asyncio",
]

POSIX_FAIO_CPPS = [
  "faio/faio_posixio",
]

WINDOWS_FAIO_CPPS = [
  "faio/faio_winio",
]

@tangle('EXTRA_TEST_GLOBS = glob.glob('+repr(unix2native(env_faio.root)+"*.flx")+')')

if WIN32:
  FAIO_CPPS = FAIO_CPPS + WINDOWS_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = glob.glob('+repr(unix2native(env_win.root)+"*.flx")+')')

if POSIX:
  FAIO_CPPS = FAIO_CPPS + POSIX_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = glob.glob('+repr(unix2native(env_posix.root)+"*.flx")+')')

cpp_cpps = FAIO_CPPS
rtl_interfaces = FAIORTL_INTERFACES
pkg_requires = ['demux','flx_pthread', 'flx_rtl'] # flx_rtl for rtl_config.
lib_requires = ['libdemux','libflx_pthread'] # however lib not required
unit_tests = EXTRA_TEST_GLOBS
iscr_source = ["lpsrc/flx_faio.pak"]
build_macro = "FAIO"
weaver_directory = 'doc/rtl/flx_faio/'

@h=tangler('rtl/flx_faio_config.hpp')
@select(h)
#ifndef __FLX_FAIO_CONFIG_H__
#define __FLX_FAIO_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FAIO
#define FAIO_EXTERN FLX_EXPORT
#else
#define FAIO_EXTERN FLX_IMPORT
#endif
#endif

@head(1,'Async IO')
@h=tangler('faio/faio_asyncio.hpp')
@select(h)
#ifndef __FLX_FAIO_ASYNCIO_H__
#define __FLX_FAIO_ASYNCIO_H__
#include <flx_faio_config.hpp>
#include "pthread_sleep_queue.hpp"

#include "demux_demuxer.hpp"        // sel_param, demuxer base
#include "flx_rtl.hpp"

namespace flx { namespace faio {

struct FAIO_EXTERN finote_t 
{
  virtual void signal()=0;
  virtual ~finote_t(){}
};

class FAIO_EXTERN wakeup_fthread_t : public finote_t 
{
  rtl::fthread_t *f;
  pthread::sleep_queue_t *q;
public:  
  wakeup_fthread_t(pthread::sleep_queue_t *q_a, rtl::fthread_t *f_a) : f(f_a), q(q_a) {}
  void signal () { q->enqueue(f); }
};


class FAIO_EXTERN flx_driver_request_base {
    finote_t *fn;
    virtual bool start_async_op_impl(demux::demuxer& demux) = 0;
public:
    flx_driver_request_base() : fn(0) {} 
    virtual ~flx_driver_request_base() {}       // so destructors work

    // returns finished flag (async may fail or immediately finish)
    void start_async_op(demux::demuxer& demuxer, finote_t *fn_a);
    void notify_finished();
};  

}} // namespace faio, flx
#endif  // __ASYNCIO__


@h=tangler('faio/faio_asyncio.cpp')
@select(h)
#include <assert.h>
#include "faio_asyncio.hpp"

namespace flx { namespace faio {

void flx_driver_request_base:: start_async_op(demux::demuxer& demuxer, finote_t *fn_a)
{
  fprintf(stderr,"start async op %p, set fn = %p\n",this,fn_a);
  fn = fn_a;
  bool completed =  start_async_op_impl(demuxer);
  if(completed) notify_finished();
}

void flx_driver_request_base:: notify_finished()
{ 
  fprintf(stderr, "Notify %p\n", fn);
  assert(fn!=0);
  fn->signal(); 
  delete fn; 
  fn=0;
}

}}

@head(1,'Timer')
@h=tangler('faio/faio_timer.hpp')
@select(h)
#ifndef __FLX_FAIO_TIMER_H__
#define __FLX_FAIO_TIMER_H__
#include <flx_faio_config.hpp>

#include "demux_demuxer.hpp"        // sel_param, demuxer base
#include "faio_asyncio.hpp"
#include "demux_timer_queue.hpp"

#include "flx_rtl.hpp"

namespace flx { namespace faio {


// sleeping
class FAIO_EXTERN sleep_request 
  : public flx_driver_request_base, public demux::sleep_task
{
  demux::timer_queue *sleepers; 
  double      delta;
public:
  sleep_request() {}        // flx linkage

  sleep_request(demux::timer_queue *sleepers_a, double d) : 
    sleepers(sleepers_a), delta(d) 
  {}

  // from driver request
  bool start_async_op_impl(demux::demuxer& demux);

  void fire();

};

}} // namespace faio, flx
#endif  

@h=tangler('faio/faio_timer.cpp')
@select(h)
#include "faio_timer.hpp"

using namespace flx::demux;
namespace flx { namespace faio {
bool
sleep_request::start_async_op_impl(demuxer& demux)
{
  fprintf(stderr,"Sleep: start async_op_impl\n");
  sleepers->add_sleep_request(this, delta);
  return false;   // no wakeup
}

void sleep_request::fire() {
  notify_finished();
}

}}

@head(1,'Jobs')
@h=tangler('faio/faio_job.hpp')
Abstract base for jobs. A job does some work asynchronously,
then wakes up the fthread that scheduled it. The fthread blocks
until the job is completed.
@p()
To use this class, just override doit().
@select(h)
#ifndef __FLX_FAIO_JOB_H__
#define __FLX_FAIO_JOB_H__
#include <flx_faio_config.hpp>
#include "demux_demuxer.hpp"
#include "pthread_work_fifo.hpp"
#include "faio_asyncio.hpp"

namespace flx { namespace faio {
class FAIO_EXTERN job_t: 
  public flx_driver_request_base,
  public pthread::worker_task 
{
   pthread::worker_fifo* job_queue;
public:  

  // from flx_driver_request_base
  bool start_async_op_impl(flx::demux::demuxer& demux);
};
}}

#endif

@h=tangler('faio/faio_job.cpp')
@select(h)
#include "faio_job.hpp"

namespace flx { namespace faio {
// from flx_driver_request_base
bool job_t::start_async_op_impl(demux::demuxer& demux)
{
  fprintf(stderr,"job_t: start async_op_impl\n");
  //printf("Adding task to worker queue\\n");
  // get worker fifo, add this task
  job_queue->add_worker_task(this);
  //printf("Task added\\n");
  return false;              // suspended
}

}}

@head(1,'Scheduler')
@h=tangler('faio/faio_drv.hpp')
@select(h)
#ifndef __FLX_FAIO_DRV_H__
#define __FLX_FAIO_DRV_H__
#include <flx_faio_config.hpp>

#include "pthread_sleep_queue.hpp"
#include "pthread_work_fifo.hpp"
#include "demux_timer_queue.hpp"
#include "demux_demuxer.hpp"

namespace flx { namespace faio {

// this may be needed but I've lost track of where
// we get SIGPIPE, SIG_IGN from ..

#if 0
void FAIO_EXTERN sigpipe_ignorer()
{
    void (*prev_handler)(int);  // solaris is FUN.
    prev_handler = signal(SIGPIPE, SIG_IGN);

    if(SIG_ERR == prev_handler)
    {
        fprintf(stderr, "failed to install SIGPIPE ignorer\n");
        throw -1;
    }
    else if(prev_handler != SIG_IGN && prev_handler != SIG_DFL)
    {
        fprintf(stderr,"warning: blew away prev SIGPIPE handler: %p\n",
            prev_handler);
    }
}
#endif

}}
#endif

@head(1,'Sockets')
@h=tangler('faio/faio_posixio.hpp')
@select(h)
#ifndef __FLX_FAIO_POSIXIO_H__
#define __FLX_FAIO_POSIXIO_H__
#include <flx_faio_config.hpp>

#include "faio_asyncio.hpp"

// we don't need to piggyback much data at all. for now just the demuxer,
// so that we can be woken up, and the buffer info (this replaces the
// felix "socket" thread type, which was ugly.

#include "demux_posix_demuxer.hpp" 

// a new sort of demuxer/event source: file io completions
// haven't given up on using the socket style demuxers yet.
#include "demux_pfileio.hpp"

#include "demux_timer_queue.hpp"

namespace flx { namespace faio {
 
class FAIO_EXTERN socketio_wakeup : public demux::socket_wakeup {
public:
  demux::sel_param   pb;     // in: what you want, out: what you get
  int       sio_flags;  // either one of PDEMUX_{READ|WRITE}A
  struct socketio_request *request;

  virtual void wakeup(demux::posix_demuxer& demux);
};

// this can handle most unix style io, that is, read & write on sockets,
// files & pipes. NICE. the fact that the socket is now in here may mean
// I can get rid of the epoll hack
// Not sure if this can be used for file fds.
class FAIO_EXTERN socketio_request : public flx_driver_request_base {
public:
    socketio_wakeup sv;
    
    socketio_request() {}       // Lord Felix demands it. Like STL.
    socketio_request(socketio_request const&);
    void operator = (socketio_request const&);
    
    socketio_request(int s, char* buf, long len, bool r);
    bool start_async_op_impl(demux::demuxer& demux);
};

// client open
class FAIO_EXTERN connect_request
  : public flx_driver_request_base, public demux::connect_control_block {
public:

  connect_request() {}      // flx linkage

  connect_request(const char* addr, int port) { addy = addr; p = port; s=-1; }
  bool start_async_op_impl(demux::demuxer& demux);
  virtual void wakeup(demux::posix_demuxer& demux);
};

// server open
class FAIO_EXTERN accept_request
  : public flx_driver_request_base, public demux::accept_control_block {
public:
  // we sometimes know that there'll be several connections to accept.
  // this'll need a different wakeup - and a different interface between
  // event source & wakeups

  accept_request() {} // flx linkage

  // eeh, give that a better name
  accept_request(int listener) { s = listener; }

  // from flx_driver_request_base
  bool start_async_op_impl(demux::demuxer& demux);

  // from accept_control_block
  virtual void wakeup(demux::posix_demuxer& demux);
};


// separate pthread file io
// hum. multiple inheritance
class FAIO_EXTERN flxfileio_request
    : public flx_driver_request_base, public demux::fileio_request
{
    demux::pasync_fileio       *aio_worker;
public:
    flxfileio_request();           // flx linkage
    ~flxfileio_request();          // flx linkage

    flxfileio_request(
      demux::pasync_fileio *a,
      int f, char* buf, long len, long off, bool rd
     )
        : fileio_request(f, buf, len, off, rd), aio_worker(a) {}

    // from driver request
    bool start_async_op_impl(demux::demuxer& demux);
};

}}
#endif

@h=tangler('faio/faio_posixio.cpp')
@select(h)
#include <stdio.h>      // printf
#include "faio_posixio.hpp"
#include "demux_sockety.hpp"    // async_connect

#include <sys/types.h>  // getsockopt & co
#include <sys/socket.h>

#include <unistd.h>     // close
#include <string.h>     // strerror - probably not portable
#include <assert.h>

using namespace flx::demux;
namespace flx { namespace faio {
socketio_request::socketio_request(int s, char* buf, long len, bool read)
{
    fprintf(stderr,"socketio_request %p making socketio_wakeup for socket %d\n",this,s);
    sv.s = s;
    sv.request = this;
  // demux supports reading AND writing. We don't. Yet.
  sv.sio_flags = ((read) ? PDEMUX_READ : PDEMUX_WRITE);

    sv.pb.buffer = buf;
    sv.pb.buffer_size = len;
    sv.pb.bytes_written = 0;        // really bytes_processed
}

socketio_request::socketio_request(socketio_request const &a)
{
  fprintf(stderr, "copying socketio_request to %p\n",this);
  sv.request = this;
}

// EXTREME HACKERY!
void socketio_request::operator=(socketio_request const &a)
{
  fprintf(stderr, "assigning socketio_request to %p\n",this);

  flx_driver_request_base::operator=(a);
  sv = a.sv;
  sv.request = this;
}

bool
socketio_request::start_async_op_impl(demux::demuxer& demux)
{
    fprintf(stderr,"socketio_request: socket %d start async_op_impl %p\n",sv.s,this);
    // fprintf(stderr, "adding wakeup: len %i, done %i\n",
    //   sv.pb.buffer_size, sv.pb.bytes_written);

    // posix_demuxer*  pd = (posix_demuxer*)&demux;
    // covariant
    posix_demuxer*  pd = dynamic_cast<posix_demuxer*>(&demux);


    // wake thread if call failed
  bool failed = (pd->add_socket_wakeup(&sv, sv.sio_flags) == -1);
  if (failed)
    fprintf(stderr,"socketio_request FAILED %p\n",this);
  else
    fprintf(stderr,"socketio_request OK %p\n",this);
  return failed;
}


void
socketio_wakeup::wakeup(posix_demuxer& demux)
{
    // handle read/write, return true if not finished.
    // otherwise wakeup return false.
  bool  connection_closed;

  fprintf(stderr, "making socketio_wakeup %p\n",this);
  //fprintf(stderr,"prehandle wakeup, this: %p, read: %i, len: %i, done %i\n",
  //  this, read, pb.buffer_size, pb.bytes_written);

  // NOTE: this code does not handle the possibility of both read AND
  // write being set. That would require thinking about the what
  // the connect_closed return value meant. In any case, we don't
  // do that stuff here yet.
  if(wakeup_flags & PDEMUX_READ)
  {
    // just check that our above assumption hasn't been violated.
    assert(wakeup_flags == PDEMUX_READ);
        connection_closed = posix_demuxer::socket_recv(s, &pb);
    }
    else
    {   
    // never hurts to be paranoid.
    assert(wakeup_flags == PDEMUX_WRITE);
        connection_closed = posix_demuxer::socket_send(s, &pb);
    }
    
  // fprintf(stderr,"posthandle wakeup, this: %p, read: %i, len: %i, done %i\n",
  //  this, read, pb.buffer_size, pb.bytes_written);
  // fprintf(stderr,"wakeup of %p, closed = %i\n", this, connection_closed);
    
    // wake up: time to process some data
    if(connection_closed || pb.bytes_written == pb.buffer_size)
    {   
    // fprintf(stderr,"schedding %p, drv: %p, f: %p\n", this, drv, f);
        request->notify_finished();
        return;
    }
    
  // fprintf(stderr,"not schedding %p\n", this);
  if(demux.add_socket_wakeup(this, sio_flags) == -1)
        fprintf(stderr,"failed to re-add_socket_wakeup\n");
}

// asynchronous connect
bool
connect_request::start_async_op_impl(demuxer& demux)
{
  fprintf(stderr,"connect_request %p: start async_op_impl\n",this);

  // covariant
  posix_demuxer*  pd = dynamic_cast<posix_demuxer*>(&demux);

  // call failed or finished (!), wake up thread as no wakeup coming
  if(start(*pd) == -1) {
    fprintf(stderr, "FAILED TO SPAWN CONNECT REQUEST\n");
    return true; 
  }

  // NONONONONO! Referring to this's variables after a successful start
  // gives rise to a race condition, which is bad.
  fprintf(stderr, "CONNECT REQUEST SPAWNED\n");
  return false;     // do not reschedule after a successful start

/*
  // I've not seen this yet, don't know why.
  if(0 == socket_err) fprintf(stderr, "WOW, instant CONNECT\n");

  // call didn't fail, could be pending or finished.
  // return socket_err != EINPROGRESS, the contrapositive, sort of
  return 0 == socket_err;   // no err => finished immediately
*/
}

void
connect_request::wakeup(posix_demuxer& demux)
{
//fprintf(stderr, "connect_request::wakeup\n");

  // fprintf(stderr,"connect woke up\n");
  connect_control_block::wakeup(demux);

  // felix thread can pick out error itself.
  notify_finished();
}


// async accept
bool
accept_request::start_async_op_impl(demuxer& demux)
{
  fprintf(stderr,"accept_request %p: start async_op_impl\n",this);
  // covariant
  posix_demuxer*  pd = dynamic_cast<posix_demuxer*>(&demux);
  bool failed = (start(*pd) == -1);      // accept_control_block function
  if(failed)
    fprintf(stderr, "FAILED TO SPAWN ACCEPT REQUEST\n");
  else
    fprintf(stderr, "ACCEPT REQUEST SPAWNED\n");
  return failed;
}

void
accept_request::wakeup(posix_demuxer& demux)
{
  // does the leg work.
  accept_control_block::wakeup(demux);

  if(accepted == -1)
  {
    // I don't know if this is a good idea...
    fprintf(stderr, "accept request failed (%i), retrying...\n",
      socket_err);
    // didn't get it - go back to sleep
    if(start(demux) == -1)
      fprintf(stderr, "failed again... probably was a bad idea\n");
    return; 
  }

  notify_finished();
}

// from driver request
flxfileio_request::~flxfileio_request(){}  
flxfileio_request::flxfileio_request(){}


bool
flxfileio_request::start_async_op_impl(demux::demuxer& demux)
{
    fprintf(stderr,"flxfileio_request: start async_op_impl\n");
    // printf("driver called fileio start_async_op code\n");
    
    // need to create the async io thing here, or ask the driver for it
    // driver needs to go a little less portable
    aio_worker->add_fileio_request(this);
    
    return false;       // no wakeup
}

}}

@h=tangler('faio/faio_winio.hpp')
@select(h)
#ifndef __FLX_FAIO_WINIO_H__
#define __FLX_FAIO_WINIO_H__
#include <flx_faio_config.hpp>

// visual studio is quite sensitve about how you do these includes.
// THIS is the way (WinSock2.h must include Windows.h).
#include <WinSock2.h>
#include <MSWSock.h>        // AcceptEx, TF_REUSE_SOCKET, etc

#include "faio_asyncio.hpp" // flx driver requests
#include "demux_overlapped.hpp"   // nicely wrapped async windows calls
    
namespace flx { namespace faio {

// interestingly, because in windows the async objects are associated
// with an IOCP before their use, we don't actually need a demuxer here
// at all. That's kind of nice. (actually iocp_associator uses it now)

// a flx driver request to the add socket s to the drivers iocp
// this is currently the only windows driver request that uses the demuxer.
class FAIO_EXTERN iocp_associator : public flx_driver_request_base {
  SOCKET  s;
public:
  // should have result & errcode
  iocp_associator() {}
  iocp_associator(SOCKET associatee) : s(associatee) {}

  bool start_async_op_impl(demux::demuxer& demux);
};

// flx <-> c++ stuff for async io (well, it was)

// transition to new windows async control block
class FAIO_EXTERN waio_base : public flx_driver_request_base {
protected:
  finote_t *fn_a;
public:
  bool  success;          // eh?

  waio_base() : success(false) {}

  // actually wakes up thread
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};


// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class FAIO_EXTERN wasync_accept
  : public waio_base, public demux::acceptex_control_block
{
public:
  wasync_accept() {}  // felix linkage demands it

  wasync_accept(SOCKET l, SOCKET a) { listener = l; acceptor = a; }

  bool start_async_op_impl(demux::demuxer& demux);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

class FAIO_EXTERN connect_ex
  : public waio_base, public demux::connectex_control_block
{
public:

  connect_ex() {}     // flx linkage

  connect_ex(SOCKET soc, const char* addr, int port)
    { s = soc; addy = addr; p = port; }

  bool start_async_op_impl(demux::demuxer& demux);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// TransmitFile here (requires file handle)
class FAIO_EXTERN wasync_transmit_file
  : public waio_base, public demux::transmitfile_control_block
{
public:
  wasync_transmit_file() 
    : transmitfile_control_block(INVALID_SOCKET, NULL) {}   // flx linkage

  wasync_transmit_file(SOCKET dst)      // for reuse of socket
    : transmitfile_control_block(dst) {}

  wasync_transmit_file(SOCKET dst, HANDLE src)  // actual transmitfile
    : transmitfile_control_block(dst, src) {}

  // from flx_request_base
  bool start_async_op_impl(demux::demuxer& demux);

  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// handles both WSASend & WSARecv
class FAIO_EXTERN wsa_socketio
  : public waio_base, public demux::wsasocketio_control_block
{
public:
  wsa_socketio()
    : wsasocketio_control_block(INVALID_SOCKET, NULL, false) {}

  wsa_socketio(SOCKET src, demux::sel_param* ppb, bool read)
    : wsasocketio_control_block(src, ppb, read) {}

  bool start_async_op_impl(demux::demuxer& demux);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// looks a bit like wsa_socketio (bad name, sends too)
class FAIO_EXTERN winfile_io
  : public waio_base, public demux::winfileio_control_block
{
public:
  winfile_io()      // flx linkage
    : winfileio_control_block(NULL, NULL, 0, false){}
  
  // offset?
  winfile_io(HANDLE f, void* buf, int len, bool read)
    : winfileio_control_block(f, buf, len, read) {}

  bool start_async_op_impl(demux::demuxer& demux);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};


}}
#endif  // __DWINIO__

@h=tangler('faio/faio_winio.cpp')
@select(h)
#include "faio_winio.hpp"
#include <stdio.h>      // printf
using namespace flx::demux;
namespace flx { namespace faio {

// way of adding sockets to the IOCP.
bool
iocp_associator::start_async_op_impl(demuxer& demux)
{
  fprintf(stderr,"iocp_associator: start async_op_impl\n");
  // covariant
  iocp_demuxer*  iod = dynamic_cast<iocp_demuxer*>(&demux);

  // not sure why we're doing dynamic casts if we don't check
  // the return value.
  //iocp_demuxer* iod = (iocp_demuxer*)&demux;

  // nasty: note how I'm making the user cookie constant (0).
  if(iod->associate_with_iocp((HANDLE)s, 0) != 0)
    fprintf(stderr,"associate request failed - get result here!\n");

  return true;      // wake caller
}

void
waio_base::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  // fprintf(stderr,"general wakeup thing - rescheduling\n");
  //fprintf(stderr,"this: %p, q: %p, f: %p, err: %i\n", this, q, f, err);

  // this tells us when things went wrong (store it)
  if(NO_ERROR != err)
    fprintf(stderr,"catchall wakeup got error: %i (should store it)\n", err);

  success = (NO_ERROR == err);  // this works pretty well
  notify_finished();
}

bool
wasync_accept::start_async_op_impl(demuxer& demux)
{
  fprintf(stderr,"wasync_accept: start async_op_impl\n");
  return start_overlapped();
}

void
wasync_accept::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}


bool
connect_ex::start_async_op_impl(demux::demuxer& demux)
{
  fprintf(stderr,"connect_ex: start async_op_impl\n");
  return start_overlapped();
}

void
connect_ex::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}


bool
wasync_transmit_file::start_async_op_impl(demux::demuxer& demux)
{
  fprintf(stderr,"wasync_transmit_file: start async_op_impl\n");
  return start_overlapped();
}

void
wasync_transmit_file::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}

bool
wsa_socketio::start_async_op_impl(demux::demuxer& demux)
{
  fprintf(stderr,"wsa_socketio: start async_op_impl\n");
  return start_overlapped();    // start overlapped op
}

// this could be factored into demux... or it might need
// to stay here... this is really a finished that isn't finished
// same goes for winfileio (I think)
void
wsa_socketio::iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  // fprintf(stderr,"wsa_socketio wakeup, nb: %li, err: %i\n", nbytes, err );
// Doing the handling myself - this can restart the the op giving us
// a possible race condition... or not? It should be sync with this call.
  // wsasocketio_control_block::iocp_op_finished(nbytes, udat, olp, err);

  ppb->bytes_written += nbytes;

  // if we're not finished, we have to reinstall our request
  // zero bytes indicates shutdown/closure, right?
  // might be using this for WSASend. Instead of broken pipes on win32, 
  // instead we get WSAECONNRESET (pretty sure) on write. On read?
  if(0 == nbytes || ppb->finished())
  {
    // this'll wake us up
    waio_base::iocp_op_finished(nbytes, udat, olp, err);
  }
  else
  {
    // go back around again
    // this returns a finished flag (bad idea). it can also fail.
    // I think it would be better to know that.
    if(start_overlapped())
      fprintf(stderr, "socketio restart finished! WHAT TO DO!?!\n");
  }
}

// file io

bool
winfile_io::start_async_op_impl(demuxer& demux)
{
  fprintf(stderr,"winfile_io: start async_op_impl\n");
  return start_overlapped();  // go
}

// this too could be factored back, I think. that waio_base finished
// would have to change. it's just asking for for some fn to realise
// that it's finished.
// the byte count shouldn't need to be updated here...
void
winfile_io::iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  // fprintf(stderr,"winfile_io wakeup, nb: %li, err: %i\n", nbytes, err );

  // fprintf(stderr,"THIS WAKEUP SHOULD BE THE SAME AS SEND/RECV make it so\n");
  // actually, I don't think it should be. the SOCKET stuff goes around
  // the loop again (and ignores errors, check it doesn't hammer).

  // keep track of bytes received.
  pb.bytes_written += nbytes;

  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}

}}


@h=tangler('lib/flx_faio.flx')
@select(h)
#import <flx.flxh>

module Faio {
requires package "demux";
requires package "faio";

open C_hack;

proc faio_req[t](x:&t) {
  val y : &address = reinterpret[&address] x;
  svc (svc_general y);
}

proc get_thread(thread: ptr[fthread]) {
    svc (svc_get_fthread thread );
}

header stdlib_h = '#include <stdlib.h>';            // malloc, free
header = '#include "faio_asyncio.hpp"';
header faio_timer_h = '#include "faio_timer.hpp"';

type sel_param = "flx::demux::sel_param";
type sel_param_ptr = "flx::demux::sel_param*";
fun to_ptr : sel_param -> sel_param_ptr = '&$1';


fun get_bytes_done : sel_param_ptr -> int = '$1->bytes_written';
proc init_pb : sel_param*address*int
= '{$1.buffer=(char*)$2;$1.buffer_size=$3;$1.bytes_written=0;}';

proc calc_eof(pb: sel_param_ptr, len: &int, eof: &bool)
{
    var bytes_done = pb.bytes_done;
    *eof = (bytes_done != *len);
    *len = bytes_done;
}

proc gc_collect_me_not_hack[t]: t = ';';

type sleep_request = 'flx::faio::sleep_request' requires faio_timer_h;
type alarm_clock = 'flx::demux::timer_queue*' requires faio_timer_h;

fun mk_alarm_clock: 1 -> alarm_clock = 'flx::demux::mk_timer_queue()';
fun mk_sleep_request: alarm_clock * double -> sleep_request = 'flx::faio::sleep_request($1,$2)';

proc sleep(clock: alarm_clock, delta: double)
{
  var sr = mk_sleep_request$ clock,delta;
  faio_req$ &sr;
}


} // module faio

@h=tangler('lib/flx_faio_posix.flx')
@select(h)
#import <flx.flxh>
// contains posix async socket io & copipes, all wrapped up streams

include "flx_faio";
module Faio_posix  {
header faio_posixio_hpp = '#include "faio_posixio.hpp"';
requires package "demux";
requires package "faio";
open C_hack;        // cast, address
open Faio;

header unistd_h = '#include <unistd.h>';            // close
header fcntl_h = '#include <fcntl.h>';              // fcntl for O_NONBLOCK
header sys_socket_h = '#include <sys/socket.h>';    // shutdown
header sockety_h = '#include "demux_sockety.hpp"';  // my socket utils

proc close: int = 'close($1);' requires unistd_h;
proc shutdown: int*int = 'shutdown($a);' requires sys_socket_h;

fun aio_ropen: string -> int = 'open($1.c_str(), O_RDONLY | O_NONBLOCK, 0)'
    requires fcntl_h;

fun ropen: charp -> int = 'open($1, O_RDONLY, 0)' requires fcntl_h;


header = '#include "faio_posixio.hpp"';

// socketio_request should be renamed to be async_fd_request
type socketio_request = "flx::faio::socketio_request";

gen mk_socketio_request: int*address*int*bool -> socketio_request
    = 'flx::faio::socketio_request($1, (char*)$2, $3, $4)';

fun get_pb: socketio_request -> sel_param_ptr = '&$1.sv.pb';

// read & write differ only by a flag
proc async_rw(fd: int, len: &int, buf: address, eof: &bool, read_flag: bool)
{
    var asyncb = mk_socketio_request(fd, buf, *len, read_flag);
    faio_req$ &asyncb;
    calc_eof(asyncb.pb, len, eof);
}

proc async_read(fd: int, len: &int, buf: address,
    eof: &bool)
{   
    async_rw(fd, len, buf, eof, true);      // read
}

proc async_write(fd: int, len: &int, buf: address, eof: &bool)
{   
    async_rw(fd, len, buf, eof, false);     // write
}

type flxfileio_request = "flx::faio::flxfileio_request";

// offset ? let it be for a moment
fun mk_faio: int*address*int*int*bool -> flxfileio_request
    = 'flx::faio::flxfileio_request($1, (char*)$2, $3, $4, $5)';
fun get_pb: flxfileio_request -> sel_param_ptr = '&$1.pb';

proc faio_rw(fd: int, len: &int, buf: address, eof: &bool, read_flag: bool)
{   
    // constant offset for now, rushing to get this in flx_stream
    var faio = mk_faio(fd, buf, *len, 0, read_flag);
    faio_req$ &faio;
    calc_eof(faio.pb, len, eof);
}

proc faio_read(fd: int, len: &int, buf: address,
    eof: &bool)
{   
    faio_rw(fd, len, buf, eof, true);       // read
}

proc faio_write(fd: int, len: &int, buf: address, eof: &bool)
{   
    faio_rw(fd, len, buf, eof, false);      // write
}

// connect!
type async_connect = 'flx::faio::connect_request';

fun mk_async_connect: charp*int -> async_connect = 'flx::faio::connect_request($a)';
fun get_socket: async_connect -> int = '$1.s';
fun get_err: async_connect -> int = '$1.socket_err';

// could do multi connects for capable drivers
proc connect(s: &int, addr: charp, port: int)
{   
    var ac = mk_async_connect(addr, port);
    faio_req$ &ac;
    *s = ac.socket;
}

type accept_request = "flx::faio::accept_request";

fun mk_accept: int -> accept_request = 'flx::faio::accept_request($1)';
fun get_socket: accept_request -> int = '$1.accepted';

// arg1 = returned socket, arg2 is port, pass 0 to have one assigned
proc mk_listener: lvalue[int]*lvalue[int]*int
    = '$1 = flx::demux::create_async_listener(&$2, $3);' requires sockety_h;

proc accept(s: &int, listener: int)
{   
    var acc = mk_accept listener ;
    faio_req$ &acc;
    *s = acc.socket;
}



} // module faio

@h=tangler('lib/flx_faio_win32.flx')
@select(h)
#import <flx.flxh>
include "flx_faio";     // defines copipes & some driver interaction

module Faio_win32 {
requires package "demux";
requires package "faio";
// contains windows overlapped/iocp io & copipes. no stream wrapper yet.
open C_hack;
open Faio;
header '#include "faio_winio.hpp"'; // this has everything (includes asyncio.h)

// useful windows function
fun GetLastError: 1 -> int = 'GetLastError()';

ctypes SOCKET;

// maybe don't use this - let the socket be passed in already associated
// with an IOCP. do I have to make this explicitly overlapped? If we
// want async io I think I'll need to associate this with the iocp.
fun cmk_socket : unit -> SOCKET = '::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)';

// well that didn't help.
//fun cmk_socket : unit -> SOCKET = 'WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED)';
// must associate with iocp to do overlapped io with s (WSASend/Recv)
proc mk_socket(s: &SOCKET)
{
    *s = cmk_socket();
    associate_with_iocp(*s);                // associate with iocp (errors?).
}


type wasync_accept = "flx::faio::wasync_accept";

fun mk_accept: SOCKET*SOCKET -> wasync_accept = 'flx::faio::wasync_accept($a)';
// make this a parameterised type
fun get_success[t]: t -> bool = '$1.success';

// this feels silly
const INVALID_SOCKET: SOCKET = 'INVALID_SOCKET';
// oops, no good if we can't check against it
fun eq : SOCKET*SOCKET -> bool = '($1 == $2)';

// windows style accept. accepted is an already created socket, unbound
proc Accept(success: &bool, listener: SOCKET, accepted: SOCKET)
{
    var acc = mk_accept(listener, accepted);
    faio_req$ &acc;    // causes AcceptEx to be called
    *success = get_success(acc);
}

type connect_ex="flx::faio::connect_ex";
fun mk_connect_ex: SOCKET*charp*int -> connect_ex = 'flx::faio::connect_ex($a)';

// for use on sockets you make yourself, who knows, maybe you want to
// reuse them
proc Connect(success: &bool, s: SOCKET, addr: charp, port: int)
{   
    var con = mk_connect_ex(s, addr, port);  
     faio_req$ &con;    // causes ConnectEx to be called
    *success = get_success(con);
}

proc Connect(s: &SOCKET, addr: charp, port: int)
{   
    mk_socket s;            // error handling?
    var success: bool;
    Connect(&success, *s, addr, port);
    // print "CONNECT success: "; print success; endl;
    // error handling?
}

// listens on all interfaces, I guess
proc cmk_listener: lvalue[SOCKET]*lvalue[int]*int
    = '$1 = flx::demux::create_listener_socket(&$2, $3);';

proc mk_listener(listener: &SOCKET, port: &int, backlog: int)
{   
    *listener <- cmk_listener(*port, backlog);
    associate_with_iocp(*listener);
}

// ignores return value
proc closesocket: SOCKET = 'closesocket($1);';

const SD_RECEIVE:int = 'SD_RECEIVE';
const SD_SEND:int = 'SD_SEND';
const SD_BOTH:int = 'SD_BOTH';

proc shutdown: SOCKET*int = 'shutdown($1, $2);';

type wasync_transmit_file = "flx::faio::wasync_transmit_file";

// I could just use HANDLEs everywhere, but I want to see how this goes
type WFILE = 'HANDLE';
const INVALID_HANDLE_VALUE: WFILE = 'INVALID_HANDLE_VALUE';
fun eq : WFILE*WFILE -> bool = '($1 == $2)';


// hacked for ro atm. the 0 means exclusive (not good, but I haven't deciphered
// the flags yet. NULL for non inheritable security attributes.
// OPEN_EXISTING is to make sure it doesn't create the file
// Geez, FILE_ATTRIBUTE_NORMAL? not hidden, not temp, etc. 
// final NULL is for template file. not sure what it does, but I don't want it.
// notice that it's opened for SHARED reading
proc OpenFile: lvalue[WFILE]*string =
  '$1 = CreateFile($2.c_str(), FILE_READ_DATA, FILE_SHARE_READ, NULL,\
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);';

// basically for windows named pipes
proc OpenFileDuplex: lvalue[WFILE]*string =
  '$1 = CreateFile($2.c_str(), FILE_READ_DATA | FILE_WRITE_DATA,\
     FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,\
     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);';

proc CloseFile: WFILE = 'if(!CloseHandle($1))\
  fprintf(stderr, "CloseHandle(WFILE) failed: %i\\n", GetLastError());';

// error handling?
// proc CloseFile: WFILE = 'CloseHandle($1);';

fun mk_transmit_file : SOCKET*WFILE -> wasync_transmit_file
    = 'flx::faio::wasync_transmit_file($a)';

// toylike interface for now, but still fun
proc TransmitFile(s: SOCKET, f: WFILE)
{   
    var tf = mk_transmit_file(s, f); 
    faio_req$ &tf;
}

// by passing special flags to TransmitFile we can transform a connected
// socket into a socket ready for use with AcceptEx. DisconnectEx explicitly
// does this and without the warning that accept-style & connect-style sockets
// cannot be reused as the other type (which isn't a problem for my use)
// however I already have TransmitFile code in place.
fun mk_reuse_socket : SOCKET -> wasync_transmit_file
    = 'flx::faio::wasync_transmit_file($a)';

proc ReuseSocket(s: SOCKET)
{   
    var tf = mk_reuse_socket(s);
    faio_req$ &tf;
}

type wsa_socketio = "flx::faio::wsa_socketio";
fun mk_wsa_socketio: SOCKET*sel_param_ptr*bool->wsa_socketio = 'flx::faio::wsa_socketio($a)';

proc WSARecv(s: SOCKET, len: &int, buf: address, eof: &bool)
{   
    var pb: sel_param;
    init_pb(pb, buf, *len);
    var ppb: sel_param_ptr = to_ptr pb;

    var rev = mk_wsa_socketio(s, ppb, true);  // reading
    faio_req$ &rev;
// we do have a success flag
    calc_eof(ppb, len, eof);
}

proc WSASend(s: SOCKET, len: &int, buf: address, eof: &bool)
{   
    var pb: sel_param;
    init_pb(pb, buf, *len);
    var ppb: sel_param_ptr = to_ptr pb;

    var rev = mk_wsa_socketio(s, ppb, false); // writing
    faio_req$ &rev;
    calc_eof(ppb, len, eof);
}

type winfile_io = "flx::faio::winfile_io";

fun mk_winfile_io: WFILE*address*int*bool->winfile_io = 'flx::faio::winfile_io($a)';

// no offset - just for streams now. write probably doesn't work
fun get_pb: winfile_io -> sel_param_ptr = '&$1.pb';

proc ReadFile(f: WFILE, len: &int, buf: address, eof: &bool)
{   
    var io = mk_winfile_io(f, buf, *len, true); // reading
    faio_req$ &io;
// we do have a success flag
    calc_eof(io.pb, len, eof);
}

proc WriteFile(f: WFILE, len: &int, buf: address, eof: &bool)
{
    var io = mk_winfile_io(f, buf, *len, false);    // writing
    faio_req$ &io;
    calc_eof(io.pb, len, eof);
}


// general request for addition of socket to iocp. might be better to
// just create them that way.
type iocp_associator = "flx::faio::iocp_associator";
fun mk_iocp_associator: SOCKET -> iocp_associator = 'flx::faio::iocp_associator($1)';

// this ends up just casting to a handle, so I should be able to use
// this for other HANDLEs. Note that the user cookie is not settable
// via this interface.
proc associate_with_iocp(s: SOCKET)
{
    // results? err code?
    var req = mk_iocp_associator(s);
    faio_req$ &req;
}

} // module win32_faio

@h = tangler("lib/flx_stream.flx")
@select(h)
include "flx_faio";
include "flx_faio_posix";
include "flx_faio_win32";
#import <flx_platform.flxh>

open Faio;  // copipes

#if POSIX
open Faio_posix;
#endif

#if WIN32
open Faio_win32;
#endif


module Flx_stream {
requires package "demux";
requires package "faio";

union devnull_t = DEVNULL;

/*
union flx_stream =
    | DEVNULL          // nothing
#if POSIX
    | UFD of int       // Unix file
    | USOCK of int     // Unix socket
#endif
// isn't this covered by the fact that under cygwin POSIX AND WIN32 are true?
//#if WIN32 or CYWGIN
#if WIN32
    | WSOCK of SOCKET  // Windows socket
    | WFD of WFILE     // Windows file
#endif
*/

// MISSING CASES: strstreams  -- strings as streams
// FILE* streams, C++ iostreams as streams. kind of messy ..
// windows named pipes (may or may not work with the WFD file io)
// try it out.

;

typeclass IByteStream[s] { 
  virtual proc flx_read: s * &int * address * &bool; 
}

typeclass OByteStream[s] { 
  virtual proc flx_write: s * &int * address * &bool; 
}

typeclass IOByteStream[s] { 
  inherit IByteStream[s];
  inherit OByteStream[s];
}

typeclass TerminalIByteStream[s] { 
  inherit IByteStream[s];
  virtual proc iclose: s; 
}

typeclass TerminalOByteStream[s] { 
  inherit OByteStream[s];
  virtual proc oclose: s; 
}

typeclass TerminalIOStream[s] { 
  inherit TerminalIBytestream[s];
  inherit TerminalOBytestream[s];
  virtual proc ioclose (f:s) { iclose f; oclose f; }
}

//
// devnull_t
//
instance IByteStream[devnull_t]
{
  proc flx_read(strm: t, len: &int, buf: address, eof: &bool)
    { *len = 0; *eof = true; }
}

instance OByteStream[devnull_t]
{
  proc flx_write(strm: devnull_t, len: &int, buf: address, eof: &bool)
    { *eof = false; }
}

instance IOByteStream[devnull_t] {}
instance TerminalIByteStream[devnull_t] { proc iclose (x:devnull_t) { } } 
instance TerminalOByteStream[devnull_t] { proc oclose (x:devnull_t) { } }
instance TerminalIOByteStream[devnull_t] { proc ioclose (x:devnull_t) { } }


//
// socket_t
//
instance IByteStream[socket_t]
{
  proc flx_read(s: socket_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { async_read(s, len, buf, eof); }
  #elif WIN32
    { WSARecv(s, len, buf, eof); }
  #endif
}

instance OByteStream[socket_t]
{
  proc flx_write(strm: flx_stream, len: &int, buf: address, eof: &bool)
  #if POSIX
    { async_write(fd, len, buf, eof); }
  #elif WIN32
    { WSASend(fd, len, buf, eof); }
  #endif
}

instance IOByteStream[socket_t] {}

instance TerminalIByteStream[socket_t]
{
  proc iclose (s:socket_t)
  #if POSIX
    { close s; }
  #else
    { closesocket s; }
  #endif
}

instance TerminalOByteStream[socket_t]
{
  proc oclose (s:socket_t) 
  #if POSIX
    { close s; }
  #elif WIN32
    { closesocket s; }
  #endif
}


instance TerminalIOByteStream[socket_t]
{
  proc oclose (s:socket_t) 
  #if POSIX
    { close s; }
  #elif WIN32
    { closesocket s; }
  #endif
}


//
// fd_t -- native file handle (disk file)
//
instance IByteStream[fd_t]
{
  proc flx_read(s: fd_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { async_read(s, len, buf, eof); }
  #elif WIN32
    { ReadFile(s, len, buf, eof); }
  #endif
}

instance OByteStream[fd_t]
{
  proc flx_write(s: fd_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { async_write(s, len, buf, eof); }
  #elif WIN32
    { WriteFile(s, len, buf, eof); }
  #endif
}

instance ByteStream[fd_t] {}

instance TerminalIByteStream[fd_t]
{
  proc iclose (x:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

instance TerminalOByteStream[fd_t]
{
  proc iclose (x:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

instance TerminalIOByteStream[fd_t]
{
  proc iclose (x:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}



/*
proc flx_shutdown(strm: flx_stream, how: int)
{
    match strm with
    | CO ?pipe => { co_shutdown(pipe, how); }
    | DEVNULL => { /* nothing to do? */ }
#if POSIX
    | USOCK ?socket => { shutdown(socket, how); }
    | UFD => { /* nuthin */ }
#endif
//#if WIN32 or CYGWIN
#if WIN32
    | WFD => { /* nothing to do */ }
    | WSOCK ?socket => { shutdown(socket, how); }
#endif
    endmatch;
}
*/

// fun things that probably need renaming
proc cat[istr,ostr where IByteStream[istr], OByteStream[ostr]]
(infd: istr , outfd: ostr, buf: address, bufsize: int) 
{
    var eof = false;
    var weof = false;
    var len: int;

    // if we finish input, stop. if output eofs, don't keep hammering on it!
    while{not(eof) and not(weof)} {
        len = bufsize;
     // print "catting in "; print len; print " bytes\n";
        flx_read(infd, &len, buf, &eof);
     // print "catting out "; print len; print " bytes\n";
        flx_write(outfd, &len, buf, &weof);
    };
};

proc cat(infd: flx_stream, outfd: flx_stream)
{
    val BUFSIZE = 10*1024;
    var buf = malloc(BUFSIZE);

    // that's some nice error checking
    cat(infd, outfd, buf, BUFSIZE);
    free(buf);
}

open List;

// if these are all file descriptors, one might not like to have them
// all open at once. would a generator be better?
// could make this supercat, with multiple in, multiple out (multiout
// in the sense of tee)
proc cat[istr,ostr where IByteStream[istr], OByteStream[ostr]]
(in_fds: list[istr], outfd: ostr,
    buf: address, bufsize: int)
{
    match in_fds with
    | Empty[istr] => {}                     // finished
    | Cons[istr] (?fd, ?l) =>
        {
            cat(fd, outfd, buf, bufsize);   // cat first
            cat(l, outfd, buf, bufsize);    // cat the rest
        }
    endmatch
    ;
}

// try the stream interface
proc echo[iostr where IOByteStream]
(fd: iostr, buf: address, bufsize: int)
{
    // echo a = cat a a. that's deep, man.
    cat(fd, fd, buf, bufsize);
};

// playing around. need to be able to control io buffers in a more
// global way. I like the supercat idea. need to be careful not to hammer
// multiple outputs. move tee to own file
proc tee[istr,ostr where IByteStream[istr], OByteStream[ostr]]
(infd: istr, outfd: ostr, outfd2: ostr)
{
    var eof = false;
    var weof = false;
    var weof2 = false;
    var len: int;

    val BUFSIZE = 10*1024;
    var buf = malloc(BUFSIZE);

    // don't hammer!
    while{not(eof) and not(weof) and not(weof2)} {
        len = BUFSIZE;
        flx_read(infd, &len, buf, &eof);
        flx_write(outfd, &len, buf, &weof);
        flx_write(outfd2, &len, buf, &weof2);
    };
    free buf;
}

} // module Flx_stream

@h = tangler("lib/flx_socket.flx")
@select(h)

include "flx_faio";
#import <flx_platform.flxh>

#if POSIX
include "flx_faio_posix";
open Faio_posix;
#endif

#if WIN32
include "flx_faio_win32";
open Faio_win32;
#endif

// for the flx_socket_to_stream function
include "flx_stream";
open Flx_stream;

module Flx_socket {

#if POSIX

typedef flx_listener = int;  // unix socket
typedef flx_socket = int;

fun flx_socket_to_stream(s: flx_socket) : flx_stream => USOCK s;

proc mk_flx_listener(l: &flx_listener, port: &int, qlen: int)
{
  // error checking?
  var listener: int <- mk_listener(*port, qlen);
  *l = listener;
}

proc flx_accept(l: flx_listener, s: &flx_socket)
{
  accept(s, l);  // success or not? error checking
}

#elif WIN32

typedef flx_listener = SOCKET;
typedef flx_socket = SOCKET;

fun flx_socket_to_stream(s: flx_socket) : flx_stream => WSOCK s;

proc mk_flx_listener(l: &flx_listener, port: &int, qlen: int)
{
  // error checking?
  var listener: SOCKET;
  mk_listener(&listener, port, qlen);
  *l = listener;
}

proc flx_accept(l: flx_listener, s: &flx_socket)
{
  var success: bool;
  // for async accept on win32 you create the accept socket yourself
  mk_socket(s);  // error check?

  // fprint (cout, "flx_accept calls AcceptEx\n");
  Accept(&success, l, *s);

  // err
  if success then {} else {fprint (cout, "Accept failed! num?\n"); } endif;
}

#endif

proc flx_read(s: flx_socket, len: &int, buf: address, eof: &bool)
{
#if POSIX
  async_read(s, len, buf, eof);
#elif WIN32
  WSARecv(s, len, buf, eof); 
#endif
}

proc flx_write(s: flx_socket, len: &int, buf: address, eof: &bool)
{   
#if POSIX
  async_write(s, len, buf, eof);
#elif WIN32
  WSASend(s, len, buf, eof);
#endif
}

instance IBuffer[flx_socket] {
  gen read(s:flx_socket, buf:address, inlen: int) = {
    var outlen = inlen;
    var eof = false;
    flx_read (s, addr outlen, buf, addr eof);
    return outlen,eof;
  }
}

instance OBuffer[flx_socket] {
  gen read(s:flx_socket, buf:address, inlen: int) = {
    var outlen = inlen;
    var eof = false;
    flx_write (s, addr outlen, buf, addr eof);
    return outlen,eof;
  }
}

// this should work without the conditional compilation
proc flx_shutdown(s: flx_socket, how: int)
{
#if POSIX
  shutdown(s, how);
#elif WIN32
  shutdown(s, how);
#endif
}

proc flx_close(s: flx_socket)
{
#if POSIX
  close(s);    // error check?
#elif WIN32
  closesocket(s);
#endif    
}

//#if WIN32 or CYGWIN
#if WIN32
proc flx_connect_win32(strm: &flx_socket, addr: charp, port: int)
{   
    var s: SOCKET;
    Connect( &s, addr, port );
    // nice error handling
    *strm = s;
}
#endif

#if POSIX
proc flx_connect_posix(strm: &flx_socket, addr: charp, port: int)
{   
    var s: int;
    connect( &s, addr, port );
    // nice error handling
    *strm = s;
}
#endif

// unified name, ipv4, cygwin gets posix (?)
proc flx_connect(s: &flx_socket, addr: charp, port: int)
{
#if WIN32
    flx_connect_win32(s, addr, port);
#else
    flx_connect_posix(s, addr, port);
#endif
}

/// TEMPORARILY PUTTING THIS CRUFTY READ/PUT LINE CODE HERE

// write_line's actually harder than this...
// I used to have trouble with the string's memory, just floating away...

// currently ignoring how string was terminated
// but you'd like to get a bool result for when you've
// hit eof. also isn't portable wrt linefeeds. crashes when
// run from cygwin. that's a bummer.
proc get_line(strm: flx_socket, s: &string)
{
  var c: char;
  val ac = C_hack::address_of(c);
  var str: string;
  var finished = false;

   while{not finished}
   {
     var len = 1;
     var eof: bool;

     flx_read(strm, &len, ac, &eof);

     // that's not working
     if eof or c == char '\n' then
     {
       // print "OUTTAHEWR\n";
       finished = true;
     }
     else
     {
       // print "got something: "; print c; endl;
       str += c;
       // print "str is now: "; print str; endl;
     } endif;

  };

  *s = str;  // pass back result
  
}

fun str_addr: string -> address = "(void*)$1.c_str()";

proc write_string(strm: flx_socket, s: string)
{
// I have to write a copy, else I get bad/stale memory for the string.
// is this something to do with inlining?
var bugger = s;
// print "writing "; print bugger; endl;
  var slen = len (bugger);
  var addr = str_addr(bugger);  // hope this string memory doesn't move on me
  var eof: bool;
  // print "write_line len: "; print slen; endl;
  flx_write(strm, &slen, addr, &eof);
}
} // module Flx_socket

@head(1,"Felix Async IO tests")

@env_faio.head(2, 'faio tests')
@env_faio.head(3)
@select(env_faio.test('.flx'))
@kat_faio("sockets")
// portable flx sockets test (rt = regression test)

#import <flx.flxh>
include "flx_socket";
open Flx_socket;

print "flx tcp stream test\n";
// System::exit 0;  // Work in progress

var listener: flx_listener;
var port = 0;  // you choose
// var port = 1024;

// check errors. how is that done?
mk_flx_listener(&listener, &port, 1);
// print "Got port: "; print port; endl;
// print "accepting\n";

print "spawning connector\n";
// not printing in thread to make output deterministic.
// note that the connect shouldn't fail (immediately) because the
// listener exists - it just hasn't called accept yet.
spawn_fthread
{
  {
    // print "Connector dude\n";  // get rid of, hard to test
    var c: flx_socket;
    flx_connect(&c, c"127.0.0.1", port); // connect to localhost
    var str: string;

    get_line(c, &str);
    print "connector got "; print str; endl;
    write_string(c, "thanks\n");         // newline important

    flx_close(c);  // finished with this
  };
};

var s: flx_socket;
flx_accept(listener, &s);
flx_close(listener);  // not needed anymore

print "got connection\n";
write_string(s, "server says hi\n");     // newline important here

var str: string;
get_line(s, &str);

print "server got "; print str; endl;
flx_close(s);
@doc()

@select(env_faio.expect())
flx tcp stream test
spawning connector
got connection
connector got server says hi
server got thanks
@doc()

@env_posix.head(2, 'Posix tests')
@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

// create a listening socket, spawn a thread to connect to it.
// in case something goes wrong could make test time out with
// spawn_fthread { { sleep 5.0; System::exit 1; }; };
print "felix posix accept/connect test\n";

var port = 0;   // let mk_listener choose the port
print "creating listener\n";
var listener: int <- mk_listener(port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{ { var c: int; connect(&c, c"127.0.0.1", port); }; };

var s: int;
accept (&s, listener);  // async!
if s == -1 then {
  System::exit 1;
} else {
  print "accepted connection\n";
  System::exit 0;
} endif;
@doc()

@select(env_posix.expect())
felix posix accept/connect test
creating listener
spawning connector
accepted connection
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

header "typedef struct { char dat[8]; } tstbuf;";
ctypes tstbuf;
proc dprint: tstbuf = 'printf("%.8s", $1.dat);';
fun get_data: tstbuf -> address = "$1.dat";
fun get_data: charp -> address = "$1";

// try to send some data down a socket
var port = 0;   // let mk_listener choose the port
var listener: int <- mk_listener(port, 1);

// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: int;
    connect(&c, c"127.0.0.1", port);

    var len = 8;
    var eof: bool;
    async_write(c, &len, get_data((c"faio2you")), &eof);
    shutdown(c, 1);  // no further writes (wakes reader)

    var b: tstbuf;
    async_read(c, &len, b.data, &eof);
    print "connector read "; dprint b; endl;
    System::exit 0;
  };
};

var s: int;
accept (&s, listener);  // async!
var b: tstbuf;
var len = 16;           // ask for more than there is and rely on shutdown
var eof: bool;
async_read(s, &len, b.data, &eof);
print "acceptor read "; print len; print " bytes: "; dprint b; endl;
async_write(s, &len, get_data((c"thanks!!")), &eof);
@doc()

@select(env_posix.expect())
acceptor read 8 bytes: faio2you
connector read thanks!!
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#include <flx.flxh>
// actually portable, but I don't know the scheme for
// adding those tests.
include "flx_stream";
print "more output here\n";
@doc()

@select(env_posix.expect())
more output here
@doc()

@env_win.head(2, 'Windows tests')
@env_win.head(3)
@select(env_win.test('.flx'))
#import <flx.flxh>
include "flx_faio_win32";
open Faio_win32;

var port = 1234;  // can't yet get os to choose the port. should fix that.
var listener: SOCKET;
mk_listener(&listener, &port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: SOCKET;
    Connect(&c, c"127.0.0.1", port);
  };
};

var s: SOCKET;
var success: bool;
mk_socket(&s);    // for async accept on win32 you create the accept socket yourself
Accept(&success, listener, s);

if success then {
  print "successful accept!\n";
  System::exit 0;
} else {
  print "accept failed!\n";
  System::exit 1;
} endif;
@doc()

@select(env_win.expect())
spawning connector
successful accept!
@doc()

@env_win.head(3)
@select(env_win.test('.flx'))
@select(h)
#import <flx.flxh>
include "Flx_faio_win32";
open Faio_win32;

// let's add a win32 namedpipe test!
// type WFILE is a HANDLE. that should work.
// note the "r" for felix string raw mode.
var pname = r"\\.\pipe\flx_pipe";

// CreateNamedPipe binding (put in a library somewhere)
// duplex, byte stream, one instance, 
// guessing 256 bytes for input and output buffers
// 0 default timeout (not using default wait, shouldn't matter)
// default security attributes
// associating with the iocp doesn't work, the pipe must be created with
// FILE_FLAG_OVERLAPPED set in dwOpenMode. Otherwise OVERLAPPED calls block.
proc CreateNamedPipe: lvalue[WFILE]*string = 
 '$1 = CreateNamedPipe($2.c_str(), PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,\
     PIPE_TYPE_BYTE, 1, 256, 256, 0, NULL);';

// OpenFile in flx_faio_win32 should work fine here

print "Creating named pipe "; print pname; endl;
var pipe: WFILE <- CreateNamedPipe(pname);

// how to connect with this stuff? can I open it non blockingly?
if pipe == INVALID_HANDLE_VALUE then
{
  print "BUGGER: CreateNamedPipeFailed: "; print (GetLastError()); endl;
} else {
  print "whoo!\n";
} endif;

// let's try to associate with IOCP here...
// Hack: the interface requires a SOCKET, which it then casts to a HANDLE.
// don't forget to create pipe with FILE_FLAG_OVERLAPPED, else we
// error #87 -> ERROR_INVALID_PARAMETER
fun HACK_TO_SOCKET: WFILE -> SOCKET = '(SOCKET)$1';
associate_with_iocp(HACK_TO_SOCKET(pipe));

header = """

using namespace flx;
using namespace demux;
using namespace faio;

// wrap up ConnectNamedPipe. This function normally blocks, so we must
// use it in a way that allows us to deschedule the fthread.
class connect_namedpipe
  : public waio_base,  public flx::demux::iocp_wakeup {
  HANDLE pipe;       // for demux
public:
  connect_namedpipe(HANDLE p = INVALID_HANDLE_VALUE) : pipe(p) {}

  // this belongs in demux class
  virtual bool start_overlapped()
  {
    fprintf(stderr, "connect named pipe start overlapped %p\\n", pipe);

    clear_overlapped();  // everyone's doing this

    BOOL success;
    success = ConnectNamedPipe(pipe, &ol);

    // fprintf(stderr, "Connect named pipe: %i\\n", success);
    if(success)
    {
      // this shouldn't happen ever. make it an error.
      fprintf(stderr, "ConnectNamedPipe SUCCEEDED (shouldn't happen)\\n");
    } else {
      int err = GetLastError();
      fprintf(stderr, "ConnectNamedPipe returned %i\\n", err);

      // this doesn't always signify failure.
      switch(err)
      {
         case ERROR_PIPE_CONNECTED: // got a connection already
           fprintf(stderr, "ALREADY GOT CONNECTION\\n");
           // do fake wakeup here for great greatness. eats user cookie.
           iocp_op_finished(0, 0, &ol, NO_ERROR);
           return true;  // async finished
         break;

         case ERROR_IO_PENDING:  // completion packet is in the mail
           fprintf(stderr, "Connection pending... (normal)\\n");
           return false;         // not finished, packet still to come
         break;
         default:
           fprintf(stderr, "ConnectNamedPipe FAILED (%i)\\n", err);
         break;
      }
      
    }

    return false;  // let's not get woken, packet still to come (?)
  }

  // this belongs in faio class
  bool start_async_op_impl(demux::demuxer& demux)
  {
    fprintf(stderr,"named_pipe: start async_op_impl\n");
    fprintf(stderr, "start_async_op for named pipe\\n");
    return start_overlapped();
  }

  // as does this
  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
  {
    fprintf(stderr, "connect named pipe FINISHED! err: %i\\n", err);
    waio_base::iocp_op_finished(nbytes, udat, olp, err);
  }


};
""";

proc getbyte(f: WFILE, outc: &char)
{
  var c: char;
  val ac = C_hack::address_of(c);
  var len = 1;
  var eof: bool;

  ReadFile(f, &len, ac, &eof);
  *outc = c;
}

proc putbyte(f: WFILE, c: char)
{
  var copyc = c;
  val ac = C_hack::address_of(copyc);
  var len = 1;
  var eof: bool;

  WriteFile(f, &len, ac, &eof);
}

// spawn a connect fthread after having created the named pipe

// I'm not yet "accepting", but hopefully I can spawn a client here
spawn_fthread {
  // print "Gudday, client thread, trying to open PIPE\n";
  // var p: WFILE <- OpenFile(pname);
  // having trouble getting io...
  var p: WFILE <- OpenFileDuplex(pname);

  // print "Client thread returned from OpenFile\n";

  if p == INVALID_HANDLE_VALUE then
  { print "BUGGER: client couldn't open pipe: "; print (GetLastError()); endl; }
  else { print "client opened pipe\n"; } endif;

  // HUM need to associate.
  print "associating client\n";
  associate_with_iocp(HACK_TO_SOCKET(p));

  var c: char;
  getbyte(p, &c);
  print "client got "; print c; endl;
  putbyte(p, char 'b');
  CloseFile(p);
};

type np_request = 'connect_namedpipe';
fun mk_np_request: WFILE -> np_request = 'connect_namedpipe($1)';

var npr = mk_np_request(pipe);
Faio::faio_req$ &npr;

print "poot! got connection (maybe)\n";
print "server trying to put byte\n";
putbyte(pipe, char 'a');
var c: char;
getbyte(pipe, &c);
print "server got "; print c; endl;
CloseFile(pipe);
@doc()

@select(env_win.expect())
Creating named pipe \\.\pipe\flx_pipe
whoo!
client opened pipe
associating client
poot! got connection (maybe)
server trying to put byte
client got a
server got b
@doc()

@head(1, 'Demos')
@h = tangler("demos/faio/demo_webserver.flx")
@select(h)
#import <flx.flxh>
#import <flx_platform.flxh>

#if POSIX
//include "flx_faio_posix";  // aio_ropen
//open Faio_posix;
#endif


include "flx_socket";
open Flx_socket;

header = """
string
getline_to_url(const string& get)
{
    // chomp off "GET " (should check it)
    if(get.length() < 4) return "";

    unsigned int pos = get.substr(4).find(' ');

    if(pos == string::npos) return "";

    return get.substr(4, pos);
}

// split url into base and file name http://foo.com/file.html
// -> http://foo.com + file.html. failure returns nothing.
bool
split_url(const string& inurl, string& base, string& file)
{
    // munch leading http:// if present
    string url;
    if(inurl.length() >= 7 && inurl.substr(0, 7) == "http://")
      url = inurl.substr(7);
    else
      url = inurl; 

    unsigned int pos = url.find('/');

    if(string::npos == pos)  return false;       // all bad

    base = url.substr(0, pos);
    file = url.substr(pos+1);
    return true;            // all good
}

bool
split_getline(const string& get, string& base, string& file)
{
    return split_url(getline_to_url(get), base, file);
}
""";

proc parse_get_line: string*lvalue[bool]*lvalue[string]*lvalue[string]
 = '$2 = split_getline($1, $3, $4);';

fun substr: string*int -> string = "$1.substr($2)";

// TODO: fill in that length field, stream back the requested jpeg,
// get port from argv.
// took out the Content-Length: 604. line. wasn't right anyway. still
// works with firefox that goes up to EOF.
// what's ETag?
val html_header = """
HTTP/1.1 200 OK
Date: Tue, 25 Apr 2006 00:16:12 GMT
Server: felix web server
Last-Modified: Wed, 01 Feb 2006 18:51:37 GMT
ETag: "6d8029-25c-43e10339"
Accept-Ranges: bytes
Connection: close
Content-Type: text/html

""";

// deleted Content-Length: 1414
val gif_header = """
HTTP/1.1 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
ETag: "7f004d-586-41aa2013"\r
Accept-Ranges: bytes\r
Connection: close\r
Content-Type: image/gif\r

""";

proc substitute(s: string, a: char, b: char, res: &string)
{
  var s2: string;
  var slen = len s;
  var i: int;

  for_each{i=0;}{i<slen}{i++;}
  {
     if s.[i] == a then
     { s2 += b; } else
     { s2 += s.[i]; } endif;

  };

  *res = s2;
}

proc serve_file(infname: string, s: flx_socket)
{
  var fname: string;

  // if empty string, serve index.html
  // not quite right - needs to handle directories too, so
  // not only foo.com/ -> index.html, but foo.com/images/ -> images/index.html
  if "" == infname then { fname = "index.html"; }else{ fname = infname;}endif;

  // set mime type depending on extension...
  // serve a "not found page" for that case (check for recursion)
  print "serve file: "; print fname; endl;

  // this isn't right, don't want the contents parsed as text, want them
  // sent faithfully over the wire. of course doesn't work for jpegs and other
  // binary formats.

  var suffix: string;
  var dotpos = stl_rfind(fname, char ".");
  // print "dotpos = "; print dotpos; endl;
  if stl_npos != dotpos then { suffix = substr(fname, dotpos+1); }
  else {} endif;

  print "suffix is "; print suffix; endl;

#if WIN32
  var wname: string;

  // quick 'n' dirty unix -> dos style pathnames
  substitute(fname, char '/', char '\\', &wname);
  print "mapped "; print fname; print " -> "; print wname; endl;
  // send header
  // TransmitFile
  var wf: WFILE <- OpenFile(wname);

  if wf == INVALID_HANDLE_VALUE then
  {
    print "BUGGER: OpenFile failed: "; print (GetLastError()); endl;
  } else {
    print "opened "; print wname; endl;

    // mime type mapping from suffix. make better here.
    if("gif" == suffix) then { write_string(s, gif_header); }
    else { write_string(s, html_header); } endif;

    print "Transmitting file!\n";
    TransmitFile(s, wf);

    // send footer
    CloseFile(wf);
  } endif;
#elif POSIX
  // this fn sets the O_NONBLOCK flag which is completely unnecessary
  // as flx_read goes via the preading worker fifo. don't know if
  // O_NONBLOCK even works on actual files.
  var fd = aio_ropen(fname);

  if fd == -1 then 
  {
    print "BUGGER, posix open failed\n";
  } else {
    print "got fd="; print fd; endl;

    // mime type mapping from suffix. make better here.
    // factor out
    if("gif" == suffix) then { write_string(s, gif_header); }
    else { write_string(s, html_header); } endif;

    var from_strm: flx_stream = UFD fd;
    var to_strm: flx_stream = USOCK s;
    cat(from_strm, to_strm);

    flx_close(from_strm); // this'll know how to close a unix fd
  } endif;

  // var contents = Text_file::load(fname);
  // print "loaded: "; print contents; endl;
  // print "contents len="; print (len contents); endl;
  // write_string(s, html_header + contents);

#endif
}

val webby_port = 1234;

print "FLX WEB!!! listening on port "; print webby_port; endl;

// up the queue len for stress testing
var p = webby_port;
var listener: flx_listener;
mk_flx_listener(&listener, &p, 10);


forever {
  var s: flx_socket;
  flx_accept(listener, &s);  // blocking
  print "got connection (or something)\n";  // error check here

  // hmm - spawning an fthread is blocking the web server. don't know why
  print "spawning fthread to handle connection\n";
  spawn_fthread {
// should spawn fthread here to allow for more io overlap

  var line: string;
  get_line(s, &line);  // should be the GET line.

  val poo = 
  if "GET " == line.[0 to 4] then line.[4 to ] else "" endif;
  print ("poo="poo); endl;

//print ("blah " line.[0 to 4]); endl;
  print "got line: "; print line; endl;

  // now I need to parse the GET line, get a file name out of its url
  // (e.g. unqualfied -> index.html and name/flx.jpg -> flx.jpg
  var succ: bool;
  var base: string;
  var file: string;

  parse_get_line(line, succ, base, file);
  // print "succ="; print succ; endl;

  if succ then {
    print "well formed get...\n";
    print "base="; print base; endl;
    print "file="; print file; endl;

    serve_file(file, s);
  } else {
    print "BAD get line: "; print line; endl;
  } endif;

  flx_close(s);

  };

};

flx_close(listener);
@doc()

@env_faio.write_katfile()
@env_posix.write_katfile()
@env_win.write_katfile()

