@execfile('config'+os.sep+'config.py')
@execfile("flxbuild"+os.sep+"iscrutil.py")

@env_faio = setup_test('test/faio/faio-')
@env_win = setup_test('test/faio/win-')
@env_posix = setup_test('test/faio/posix-')

@def kat_faio(code):
  env_faio.kat(get_tangler(),code)

@def kat_win(code):
  env_win.kat(get_tangler(),code)

@def kat_posix(code):
  env_posix.kat(get_tangler(),code)


@head(1,"Faio")
Asynch I/O interface pack.

@h = tangler('config/faio.fpc', 'data')
@select(h)
Name: faio
Description: Asynchronous I/O support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libfaio_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libfaio_static")
 else:
   tangle("provides_dlib: -lfaio_dynamic")
   tangle("provides_slib: -lfaio_static")
Requires: demux

@h = tangler('spkgs/faio.py')
@select(h)
FAIORTL_INTERFACES = [
 'faio/faio_asyncio.hpp',
 'faio/faio_job.hpp',
 'faio/faio_timer.hpp',
 'faio/faio_posixio.hpp',
 'faio/faio_winio.hpp',
]

FAIO_CPPS = [
  "faio/faio_timer",
  "faio/faio_job",
  "faio/faio_asyncio",
]

POSIX_FAIO_CPPS = [
  "faio/faio_posixio",
]

WINDOWS_FAIO_CPPS = [
  "faio/faio_winio",
]

@tangle('EXTRA_TEST_GLOBS = glob.glob('+repr(unix2native(env_faio.root)+"*.flx")+')')

if WIN32:
  FAIO_CPPS = FAIO_CPPS + WINDOWS_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = EXTRA_TEST_GLOBS + glob.glob('+repr(unix2native(env_win.root)+"*.flx")+')')

if POSIX:
  FAIO_CPPS = FAIO_CPPS + POSIX_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = EXTRA_TEST_GLOBS + glob.glob('+repr(unix2native(env_posix.root)+"*.flx")+')')

cpp_cpps = FAIO_CPPS
rtl_interfaces = FAIORTL_INTERFACES
pkg_requires = ['demux','flx_pthread', 'flx_rtl'] # flx_rtl for rtl_config.
lib_requires = ['libdemux','libflx_pthread'] # however lib not required
unit_tests = EXTRA_TEST_GLOBS
demos = glob.glob(os.path.join('demos', 'faio', '*.flx'))
iscr_source = ["lpsrc/flx_faio.pak"]
build_macro = "FAIO"
weaver_directory = 'doc/rtl/flx_faio/'

@h=tangler('rtl/flx_faio_config.hpp')
@select(h)
#ifndef __FLX_FAIO_CONFIG_H__
#define __FLX_FAIO_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FAIO
#define FAIO_EXTERN FLX_EXPORT
#else
#define FAIO_EXTERN FLX_IMPORT
#endif
#endif

@head(1,'Async IO')
@h=tangler('faio/faio_asyncio.hpp')
@select(h)
#ifndef __FLX_FAIO_ASYNCIO_H__
#define __FLX_FAIO_ASYNCIO_H__
#include <flx_faio_config.hpp>
#include "pthread_sleep_queue.hpp"

#include "demux_demuxer.hpp"        // sel_param, demuxer base
#include "flx_rtl.hpp"

namespace flx { namespace faio {

struct FAIO_EXTERN finote_t 
{
  virtual void signal()=0;
  virtual ~finote_t(){}
};

class FAIO_EXTERN wakeup_fthread_t : public finote_t 
{
  rtl::fthread_t *f;
  pthread::sleep_queue_t *q;
public:  
  wakeup_fthread_t(pthread::sleep_queue_t *q_a, rtl::fthread_t *f_a) : f(f_a), q(q_a) {}
  void signal () { q->enqueue(f); }
};


class FAIO_EXTERN flx_driver_request_base {
    finote_t *fn;
    virtual bool start_async_op_impl(demux::demuxer& demux) = 0;
public:
    flx_driver_request_base() : fn(0) {} 
    virtual ~flx_driver_request_base() {}       // so destructors work

    // returns finished flag (async may fail or immediately finish)
    void start_async_op(demux::demuxer& demuxer, finote_t *fn_a);
    void notify_finished();
};  

}} // namespace faio, flx
#endif  // __ASYNCIO__


@h=tangler('faio/faio_asyncio.cpp')
@select(h)
#include <assert.h>
#include "faio_asyncio.hpp"

namespace flx { namespace faio {

void flx_driver_request_base:: start_async_op(demux::demuxer& demuxer, finote_t *fn_a)
{
  //fprintf(stderr,"start async op %p, set fn = %p\n",this,fn_a);
  fn = fn_a;
  bool completed =  start_async_op_impl(demuxer);
  if(completed) notify_finished();
}

void flx_driver_request_base:: notify_finished()
{ 
  //fprintf(stderr, "Notify %p\n", fn);
  assert(fn!=0);
  fn->signal(); 
  delete fn; 
  fn=0;
}

}}

@head(1,'Scheduler')
@h=tangler('faio/faio_drv.hpp')
@select(h)
#ifndef __FLX_FAIO_DRV_H__
#define __FLX_FAIO_DRV_H__
#include <flx_faio_config.hpp>

#include "pthread_sleep_queue.hpp"
#include "pthread_work_fifo.hpp"
#include "demux_timer_queue.hpp"
#include "demux_demuxer.hpp"

namespace flx { namespace faio {

// this may be needed but I've lost track of where
// we get SIGPIPE, SIG_IGN from ..

#if 0
void FAIO_EXTERN sigpipe_ignorer()
{
    void (*prev_handler)(int);  // solaris is FUN.
    prev_handler = signal(SIGPIPE, SIG_IGN);

    if(SIG_ERR == prev_handler)
    {
        fprintf(stderr, "failed to install SIGPIPE ignorer\n");
        throw -1;
    }
    else if(prev_handler != SIG_IGN && prev_handler != SIG_DFL)
    {
        fprintf(stderr,"warning: blew away prev SIGPIPE handler: %p\n",
            prev_handler);
    }
}
#endif

}}
#endif

@include_file("flx_timer.ipk")
@include_file("flx_job.ipk")
@include_file("flx_posixio.ipk")
@include_file("flx_winio.ipk")

@h=tangler('lib/flx_faio.flx')
@select(h)
#import <flx.flxh>

module Faio {
requires package "demux";
requires package "faio";

open C_hack;

proc faio_req[t](x:&t) {
  val y : &address = reinterpret[&address] x;
  svc (svc_general y);
}

proc get_thread(thread: ptr[fthread]) {
    svc (svc_get_fthread thread );
}

header stdlib_h = '#include <stdlib.h>';            // malloc, free
header = '#include "faio_asyncio.hpp"';
header faio_timer_h = '#include "faio_timer.hpp"';

type sel_param = "flx::demux::sel_param";
type sel_param_ptr = "flx::demux::sel_param*";

fun get_bytes_done : sel_param_ptr -> int = '$1->bytes_written';
proc init_pb : sel_param*address*int
= '{$1.buffer=(char*)$2;$1.buffer_size=$3;$1.bytes_written=0;}';

proc calc_eof(pb: sel_param_ptr, len: &int, eof: &bool)
{
    var bytes_done = pb.bytes_done;
    *eof = (bytes_done != *len);
    *len = bytes_done;
}

type sleep_request = 'flx::faio::sleep_request' requires faio_timer_h;
type alarm_clock = 'flx::demux::timer_queue*' requires faio_timer_h;

fun mk_alarm_clock: 1 -> alarm_clock = 'flx::demux::mk_timer_queue()';
fun mk_sleep_request: alarm_clock * double -> sleep_request = 'flx::faio::sleep_request($1,$2)';

proc sleep(clock: alarm_clock, delta: double)
{
  var sr = mk_sleep_request$ clock,delta;
  faio_req$ &sr;
}


} // module faio

@h = tangler("lib/flx_stream.flx")
@select(h)
#import <flx.flxh>

include "flx_faio";
#if POSIX
include "flx_faio_posix";
#elif WIN32
include "flx_faio_win32";
#endif

module Flx_stream {
requires package "demux";
requires package "faio";

open Faio; 

#if POSIX
open Faio_posix;
#elif WIN32
open Faio_win32;
#endif

union devnull_t = DEVNULL;

typeclass IByteStream[s] { 
  virtual proc read: s * &int * address * &bool; 
}

typeclass OByteStream[s] { 
  virtual proc write: s * &int * address * &bool; 
}

typeclass IOByteStream[s] { 
  inherit IByteStream[s];
  inherit OByteStream[s];
}

typeclass TerminalIByteStream[s] { 
  inherit IByteStream[s];
  virtual proc iclose: s; 
}

typeclass TerminalOByteStream[s] { 
  inherit OByteStream[s];
  virtual proc oclose: s; 
}

typeclass TerminalIOByteStream[s] { 
  inherit TerminalIByteStream[s];
  inherit TerminalOByteStream[s];
  virtual proc ioclose (f:s) { iclose f; oclose f; }
}

//
// devnull_t
//
instance IByteStream[devnull_t]
{
  proc read(strm: devnull_t, len: &int, buf: address, eof: &bool)
    { *len = 0; *eof = true; }
}

instance OByteStream[devnull_t]
{
  proc write(strm: devnull_t, len: &int, buf: address, eof: &bool)
    { *eof = false; }
}

instance IOByteStream[devnull_t] {}
instance TerminalIByteStream[devnull_t] { proc iclose (x:devnull_t) { } } 
instance TerminalOByteStream[devnull_t] { proc oclose (x:devnull_t) { } }
instance TerminalIOByteStream[devnull_t] { proc ioclose (x:devnull_t) { } }


//
// fd_t -- native file handle (disk file)
//
instance IByteStream[fd_t]
{
  proc read(s: fd_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { faio_read(s, len, buf, eof); }
  #elif WIN32
    { ReadFile(s, len, buf, eof); }
  #endif
}

instance OByteStream[fd_t]
{
  proc write(s: fd_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { faio_write(s, len, buf, eof); }
  #elif WIN32
    { WriteFile(s, len, buf, eof); }
  #endif
}

instance IOByteStream[fd_t] {}

instance TerminalIByteStream[fd_t]
{
  proc iclose (f:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

instance TerminalOByteStream[fd_t]
{
  proc oclose (f:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

instance TerminalIOByteStream[fd_t]
{
  proc ioclose (f:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(infd: istr , outfd: ostr, buf: address, bufsize: int) 
{
    var eof = false;
    var weof = false;
    var len: int;

    // if we finish input, stop. if output eofs, don't keep hammering on it!
    while{not(eof) and not(weof)} {
        len = bufsize;
     // print "catting in "; print len; print " bytes\n";
        read(infd, &len, buf, &eof);
     // print "catting out "; print len; print " bytes\n";
        write(outfd, &len, buf, &weof);
    };
};

proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(infd: istr, outfd: ostr)
{
    val BUFSIZE = 10*1024;
    var buf = C_hack::malloc(BUFSIZE);

    // that's some nice error checking
    cat(infd, outfd, buf, BUFSIZE);
    C_hack::free(buf);
}

open List;

proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(in_fds: list[istr], outfd: ostr,
    buf: address, bufsize: int)
{
    match in_fds with
    | Empty[istr] => {}                     // finished
    | Cons[istr] (?fd, ?l) =>
        {
            cat(fd, outfd, buf, bufsize);   // cat first
            cat(l, outfd, buf, bufsize);    // cat the rest
        }
    endmatch
    ;
}

proc echo[iostr with IOByteStream[iostr]]
(fd: iostr, buf: address, bufsize: int)
{
    // echo a = cat a a. that's deep, man.
    cat(fd, fd, buf, bufsize);
};

proc tee[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(infd: istr, outfd: ostr, outfd2: ostr)
{
    var eof = false;
    var weof = false;
    var weof2 = false;
    var len: int;

    val BUFSIZE = 10*1024;
    var buf = C_hack::malloc(BUFSIZE);

    // don't hammer!
    while{not(eof) and not(weof) and not(weof2)} {
        len = BUFSIZE;
        read(infd, &len, buf, &eof);
        write(outfd, &len, buf, &weof);
        write(outfd2, &len, buf, &weof2);
    };
    C_hack::free buf;
}

// highly inefficient!
proc get_line[istr with IByteStream[istr]] 
(strm: istr, s: &string)
{
  var c: char;
  val ac = C_hack::cast[address]$ C_hack::addr c;
  var str: string;
  var finished = false;

  whilst not finished do
    var len = 1;
    var eof: bool;

    read(strm, &len, ac, &eof);

    if eof or c == char '\n' do
      finished = true;
    else
      str += c;
    done;
  done;
  *s = str;  // pass back result
}

proc write_string[ostr with OByteStream[ostr]]
(sk: ostr, var s: string)
{
  var slen = len s;
  var a = C_hack::cast[address]$ cstr s; 
  var eof: bool;
  write(sk, &slen, a, &eof);
}


} // module Flx_stream

@h = tangler("lib/flx_socket.flx")
@select(h)
#import <flx.flxh>
include "flx_faio";

#if POSIX
include "flx_faio_posix";
#elif WIN32
include "flx_faio_win32";
#endif

module Flx_socket {

#if POSIX
typedef socket_t = Faio_posix::socket_t;
#elif WIN32
typedef socket_t = Faio_win32::socket_t;
#endif


proc mk_listener(l: &socket_t, port: &int, qlen: int)
{
#if POSIX
  Faio_posix::mk_listener(l,port, qlen);
#elif WIN32
  Faio_win32::mk_listener(l, port, qlen);
#endif
}

proc accept(l: socket_t, s: &socket_t)
{
#if POSIX
  Faio_posix::accept(s, l);  // success or not? error checking
#elif WIN32
  var success: bool;
  Faio_win32::mk_socket(s);  // error check?
  Faio_win32::Accept(&success, l, *s);
  if not success do
    fprint (cout, "Accept failed! num?\n");
  done;
#endif
}

proc shutdown(s: socket_t, how: int)
{
#if POSIX
  Faio_posix::shutdown(s, how);
#elif WIN32
  Faio_win32::shutdown(s, how);
#endif
}

proc connect(s: &socket_t, addr: charp, port: int)
{   
#if POSIX 
    Faio_posix::connect(s, addr, port );
#elif WIN32
    Faio_win32::Connect( s, addr, port );
#endif
}


//
// socket_t
//
instance IByteStream[socket_t]
{
  proc read(s: socket_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { Faio_posix::async_read(s, len, buf, eof); }
  #elif WIN32
    { Faio_win32::WSARecv(s, len, buf, eof); }
  #endif
}

instance OByteStream[socket_t]
{
  proc write(s: socket_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { Faio_posix::async_write(s, len, buf, eof); }
  #elif WIN32
    { Faio_win32::WSASend(s, len, buf, eof); }
  #endif
}

instance IOByteStream[socket_t] {}

instance TerminalIByteStream[socket_t]
{
  proc iclose (s:socket_t)
  #if POSIX
    { Faio_posix::close s; }
  #else
    { Faio_win32::closesocket s; }
  #endif
}

instance TerminalOByteStream[socket_t]
{
  proc oclose (s:socket_t) 
  #if POSIX
    { Faio_posix::close s; }
  #elif WIN32
    { Faio_win32::closesocket s; }
  #endif
}


instance TerminalIOByteStream[socket_t]
{
  proc ioclose (s:socket_t) 
  #if POSIX
    { Faio_posix::close s; }
  #elif WIN32
    { Faio_win32::closesocket s; }
  #endif
}

}

@head(1,"Felix Async IO tests")

@env_faio.head(2, 'faio tests')
@env_faio.head(3)
@select(env_faio.test('.flx'))
@kat_faio("sockets")
#import <flx.flxh>
include "flx_stream";
include "flx_socket";
open Flx_stream;
open Flx_socket;
open Flx_stream::TerminalIOByteStream[Flx_socket::socket_t];

print "flx tcp stream test\n";

var listener: socket_t;
var port = 0;  // you choose
// var port = 1024;

// check errors. how is that done?
mk_listener(&listener, &port, 1);
// print "Got port: "; print port; endl;
// print "accepting\n";

print "spawning connector\n";
// not printing in thread to make output deterministic.
// note that the connect shouldn't fail (immediately) because the
// listener exists - it just hasn't called accept yet.
spawn_fthread
{
  {
    // print "Connector dude\n";  // get rid of, hard to test
    var c: socket_t;
    connect(&c, c"127.0.0.1", port); // connect to localhost
    var str: string;

    get_line(c, &str);
    print "connector got "; print str; endl;
    write_string(c, "thanks\n");         // newline important

    ioclose(c);  // finished with this
  };
};

var s: socket_t;
accept(listener, &s);
ioclose(listener);  // not needed anymore

print "got connection\n";
write_string(s, "server says hi\n");     // newline important here

var str: string;
get_line(s, &str);

print "server got "; print str; endl;
ioclose(s);
@doc()

@select(env_faio.expect())
flx tcp stream test
spawning connector
got connection
connector got server says hi
server got thanks
@doc()

@env_posix.head(2, 'Posix tests')
@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

// create a listening socket, spawn a thread to connect to it.
// in case something goes wrong could make test time out with
// spawn_fthread { { sleep 5.0; System::exit 1; }; };
print "felix posix accept/connect test\n";

var port = 0;   // let mk_listener choose the port
print "creating listener\n";
var &listener: socket_t <- mk_listener(&port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{ { var c: socket_t; connect(&c, c"127.0.0.1", port); }; };

var s: socket_t;
accept (&s, listener);  // async!
if bad_socket s then {
  System::exit 1;
} else {
  print "accepted connection\n";
  System::exit 0;
} endif;
@doc()

@select(env_posix.expect())
felix posix accept/connect test
creating listener
spawning connector
accepted connection
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

header "typedef struct { char dat[8]; } tstbuf;";
ctypes tstbuf;
proc dprint: tstbuf = 'printf("%.8s", $1.dat);';
fun get_data: tstbuf -> address = "$1.dat";
fun get_data: charp -> address = "$1";

// try to send some data down a socket
var port = 0;   // let mk_listener choose the port
var &listener: socket_t <- mk_listener(&port, 1);

// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: socket_t;
    connect(&c, c"127.0.0.1", port);

    var len = 8;
    var eof: bool;
    async_write(c, &len, get_data((c"faio2you")), &eof);
    shutdown(c, 1);  // no further writes (wakes reader)

    var b: tstbuf;
    async_read(c, &len, b.data, &eof);
    print "connector read "; dprint b; endl;
    System::exit 0;
  };
};

var s: socket_t;
accept (&s, listener);  // async!
var b: tstbuf;
var len = 16;           // ask for more than there is and rely on shutdown
var eof: bool;
async_read(s, &len, b.data, &eof);
print "acceptor read "; print len; print " bytes: "; dprint b; endl;
async_write(s, &len, get_data((c"thanks!!")), &eof);
@doc()

@select(env_posix.expect())
acceptor read 8 bytes: faio2you
connector read thanks!!
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#include <flx.flxh>
// actually portable, but I don't know the scheme for
// adding those tests.
include "flx_stream";
print "more output here\n";
@doc()

@select(env_posix.expect())
more output here
@doc()

@env_win.head(2, 'Windows tests')
@env_win.head(3)
@select(env_win.test('.flx'))
#import <flx.flxh>
include "flx_faio_win32";
open Faio_win32;

var port = 1234;  // can't yet get os to choose the port. should fix that.
var listener: SOCKET;
mk_listener(&listener, &port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: SOCKET;
    Connect(&c, c"127.0.0.1", port);
  };
};

var s: SOCKET;
var success: bool;
mk_socket(&s);    // for async accept on win32 you create the accept socket yourself
Accept(&success, listener, s);

if success then {
  print "successful accept!\n";
  System::exit 0;
} else {
  print "accept failed!\n";
  System::exit 1;
} endif;
@doc()

@select(env_win.expect())
spawning connector
successful accept!
@doc()

@env_win.head(3)
@select(env_win.test('.flx'))
#import <flx.flxh>
include "Flx_faio_win32";
open Faio_win32;

// let's add a win32 namedpipe test!
// type WFILE is a HANDLE. that should work.
// note the "r" for felix string raw mode.
var pname = r"\\.\pipe\flx_pipe";

// CreateNamedPipe binding (put in a library somewhere)
// duplex, byte stream, one instance, 
// guessing 256 bytes for input and output buffers
// 0 default timeout (not using default wait, shouldn't matter)
// default security attributes
// associating with the iocp doesn't work, the pipe must be created with
// FILE_FLAG_OVERLAPPED set in dwOpenMode. Otherwise OVERLAPPED calls block.
proc CreateNamedPipe: lvalue[WFILE]*string = 
 '$1 = CreateNamedPipe($2.c_str(), PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,\
     PIPE_TYPE_BYTE, 1, 256, 256, 0, NULL);';

// OpenFile in flx_faio_win32 should work fine here

print "Creating named pipe "; print pname; endl;
var pipe: WFILE <- CreateNamedPipe(pname);

// how to connect with this stuff? can I open it non blockingly?
if pipe == INVALID_HANDLE_VALUE then
{
  print "BUGGER: CreateNamedPipeFailed: "; print (GetLastError()); endl;
} else {
  print "whoo!\n";
} endif;

// let's try to associate with IOCP here...
// Hack: the interface requires a SOCKET, which it then casts to a HANDLE.
// don't forget to create pipe with FILE_FLAG_OVERLAPPED, else we
// error #87 -> ERROR_INVALID_PARAMETER
fun HACK_TO_SOCKET: WFILE -> SOCKET = '(SOCKET)$1';
associate_with_iocp(HACK_TO_SOCKET(pipe));

header = """

using namespace flx;
using namespace demux;
using namespace faio;

// wrap up ConnectNamedPipe. This function normally blocks, so we must
// use it in a way that allows us to deschedule the fthread.
class connect_namedpipe
  : public waio_base,  public flx::demux::iocp_wakeup {
  HANDLE pipe;       // for demux
public:
  connect_namedpipe(HANDLE p = INVALID_HANDLE_VALUE) : pipe(p) {}

  // this belongs in demux class
  virtual bool start_overlapped()
  {
    fprintf(stderr, "connect named pipe start overlapped %p\\n", pipe);

    clear_overlapped();  // everyone's doing this

    BOOL success;
    success = ConnectNamedPipe(pipe, &ol);

    // fprintf(stderr, "Connect named pipe: %i\\n", success);
    if(success)
    {
      // this shouldn't happen ever. make it an error.
      fprintf(stderr, "ConnectNamedPipe SUCCEEDED (shouldn't happen)\\n");
    } else {
      int err = GetLastError();
      fprintf(stderr, "ConnectNamedPipe returned %i\\n", err);

      // this doesn't always signify failure.
      switch(err)
      {
         case ERROR_PIPE_CONNECTED: // got a connection already
           fprintf(stderr, "ALREADY GOT CONNECTION\\n");
           // do fake wakeup here for great greatness. eats user cookie.
           iocp_op_finished(0, 0, &ol, NO_ERROR);
           return true;  // async finished
         break;

         case ERROR_IO_PENDING:  // completion packet is in the mail
           fprintf(stderr, "Connection pending... (normal)\\n");
           return false;         // not finished, packet still to come
         break;
         default:
           fprintf(stderr, "ConnectNamedPipe FAILED (%i)\\n", err);
         break;
      }
      
    }

    return false;  // let's not get woken, packet still to come (??)
  }

  // this belongs in faio class
  bool start_async_op_impl(demux::demuxer& demux)
  {
    fprintf(stderr,"named_pipe: start async_op_impl\\n");
    fprintf(stderr, "start_async_op for named pipe\\n");
    return start_overlapped();
  }

  // as does this
  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
  {
    fprintf(stderr, "connect named pipe FINISHED! err: %i\\n", err);
    waio_base::iocp_op_finished(nbytes, udat, olp, err);
  }


};
""";

proc getbyte(f: WFILE, outc: &char)
{
  var c: char;
  val ac = C_hack::address_of(c);
  var len = 1;
  var eof: bool;

  ReadFile(f, &len, ac, &eof);
  *outc = c;
}

proc putbyte(f: WFILE, c: char)
{
  var copyc = c;
  val ac = C_hack::address_of(copyc);
  var len = 1;
  var eof: bool;

  WriteFile(f, &len, ac, &eof);
}

// spawn a connect fthread after having created the named pipe

// I'm not yet "accepting", but hopefully I can spawn a client here
spawn_fthread {
  // print "Gudday, client thread, trying to open PIPE\n";
  // var p: WFILE <- OpenFile(pname);
  // having trouble getting io...
  var p: WFILE <- OpenFileDuplex(pname);

  // print "Client thread returned from OpenFile\n";

  if p == INVALID_HANDLE_VALUE then
  { print "BUGGER: client couldn't open pipe: "; print (GetLastError()); endl; }
  else { print "client opened pipe\n"; } endif;

  // HUM need to associate.
  print "associating client\n";
  associate_with_iocp(HACK_TO_SOCKET(p));

  var c: char;
  getbyte(p, &c);
  print "client got "; print c; endl;
  putbyte(p, char 'b');
  CloseFile(p);
};

type np_request = 'connect_namedpipe';
fun mk_np_request: WFILE -> np_request = 'connect_namedpipe($1)';

var npr = mk_np_request(pipe);
Faio::faio_req$ &npr;

print "poot! got connection (maybe)\n";
print "server trying to put byte\n";
putbyte(pipe, char 'a');
var c: char;
getbyte(pipe, &c);
print "server got "; print c; endl;
CloseFile(pipe);
@doc()

@select(env_win.expect())
Creating named pipe \\.\pipe\flx_pipe
whoo!
client opened pipe
associating client
poot! got connection (maybe)
server trying to put byte
client got a
server got b
@doc()

@head(1, 'Demos')
@h = tangler("demos/faio/demo_webserver.flx")
@select(h)
#import <flx.flxh>
#import <flx_platform.flxh>

#if POSIX
//include "flx_faio_posix";  // aio_ropen
//open Faio_posix;
#endif


include "flx_socket";
open Flx_socket;

header = """
string
getline_to_url(const string& get)
{
    // chomp off "GET " (should check it)
    if(get.length() < 4) return "";

    unsigned int pos = get.substr(4).find(' ');

    if(pos == string::npos) return "";

    return get.substr(4, pos);
}

// split url into base and file name http://foo.com/file.html
// -> http://foo.com + file.html. failure returns nothing.
bool
split_url(const string& inurl, string& base, string& file)
{
    // munch leading http:// if present
    string url;
    if(inurl.length() >= 7 && inurl.substr(0, 7) == "http://")
      url = inurl.substr(7);
    else
      url = inurl; 

    unsigned int pos = url.find('/');

    if(string::npos == pos)  return false;       // all bad

    base = url.substr(0, pos);
    file = url.substr(pos+1);
    return true;            // all good
}

bool
split_getline(const string& get, string& base, string& file)
{
    return split_url(getline_to_url(get), base, file);
}
""";

proc parse_get_line: string*lvalue[bool]*lvalue[string]*lvalue[string]
 = '$2 = split_getline($1, $3, $4);';

fun substr: string*int -> string = "$1.substr($2)";

// TODO: fill in that length field, stream back the requested jpeg,
// get port from argv.
// took out the Content-Length: 604. line. wasn't right anyway. still
// works with firefox that goes up to EOF.
// what's ETag?
val html_header = """
HTTP/1.1 200 OK
Date: Tue, 25 Apr 2006 00:16:12 GMT
Server: felix web server
Last-Modified: Wed, 01 Feb 2006 18:51:37 GMT
ETag: "6d8029-25c-43e10339"
Accept-Ranges: bytes
Connection: close
Content-Type: text/html

""";

// deleted Content-Length: 1414
val gif_header = """
HTTP/1.1 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
ETag: "7f004d-586-41aa2013"\r
Accept-Ranges: bytes\r
Connection: close\r
Content-Type: image/gif\r

""";

proc substitute(s: string, a: char, b: char, res: &string)
{
  var s2: string;
  var slen = len s;
  var i: int;

  for_each{i=0;}{i<slen}{i++;}
  {
     if s.[i] == a then
     { s2 += b; } else
     { s2 += s.[i]; } endif;

  };

  *res = s2;
}

proc serve_file(infname: string, s: flx_socket)
{
  var fname: string;

  // if empty string, serve index.html
  // not quite right - needs to handle directories too, so
  // not only foo.com/ -> index.html, but foo.com/images/ -> images/index.html
  if "" == infname then { fname = "index.html"; }else{ fname = infname;}endif;

  // set mime type depending on extension...
  // serve a "not found page" for that case (check for recursion)
  print "serve file: "; print fname; endl;

  // this isn't right, don't want the contents parsed as text, want them
  // sent faithfully over the wire. of course doesn't work for jpegs and other
  // binary formats.

  var suffix: string;
  var dotpos = stl_rfind(fname, char ".");
  // print "dotpos = "; print dotpos; endl;
  if stl_npos != dotpos then { suffix = substr(fname, dotpos+1); }
  else {} endif;

  print "suffix is "; print suffix; endl;

#if WIN32
  var wname: string;

  // quick 'n' dirty unix -> dos style pathnames
  substitute(fname, char '/', char '\\', &wname);
  print "mapped "; print fname; print " -> "; print wname; endl;
  // send header
  // TransmitFile
  var wf: WFILE <- OpenFile(wname);

  if wf == INVALID_HANDLE_VALUE then
  {
    print "BUGGER: OpenFile failed: "; print (GetLastError()); endl;
  } else {
    print "opened "; print wname; endl;

    // mime type mapping from suffix. make better here.
    if("gif" == suffix) then { write_string(s, gif_header); }
    else { write_string(s, html_header); } endif;

    print "Transmitting file!\n";
    TransmitFile(s, wf);

    // send footer
    CloseFile(wf);
  } endif;
#elif POSIX
  // this fn sets the O_NONBLOCK flag which is completely unnecessary
  // as read goes via the preading worker fifo. don't know if
  // O_NONBLOCK even works on actual files.
  var fd = aio_ropen(fname);

  if fd == -1 then 
  {
    print "BUGGER, posix open failed\n";
  } else {
    print "got fd="; print fd; endl;

    // mime type mapping from suffix. make better here.
    // factor out
    if("gif" == suffix) then { write_string(s, gif_header); }
    else { write_string(s, html_header); } endif;

    var from_strm: flx_stream = UFD fd;
    var to_strm: flx_stream = USOCK s;
    cat(from_strm, to_strm);

    flx_close(from_strm); // this'll know how to close a unix fd
  } endif;

  // var contents = Text_file::load(fname);
  // print "loaded: "; print contents; endl;
  // print "contents len="; print (len contents); endl;
  // write_string(s, html_header + contents);

#endif
}

val webby_port = 1234;

print "FLX WEB!!! listening on port "; print webby_port; endl;

// up the queue len for stress testing
var p = webby_port;
var listener: flx_listener;
mk_flx_listener(&listener, &p, 10);


forever {
  var s: flx_socket;
  flx_accept(listener, &s);  // blocking
  print "got connection (or something)\n";  // error check here

  // hmm - spawning an fthread is blocking the web server. don't know why
  print "spawning fthread to handle connection\n";
  spawn_fthread {
// should spawn fthread here to allow for more io overlap

  var line: string;
  get_line(s, &line);  // should be the GET line.

  val poo = 
  if "GET " == line.[0 to 4] then line.[4 to ] else "" endif;
  print ("poo="poo); endl;

//print ("blah " line.[0 to 4]); endl;
  print "got line: "; print line; endl;

  // now I need to parse the GET line, get a file name out of its url
  // (e.g. unqualfied -> index.html and name/flx.jpg -> flx.jpg
  var succ: bool;
  var base: string;
  var file: string;

  parse_get_line(line, succ, base, file);
  // print "succ="; print succ; endl;

  if succ then {
    print "well formed get...\n";
    print "base="; print base; endl;
    print "file="; print file; endl;

    serve_file(file, s);
  } else {
    print "BAD get line: "; print line; endl;
  } endif;

  flx_close(s);

  };

};

flx_close(listener);
@doc()

@env_faio.write_katfile()
@env_posix.write_katfile()
@env_win.write_katfile()

