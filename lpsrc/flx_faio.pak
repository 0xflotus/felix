@execfile('config'+os.sep+'config.py')
@execfile("flxbuild"+os.sep+"iscrutil.py")

@env_faio = setup_test('test/faio/faio-')
@env_win = setup_test('test/faio/win-')
@env_posix = setup_test('test/faio/posix-')

@def kat_faio(code):
  env_faio.kat(get_tangler(),code)

@def kat_win(code):
  env_win.kat(get_tangler(),code)

@def kat_posix(code):
  env_posix.kat(get_tangler(),code)


@head(1,"Faio")
Asynch I/O interface pack.

@h = tangler('config/faio.fpc', 'data')
@select(h)
Name: faio
Description: Asynchronous I/O support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libfaio_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libfaio_static")
 else:
   tangle("provides_dlib: -lfaio_dynamic")
   tangle("provides_slib: -lfaio_static")
Requires: demux

@h = tangler('spkgs/faio.py')
@select(h)
FAIORTL_INTERFACES = [
 'faio/faio_asyncio.hpp',
 'faio/faio_job.hpp',
 'faio/faio_timer.hpp',
 'faio/faio_posixio.hpp',
 'faio/faio_winio.hpp',
]

FAIO_CPPS = [
  "faio/faio_timer",
  "faio/faio_job",
  "faio/faio_asyncio",
]

POSIX_FAIO_CPPS = [
  "faio/faio_posixio",
]

WINDOWS_FAIO_CPPS = [
  "faio/faio_winio",
]

@tangle('EXTRA_TEST_GLOBS = glob.glob('+repr(unix2native(env_faio.root)+"*.flx")+')')

if WIN32:
  FAIO_CPPS = FAIO_CPPS + WINDOWS_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = EXTRA_TEST_GLOBS + glob.glob('+repr(unix2native(env_win.root)+"*.flx")+')')

if POSIX:
  FAIO_CPPS = FAIO_CPPS + POSIX_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = EXTRA_TEST_GLOBS + glob.glob('+repr(unix2native(env_posix.root)+"*.flx")+')')

cpp_cpps = FAIO_CPPS
rtl_interfaces = FAIORTL_INTERFACES
pkg_requires = ['demux','flx_pthread', 'flx_rtl'] # flx_rtl for rtl_config.
lib_requires = ['libdemux','libflx_pthread'] # however lib not required
unit_tests = EXTRA_TEST_GLOBS
demos = glob.glob(os.path.join('demos', 'faio', '*.flx'))
iscr_source = ["lpsrc/flx_faio.pak"]
build_macro = "FAIO"
weaver_directory = 'doc/rtl/flx_faio/'

@h=tangler('rtl/flx_faio_config.hpp')
@select(h)
#ifndef __FLX_FAIO_CONFIG_H__
#define __FLX_FAIO_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FAIO
#define FAIO_EXTERN FLX_EXPORT
#else
#define FAIO_EXTERN FLX_IMPORT
#endif
#endif

@head(1,'Async IO')
@h=tangler('faio/faio_asyncio.hpp')
@select(h)
#ifndef __FLX_FAIO_ASYNCIO_H__
#define __FLX_FAIO_ASYNCIO_H__
#include <flx_faio_config.hpp>
#include "pthread_sleep_queue.hpp"

#include "demux_demuxer.hpp"        // sel_param, demuxer base
#include "flx_rtl.hpp"

namespace flx { namespace faio {

struct FAIO_EXTERN finote_t 
{
  virtual void signal()=0;
  virtual ~finote_t(){}
};

class FAIO_EXTERN wakeup_fthread_t : public finote_t 
{
  rtl::fthread_t *f;
  pthread::sleep_queue_t *q;
public:  
  wakeup_fthread_t(pthread::sleep_queue_t *q_a, rtl::fthread_t *f_a) : f(f_a), q(q_a) {}
  void signal () { q->enqueue(f); }
};


class FAIO_EXTERN flx_driver_request_base {
    finote_t *fn;
    virtual bool start_async_op_impl() = 0;
public:
    flx_driver_request_base() : fn(0) {} 
    virtual ~flx_driver_request_base() {}       // so destructors work

    // returns finished flag (async may fail or immediately finish)
    void start_async_op(finote_t *fn_a);
    void notify_finished();
};  

}} // namespace faio, flx
#endif  // __ASYNCIO__


@h=tangler('faio/faio_asyncio.cpp')
@select(h)
#include <assert.h>
#include "faio_asyncio.hpp"

namespace flx { namespace faio {

void flx_driver_request_base:: start_async_op(finote_t *fn_a)
{
  //fprintf(stderr,"start async op %p, set fn = %p\n",this,fn_a);
  fn = fn_a;
  bool completed =  start_async_op_impl();
  if(completed) 
  {
    //fprintf(stderr,"instant complete\n");
    notify_finished();
  }
  else
  {
    //fprintf(stderr,"Pending\n");
  }
}

void flx_driver_request_base:: notify_finished()
{ 
  //fprintf(stderr, "faio_req=%p, Notify %p\n", this,fn);
  assert(fn!=0);
  finote_t *fin = fn;
  fn=0;
  fin->signal(); 
  delete fin; 
  //fprintf(stderr, "faio_req=%p, FINISHED\n",this);
}

}}

@head(1,'Scheduler')
@h=tangler('faio/faio_drv.hpp')
@select(h)
#ifndef __FLX_FAIO_DRV_H__
#define __FLX_FAIO_DRV_H__
#include <flx_faio_config.hpp>

#include "pthread_sleep_queue.hpp"
#include "pthread_work_fifo.hpp"
#include "demux_timer_queue.hpp"
#include "demux_demuxer.hpp"

namespace flx { namespace faio {

// this may be needed but I've lost track of where
// we get SIGPIPE, SIG_IGN from ..

#if 0
void FAIO_EXTERN sigpipe_ignorer()
{
    void (*prev_handler)(int);  // solaris is FUN.
    prev_handler = signal(SIGPIPE, SIG_IGN);

    if(SIG_ERR == prev_handler)
    {
        fprintf(stderr, "failed to install SIGPIPE ignorer\n");
        throw -1;
    }
    else if(prev_handler != SIG_IGN && prev_handler != SIG_DFL)
    {
        fprintf(stderr,"warning: blew away prev SIGPIPE handler: %p\n",
            prev_handler);
    }
}
#endif

}}
#endif

@include_file("flx_timer.ipk")
@include_file("flx_job.ipk")
@include_file("flx_posixio.ipk")
@include_file("flx_winio.ipk")

@h=tangler('lib/flx_faio.flx')
@select(h)
#import <flx.flxh>

module Faio {
requires package "demux";
requires package "faio";

open C_hack;

proc faio_req[t](x:&t) {
  val y : &address = reinterpret[&address] x;
  svc (svc_general y);
}

proc get_thread(thread: ptr[fthread]) {
    svc (svc_get_fthread thread );
}

header stdlib_h = '#include <stdlib.h>';            // malloc, free
header = '#include "faio_asyncio.hpp"';
header faio_timer_h = '#include "faio_timer.hpp"';

type sel_param = "flx::demux::sel_param";
type sel_param_ptr = "flx::demux::sel_param*";

fun get_bytes_done : sel_param_ptr -> int = '$1->bytes_written';
proc init_pb : sel_param*address*int
= '{$1.buffer=(char*)$2;$1.buffer_size=$3;$1.bytes_written=0;}';

proc calc_eof(pb: sel_param_ptr, len: &int, eof: &bool)
{
    var bytes_done = pb.bytes_done;
    *eof = (bytes_done != *len);
    *len = bytes_done;
}

type sleep_request = 'flx::faio::sleep_request' requires faio_timer_h;
type alarm_clock = 'flx::demux::timer_queue*' requires faio_timer_h;

fun mk_alarm_clock: 1 -> alarm_clock = 'flx::demux::mk_timer_queue()';
fun mk_sleep_request: alarm_clock * double -> sleep_request = 'flx::faio::sleep_request($1,$2)';

proc sleep(clock: alarm_clock, delta: double)
{
  var sr = mk_sleep_request$ clock,delta;
  faio_req$ &sr;
}


} // module faio

@h = tangler("lib/flx_stream.flx")
@select(h)
#import <flx.flxh>

include "flx_faio";
#if POSIX
include "flx_faio_posix";
#elif WIN32
include "flx_faio_win32";
#endif

module Flx_stream {
requires package "demux";
requires package "faio";

open Faio; 

#if POSIX
open Faio_posix;
typedef fd_t = Faio_posix::fd_t;
#elif WIN32
open Faio_win32;
#endif

union devnull_t = DEVNULL;

typeclass IByteStream[s] { 
  virtual proc read: s * &int * address * &bool; 
}

typeclass OByteStream[s] { 
  virtual proc write: s * &int * address * &bool; 
}

typeclass IOByteStream[s] { 
  inherit IByteStream[s];
  inherit OByteStream[s];
}

typeclass TerminalIByteStream[s] { 
  inherit IByteStream[s];
  virtual proc iclose: s; 
}

typeclass TerminalOByteStream[s] { 
  inherit OByteStream[s];
  virtual proc oclose: s; 
}

typeclass TerminalIOByteStream[s] { 
  inherit TerminalIByteStream[s];
  inherit TerminalOByteStream[s];
  virtual proc ioclose: s;
}

//
// devnull_t
//
instance IByteStream[devnull_t]
{
  proc read(strm: devnull_t, len: &int, buf: address, eof: &bool)
    { *len = 0; *eof = true; }
}

instance OByteStream[devnull_t]
{
  proc write(strm: devnull_t, len: &int, buf: address, eof: &bool)
    { *eof = false; }
}

instance IOByteStream[devnull_t] {}
instance TerminalIByteStream[devnull_t] { proc iclose (x:devnull_t) { } } 
instance TerminalOByteStream[devnull_t] { proc oclose (x:devnull_t) { } }
instance TerminalIOByteStream[devnull_t] { proc ioclose (x:devnull_t) { } }


//
// fd_t -- native file handle (disk file)
//
instance IByteStream[fd_t]
{
  proc read(s: fd_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { faio_read(s, len, buf, eof); }
  #elif WIN32
    { ReadFile(s, len, buf, eof); }
  #endif
}

instance OByteStream[fd_t]
{
  proc write(s: fd_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { faio_write(s, len, buf, eof); }
  #elif WIN32
    { WriteFile(s, len, buf, eof); }
  #endif
}

instance IOByteStream[fd_t] {}

instance TerminalIByteStream[fd_t]
{
  proc iclose (f:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

instance TerminalOByteStream[fd_t]
{
  proc oclose (f:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

instance TerminalIOByteStream[fd_t]
{
  proc ioclose (f:fd_t)
  #if POSIX
    { close f; }
  #elif WIN32
    { CloseFile f; }
  #endif
}

proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(infd: istr , outfd: ostr, buf: address, bufsize: int) 
{
    var eof = false;
    var weof = false;
    var len: int;

    // if we finish input, stop. if output eofs, don't keep hammering on it!
    while{not(eof) and not(weof)} {
        len = bufsize;
        read(infd, &len, buf, &eof);
        fprint$ cerr,q"catted in $len bytes, eof=$eof\n";
        //fprint$ cerr, string(C_hack::cast[charp] buf,len);
        write(outfd, &len, buf, &weof);
        fprint$ cerr,q"catted out $len bytes, eof=$weof\n";
    };
}

// It's very unfortunate that memcmp doesn't return the position
// of the first non-equality

proc stream_cmp[istr1,istr2 with IByteStream[istr1], IByteStream[istr2]]
(fd1: istr1 , fd2: istr2, buf1: address, buf2: address, bufsize: int, sign: &int) 
{
  var eof1 = false;
  var eof2 = false;
  var len1: int;
  var len2: int;
  var terminated = false;
  var cmp = 0;

  while{cmp == 0 and not terminated} {
    len1 = bufsize; read(fd1, &len1, buf1, &eof1);
    len2 = bufsize; read(fd2, &len2, buf2, &eof2);
//print "Len1="; print len1; endl;
//print "Len2="; print len2; endl;

    len  := min(len1,len2);
    cmp = Carray::memcmp(buf1, buf2, size len);

    if cmp == 0 do 
      cmp = len1 - len2;
      if cmp == 0 do
        terminated = eof1 and eof2;
        cmp = 
          // ugg: false = case 0, true = case 1
          match eof1, eof2 with
          | case 1, case 1 => 0
          | case 0, case 0 => 0
          | case 0, case 1 => 1
          | case 1, case 0 => -1
          endmatch
        ;
      done;
    done;
  };
  *sign = cmp;
}


proc cmp
  [istr1, istr2 with IByteStream[istr1], IByteStream[istr2]]
  (i1: istr1, i2: istr2, res: &int)
{
  val BUFSIZE = 100000;
  var buf1 = C_hack::malloc(BUFSIZE);
  var buf2 = C_hack::malloc(BUFSIZE);
  stream_cmp(i1, i2, buf1, buf2, BUFSIZE, res);
  C_hack::free(buf1);
  C_hack::free(buf2);
}

proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(infd: istr, outfd: ostr)
{
    val BUFSIZE = 100000;
    var buf = C_hack::malloc(BUFSIZE);

    // that's some nice error checking
    cat(infd, outfd, buf, BUFSIZE);
    C_hack::free(buf);
}

open List;

proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(in_fds: list[istr], outfd: ostr,
    buf: address, bufsize: int)
{
    match in_fds with
    | Empty[istr] => {}                     // finished
    | Cons[istr] (?fd, ?l) =>
        {
            cat(fd, outfd, buf, bufsize);   // cat first
            cat(l, outfd, buf, bufsize);    // cat the rest
        }
    endmatch
    ;
}

proc echo[iostr with IOByteStream[iostr]]
(fd: iostr, buf: address, bufsize: int)
{
    // echo a = cat a a. that's deep, man.
    cat(fd, fd, buf, bufsize);
};

proc tee[istr,ostr with IByteStream[istr], OByteStream[ostr]]
(infd: istr, outfd: ostr, outfd2: ostr)
{
    var eof = false;
    var weof = false;
    var weof2 = false;
    var len: int;

    val BUFSIZE = 10*1024;
    var buf = C_hack::malloc(BUFSIZE);

    // don't hammer!
    while{not(eof) and not(weof) and not(weof2)} {
        len = BUFSIZE;
        read(infd, &len, buf, &eof);
        write(outfd, &len, buf, &weof);
        write(outfd2, &len, buf, &weof2);
    };
    C_hack::free buf;
}

// highly inefficient!
proc get_line[istr with IByteStream[istr]] 
(strm: istr, s: &string)
{
  var c: char;
  val ac = C_hack::cast[address]$ C_hack::addr c;
  var st: string;
  var finished = false;

  whilst not finished do
    var len = 1;
    var eof: bool;

    read(strm, &len, ac, &eof);

    if eof or c == char '\n' do
      finished = true;
    else
      st += c;
    done;
  done;
  *s = st;  // pass back result
}

proc write_string[ostr with OByteStream[ostr]]
(sk: ostr, var s: string)
{
  var slen = len s;
  var a = C_hack::cast[address]$ cstr s; 
  var eof: bool;
  write(sk, &slen, a, &eof);
}


} // module Flx_stream

@h = tangler("lib/flx_socket.flx")
@select(h)
#import <flx.flxh>
include "flx_faio";
include "flx_stream";

#if POSIX
include "flx_faio_posix";
#elif WIN32
include "flx_faio_win32";
#endif

module Flx_socket {

#if POSIX
typedef socket_t = Faio_posix::socket_t;
#elif WIN32
typedef socket_t = Faio_win32::socket_t;
#endif


proc mk_listener(l: &socket_t, port: &int, qlen: int)
{
#if POSIX
  Faio_posix::mk_listener(l,port, qlen);
#elif WIN32
  Faio_win32::mk_listener(l, port, qlen);
#endif
}

proc accept(l: socket_t, s: &socket_t)
{
#if POSIX
  Faio_posix::accept(s, l);  // success or not? error checking
#elif WIN32
  var success: bool;
  Faio_win32::mk_socket(s);  // error check?
  Faio_win32::Accept(&success, l, *s);
  if not success do
    fprint (cout, "Accept failed! num?\n");
  done;
#endif
}

proc shutdown(s: socket_t, how: int)
{
#if POSIX
  Faio_posix::shutdown(s, how);
#elif WIN32
  Faio_win32::shutdown(s, how);
#endif
}

proc connect(s: &socket_t, addr: charp, port: int)
{   
#if POSIX 
    Faio_posix::connect(s, addr, port );
#elif WIN32
    Faio_win32::Connect( s, addr, port );
#endif
}


//
// socket_t
//
instance Flx_stream::IByteStream[socket_t]
{
  proc read(s: socket_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { Faio_posix::async_read(s, len, buf, eof); }
  #elif WIN32
    { Faio_win32::WSARecv(s, len, buf, eof); }
  #endif
}

instance Flx_stream::OByteStream[socket_t]
{
  proc write(s: socket_t, len: &int, buf: address, eof: &bool)
  #if POSIX
    { Faio_posix::async_write(s, len, buf, eof); }
  #elif WIN32
    { Faio_win32::WSASend(s, len, buf, eof); }
  #endif
}

instance Flx_stream::IOByteStream[socket_t] {}

instance Flx_stream::TerminalIByteStream[socket_t]
{
  proc iclose (s:socket_t)
  #if POSIX
    { Faio_posix::shutdown (s,0); Faio_posix::close s; }
  #else
    { Faio_win32::closesocket s; }
  #endif
}

instance Flx_stream::TerminalOByteStream[socket_t]
{
  proc oclose (s:socket_t) 
  #if POSIX
    { Faio_posix::shutdown (s,1); Faio_posix::close s; }
  #elif WIN32
    { Faio_win32::closesocket s; }
  #endif
}


instance Flx_stream::TerminalIOByteStream[socket_t]
{
  proc ioclose (s:socket_t) 
  #if POSIX
    { /* Faio_posix::shutdown(s,2); */ 
      fprint (cerr,q"STREAM:Closing socket $s\n");
      Faio_posix::close s; 
    }
  #elif WIN32
    { Faio_win32::closesocket s; }
  #endif
}

}

@head(1,"Felix Async IO tests")

@env_faio.head(2, 'faio tests')
@env_faio.head(3)
@select(env_faio.test('.flx'))
@kat_faio("sockets")
#import <flx.flxh>
include "flx_stream";
include "flx_socket";
open Flx_stream;
open Flx_socket;
open Flx_stream::TerminalIOByteStream[Flx_socket::socket_t];

print "flx tcp stream test\n";

var listener: socket_t;
var port = 0;  // you choose
// var port = 1024;

// check errors. how is that done?
mk_listener(&listener, &port, 1);
// print "Got port: "; print port; endl;
// print "accepting\n";

print "spawning connector\n";
// not printing in thread to make output deterministic.
// note that the connect shouldn't fail (immediately) because the
// listener exists - it just hasn't called accept yet.
spawn_fthread
{
  {
    // print "Connector dude\n";  // get rid of, hard to test
    var c: socket_t;
    connect(&c, c"127.0.0.1", port); // connect to localhost
    var st: string;

    get_line(c, &st);
    print "connector got "; print st; endl;
    write_string(c, "thanks\n");         // newline important

    ioclose(c);  // finished with this
  };
};

var s: socket_t;
accept(listener, &s);
ioclose(listener);  // not needed anymore

print "got connection\n";
write_string(s, "server says hi\n");     // newline important here

var st: string;
get_line(s, &st);

print "server got "; print st; endl;
ioclose(s);
@doc()

@select(env_faio.expect())
flx tcp stream test
spawning connector
got connection
connector got server says hi
server got thanks
@doc()

@env_posix.head(2, 'Posix tests')
@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

// create a listening socket, spawn a thread to connect to it.
// in case something goes wrong could make test time out with
// spawn_fthread { { sleep 5.0; System::exit 1; }; };
print "felix posix accept/connect test\n";

var port = 0;   // let mk_listener choose the port
print "creating listener\n";
var &listener: socket_t <- mk_listener(&port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{ { var c: socket_t; connect(&c, c"127.0.0.1", port); }; };

var s: socket_t;
accept (&s, listener);  // async!
if bad_socket s then {
  System::exit 1;
} else {
  print "accepted connection\n";
  System::exit 0;
} endif;
@doc()

@select(env_posix.expect())
felix posix accept/connect test
creating listener
spawning connector
accepted connection
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

header "typedef struct { char dat[8]; } tstbuf;";
ctypes tstbuf;
proc dprint: tstbuf = 'printf("%.8s", $1.dat);';
fun get_data: tstbuf -> address = "$1.dat";
fun get_data: charp -> address = "$1";

// try to send some data down a socket
var port = 0;   // let mk_listener choose the port
var &listener: socket_t <- mk_listener(&port, 1);

// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: socket_t;
    connect(&c, c"127.0.0.1", port);

    var len = 8;
    var eof: bool;
    async_write(c, &len, get_data((c"faio2you")), &eof);
    shutdown(c, 1);  // no further writes (wakes reader)

    var b: tstbuf;
    async_read(c, &len, b.data, &eof);
    print "connector read "; dprint b; endl;
    System::exit 0;
  };
};

var s: socket_t;
accept (&s, listener);  // async!
var b: tstbuf;
var len = 16;           // ask for more than there is and rely on shutdown
var eof: bool;
async_read(s, &len, b.data, &eof);
print "acceptor read "; print len; print " bytes: "; dprint b; endl;
async_write(s, &len, get_data((c"thanks!!")), &eof);
@doc()

@select(env_posix.expect())
acceptor read 8 bytes: faio2you
connector read thanks!!
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#include <flx.flxh>
// actually portable, but I don't know the scheme for
// adding those tests.
include "flx_stream";
print "more output here\n";
@doc()

@select(env_posix.expect())
more output here
@doc()

@env_win.head(2, 'Windows tests')
@env_win.head(3)
@select(env_win.test('.flx'))
#import <flx.flxh>
include "flx_faio_win32";
open Faio_win32;

var port = 1234;  // can't yet get os to choose the port. should fix that.
var listener: SOCKET;
mk_listener(&listener, &port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: SOCKET;
    Connect(&c, c"127.0.0.1", port);
  };
};

var s: SOCKET;
var success: bool;
mk_socket(&s);    // for async accept on win32 you create the accept socket yourself
Accept(&success, listener, s);

if success then {
  print "successful accept!\n";
  System::exit 0;
} else {
  print "accept failed!\n";
  System::exit 1;
} endif;
@doc()

@select(env_win.expect())
spawning connector
successful accept!
@doc()

@env_win.head(3)
@select(env_win.test('.flx'))
#import <flx.flxh>
include "Flx_faio_win32";
open Faio_win32;

// let's add a win32 namedpipe test!
// type WFILE is a HANDLE. that should work.
// note the "r" for felix string raw mode.
var pname = r"\\.\pipe\flx_pipe";

// CreateNamedPipe binding (put in a library somewhere)
// duplex, byte stream, one instance, 
// guessing 256 bytes for input and output buffers
// 0 default timeout (not using default wait, shouldn't matter)
// default security attributes
// associating with the iocp doesn't work, the pipe must be created with
// FILE_FLAG_OVERLAPPED set in dwOpenMode. Otherwise OVERLAPPED calls block.
proc CreateNamedPipe: lvalue[WFILE]*string = 
 '$1 = CreateNamedPipe($2.c_str(), PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,\
     PIPE_TYPE_BYTE, 1, 256, 256, 0, NULL);';

// OpenFile in flx_faio_win32 should work fine here

print "Creating named pipe "; print pname; endl;
var pipe: WFILE <- CreateNamedPipe(pname);

// how to connect with this stuff? can I open it non blockingly?
if pipe == INVALID_HANDLE_VALUE then
{
  print "BUGGER: CreateNamedPipeFailed: "; print (GetLastError()); endl;
} else {
  print "whoo!\n";
} endif;

// let's try to associate with IOCP here...
// Hack: the interface requires a SOCKET, which it then casts to a HANDLE.
// don't forget to create pipe with FILE_FLAG_OVERLAPPED, else we
// error #87 -> ERROR_INVALID_PARAMETER
fun HACK_TO_SOCKET: WFILE -> SOCKET = '(SOCKET)$1';
associate_with_iocp(HACK_TO_SOCKET(pipe));

header = """

using namespace flx;
using namespace demux;
using namespace faio;

// wrap up ConnectNamedPipe. This function normally blocks, so we must
// use it in a way that allows us to deschedule the fthread.
class connect_namedpipe
  : public waio_base,  public flx::demux::iocp_wakeup {
  HANDLE pipe;       // for demux
public:
  connect_namedpipe(HANDLE p = INVALID_HANDLE_VALUE) : pipe(p) {}

  // this belongs in demux class
  virtual bool start_overlapped()
  {
    fprintf(stderr, "connect named pipe start overlapped %p\\n", pipe);

    clear_overlapped();  // everyone's doing this

    BOOL success;
    success = ConnectNamedPipe(pipe, &ol);

    // fprintf(stderr, "Connect named pipe: %i\\n", success);
    if(success)
    {
      // this shouldn't happen ever. make it an error.
      fprintf(stderr, "ConnectNamedPipe SUCCEEDED (shouldn't happen)\\n");
    } else {
      int err = GetLastError();
      fprintf(stderr, "ConnectNamedPipe returned %i\\n", err);

      // this doesn't always signify failure.
      switch(err)
      {
         case ERROR_PIPE_CONNECTED: // got a connection already
           fprintf(stderr, "ALREADY GOT CONNECTION\\n");
           // do fake wakeup here for great greatness. eats user cookie.
           iocp_op_finished(0, 0, &ol, NO_ERROR);
           return true;  // async finished
         break;

         case ERROR_IO_PENDING:  // completion packet is in the mail
           fprintf(stderr, "Connection pending... (normal)\\n");
           return false;         // not finished, packet still to come
         break;
         default:
           fprintf(stderr, "ConnectNamedPipe FAILED (%i)\\n", err);
         break;
      }
      
    }

    return false;  // let's not get woken, packet still to come (??)
  }

  // this belongs in faio class
  bool start_async_op_impl()
  {
    fprintf(stderr,"named_pipe: start async_op_impl\\n");
    fprintf(stderr, "start_async_op for named pipe\\n");
    return start_overlapped();
  }

  // as does this
  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
  {
    fprintf(stderr, "connect named pipe FINISHED! err: %i\\n", err);
    waio_base::iocp_op_finished(nbytes, udat, olp, err);
  }


};
""";

proc getbyte(f: WFILE, outc: &char)
{
  var c: char;
  val ac = C_hack::address_of(c);
  var len = 1;
  var eof: bool;

  ReadFile(f, &len, ac, &eof);
  *outc = c;
}

proc putbyte(f: WFILE, c: char)
{
  var copyc = c;
  val ac = C_hack::address_of(copyc);
  var len = 1;
  var eof: bool;

  WriteFile(f, &len, ac, &eof);
}

// spawn a connect fthread after having created the named pipe

// I'm not yet "accepting", but hopefully I can spawn a client here
spawn_fthread {
  // print "Gudday, client thread, trying to open PIPE\n";
  // var p: WFILE <- OpenFile(pname);
  // having trouble getting io...
  var p: WFILE <- OpenFileDuplex(pname);

  // print "Client thread returned from OpenFile\n";

  if p == INVALID_HANDLE_VALUE then
  { print "BUGGER: client couldn't open pipe: "; print (GetLastError()); endl; }
  else { print "client opened pipe\n"; } endif;

  // HUM need to associate.
  print "associating client\n";
  associate_with_iocp(HACK_TO_SOCKET(p));

  var c: char;
  getbyte(p, &c);
  print "client got "; print c; endl;
  putbyte(p, char 'b');
  CloseFile(p);
};

type np_request = 'connect_namedpipe';
fun mk_np_request: WFILE -> np_request = 'connect_namedpipe($1)';

var npr = mk_np_request(pipe);
Faio::faio_req$ &npr;

print "poot! got connection (maybe)\n";
print "server trying to put byte\n";
putbyte(pipe, char 'a');
var c: char;
getbyte(pipe, &c);
print "server got "; print c; endl;
CloseFile(pipe);
@doc()

@select(env_win.expect())
Creating named pipe \\.\pipe\flx_pipe
whoo!
client opened pipe
associating client
poot! got connection (maybe)
server trying to put byte
client got a
server got b
@doc()

@env_faio.write_katfile()
@env_posix.write_katfile()
@env_win.write_katfile()

