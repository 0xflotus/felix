@execfile('config'+os.sep+'config.py')
@execfile("flxbuild"+os.sep+"iscrutil.py")

@env_faio = setup_test('test/faio/faio-')
@env_win = setup_test('test/faio/win-')
@env_posix = setup_test('test/faio/posix-')

@def kat_faio(code):
  env_faio.kat(get_tangler(),code)

@def kat_win(code):
  env_win.kat(get_tangler(),code)

@def kat_posix(code):
  env_posix.kat(get_tangler(),code)

@head(1,"Faio")
Asynch I/O interface pack.

@h = tangler('config/faio.fpc', 'data')
@select(h)
Name: faio
Description: Asynchronous I/O support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libfaio_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libfaio_static")
 else:
   tangle("provides_dlib: -lfaio_dynamic")
   tangle("provides_slib: -lfaio_static")
Requires: demux

@select(tangler('spkgs/faio.py'))
FAIORTL_INTERFACES = [
  'config/target/flx_faio_config.hpp',
  'src/faio/faio_asyncio.hpp',
  'src/faio/faio_job.hpp',
  'src/faio/faio_timer.hpp',
  'src/faio/faio_posixio.hpp',
  'src/faio/faio_winio.hpp',
]

FAIO_CPPS = [
  "src/faio/faio_timer",
  "src/faio/faio_job",
  "src/faio/faio_asyncio",
]

POSIX_FAIO_CPPS = [
  "src/faio/faio_posixio",
]

WINDOWS_FAIO_CPPS = [
  "src/faio/faio_winio",
]

@tangle('EXTRA_TEST_GLOBS = glob.glob('+repr(unix2native(env_faio.root)+"*.flx")+')')

if WIN32:
  FAIO_CPPS = FAIO_CPPS + WINDOWS_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = EXTRA_TEST_GLOBS + glob.glob('+repr(unix2native(env_win.root)+"*.flx")+')')

if POSIX:
  FAIO_CPPS = FAIO_CPPS + POSIX_FAIO_CPPS
@tangle('  EXTRA_TEST_GLOBS = EXTRA_TEST_GLOBS + glob.glob('+repr(unix2native(env_posix.root)+"*.flx")+')')

cpp_cpps = FAIO_CPPS
build_macro = "FAIO"

rtl_interfaces = FAIORTL_INTERFACES
felix_rtl = [
  'src/faio/flx_faio.flx',
  'src/faio/flx_faio_posix.flx',
  'src/faio/flx_faio_win32.flx',
  'src/faio/flx_socket.flx',
  'src/faio/flx_stream.flx',
]

pkg_requires = ['demux','flx_pthread', 'flx_rtl'] # flx_rtl for rtl_config.
lib_requires = ['libdemux','libflx_pthread'] # however lib not required
unit_tests = EXTRA_TEST_GLOBS
demos = glob.glob(os.path.join('demos', 'faio', '*.flx'))
iscr_source = ["lpsrc/flx_faio.pak"]
weaver_directory = 'doc/rtl/flx_faio/'
tmpdir = ['faio']
xfiles = [os.path.join('src', 'faio', '*')]

@h=tangler('config/target/flx_faio_config.hpp')
@select(h)
#ifndef __FLX_FAIO_CONFIG_H__
#define __FLX_FAIO_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FAIO
#define FAIO_EXTERN FLX_EXPORT
#else
#define FAIO_EXTERN FLX_IMPORT
#endif
#endif

@head(1,"Felix Async IO tests")

@env_faio.head(2, 'faio tests')
@env_faio.head(3)
@select(env_faio.test('.flx'))
@kat_faio("sockets")
#import <flx.flxh>
include "flx_stream";
include "flx_socket";
open Flx_stream;
open Flx_socket;
open Flx_stream::TerminalIOByteStream[Flx_socket::socket_t];

print "flx tcp stream test\n";

var listener: socket_t;
var port = 0;  // you choose
// var port = 1024;

// check errors. how is that done?
mk_listener(&listener, &port, 1);
// print "Got port: "; print port; endl;
// print "accepting\n";

print "spawning connector\n";
// not printing in thread to make output deterministic.
// note that the connect shouldn't fail (immediately) because the
// listener exists - it just hasn't called accept yet.
spawn_fthread
{
  {
    // print "Connector dude\n";  // get rid of, hard to test
    var c: socket_t;
    connect(&c, c"127.0.0.1", port); // connect to localhost
    var st: string;

    get_line(c, &st);
    print "connector got "; print st; endl;
    write_string(c, "thanks\n");         // newline important

    ioclose(c);  // finished with this
  };
};

var s: socket_t;
accept(listener, &s);
ioclose(listener);  // not needed anymore

print "got connection\n";
write_string(s, "server says hi\n");     // newline important here

var st: string;
get_line(s, &st);

print "server got "; print st; endl;
ioclose(s);
@doc()

@select(env_faio.expect())
flx tcp stream test
spawning connector
got connection
connector got server says hi
server got thanks
@doc()

@env_posix.head(2, 'Posix tests')
@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

// create a listening socket, spawn a thread to connect to it.
// in case something goes wrong could make test time out with
// spawn_fthread { { sleep 5.0; System::exit 1; }; };
print "felix posix accept/connect test\n";

var port = 0;   // let mk_listener choose the port
print "creating listener\n";
var &listener: socket_t <- mk_listener(&port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{ { var c: socket_t; connect(&c, c"127.0.0.1", port); }; };

var s: socket_t;
accept (&s, listener);  // async!
if bad_socket s then {
  System::exit 1;
} else {
  print "accepted connection\n";
  System::exit 0;
} endif;
@doc()

@select(env_posix.expect())
felix posix accept/connect test
creating listener
spawning connector
accepted connection
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
include "flx_faio_posix";
open Faio_posix;

header "typedef struct { char dat[8]; } tstbuf;";
ctypes tstbuf;
proc dprint: tstbuf = 'printf("%.8s", $1.dat);';
fun get_data: tstbuf -> address = "$1.dat";
fun get_data: charp -> address = "$1";

// try to send some data down a socket
var port = 0;   // let mk_listener choose the port
var &listener: socket_t <- mk_listener(&port, 1);

// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: socket_t;
    connect(&c, c"127.0.0.1", port);

    var len = 8;
    var eof: bool;
    async_write(c, &len, get_data((c"faio2you")), &eof);
    shutdown(c, 1);  // no further writes (wakes reader)

    var b: tstbuf;
    async_read(c, &len, b.data, &eof);
    print "connector read "; dprint b; endl;
    System::exit 0;
  };
};

var s: socket_t;
accept (&s, listener);  // async!
var b: tstbuf;
var len = 16;           // ask for more than there is and rely on shutdown
var eof: bool;
async_read(s, &len, b.data, &eof);
print "acceptor read "; print len; print " bytes: "; dprint b; endl;
async_write(s, &len, get_data((c"thanks!!")), &eof);
@doc()

@select(env_posix.expect())
acceptor read 8 bytes: faio2you
connector read thanks!!
@doc()

@env_posix.head(3)
@select(env_posix.test('.flx'))
#import <flx.flxh>
// actually portable, but I don't know the scheme for
// adding those tests.
include "flx_stream";
print "more output here\n";
@doc()

@select(env_posix.expect())
more output here
@doc()

@env_win.head(2, 'Windows tests')
@env_win.head(3)
@select(env_win.test('.flx'))
#import <flx.flxh>
include "flx_faio_win32";
open Faio_win32;

var port = 1234;  // can't yet get os to choose the port. should fix that.
var listener: SOCKET;
mk_listener(&listener, &port, 1);

print "spawning connector\n";
// not printing in thread to make output repeatable in
// the face of scheduler changes.
spawn_fthread{
  {
    var c: SOCKET;
    Connect(&c, c"127.0.0.1", port);
  };
};

var s: SOCKET;
var success: bool;
mk_socket(&s);    // for async accept on win32 you create the accept socket yourself
Accept(&success, listener, s);

if success then {
  print "successful accept!\n";
  System::exit 0;
} else {
  print "accept failed!\n";
  System::exit 1;
} endif;
@doc()

@select(env_win.expect())
spawning connector
successful accept!
@doc()

@env_win.head(3)
@select(env_win.test('.flx'))
#import <flx.flxh>
include "Flx_faio_win32";
open Faio_win32;

// let's add a win32 namedpipe test!
// type WFILE is a HANDLE. that should work.
// note the "r" for felix string raw mode.
var pname = r"\\.\pipe\flx_pipe";

// CreateNamedPipe binding (put in a library somewhere)
// duplex, byte stream, one instance,
// guessing 256 bytes for input and output buffers
// 0 default timeout (not using default wait, shouldn't matter)
// default security attributes
// associating with the iocp doesn't work, the pipe must be created with
// FILE_FLAG_OVERLAPPED set in dwOpenMode. Otherwise OVERLAPPED calls block.
proc CreateNamedPipe: lvalue[WFILE]*string =
 '$1 = CreateNamedPipe($2.c_str(), PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,\
     PIPE_TYPE_BYTE, 1, 256, 256, 0, NULL);';

// OpenFile in flx_faio_win32 should work fine here

print "Creating named pipe "; print pname; endl;
var pipe: WFILE <- CreateNamedPipe(pname);

// how to connect with this stuff? can I open it non blockingly?
if pipe == INVALID_HANDLE_VALUE then
{
  print "BUGGER: CreateNamedPipeFailed: "; print (GetLastError()); endl;
} else {
  print "whoo!\n";
} endif;

// let's try to associate with IOCP here...
// Hack: the interface requires a SOCKET, which it then casts to a HANDLE.
// don't forget to create pipe with FILE_FLAG_OVERLAPPED, else we
// error #87 -> ERROR_INVALID_PARAMETER
fun HACK_TO_SOCKET: WFILE -> SOCKET = '(SOCKET)$1';
associate_with_iocp(HACK_TO_SOCKET(pipe));

header = """

using namespace flx;
using namespace demux;
using namespace faio;

// wrap up ConnectNamedPipe. This function normally blocks, so we must
// use it in a way that allows us to deschedule the fthread.
class connect_namedpipe
  : public waio_base,  public flx::demux::iocp_wakeup {
  HANDLE pipe;       // for demux
public:
  connect_namedpipe(HANDLE p = INVALID_HANDLE_VALUE) : pipe(p) {}

  // this belongs in demux class
  virtual bool start_overlapped()
  {
    fprintf(stderr, "connect named pipe start overlapped %p\\n", pipe);

    clear_overlapped();  // everyone's doing this

    BOOL success;
    success = ConnectNamedPipe(pipe, &ol);

    // fprintf(stderr, "Connect named pipe: %i\\n", success);
    if(success)
    {
      // this shouldn't happen ever. make it an error.
      fprintf(stderr, "ConnectNamedPipe SUCCEEDED (shouldn't happen)\\n");
    } else {
      int err = GetLastError();
      fprintf(stderr, "ConnectNamedPipe returned %i\\n", err);

      // this doesn't always signify failure.
      switch(err)
      {
         case ERROR_PIPE_CONNECTED: // got a connection already
           fprintf(stderr, "ALREADY GOT CONNECTION\\n");
           // do fake wakeup here for great greatness. eats user cookie.
           iocp_op_finished(0, 0, &ol, NO_ERROR);
           return true;  // async finished
         break;

         case ERROR_IO_PENDING:  // completion packet is in the mail
           fprintf(stderr, "Connection pending... (normal)\\n");
           return false;         // not finished, packet still to come
         break;
         default:
           fprintf(stderr, "ConnectNamedPipe FAILED (%i)\\n", err);
         break;
      }
    }

    return false;  // let's not get woken, packet still to come (??)
  }

  // this belongs in faio class
  bool start_async_op_impl()
  {
    fprintf(stderr,"named_pipe: start async_op_impl\\n");
    fprintf(stderr, "start_async_op for named pipe\\n");
    return start_overlapped();
  }

  // as does this
  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
  {
    fprintf(stderr, "connect named pipe FINISHED! err: %i\\n", err);
    waio_base::iocp_op_finished(nbytes, udat, olp, err);
  }


};
""";

proc getbyte(f: WFILE, outc: &char)
{
  var c: char;
  val ac = C_hack::address_of(c);
  var len = 1;
  var eof: bool;

  ReadFile(f, &len, ac, &eof);
  *outc = c;
}

proc putbyte(f: WFILE, c: char)
{
  var copyc = c;
  val ac = C_hack::address_of(copyc);
  var len = 1;
  var eof: bool;

  WriteFile(f, &len, ac, &eof);
}

// spawn a connect fthread after having created the named pipe

// I'm not yet "accepting", but hopefully I can spawn a client here
spawn_fthread {
  // print "Gudday, client thread, trying to open PIPE\n";
  // var p: WFILE <- OpenFile(pname);
  // having trouble getting io...
  var p: WFILE <- OpenFileDuplex(pname);

  // print "Client thread returned from OpenFile\n";

  if p == INVALID_HANDLE_VALUE then
  { print "BUGGER: client couldn't open pipe: "; print (GetLastError()); endl; }
  else { print "client opened pipe\n"; } endif;

  // HUM need to associate.
  print "associating client\n";
  associate_with_iocp(HACK_TO_SOCKET(p));

  var c: char;
  getbyte(p, &c);
  print "client got "; print c; endl;
  putbyte(p, char 'b');
  CloseFile(p);
};

type np_request = 'connect_namedpipe';
fun mk_np_request: WFILE -> np_request = 'connect_namedpipe($1)';

var npr = mk_np_request(pipe);
Faio::faio_req$ &npr;

print "poot! got connection (maybe)\n";
print "server trying to put byte\n";
putbyte(pipe, char 'a');
var c: char;
getbyte(pipe, &c);
print "server got "; print c; endl;
CloseFile(pipe);
@doc()

@select(env_win.expect())
Creating named pipe \\.\pipe\flx_pipe
whoo!
client opened pipe
associating client
poot! got connection (maybe)
server trying to put byte
client got a
server got b
@doc()

@env_faio.write_katfile()
@env_posix.write_katfile()
@env_win.write_katfile()

