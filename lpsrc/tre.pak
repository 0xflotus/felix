@execfile('config/config.py')
@execfile("flxbuild"+os.sep+"iscrutil.py")

@env = setup_test('test/tre/tre-')

@head(1,'tre')
@h = tangler('spkgs/tre.py')
@select(h)

rtl_interfaces = [
  'config/target/flx_tre_config.hpp',
  'src/tre/tre_gettext.hpp',
  'src/tre/tre_regex.hpp',
  'src/tre/tre_ast.hpp',
  'src/tre/tre_compile.hpp',
  'src/tre/tre_config.hpp',
  'src/tre/tre_filter.hpp',
  'src/tre/tre_match-utils.hpp',
  'src/tre/tre_mem.hpp',
  'src/tre/tre_parse.hpp',
  ]

TRE_CPPS = [
  'src/tre/tre_regcomp',
  'src/tre/tre_regerror',
  'src/tre/tre_regexec',
  'src/tre/tre_ast',
  'src/tre/tre_compile',
  'src/tre/tre_filter',
  'src/tre/tre_match-approx',
  'src/tre/tre_match-backtrack',
  'src/tre/tre_match-parallel',
  'src/tre/tre_mem',
  'src/tre/tre_parse',
  'src/tre/tre_stack'
  ]

cpp_cpps = TRE_CPPS
iscr_source = ['lpsrc/tre.pak']
weaver_directory = 'doc/rtl/tre/'
build_macro = "TRE"
@tangle('unit_tests = glob.glob('+repr(unix2native(env.root)+"*.flx")+')')
tmpdir = ['tre']
xfiles = [os.path.join('src', 'tre', '*')]

@h = tangler('config/tre.fpc')
@select(h)

@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libtre_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libtre_static")
 else:
   tangle("provides_dlib: -ltre_dynamic")
   tangle("provides_slib: -ltre_static")

@h=tangler('config/target/flx_target_tre_config.hpp')
@select(h)
#ifndef __FLX_TARGET_TRE_CONFIG_H__
#define __FLX_TARGET_TRE_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_TRE
#define TRE_EXTERN FLX_EXPORT
#else
#define TRE_EXTERN FLX_IMPORT
#endif
#endif

/* config.h.  Generated by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
   systems. This function is required for `alloca.c' support on those systems.
   */
/* #undef CRAY_STACKSEG_END */

/* Define to 1 if using `alloca.c'. */
/* #undef C_ALLOCA */

/* Define to 1 if translation of program messages to the user's native
   language is requested. */
#define ENABLE_NLS 0

/* Define to 1 if you have `alloca', as a function or macro. */
//#define HAVE_ALLOCA 1

/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
   */
//#define HAVE_ALLOCA_H 1

/* Define if the GNU dcgettext() function is already present or preinstalled.
   */
//#define HAVE_DCGETTEXT 1

/* Define to 1 if you have the <dlfcn.h> header file. */
//#define HAVE_DLFCN_H 1

/* Define to 1 if you have the <getopt.h> header file. */
//#define HAVE_GETOPT_H 1

/* Define to 1 if you have the `getopt_long' function. */
//#define HAVE_GETOPT_LONG 1

/* Define if the GNU gettext() function is already present or preinstalled. */
//#define HAVE_GETTEXT 1

/* Define if you have the iconv() function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <inttypes.h> header file. */
//#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the `isascii' function. */
#define HAVE_ISASCII 1

/* Define to 1 if you have the `isblank' function. */
/* RF: had to comment this out to get cl.exe version working */
/* #define HAVE_ISBLANK 1 */

/* Define to 1 if you have the `iswascii' function or macro. */
/* #undef HAVE_ISWASCII */

/* Define to 1 if you have the `iswblank' function or macro. */
//#define HAVE_ISWBLANK 1

/* Define to 1 if you have the `iswctype' function or macro. */
//#define HAVE_ISWCTYPE 1

/* Define to 1 if you have the `iswlower' function or macro. */
//#define HAVE_ISWLOWER 1

/* Define to 1 if you have the `iswupper' function or macro. */
//#define HAVE_ISWUPPER 1

/* Define to 1 if you have the <libutf8.h> header file. */
/* #undef HAVE_LIBUTF8_H */

/* Define to 1 if you have the `mbrtowc' function or macro. */
//#define HAVE_MBRTOWC 1

/* Define to 1 if the system has the type `mbstate_t'. */
//#define HAVE_MBSTATE_T 1

/* Define to 1 if you have the `mbtowc' function or macro. */
/* #undef HAVE_MBTOWC */

/* Define to 1 if you have the <memory.h> header file. */
//#define HAVE_MEMORY_H 1

/* Define to 1 if you have the <regex.h> header file. */
/* #undef HAVE_REGEX_H */

/* Define to 1 if the system has the type `reg_errcode_t'. */
/* #undef HAVE_REG_ERRCODE_T */

/* Define to 1 if you have the <stdint.h> header file. */
//#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
//#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
//#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
//#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the `towlower' function or macro. */
//#define HAVE_TOWLOWER 1

/* Define to 1 if you have the `towupper' function or macro. */
//#define HAVE_TOWUPPER 1

/* Define to 1 if you have the <unistd.h> header file. */
//#define HAVE_UNISTD_H 1

/* Define to 1 if you have the <wchar.h> header file. */
//#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
//#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcschr' function or macro. */
//#define HAVE_WCSCHR 1

/* Define to 1 if you have the `wcscpy' function or macro. */
//#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function or macro. */
//#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wcsncpy' function or macro. */
//#define HAVE_WCSNCPY 1

/* Define to 1 if you have the `wcsrtombs' function or macro. */
//#define HAVE_WCSRTOMBS 1

/* Define to 1 if you have the `wcstombs' function or macro. */
/* #undef HAVE_WCSTOMBS */

/* Define to 1 if you have the `wctype' function or macro. */
//#define HAVE_WCTYPE 1

/* Define to 1 if you have the <wctype.h> header file. */
//#define HAVE_WCTYPE_H 1

/* Define to 1 if the system has the type `wint_t'. */
//#define HAVE_WINT_T 1

/* Define if you want to disable debug assertions. */
#define NDEBUG 1

/* Name of package */
#define PACKAGE "tre"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "Ville Laurikari <vl@iki.fi>"

/* Define to the full name of this package. */
#define PACKAGE_NAME "TRE"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "TRE 0.7.2"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "tre"

/* Define to the version of this package. */
#define PACKAGE_VERSION "0.7.2"

/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at run-time.
	STACK_DIRECTION > 0 => grows toward higher addresses
	STACK_DIRECTION < 0 => grows toward lower addresses
	STACK_DIRECTION = 0 => direction of growth unknown */
/* #undef STACK_DIRECTION */

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Define if you want to enable approximate matching functionality. */
#define TRE_APPROX 1

/* Define if you want TRE to print debug messages to stdout. */
/* #undef TRE_DEBUG */

/* Define to enable multibyte character set support. */
#define TRE_MULTIBYTE 0

/* Define to a field in the regex_t struct where TRE should store a pointer to
   the internal tre_tnfa_t structure */
#define TRE_REGEX_T_FIELD value

/* Define to the absolute path to the system regex.h */
/* #undef TRE_SYSTEM_REGEX_H_PATH */

/* Define if you want TRE to use alloca() instead of malloc() when allocating
   memory needed for regexec operations. */
//#define TRE_USE_ALLOCA 1

/* Define to include the system regex.h from TRE regex.h */
/* #undef TRE_USE_SYSTEM_REGEX_H */

/* TRE version string. */
#define TRE_VERSION "0.7.2"

/* TRE version level 1. */
#define TRE_VERSION_1 0

/* TRE version level 2. */
#define TRE_VERSION_2 7

/* TRE version level 3. */
#define TRE_VERSION_3 2

/* Define to enable wide character (wchar_t) support. */
//#define TRE_WCHAR 1

/* Version number of package */
#define VERSION "0.7.2"

/* Define to the maximum value of wchar_t if not already defined elsewhere */
/* #undef WCHAR_MAX */

/* Define if wchar_t is signed */
/* #undef WCHAR_T_SIGNED */

/* Define if wchar_t is unsigned */
/* #undef WCHAR_T_UNSIGNED */

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to enable GNU extensions in glibc */
//#define _GNU_SOURCE 1

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define on IRIX */
/* #undef _REGCOMP_INTERNAL */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
#ifndef __cplusplus
/* #undef inline */
#endif


@h=tangler('lib/tre.flx')
@select(h)
#import <flx.flxh>

module Tre 
{
  open C_hack;
  requires package 'tre';
  header '#include "tre_regex.hpp"';
  type tre_regex_t = "regex_t";

  const tre_version: string = "tre_version()";
  
  private fun _tre_regcomp: ptr[tre_regex_t] * string  -> int =
    "regncomp($1,$2.data(),$2.size(),REG_EXTENDED)"
  ;
  
  fun tre_regcomp (x:string): opt[tre_regex_t] = {
    var cr: tre_regex_t;
    var res = _tre_regcomp(addr cr, x);
    return 
      if res == 0 then Some cr else None[tre_regex_t] endif
    ;
  }

  fun nsub: ptr[tre_regex_t] -> int = "$1->re_nsub+1";
  
  ctypes regoff_t;
  cstruct regmatch_t {
    rm_so: regoff_t;
    rm_eo: regoff_t;
  }
  
  fun add: ptr[char] * regoff_t -> ptr[char] = "$1+$2";
  fun sub: regoff_t * regoff_t -> int = "(int)($1-$2)";
  fun _ctor_int : regoff_t -> int = "int($1)";

  private fun _tre_regexec: 
    ptr[tre_regex_t] *     // the compiled regex
    string *               // string to search
    int *                  // number of matches to return
    ptr[regmatch_t]        // array to hold matches
    -> int
  =
    "regnexec($1,$2.data(),$2.size(),$3,$4,0);"
  ;
  
  fun tre_regexec (re_in: tre_regex_t) (x:string): int * int * ptr[regmatch_t] =
  {
    var re = re_in;
    val nmatches = nsub$ addr re;
    var matches = Carray::array_alloc[regmatch_t] nmatches;
    var res = _tre_regexec(addr re, x, nmatches, matches);
    return res,nmatches,matches;
  }
}

@head(1, 'Tre tests')
@env.head(2)
@select(env.test('.flx'))
#import <flx.flxh>
include "tre.flx";
open Tre;
open C_hack;
open Carray;

print$ "Using tre " tre_version; endl;

var r = tre_regcomp("(a|b)*abb");
print "Done tre compile"; endl;

print 
  match r with
  | Some _ => "Compiled"
  | None => "failed" 
  endmatch
;
endl;


var re : tre_regex_t = 
  match r with 
  | Some ?re => re 
  | None => re // HACK!
  endmatch
;  

var s = "aabbabababb";
res,n,a := tre_regexec re s;
print "Result = "; print res; endl;
print "nmatches = "; print n; endl;

var i : int;
for_each { i=0; } { i<n } { ++i; }
  {
    if int(a.[i].rm_so) == -1 do
      print i; print " -> nomatch\n";
    else 
      print i; print "-> match '";
      start := int(a.[i].rm_so);
      finish := int(a.[i].rm_eo);
      print s.[start to finish];
      print "'"; endl;
    done;
  }
;

print "Finished"; endl;
@doc()

@select(env.expect())
Using tre TRE 0.7.2 (GPL)
Done tre compile
Compiled
Result = 0
nmatches = 2
0-> match 'aabbabababb'
1-> match 'b'
Finished
@doc()
