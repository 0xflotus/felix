@head(1,"Elide unused entries")
Name binding pass 2.

@h = tangler("src/flx_useless.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2

val elide_unused:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  fully_bound_symbol_table_t

@h = tangler("src/flx_useless.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions

(* Elide calls to useless procedures. Note we can't simply
elide the procedures, since they might be addressed/passed
as an argument, or be a root [main or exported]. 

Instead we rely on 'elide_useless' to elide procedures 
which are unused, by first eliding the call.
*)

exception Useful
exception Cannot_inline

let get_children child_map i = 
  try 
    Hashtbl.find child_map i 
  with Not_found -> []

let rec isuseless bbdfns exes = 
  let check i =         
    try 
      match Hashtbl.find bbdfns i with 
      | _,_,_,`BBDCL_procedure (props,_,_,exes) -> 
        if not (isuseless bbdfns exes) 
        then raise Useful
        else ()
      | _,_,_,`BBDCL_proc _
        -> raise Useful
      | _ -> failwith "[isuseless] Expected procedure type"
    with 
      Not_found -> ()
  in
  try
    iter
    (fun x -> match (x:bexe_t) with
      | `BEXE_call_prim (_,i,_,_)
      | `BEXE_call_direct (_,i,_,_)
        -> 
         check i

      | `BEXE_call (_,(`BEXPR_closure (_,_),_),_) 
      | `BEXE_call_stack _
      | `BEXE_jump _ -> assert false
      | `BEXE_jump_direct _ -> assert false

      | `BEXE_assign _
      | `BEXE_call _ (* assume useful if not call to named useful proc *)
      | `BEXE_read _ (* useful even if local, due to side effect *)
      | `BEXE_code _ 
      | `BEXE_nonreturn_code _ 
      | `BEXE_ifgoto _ (* assume a non-local goto here *)
      | `BEXE_ifnotgoto _ (* assume a non-local goto here *)
      | `BEXE_goto _ (* assume a non-local goto here *)
      | `BEXE_fun_return _ (* returning a value is useful *)
      | `BEXE_reglex _ 
      | `BEXE_regmatch _ 
      | `BEXE_halt _ 
        -> raise Useful 

      (* NOTE: 
        BEXE_init usually inits a local variable 
          which isn't useful by itself, however,
          it can also be used to init module variables ..
          we cant tell the difference atm ..
      *)
      | `BEXE_init _ 
        -> raise Useful

      (*
        BEXE_loop isn't useful by itself
      *)
      | `BEXE_loop _
      | `BEXE_label _
      | `BEXE_nop _
      | `BEXE_comment _
      | `BEXE_proc_return _
        -> ()
    )
    exes
    ;
    true
  with Useful -> false

(* a call to a proc like
  
  proc[T2] f(a2:at2) { call g x; }
  call f[T1] a1;

can be replaced by

  call g' x'; 

where g' = g replacing a2 with a1
and x' = x replacing a2 with a1.

We also need type replacement where
the type T2 is set to the ts list of f, here T1.

Replacement should work also in a case like:

  call f[int] a1;


where we have T2-> int
*)

let ident x = x

let param_subst bbdfns id syms sr vs b ps ts b' =
  if length vs <> length ts
  then syserr sr
  (
    "In body of " ^ id ^ 
    ": length of vs ["^catmap "," fst vs^
    "] <> length of ts [" ^ 
    catmap "," (sbt syms.dfns) ts ^
    "]"
  );
  let bs = 
    match ps with
    | [x] -> [b']
    | _ ->
    match b' with
    | `BEXPR_tuple bs,_ -> bs
    | x,`BTYP_tuple tts -> 
      let n = length ps in
      assert (n = length tts);
      map2 
      (fun i t -> `BEXPR_get_n (i,b'),t)
      (nlist n) tts

    | x,`BTYP_array (t,`BTYP_unitsum n) -> 
      assert (n = length ps);
      map
      (fun i -> `BEXPR_get_n (i,b'),t)
      (nlist n)

    | _ -> 
      syserr sr 
      (
        "[param_subst] expected tuple argument, got " ^
        sbe syms.dfns b'
      )
  in
  let pmap = Hashtbl.create 97 in
  iter2
  (fun (_,(i,_)) e -> Hashtbl.add pmap i e)
  ps bs
  ;
  let varmap = Hashtbl.create 97 in
  iter2
  (fun (_,i) t -> Hashtbl.add varmap i t)
  vs ts
  ;
  let auxt t = varmap_subst varmap t in
  let rec aux e = match map_tbexpr ident aux auxt e with
  | (`BEXPR_name (i,ts) as x,t) ->
    begin 
      try 
        Hashtbl.find pmap i
      with Not_found -> x, auxt t
    end
  | x -> x
  in
    let a = aux b in
    (*
    print_endline ("replace " ^ sbe syms.dfns b ^ "-->" ^ sbe syms.dfns a);
    *)
    a

let check_can_inline (child_map, bbdfns) i =
  let children = get_children child_map i in
  iter
    begin fun i ->
      let id,sr,parent,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_var _
      | `BBDCL_val _ -> ()
      | _ -> raise Cannot_inline
    end
  children 


(* This is basically beta expansion.
Given an application

  f a

where f(x)= b , we can replace the application
with b[x->a] .. the return value of the function,
with each x replaced by a.

However, a itself may be an application, and more 
generally f may be an application. For example

  (g x) (h d)

So we need to 'drill down' until, roughly speaking,
until we reach either a function or variable.

This expansion mapping is determined by the 
term structure and not any definitions, and
so can't be recursive, or chain inlines:
that requires rescanning the result of inlining.
*)


let tident t = t 

 
let rec inline_applies syms (child_map, bbdfns) exclude x = 
  let iai i x = inline_applies syms (child_map,bbdfns) (i::exclude) x in
  let ia x = inline_applies syms (child_map,bbdfns) exclude x in
  let x = map_tbexpr ident ia tident x in
  let x = reduce_tbexpr bbdfns x in
  match x with
  | `BEXPR_apply ((`BEXPR_closure (i,ts),_),b'),t -> 
    assert false
    (*
    begin match Hashtbl.find bbdfns i with
    | _,_,_,`BBDCL_fun _ ->
      `BEXPR_apply_prim (i,ts, b'),t
    | _,_,_,`BBDCL_function _ ->
      `BEXPR_apply_direct (i,ts, b'),t
    | _ -> (* needed temporarily for constructors .. *)
      `BEXPR_apply_direct (i,ts, b'),t
    end
    *) 

  | `BEXPR_apply_stack (i,ts,b'),t 
  | `BEXPR_apply_direct (i,ts,b'),t 
    when not (mem i exclude) ->
    begin 
      match Hashtbl.find bbdfns i 
      with id,parent,sr2,bbdcl -> 
      match bbdcl with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        begin match exes with
        | [`BEXE_fun_return (sr3,b)] ->
          begin 
            try 
              check_can_inline (child_map, bbdfns) i;
              (* POSSIBLE INFINITE RECURSE .. *)
              let b = iai i b in
              let a = param_subst bbdfns id syms sr3 vs b ps ts b' in
              a
            with Cannot_inline -> 
              x
          end
        | _ -> x
        end
      | _ -> x
    end
  | _ -> x

(* NOTES ON INLINING.
  In general, any call can be replaced by the body
  of the called procedure with the argument
  substituted in for the paramater, and any type variable
  similarly replaced by its instance; in addition,
  each label needs to be replaced by a fresh label,
  and each goto to one of those labels similarly
  replaced.

  Any variable must also be replaced by a fresh variable.
  Values can always be substituted out.
  
  The following conditions make inlining
  more difficult than that though: if a called
  routine contains a nested procedure which it
  calls, and that procedure refers to variables
  in it, then a display pointer is required:
  to make this work, the nested procedure has
  to be copied and relocated as a procedure
  nested in the caller; that is, a fresh
  procedure generated. This step can be elided
  of course, if the resultant procedure can
  also be inlined.

*)

let rec useless_call_elim syms used (child_map,bbdfns) vs' exes index =
  let uce exes = useless_call_elim syms used (child_map,bbdfns) vs' exes index in
  let ia x = inline_applies syms (child_map,bbdfns) [] x in
  let exes' = ref [] in
  iter
  (fun (x:bexe_t) -> match x with
  | `BEXE_init (sr,i,b) -> 
    (* Elide initialisation of unused variables *)
    if IntSet.mem i used
    then
      exes' := `BEXE_init (sr,i,ia b) :: !exes'

  | `BEXE_assign (sr,a,b) -> exes' := `BEXE_assign (sr,ia a,ia b) :: !exes'

  | `BEXE_call_stack (sr,i,ts, b') -> assert false

  | `BEXE_call_direct (sr,i,ts, b') ->
      begin match Hashtbl.find bbdfns i with
      | id,parent,sr2,`BBDCL_procedure (props,vs,ps,inner_exes) ->
        if not (isuseless bbdfns inner_exes) 
        then begin 
          match inner_exes with
          (* inline simple procedures *)
          | [`BEXE_call (sr3,a,b)]
          | [`BEXE_call (sr3,a,b); `BEXE_proc_return _]
            ->
              begin 
                try
                  check_can_inline (child_map,bbdfns) i;
                  let b = param_subst bbdfns id syms sr3 vs b ps ts b' in
                  let a = param_subst bbdfns id syms sr3 vs a ps ts b' in
                  let a = ia a in
                  let b = ia b in
                  match a with
                  | `BEXPR_closure (i,ts),_ ->
                    exes' := `BEXE_call_direct (sr,i,ts,b) :: !exes'
                  | _ ->
                    exes' := `BEXE_call (sr,a,b) :: !exes'
                with 
                  Cannot_inline -> 
                    exes' := `BEXE_call_direct (sr,i,ts,ia b') :: !exes'
              end

          | [`BEXE_call_direct (sr3,i',ts',b)]
          | [`BEXE_call_direct (sr3,i',ts',b); `BEXE_proc_return _]
           ->
              begin 
                try
                  check_can_inline (child_map,bbdfns) i;
                  let b = param_subst bbdfns id syms sr3 vs b ps ts b' in
                  let b = ia b in
                  let varmap = Hashtbl.create 97 in
                  iter2
                  (fun (_,i) t -> Hashtbl.add varmap i t)
                  vs ts
                  ;
                  let auxt t = varmap_subst varmap t in
                  let ts' = map auxt ts' in
                  exes' := `BEXE_call_direct (sr,i',ts',b) :: !exes'
                with 
                  Cannot_inline -> 
                    exes' := `BEXE_call_direct (sr,i,ts,ia b') :: !exes'
              end

          | [`BEXE_call_prim (sr3,i',ts',b)]
          | [`BEXE_call_prim (sr3,i',ts',b); `BEXE_proc_return _]
           ->
              begin 
                try
                  check_can_inline (child_map,bbdfns) i;
                  let b = param_subst bbdfns id syms sr3 vs b ps ts b' in
                  let b = ia b in
                  let varmap = Hashtbl.create 97 in
                  iter2
                  (fun (_,i) t -> Hashtbl.add varmap i t)
                  vs ts
                  ;
                  let auxt t = varmap_subst varmap t in
                  let ts' = map auxt ts' in
                  exes' := `BEXE_call_prim (sr,i',ts',b) :: !exes'
                with 
                  Cannot_inline -> 
                    exes' := `BEXE_call_direct (sr,i,ts,ia b') :: !exes'
              end

          | _ 
            -> 
              exes' := `BEXE_call_direct (sr,i,ts,ia b') :: !exes'
        end else begin
          (*
          print_endline ("Eliding useless call to " ^ si i);
          *)
          ()
        end

      | _ -> exes' := `BEXE_call_direct (sr,i,ts,ia b') :: !exes'
      end


  | `BEXE_call (sr,((`BEXPR_closure (i,ts),_) as f), b') -> assert false


  | `BEXE_jump _ -> assert false
  | `BEXE_jump_direct _ -> assert false

  | `BEXE_call (sr,a,b) -> 
    let a = ia a in
    begin match a with
    | `BEXPR_closure (i,ts),_ ->
      exes' := `BEXE_call_direct (sr,i,ts, ia b) :: !exes'
    | _ -> 
      exes' := `BEXE_call (sr,a,ia b) :: !exes'
    end

  | `BEXE_call_prim (sr,i,ts,b) -> exes' := `BEXE_call_prim (sr,i,ts, ia b) :: !exes'

  | `BEXE_fun_return (sr,a) -> exes' := `BEXE_fun_return (sr,ia a) :: !exes'
  | `BEXE_ifgoto (sr,e,l) -> exes' := `BEXE_ifgoto (sr,ia e, l) :: !exes'
  | `BEXE_ifnotgoto (sr,e,l) -> exes' := `BEXE_ifnotgoto (sr,ia e, l) :: !exes'
  | `BEXE_loop (sr,i,e) -> exes' := `BEXE_loop (sr,i,ia e) :: !exes'

  | `BEXE_nop _ -> () (* elide NOP *)
  | `BEXE_comment _  -> exes' := x :: !exes' (* but not comments *)

  | `BEXE_label (sr,s) -> 
    while            (* eliminate jumps to next instruction *)
      match !exes' with
      | (`BEXE_goto (_,s')) :: _
      | (`BEXE_ifgoto (_,_,s')) :: _
      | (`BEXE_ifnotgoto (_,_,s')) :: _
        -> s = s'
      | _ -> false
    do 
      exes' := tl !exes'
    done
    ;
    exes' := x :: !exes'

  | `BEXE_regmatch (sr,e,(a,n,h,tr)) ->
     let h' = Hashtbl.create 97 in
     Hashtbl.iter
     (fun i e -> Hashtbl.add h' i (ia e))
     h
     ;
    exes' := `BEXE_regmatch (sr,ia e,(a,n,h',tr)) :: !exes'


  | `BEXE_reglex (sr,p1,p2,(a,n,h,tr)) ->
     let h' = Hashtbl.create 97 in
     Hashtbl.iter
     (fun i e -> Hashtbl.add h' i (ia e))
     h
     ;
    exes' := `BEXE_reglex (sr,ia p1, ia p2,(a,n,h',tr)) :: !exes'

  | `BEXE_goto _
  | `BEXE_proc_return _
  | `BEXE_code _
  | `BEXE_nonreturn_code _
  | `BEXE_read _
  | `BEXE_halt _
    -> exes' := x :: !exes' 
  )
  exes
  ;
  List.rev !exes'

let copy_bbdcl syms used (child_map,bbdfns) bbdfns2 i =
  let data =
    match Hashtbl.find bbdfns i with
    | id,parent,sr,`BBDCL_procedure (props,vs,p,exes) ->
      let exes = useless_call_elim syms used (child_map,bbdfns) vs exes i in
      id,parent,sr,`BBDCL_procedure (props,vs,p,exes)

    | id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) ->
      let exes = useless_call_elim syms used (child_map,bbdfns) vs exes i in
      id,parent,sr,`BBDCL_function (props,vs,p,ret,exes)
    | x -> x
  in
    Hashtbl.add bbdfns2 i data

let elide_unused syms  
  (child_map, bbdfns) 
=
  (* make set of used things, initially empty *)
  let used = ref IntSet.empty in
  let uses i = Flx_use.uses syms used bbdfns i in

  (* add root items to set, then add items it uses *)
  IntSet.iter uses !(syms.roots)
  ;
  (* copy used things *)
  let bbdfns2 = Hashtbl.create 97 in
  IntSet.iter (copy_bbdcl syms !used (child_map,bbdfns) bbdfns2) !used
  ;
  bbdfns2

