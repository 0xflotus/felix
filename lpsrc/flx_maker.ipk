@head(1,'Maker')
@flx_version = '1.0a2'
@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################

# --------------------------------------------------
# IMPORT UTILITY RESOURCES
# ---------------------------------------------------
import os
import stat
import string
import sys

# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------
options = sys.argv[1:]
if options:
  print "OPTIONS: ", options
if "clean" in options:
    os.system("rm -f tmp/* src/* test/* lpsrc/*.cache")
do_tests = "test" in options or "tut" in options or "rt" in options or "bt" in options
use_interscript = "noiscr" not in options

# ------------------------------------------------
# BEGIN USER CONFIGURABLE SECTION
#-------------------------------------------------

# uncomment to DISABLE INTERSCRIPT
#use_interscript = 0

# invoke ocaml interface compiler
OCAMLBINPREFIX=''
OCAML_OBJDIR='src'
OCAMLC=OCAMLBINPREFIX+'ocamlc.opt -I '+OCAML_OBJDIR+' -rectypes '

# where the ocaml is installed
#OCAML_INCLUDE_DIRECTORY='/usr/local/lib/ocaml'

# where gnu readline header files are
#READLINE_INCLUDE_DIRECTORY='/usr/include/readline'

# for compiling mainlines
FLX_CPP_LINK = "g++ -Wno-long-long -D_GNU_SOURCE -ansi -rdynamic -ldl "

# for building shared libraries
FLX_CPP_DYNLINK = "g++ -Wno-long-long -D_GNU_SOURCE -ansi -shared -I."

# ------------------------------------------------
# END USER CONFIGURABLE SECTION
#-------------------------------------------------

# invoke ocaml implementation compiler
OCAMLOPT=OCAMLBINPREFIX+'ocamlopt.opt -I '+OCAML_OBJDIR+' '

# invoke ocaml yacc parser generator
OCAMLYACC = OCAMLBINPREFIX+'ocamlyacc '

# invoke ocaml lex lexer generator
OCAMLLEX = OCAMLBINPREFIX+'ocamllex.opt '

# where documentation gets put
WEAVER_DIRECTORY='doc/'
TUTORIAL_DIRECTORY='tut/'
TUTORIAL_DOC=TUTORIAL_DIRECTORY+'doc/'
TUTORIAL_EXAMPLES=TUTORIAL_DIRECTORY+'examples/'

# where the garbage collector sources are
# (the collector is now a separate package)
FLX_GC_SRC='src/'

# -------------------------------------------------
# BEGIN IMPLEMENTOR CONFIGURABLE SECTION
# ------------------------------------------------

# files containing ocamllex sources
LEXS = ['flx_lex']

# files containing ocamlyacc sources
PARSES = ['flx_parse']

# ocaml interface files
INTERFACES = [
  'flx_util'         ,
  'flx_types'        ,
  'flx_mtypes'       ,
  'flx_exceptions'   ,
  'flx_srcref'       ,
  'flx_typing'       ,
  'flx_string'       ,
  'flx_id'           ,
  'flx_print'        ,
  'flx_unify'        ,
  'flx_parse'        ,
  'flx_keywords'     ,
  'flx_lex'          ,
  'flx_pretok'       ,
  'flx_lex1'         ,
  'flx_tok'          ,
  'flx_parse_ctrl'   ,
  'flx_pat'          , 
  'flx_desugar'      , 
  'flx_symtab'       , 
  'flx_lookup'       , 
  'flx_mbind'        , 
  'flx_bbind'        , 
  'flx_name'         , 
  'flx_tgen'         , 
  'flx_gen'          , 
]

# ocaml implementation files
IMPLEMENTATIONS = [
  'flx_util'         ,
  'flx_mtypes'       ,
  'flx_srcref'       ,
  'flx_typing'       ,
  'flx_exceptions'   ,
  'flx_string'       ,
  'flx_id'           ,
  'flx_print'        ,
  'flx_unify'        ,
  'flx_parse'        ,
  'flx_keywords'     ,
  'flx_lex'          ,
  'flx_pretok'       ,
  'flx_lex1'         ,
  'flx_tok'          ,
  'flx_parse_ctrl'   ,
  'flx_pat'          , 
  'flx_desugar'      , 
  'flx_symtab'       , 
  'flx_lookup'       , 
  'flx_mbind'        , 
  'flx_bbind'        , 
  'flx_name'         , 
  'flx_tgen'         , 
  'flx_gen'          , 
]

DRIVERS = [
  'flx_run',
]

# C files that we need to compile, with options required to build them
COBJECTS = {
}
# *.so/.a libraries
CLIBRARIES = ['nums']

# *.cmxa libraries
OLIBRARIES = ['nums','flxlib']


# target executable programs to produce
EXES = [
  'flxl',
  'flxp',
  'flxd',
  'flxb',
  'flxg',
]

if 1:
  s = ' -cclib "-Lsrc '
  for library in CLIBRARIES:
    s = s + ' -l'+library
  s = s + '"'
  LDFLAGS = s
  del s

if 1:
  o = ''
  for object in COBJECTS.keys():
    o = o + ' src/' + object + '.o'
  OBJECT_FILES = o
  del o

TESTS = [
  'test/test_library1.flx',
]

# -------------------------------------------------
# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------

# ----------- Utilities ---------------------
class MakeError: pass

def filetime(f):
  try:
    return os.stat(f)[stat.ST_MTIME]
  except: return 0

def xqt(x):
  print x
  sys.stdin.flush()
  f = os.popen(x + " 2>&1","r")
  output = f.readlines()
  result = f.close()
  if result: print "  .. ERROR CODE",hex(result)
  if output: print string.join(output,"")
  sys.stdin.flush()

  if result:
    raise MakeError

def run(x):
  print x
  sys.stdin.flush()
  result = os.system(x)
  if result: print "  .. ERROR CODE",hex(result)
  sys.stdin.flush()

  if result:
    raise MakeError

def erasefile(f):
  try:
    os.unlink(f)
  except:
    pass
# ----------- Here begins the actual build procedure ---------------------

buildall = "clean" in options
stop_on_error = "stop_on_error" in options
import glob

try:
  # STEP 0: run interscript
  if "noiscr" not in options:
    if "doc" in options:
      xqt('iscr --language=en --weaver=web --weaver=latex --passes=200 --weaver-directory='+WEAVER_DIRECTORY+' lpsrc/flx.pak')
      xqt('iscr --language=en --weaver=web --weaver=latex --passes=200 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tutorial.pak')
    else:
      xqt('iscr lpsrc/flx.pak')
      xqt('iscr lpsrc/flx_tutorial.pak')
    os.system('rm -f tmp.tmp')

  # COMPILER DRIVER PROGRAMS

  for testfile in DRIVERS:
    print 'Compiling driver program ',testfile
    basename = string.split(testfile,'.')[0]
    if buildall or filetime("rtl/"+basename+ '.cpp') > filetime("bin/"+basename):
      try:
        xqt(FLX_CPP_LINK + " -I. " +
          "rtl/flx_gc.cpp " +
          "rtl/flx_collector.cpp " +
          "rtl/flx_rtl.cpp " +
          "rtl/" + basename + ".cpp -o bin/" + basename)
      except MakeError:
        print "Unable to build driver"
        raise MakeError

  if do_tests:
    REGRESSION_TESTS = glob.glob('test/rt*.flx')
    BAD_TESTS = glob.glob('test/bt*.flx')
    TUTORIAL_TESTS = glob.glob('tut/examples/tut*.flx')
    if "test" in options:
      TESTS = TESTS + REGRESSION_TESTS + TUTORIAL_TESTS
    else:
      if "tut" in options:
        TESTS = TESTS + TUTORIAL_TESTS
      if "rt" in options:
        TESTS = TESTS + REGRESSION_TESTS
    TESTS.sort()
    BAD_TESTS.sort()

  # STEP 1: Compile all C files
  for cobject in COBJECTS.keys():
    flags = COBJECTS[cobject]
    file = 'src/'+cobject
    if buildall or filetime(file +".c") > filetime(file +".o"):
      xqt(CCOMPILE +" -I "+OCAML_INCLUDE_DIRECTORY+" -I. "+flags+" "+file+".c")

  # STEP 2: Generate lexers
  for lex in LEXS:
    file = 'src/'+lex
    if buildall or filetime(file + '.mll') > filetime(file +'.ml'):
      buildall = 1
      xqt(OCAMLLEX + file + '.mll')

  # STEP 3: Generate parsers
  for parse in PARSES:
    file = 'src/'+parse
    if buildall or filetime(file + '.mly') > filetime(file +'.ml'):
      buildall = 1
      xqt(OCAMLYACC+ ' -v '+ file + '.mly')

  # STEP 4: Compile ocaml interfaces
  for interface in INTERFACES:
    file = 'src/'+interface
    if buildall or filetime(file + '.mli') > filetime(file+'.cmi'):
      buildall = 1
      xqt(OCAMLC + ' -c '+file+ '.mli')

  # STEP 5: Compile ocaml implementations
  for implementation in IMPLEMENTATIONS + EXES:
    file = 'src/'+implementation
    if buildall or filetime(file+ '.ml') > filetime(file+'.cmx'):
      buildall = 1
      xqt(OCAMLOPT + ' -c ' + file +'.ml')


  # STEP 6: Build FELIX Library
  linkstring = OCAMLOPT + " -a -o src/flxlib.cmxa "
  library_filetime = filetime('src/flxlib.cmxa')
  for implementation in IMPLEMENTATIONS:
    file = 'src/'+implementation
    if filetime(file+'.cmx') > library_filetime:
      for implementation in IMPLEMENTATIONS:
        file = 'src/'+implementation
        linkstring = linkstring + file + ".cmx "
      xqt(linkstring)
      buildall = 1
      break

  # STEP 8: Link executables
  x = ''
  for library in OLIBRARIES:
    x = x + ' ' + library + '.cmxa'

  # finally, mainline *.cmx files to link to executables
  for exe in EXES:
    if buildall or filetime(exe + '.cmx') > filetime(exe):
      xqt(OCAMLOPT + LDFLAGS + ' -o bin/'+exe + x + OBJECT_FILES + ' ' + exe + '.cmx')

  w = 50
  # run tests
  if do_tests:
    try:
      results = []

      # GENERATE C++ FROM FELIX SOURCE
      for testfile in TESTS:
        #print 'Running Felix code generator on ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or \
          filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
          filetime('bin/flxg')> filetime(basename+'.cpp') or \
          filetime('lib/std.flx') > filetime(basename+'.cpp') or \
          filetime('lib/std.flx') > filetime(basename+'.cpp'):
          try:
            xqt('bin/flxg -q -Ilib ' + basename)
            #print 'TESTFILE -- generated ',basename
            results.append("flxg " + (basename+ ' ' * w)[:w]+ ' OK')
          except MakeError:
            print 'TESTFILE -- ERROR!',basename
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+'.so')
            if stop_on_error: raise MakeError
            results.append("flxg " + (basename + ' '*w)[:w] + ' ERROR')

      # FAILURE TESTS 
      if "bt" in options:
        for testfile in BAD_TESTS:
          #print 'Running Felix code generator on ',testfile
          basename = string.split(testfile,'.')[0]
          cppfilename = basename + ".cpp"
          if buildall or \
            filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
            filetime('bin/flxg')> filetime(basename+'.cpp') or \
            filetime('lib/std.flx') > filetime(basename+'.cpp'):
            try:
              xqt('bin/flxg -e -Ilib ' + basename)
              #print 'TESTFILE -- failed as expected',basename
              results.append("flxg " + (basename+ ' ' * w)[:w]+ ' OK')
              erasefile(basename+'.cpp')
              erasefile(basename+'.hpp')
              erasefile(basename+'.so')
            except MakeError:
              print 'TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED!',basename
              erasefile(basename+'.cpp')
              erasefile(basename+'.hpp')
              erasefile(basename+'.so')
              if stop_on_error: raise MakeError
              results.append("flxg " + (basename + ' '*w)[:w] + ' ERROR')

      # C++ COMPILE SHARED LIBRARIES
      for testfile in TESTS:
        #print 'Compiling generated code of ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or filetime(basename+ '.cpp') > filetime(basename+'.so'):
          try:
            xqt(FLX_CPP_DYNLINK+" "+cppfilename + " -o " + basename + ".so" )
            #print 'TESTFILE -- OK!',basename
            results.append("g++  " + (basename + ' ' * w)[:w]+ ' OK')
          except MakeError:
            print 'TESTFILE -- ERROR!',basename
            erasefile(basename+'.so')
            if stop_on_error: raise MakeError
            results.append("g++  " + (basename + ' '*w)[:w] + ' ERROR')


      for testfile in TESTS:
        basename = string.split(testfile,'.')[0]
        testscript = "./bin/flx_run ./"+basename+".so"
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append("Exec " + (testscript + ' ' * w)[:w]+ ' OK')
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append("Exec " + (testscript + ' '*w)[:w] + ' ERROR')

      print "RUN COMPLETE"
    finally:
      # REPORT FINAL RESULTS
      print
      print '**********************************'
      print 'final results'
      for x in results: print x
      print '**********************************'

except MakeError:
  print "Terminating due to error"

@head(1,'Man pages')
@select(tangler('man/felix.1'))
.TH FELIX LANGUAGE "2002 April 11"
.SH NAME
Felix language
.SH SYNOPSIS
.br
.B Felix
is a modern statically typed, modular programming language
which targets shared libraries rather than programs.
It features automatic generation of event driven, cooperatively
multitasked programs written in algorithmic style.
It is hybrid functional, procedural
and object oriented system

.SH TECHNOLOGY
.B Felix
generates C++ which is then built into a shared library
and dynamically loaded by a client written architectural
framework, which is also responsible for feeding an appropriate
Felix coroutine messages.
.br
.B Felix
provides no primitive types. Instead, it provides
powerful type combinators, and a facility for
binding C++ types to Felix ones. A set of basic
primitive types are provided in the standard library.

.SH C++ bindings 
Here is an example of a C++ binding.

.B type
int = "int";
.br
.B fun 
add: int * int -> int = "$1+$2";
.br
.B proc 
print: int = 'printf("%d",$1);';

.SH Exporting symbols
Symbols are exported by the export statement.
.B export
add of int * int as "add_int";
.br
.B export
int as "flx_int";

.SH FILES
.B *.flx
are Felix input files
.br
.B *.cpp
generated 
C++ implementation files
.B *.hpp
generated 
C++ header files

.B std.flx
is the standard library.
.SH SEE ALSO
.B flx(1) 
for a list of the tools.
.B flx_op(1)
for a list of operators

.SH WEB SITE
See 
.B http://felix.sf.net

.SH AUTHOR
John Maxwell Skaller, mailto:skaller@ozemail.com.au

@select(tangler('man/flx_op.1'))
.TH FELIX OPERATORS "2002 April 11"
.SH NAME
Felix operators and operator names
(these need to be checked!).

A chainable binary operator such as +
creates a list of subexpressions.

.SH assignment
Assignment operators are sugar for statements,
so only one is allowed.

.B = asgn  
.br
.B <- asgn 
.br
.B := asgn 
.br
.B += pluseq
.br
.B -= minuseq
.br
.B *= muleq
.br
.B /= diveq
.br
.B %= modeq
.br
.B |= oreq
.br
.B ^= xoreq
.br
.B &= andeq
.br

.SH tuple
.B , chain
.br

.SH logic 
Note that "shortcut" doesn't apply in Felix since
expressions are purely functional.

.B || lor 
chain
.br
.B && land 
chain
.br
.B ! lnot 
prefix
.br

.SH comparison
.B == eq 
binary
.br
.B <= le 
chain
.br
.B < lt 
chain
.br
.B >= ge 
chain
.br
.B > gt 
chain
.br
.B <> ne 
chain
.br
.B != ne 
chain
.br

.B -> arrow
left assoc
.br

.B case <int> of <int>
unassoc
.br

.SH numeric
Note that + has a lower precedence than -,
and * has a lower precedence than / which is
unusual.

.B - sub 
left assoc
.br
.B + add 
chain
.br
.B * mul 
chain
.br
.B / div 
left assoc
.br
.B % mod 
left assoc
.br
.B - sub 
prefix 
.br
.B + sub 
prefix 
.br
.B ** 
pow
right (special prec rules)
.br

.SH addressing
.B & 
prefix 
.br
.B * 
prefix
.br

.SH bitwise 
.B | bor 
chain
.br
.B ^ xor 
chain
.br
.B & band 
chain
.br
.B ~ bnot 
prefix
.br

.SH application
.B (juxtaposition) 
left assoc

.SH coercion
.B :
left assoc

.SH component
.B . 
left assoc
.br

.SH qualified name
.B :: 
left assoc
.br

.SH suffixed name
.B of
left assoc

.SH SEE ALSO
.B flx(1) 
for a list of the tools.
.B felix(1)
for a language introduction

.SH WEB SITE
See 
.B http://felix.sf.net

.SH AUTHOR
John Maxwell Skaller, mailto:skaller@ozemail.com.au

@select(tangler('man/flx.1'))
.TH FELIX TOOLS "2002 April 11"
.SH NAME
Felix tools
.SH SYNOPSIS
.br
.B flxl 
[-Iinclude-dir]
filebasename

.br
.B flxp 
[-Iinclude-dir]
filebasename

.br
.B flxd 
[-Iinclude-dir]
filebasename

.br
.B flxb 
[-Iinclude-dir]
filebasename

.br
.B flxg 
[-v]
[-Iinclude-dir]
filebasename

.br
.B flx_run 
libname

.br
.B flx
filebasename

.SH DESCRIPTION
The 
.B filebase 
name must not include an extension, which
must be '.flx'.
.br

.B flxl 
lexes the input and prints the token list to standard output

.br
.B flxp
lexes and parses the input and prints the parse tree to standard output

.br
.B flxd
lexes, parses and
desugars the the input and prints the desugared 
AST tree to standard output

.br
.B flxb
lexes, parses, desugars and binds identifiers and prints
the bindings to  standard output

.br
.B flxg
lexes, parses, desugars, binds, and generates C++ code.
Two files,
.B filebase.cpp
and
.B filebase.hpp
are created. Use the 
.B -v 
option for verbose output.

.br
.B flx 
is a load and go test harness which compiles its
argument to C++, compiles and links the C++ using gcc,
then executes the resulting library using flx_run.

.SH USE
.B flxg
is the compiler proper. flx[lpdb] are provided to
aid in debugging, and perform successive phases of
the compilation process.

.B flx
is a script which combines felix compilation,
C++ compilation of the output, and execution
using the standard program driver,
for rapid prototyping in a scripting style.

.B flx_run
is the standard prgram driver. Its argument
is a shared library which is passed to 
dlopen (note you need to use ./lib.so on
linux to preempt the stanard search path).

The driver creates a single thread
from the libraries main entry point
.B _init_
and runs the thread until it terminates,
then exits. The message type here is 
.B void
and the driver exists with an error
diagnostic if the thread tries to read
any messages.

.B flx_sif
is like 
.B flx_run
except that it reads standard input
and passes lines to the single instance
thread. The lines include terminating
newline character. A zero length line
is passed at end of file. The message 
types is 
.B std::basic_string<char>

.SH WEB SITE
See 
.B http://felix.sf.net

.SH BUGS
Plenty, this is a pre-alpha release.

.SH TODO
Separate compilation is the big one.

.SH SEE ALSO
Felix(1) for a brief introduction to the language.

.SH AUTHOR
John Maxwell Skaller, mailto:skaller@ozemail.com.au

@head(1,'Makefile')
@select(tangler('makefile'))
@tangle('all: dummy')
@tangle('\tpython script/maker')
@tangle('')
@tangle('doc: dummy')
@tangle('\tpython script/maker doc')
@tangle('\tcp doc/*.css tut/doc')
@tangle('')
@tangle('test: dummy')
@tangle('\tpython script/maker test stop_on_error')
@tangle('')
@tangle('tarball: dummy')
@tangle('\ttar -zcvf flx_'+flx_version+'_linux.tgz\\')
@tangle('\t\tmakefile README CONTENTS INSTALL VERSION  \\')
@tangle('\t\tlpsrc/*.ipk \\')
@tangle('\t\tlpsrc/*.pak \\')
@tangle('\t\tscript/maker \\')
@tangle('\t\tsrc/*.ml \\')
@tangle('\t\tsrc/*.mli \\')
@tangle('\t\tsrc/*.mly \\')
@tangle('\t\tsrc/*.mll \\')
@tangle('\t\tlib/*.flx \\')
@tangle('\t\ttest/*.flx \\')
@tangle('\t\ttest/*.cpp \\')
@tangle('\t\ttest/*.hpp \\')
@tangle('\t\ttut/examples/*.flx \\')
@tangle('\t\ttut/doc/*.html \\')
@tangle('\t\ttut/doc/*.css \\')
@tangle('\t\ttut/doc/*.tex \\')
@tangle('\t\tdoc/*.html \\')
@tangle('\t\tdoc/*.css \\')
@tangle('\t\tdoc/*.tex \\')
@tangle('\t\tbin/flx \\')
@tangle('\t\tbin/flxg \\')
@tangle('\t\tbin/flx_run \\')
@tangle('')
@tangle('www: dummy')
@tangle('\tiscr lpsrc/flx_sourceforge.pak')
@tangle('')
@tangle('upload_www: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('')
@tangle('upload: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('\tscp flx_'+flx_version+'_linux.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('test_clean: dummy')
@tangle('\trm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so')
@tangle('\trm -rf test/rt*.cpp test/rt*.hpp test/rt*.so')
@tangle('')
@tangle('really_clean: dummy')
@tangle('\trm -rf tut test www src misc man script bin doc lib tmp.tmp')
@tangle('')
@tangle('boot: dummy')
@tangle('\tiscr lpsrc/flx.pak')
@tangle('')
@tangle('dummy:')
@tangle('\techo "out of date"')
@tangle('')

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..

@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

  makefile
@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENSE   license details
The directories are:

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler,
          -- the tutorial .. and everything else
  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory

@head(1,'VERSION')
@select(tangler('VERSION'))
@tangle('This is Felix version '+flx_version)

@head(1,'LICENSE')
@select(tangler('LICENSE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the author
is not misrepresented in any way.


@head(1,'INSTALL')
@select(tangler('INSTALL'))
LINUX
-----

You don't need to build anything, though you can.
The compiler binary and run time are already
packaged in this tarball. You can just run

  make test

immediately.

UNIX SOURCE BUILD
-----------------

You need ocaml and Python as described in the full
build below, but interscript is not required,
since all the extracted sources and documentation
are already included in this tarball. You can just

   make
   make test


FULL BUILD.
-----------

1. Download, build, and install Ocaml 3.04 
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download and install Interscript
   if you don't have it already -- requires Python

   http://interscript.sourceforge.net

4. Download the Felix tarball (this package)
   and unpack it into a clean directory (the felix directory)

@tangle('   tar -zxvf felix_'+flx_version+'_linux.tgz')

   Don't worry about the "linux" part of the name.
   Some binaries are installed which are ready to
   go on Linux, but the build will replace them

   Heh. Until you get this step, you can't read
   this INSTALL file anyhow :-)

5. Build the compiler

   make

6. Build the documentation and tutorial

   make doc

7. Test the compiler

   make test

IF IT DOESN'T WORK
------------------

The build as described will NOT work on non-Unix systems,
and it will NOT work unless you have gcc.

You will need to edit 'script/maker' and 'bin/flx'
scripts to change the compiler and/or compiler options.
It is essential to edit the LP sources in the file

  lpsrc/flx_maker.ipk

if you want these changes to persist, since the next
LP extract (tangle) process will replace these files
with one generated from the LP sources.

On Windows: for non Cygwin systems, you will have to
modify the driver programs, since they use
Unix dlopen/dlsym to open shared libraries.

On Mac: Ocaml doesn't provide an optimising
compiler for this platform. You will need to change
the ocaml compiler from 'ocamlopt.opt' to just 'ocamlc'.
This will make a bytecode version of the felix compiler,
which should work just fine. It is unlikely that Felix
can run using shared libraries on a Mac, other than the
OSX platform (latest iMac) which is a FreeBSD Unix variant.

REBUILD
-------

Normally, 'make' and 'make test' should be sensitive
to source code changes, but sometimes this doesn't
work. You will need:

  make test_clean    -- delete all C/C++ generated from felix files
                        to force the felix compiler to rebuild them

  make very_clean    -- this deletes EVERYTHING except the LP sources

  iscr lpsrc/flx.pak -- re-extract sources, including makefile
  make boot          -- use this to rebuild after a make very_clean,
                        but you need iscr lpsrc/flx.pak to re-extract
                        the makefile :-)

@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.

@select(tangler('doc/interscript.css'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('doc/user.css'))
// dummy: to be replaced by the user (but needed for some browsers)

@head(1,'Run script')
@select(tangler('bin/flx'))
#/bin/env sh
if [ "$1.flx" -nt "$1.so" ];
then
  rm -f $1.cpp $1.hpp $1.so
  if 
    ./bin/flxg -q -Ilib $1
  then
    if 
      g++ -Wno-long-long -D_GNU_SOURCE -ansi -shared  \
        $1.cpp \
        -o $1.so
    then
      ./bin/flx_run ./$1.so
    fi
  fi
else
  ./bin/flx_run ./$1.so
fi

@os.system('chmod a+x bin/flx')
@os.system('cp doc/*.css tut/doc')

