@head(2,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID

@h = tangler('script/fcount.py','python')
@select(h)
import glob
import os
import sys
try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

try:
  key = sys.argv[2]
except:
  key = "std"

try:
  globspec = sys.argv[3]
except:
  globspec = "tut/examples/*.hpp"

print "function counter: STATS FILE",filename, "KEY", key, "GLOB",globspec
dict = {}
try:
  execfile (filename)
except:pass

def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  return result,output


files = glob.glob(globspec)

for file in files:
  cmd = 'egrep "//PROC|//FUNCTION" ' + file + ' | wc -l'
  result,output = get_stdout(cmd)
  output = output[0][:-1]
  x = int(output)
  try:
    d= dict[file]
  except:
    dict[file]={}
    d = dict[file]
  d[key]=x

f = open(filename,"w")
f.write("dict="+repr(dict))
f.close()

@h = tangler('script/pfcount.py','python')
@select(h)
import glob
import os
import sys
try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

only_nonopt = 0
try:
  x = sys.argv[2]
except:
  only_nonopt = 1

dict = {}
try:
  execfile (filename)
except:pass

keys = {}
i = 0
for k in dict.keys():
  i = max(i,len(k))
  d = dict[k]
  for key in d.keys():
    keys[key]=None

keys = keys.keys()
j=0
for k in keys:
  j = max(j,len(k))

print "Function counts for test programs"
print "================================="
print
print ("%-"+str(i+2)+"s") % "File" + "    ",
for t in keys:
  print ("%"+str(j+2)+"s") % t,
print
print "--------"

skeys = dict.keys()
skeys.sort()

for k in skeys:
  d = dict[k]
  x= ("%-"+str(i+2)+"s") % k + "..  "
  discard = 0
  for t in keys:
    v = d.get(t,-1)
    if v == -1:
      v = ""
    elif (v == 1 or v == 0) and t == "inline" and only_nonopt: 
      discard = 1
      break
    else:
      v = str(v)
    v = ("%"+str(j+2)+"s") % v
    x = x+v
  if not discard: print x


@h = tangler('script/detab.py','python')
@select(h)
import string
import sys

f = open(sys.argv[1])
data = f.readlines()
f.close()
f = open(sys.argv[1],"w")
for line in data:
  line = string.expandtabs(line)
  f.write(line)
f.close()

@h = tangler('script/mksm.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/smbase/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'cycles.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
  'mypopen.h',
  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'unixutil.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'cycles.c',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
  'mypopen.c',
  'mysig.cc',
  'point.cc',
  'pprint.cc',
  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'unixutil.c',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

mods = {}
tgts = [] 

for fn in sm_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/sm_'+base
  if target[-2:]=='cc': 
    target = target[:-2]+'cpp'
  elif target[-1:]=='c':
    target = target[:-1]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'smbase')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkast.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/ast/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'cycles.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
  'mypopen.h',
  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'unixutil.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'cycles.c',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
  'mypopen.c',
  'mysig.cc',
  'point.cc',
  'pprint.cc',
  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'unixutil.c',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]


ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]
mods = {}
tgts = [] 

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""


for fn in ast_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/ast_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

print "@head(1,'ast')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  'sm_cycles',
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkelk.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/elkhound/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'cycles.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
  'mypopen.h',
  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'unixutil.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'cycles.c',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
  'mypopen.c',
  'mysig.cc',
  'point.cc',
  'pprint.cc',
  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'unixutil.c',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]

elk_files = [
  'gramlex.lex',
  'grampar.y',
  'asockind.h',
  'cyctimer.h',
  'emitcode.h',
  'flatutil.h',
  'genml.h',
  'glrconfig.h',
  'glr.h',
  'gramanl.h',
  'gramast.ast.gen.h',
  'grammar.h',
  'grampar.codes.h',
  'grampar.h',
  'grampar.tab.h',
  'lexerint.h',
  'mlsstr.h',
  'ownerspec.h',
  'parsetables.h',
  'ptreeact.h',
  'ptreenode.h',
  'rcptr.h',
  'useract.h',
  'util.h',
  'asockind.cc',
  'cyctimer.cc',
  'emitcode.cc',
  'genml.cc',
  'glr.cc',
  'gramanl.cc',
  'gramast.ast.gen.cc',
  'gramlex.yy.cc',
  'grampar.cc',
  'grampar.tab.cc',
  'grammar.cc',
  'mlsstr.cc',
  'parsetables.cc',
  'ptreeact.cc',
  'ptreenode.cc',
  'useract.cc',
  'gramexpl.cc'
]
mods = {}
tgts = [] 


for fn in elk_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/elk_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'elkhound')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      elif fl in elk_files:
        print '#include "elk_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkocs.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/ocs-1.0/src/'

files = [
  'ocs_char.ml',
  'ocs_char.mli',
  'ocs_compile.ml',
  'ocs_compile.mli',
  'ocs_complex.ml',
  'ocs_complex.mli',
  'ocs_contin.ml',
  'ocs_contin.mli',
  'ocs_env.ml',
  'ocs_env.mli',
  'ocs_error.ml',
  'ocs_eval.ml',
  'ocs_eval.mli',
  'ocs_io.ml',
  'ocs_io.mli',
  'ocs_lex.ml',
  'ocs_lex.mli',
  'ocs_list.ml',
  'ocs_list.mli',
  'ocs_macro.ml',
  'ocs_macro.mli',
  'ocs_main.ml',
  'ocs_misc.ml',
  'ocs_misc.mli',
  'ocs_numaux.ml',
  'ocs_numaux.mli',
  'ocs_num.ml',
  'ocs_num.mli',
  'ocs_numstr.ml',
  'ocs_numstr.mli',
  'ocs_port.ml',
  'ocs_port.mli',
  'ocs_prim.ml',
  'ocs_prim.mli',
  'ocs_print.ml',
  'ocs_print.mli',
  'ocs_read.ml',
  'ocs_read.mli',
  'ocs_string.ml',
  'ocs_string.mli',
  'ocs_sym.ml',
  'ocs_sym.mli',
  'ocs_top.ml',
  'ocs_top.mli',
  'ocs_types.mli',
  'ocs_vartable.ml',
  'ocs_vartable.mli',
  'ocs_vector.ml',
  'ocs_vector.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'OCS')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/lua-5.0.2/src/'

files = [
  'lapi.c',
  'lapi.h',
  'lcode.c',
  'lcode.h',
  'ldebug.c',
  'ldebug.h',
  'ldo.c',
  'ldo.h',
  'ldump.c',
  'lfunc.c',
  'lfunc.h',
  'lgc.c',
  'lgc.h',
  'llex.c',
  'llex.h',
  'llimits.h',
  'lmem.c',
  'lmem.h',
  'lobject.c',
  'lobject.h',
  'lopcodes.c',
  'lopcodes.h',
  'lparser.c',
  'lparser.h',
  'lstate.c',
  'lstate.h',
  'lstring.c',
  'lstring.h',
  'ltable.c',
  'ltable.h',
  'ltests.c',
  'ltm.c',
  'ltm.h',
  'lundump.c',
  'lundump.h',
  'lvm.c',
  'lvm.h',
  'lzio.c',
  'lzio.h',
  'lib/lauxlib.c',
  'lib/lbaselib.c',
  'lib/ldblib.c',
  'lib/liolib.c',
  'lib/lmathlib.c',
  'lib/loadlib.c',
  'lib/lstrlib.c',
  'lib/ltablib.c',
  'luac/luac.c',
  'lua/lua.c',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[-1]=='c' :
    target = 'lua/'+base+'pp'
  else:
    target = 'lua/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'Lua')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua_scripts.py','python')
@select(h)

import string
import os
import glob

prefix = '/usr/local/src/lua-5.0.2/test/'
files = glob.glob(prefix+'*.lua')
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'misc/lua/'+base
  tgts.append((fn,target))

print "@head(1,'Lua test scripts')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mkcil.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/cil/'
files = [
  'src/check.ml',
  'src/check.mli',
  'src/cil.ml',
  'src/cil.mli',
  'src/cilutil.ml',
  'src/clist.ml',
  'src/clist.mli',
  'src/escape.ml',
  'src/escape.mli',
  'src/formatcil.ml',
  'src/formatcil.mli',
  'src/formatlex.mll',
  'src/formatparse.mly',
  'src/libmaincil.ml',
  'src/maincil.ml',
  'src/mergecil.ml',
  'src/mergecil.mli',
  'src/rmtmps.ml',
  'src/rmtmps.mli',
  'src/testcil.ml',
  'src/frontc/cabs2cil.ml',
  'src/frontc/cabs2cil.mli',
  'src/frontc/cabs.ml',
  'src/frontc/cabsvisit.ml',
  'src/frontc/cabsvisit.mli',
  'src/frontc/clexer.mli',
  'src/frontc/clexer.mll',
  'src/frontc/cparser.mly',
  'src/frontc/cprint.ml',
  'src/frontc/frontc.ml',
  'src/frontc/frontc.mli',
  'src/frontc/lexerhack.ml',
  'src/frontc/patch.ml',
  'src/frontc/patch.mli',
  'ocamlutil/errormsg.ml',
  'ocamlutil/errormsg.mli',
  'ocamlutil/inthash.ml',
  'ocamlutil/pretty.ml',
  'ocamlutil/pretty.mli',
  'ocamlutil/stats.ml',
  'ocamlutil/stats.mli',
  'ocamlutil/trace.ml',
  'ocamlutil/trace.mli',
  'ocamlutil/util.ml',
  'ocamlutil/util.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/flx_cil_'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')
  m = base[:i]
  mods[string.capitalize(m)]='Flx_cil_' + m

ms = mods.keys()
for k in ms:
  print mods[k]

print "@head(1,'CIL')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    for s in ms:
      r = mods[s]
      line = string.replace(line,s,r)
    print line,
      
@h = tangler('script/mk_fish','python')
@select(h)
import glob
glob = glob.glob

for i in glob("*.mli")+glob("*.mll")+glob("*.mly")+glob("*.ml"):
  if i not in ["parse_fish.ml","lex_fish.ml"]:
    print '@head(2,"'+i+'")'
    print i+"."
    print '@select(tangler("src/'+i+'"))'
    f = open(i)
    for j in f: print j,
    f.close()
    print

@h = tangler('script/mk_expect','python')
@select(h)
import glob
import sys
for k in sys.argv[1:]:
  files = glob.glob(k+'/*.output')
  print '@head(1,"Expected outputs for '+k+'")'
  for i in files:
    j = i[:-7]+'.expect'
    print '@head(2,"'+j+'")'
    print '@select(tangler("'+j+'","data"))'
    f = open(i,"r")
    for l in f: print l,
    f.close()

@h = tangler('script/elk_flx_grgen','python')
@select(h)
import string
import sys

ts ={}
nt = ""
d = {}

def isterminal(w):
  return w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def isnonterminal(w): 
  return not isterminal(w)

def check_symbol(w):
  if isterminal(w): ts[w]=1

def cvt_symbol(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/': 
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state: 
      if l <> "\n":
        handle_line(l[:-1])
    else: 
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

ts['WSTRING']=1
ts['USTRING']=1
ts = ts.keys()
ts.sort()
print "terminals {"
print "   0 : TOK_EOF;"
j = 1
for k in ts:
  print ' ',"%4d" % j,': TOK_'+k,';'
  j = j + 1
print
attrtoks = ["CSTRING","STRING","WSTRING","USTRING","NAME","FLOAT","INTEGER"]
for k in attrtoks:
  print "  token(void*) TOK_"+k+";"

print "}"
print 
 
print "context_class Flx_Elk_Parser : public UserActions {};"
print
print "nonterm(void*) top {"
print "  -> _1:compilation_unit { return _1; }"
print "}"
print
ntno = 1
for k in d.keys():
  print "nonterm(void*)",k," {"
  v = d[k]
  for p in v:
    print "  -> ",
    acnt = 0
    for w in p:
      s = cvt_symbol(w)
      if w in attrtoks or not isterminal(s):
        acnt = acnt + 1
        print "_"+str(acnt)+":"+s,
      else:
        print cvt_symbol(w),
    print "  {"
    print "     void **data = (void**)malloc(sizeof(void*)*"+str(acnt+1)+");"
    print "     data[0] = (void*)"+str(acnt)+";"
    for i in range(1,acnt+1):
      print "     data["+str(i)+"] = _"+str(i)+";"
    print "     return (void*)data;"
    print "  }"
  print "}"
  print
 
@h = tangler('script/flx_flx_grgen','python')
@select(h)
import string
import sys

ts ={}
nt = ""
d = {}

def isterminal(w):
  return w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def isnonterminal(w):
  return not isterminal(w)

def check_symbol(w):
  if isterminal(w): ts[w]=1

def cvt_symbol(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return w

def cvt_symbol2(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return "nt_"+w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/':
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state:
      if l <> "\n":
        handle_line(l[:-1])
    else:
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

attrtok_map = {
  "CSTRING":'string',
  "STRING":'string',
  "WSTRING":'string',
  "USTRING":'string',
  "NAME":'string',
  "FLOAT":'string',
  "INTEGER":'(string * string)',
}
attrtoks = attrtok_map.keys()

print 'include "std";'
print 'include "flx_token";'
print
print 'module flx_grammar'
print '{'
print '  open flx_token;'

print

print '  '+"nonterm top:compilation_unit_t ="
print '  '+"  | _1:nt_compilation_unit =>  _1 "
print '  '+";"
print
for k in d.keys():
  print '  '+"union",k+"_t ="
  v = d[k]
  pno = 0
  nps = len(v)
  for p in v:
    pno = pno + 1
    s = "  |  "
    acnt = 0
    l = len (p)
    j = 0
    s= "  | " + k+"_"+str(pno)
    lead = " of "
    for w in p:
      ss = cvt_symbol(w)
      if w in attrtoks:
        s = s + lead +attrtok_map[w]
        lead = " * "
      elif not isterminal(w):
        acnt = acnt + 1
        s=s+ lead + ss+ "_t"
        lead = " * "
      j = j + 1
    print '  '+s
  print '  '+";"
  print

  print '  '+"nonterm nt_"+k,":",k+"_t ="
  v = d[k]
  pno = 0
  nps = len(v)
  for p in v:
    pno = pno + 1
    s = "  |  "
    acnt = 0
    l = len (p)
    j = 0
    for w in p:
      ss = cvt_symbol2(w)
      if w in attrtoks or not isterminal(w):
        acnt = acnt + 1
        s=s+ "_"+str(acnt)+":"+ss
      else:
        s=s+ss
      j = j + 1
      if j != l:
        s=s+" "
    print '  '+s

    s= "    => " + k+"_"+str(pno)
    if acnt > 0: s=s+"("
    for i in range(1,acnt+1):
      s = s + "_"+str(i)
      if i != acnt:
        s= s + ", "
    if acnt > 0: s=s+")"
    print '  '+s
    if pno != nps: print
  print '  '+";"
  print
print "}"

@h = tangler('script/flx_tokgen','python')
@select(h)
import string
import sys
execfile ("config/flx_data.py")
ts ={}
for k,t in flx_keywords: ts[t]=1
for t,l in flx_1_char_syms: ts[t]=1
for t,l in flx_2_char_syms: ts[t]=1
for t,l in flx_3_char_syms: ts[t]=1
ts['ERROR']=1

nt = ""
d = {}

def isterminal(w):
  return w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def isnonterminal(w): 
  return not isterminal(w)

def check_symbol(w):
  if isterminal(w): ts[w]=1

def cvt_symbol(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return w

def cvt_symbol2(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return "nt_"+w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/': 
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state: 
      if l <> "\n":
        handle_line(l[:-1])
    else: 
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

attrtok_map = {
  "ERROR":'string',
  "CSTRING":'string',
  "STRING":'string',
  "WSTRING":'string',
  "USTRING":'string',
  "NAME":'string',
  "FLOAT":'string',
  "INTEGER":'(string * string)',
}
attrtoks = attrtok_map.keys()

ts['WSTRING']=1
ts['USTRING']=1
ts = ts.keys()
ts.sort()
print 'include "std";'
print 
print 'module flx_token'
print '{'

print "  union flx_token_t = "
print "    | TOK_EOF                                 //0"
j = 1
for k in ts:
  s = '  | TOK_'+k
  if k in attrtoks:
    s = s + " of " + attrtok_map[k]
  print '  '+(s  + " " *45)[:45]+'//'+str(j)
  j = j + 1
print '  '+";"
print 
print "}" 

@h = tangler('script/elk_flx_lexgen','python')
@select(h)
import string
import sys

ts ={}
nt = ""
d = {}

def check_symbol(w):
  if w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
    ts[w]=1

def cvt_symbol(w):
  if w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
    return "TOK_" + w
  else:
    return w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/': 
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state: 
      if l <> "\n":
        handle_line(l[:-1])
    else: 
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

ts['WSTRING']=1
ts['USTRING']=1
ts = ts.keys()
ts.sort()
print '#include "elk_flx_lexer.h"'
print '#include "stdio.h"'
print '#include "string.h"'
print
print "enum Elk_Flx_Lexcode {"
print "  TOK_EOF,                    //0"
j=1
for k in ts:
    print ('  TOK_'+k+',                        ')[:30]+'//'+str(j)
    j = j + 1
print "};"
print 

print "char *Elk_Flx_Lexcode_Desc[] = {"
print '  "TOK_EOF",                    //0'
j=1
for k in ts:
  print ('  "TOK_'+k+'",                        ')[:30]+'//'+str(j)
  j = j + 1
print "};"
print 

n = len(ts)+1
print "static int const ntoks = "+str(n)+";"


print r"""
string Elk_Flx_Lexer::tokenDesc() const
{
  switch (type) {
    case TOK_NAME:   
    case TOK_INTEGER:   
    case TOK_FLOAT:   
    case TOK_STRING:   
    case TOK_CSTRING:   
    case TOK_WSTRING:   
    case TOK_USTRING:   
    {
      char buffer[200];
      strcpy(buffer,tokenKindDesc(type));
      strcat(buffer,"=");
      strcat(buffer,(char*)sval);
      return buffer;
    }
    default:               return tokenKindDesc(type);
  }
}

string Elk_Flx_Lexer::tokenKindDesc(int kind) const {
  return Elk_Flx_Lexcode_Desc[kind];
}

void Elk_Flx_Lexer::nextToken(LexerInterface *lex) {
  char buffer[100];
  if (fgets(buffer,100,stdin)) {
    int n = strlen(buffer) - 1; //skip the newline
    memmove(buffer+4,buffer,n); 
    memcpy(buffer,"TOK_",4);
    n+=4;
    buffer[n]=0;
    buffer[n+1]=0;
    char *extra = buffer;
    // skip non white
    while(*extra && *extra != ' ')++extra;
    
    // terminate token
    *extra++ = 0;

    // skip white
    while(*extra && *extra == ' ')++extra;
    
    int k;
    for(k=0; k<ntoks; ++k)
      if(strcmp(Elk_Flx_Lexcode_Desc[k],buffer)==0)
        break;
    if(k==ntoks) {
      printf("Invalid token '%s'",buffer); 
      abort();
    }
    lex->type = k;
    lex->sval = (SemanticValue)extra;
  }
  else {
    lex->type = TOK_EOF;
    lex->sval = NULL;
  }
  return;
}


#ifdef TEST_LEXER
int main()
{
  Elk_Flx_Lexer lexer;
  for (;;) {
    lexer.getTokenFunc()(&lexer);    // first call yields a function pointer
                                                                                
    // print the returned token
    string desc = lexer.tokenDesc();
    printf("%s\n", (char const*)desc);
                                                                                
    if (lexer.type == TOK_ENDMARKER) {
      break;
    }
  }
                                                                                
  return 0;
}
#endif // TEST_LEXER
"""

@h = tangler('misc/elk_flx_lexer.h')
@select(h)
#ifndef ELK_FLX_LEXER
#define ELK_FLX_LEXER

#include "lexerint.h"
// read characters from stdin, yield tokens for the parser
class Elk_Flx_Lexer : public LexerInterface {
public:
  // function that retrieves the next token from
  // the input stream
  static void nextToken(LexerInterface *lex);
  virtual NextTokenFunc getTokenFunc() const
    { return &Elk_Flx_Lexer::nextToken; }
 
  // debugging assistance functions
  string tokenDesc() const;
  string tokenKindDesc(int kind) const;
};

#endif

@h = tangler('script/get_grammar','python')
@select(h)
import string
import sys
f = open(sys.argv[1])
start = 0
count = 0
for l in f:
  if start:
    if l[:2]=='%%': start=0
    else:
      out = ""
      for ch in l:
        if ch == '{': count+=1
        elif ch == '}': count-=1
        elif count == 0: out += ch
      out = string.strip(out)
      if out: 
        if out[0]=='|': 
          out = string.strip(out[1:])
          if out=="": print "  | /* empty */"
          else: print "  | "+out
        elif out[-1]==':': 
          print 
          print out
        elif out==';': pass
        else: 
          print out
  elif l[:2]=='%%': start=1
f.close()


@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
@tangle("FLX_MAKER_CVS_ID='"+FLX_MAKER_CVS_ID+"'")
import os
import stat
import string
import sys
import re


try:
  execfile("config/config.py")
except:
  print "ERROR IN config/config.py"
  print "You must either"
  print "(a) edit config/config.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

FLXFLAGS = ""

# --------------------------------------------------
# IMPORT UTILITY RESOURCES
# ---------------------------------------------------
def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  return result,output

def get_stdouterr(x):
  return get_stdout(x+" 2>&1")

def flush():
  try: sys.stdin.flush()
  except: pass

def run(x):
  print x
  flush()
  result = os.system(ENV+x)
  if result: print "  .. ERROR CODE",hex(result)
  flush()

  if result:
    raise MakeError


def xqt(x):
  if "quiet" not in options: print x
  flush()
  result,output = get_stdouterr(x)
  if result: 
    if "quiet" in options: print x
    print "  .. ERROR CODE",hex(result)
  if output: 
    if result or "quiet" not in options:
      print string.join(output,"")
  flush()

  if result:
    raise MakeError

ENV = 'env PATH=bin:$PATH LD_LIBRARY_PATH=rtl:$LD_LIBRARY_PATH '
def exqt(x): xqt(ENV+x)

# used when a negative result is expected (return code is supposed to be nonzero)
# used for a grep which is supposed to fail
def nxqt(x):
  x = ENV+x
  if "quiet" not in options: print x
  flush()
  result,output = get_stdouterr(x)
  if not result:
    if output: print string.join(output,"")
  flush()

  if not result:
    raise MakeError


# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

options = sys.argv[1:]
CCMACS=""
for i in options:
  if i[0:2]=="-D": CCMACS=CCMACS+i+" "

if "silent" in options: 
  options.append("quiet")

if "bagley" in options: 
  options.append("time_execution")
  options.append("inline")

if "inline" in options:
  FLXFLAGS = FLXFLAGS + "--inline "
if options:
  print "OPTIONS: ", options

if "compiler" in options or "bytecode" in options or "olink" in options:
  options.append("flxcc")
  options.append("felix")

keyopt = {}
for o in options:
  try:
    key,value = string.split(o,"+=")
    old = keyopt.get(key,[])
    if type(old) == type(""): old = [old]
    keyopt[key] = old + [value]
  except:
    try:
      key,value = string.split(o,"=")
      keyopt[key]=value
    except: pass

USER_TESTS = keyopt.get("flx",[])
if type(USER_TESTS) == type(""):
  USER_TESTS = [USER_TESTS]

if "help" in options:
  print "extract - extract sources"
  print "compiler - build compiler"
  print "bytecode - build bytecode version of compiler"
  print "profile - build profiling version of compiler"
  print "drivers - build drivers"
  print "regression - run regression tests"
  print "performance - run performance tests"
  print "bagley - run bagley shootout performance tests"
  print "tutorial - run tutorial examples"
  print "tests- regression and tutorial combined"
  print "clean - remove generated C++ and binaries from test locations"
  print "debug - build debugging versions of targets"
  print "optimise_c - build high performance versions of c++ targets"
  print "optimise_felix - build high performance versions of ocaml targets NOT RECOMMENDED!"
  print "doc - build all user documentation"

if "clean" in options:
  os.system("rm -rf test/*.cpp test/*.hpp test/*.so test/*.par")
  os.system("rm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so tut/examples/*.par")
  os.system("rm -rf bagley/felix/*.cpp bagley/felix/*.hpp bagley/felix/*.so bagley/felix/*.par")

if "tests" in options or "test" in options:
  options = options + ["regression","tutorial"]

def flxg(x,basename):
  x = './bin/flxg ' + x
  exqt(x)

# ------------------------------------------------
# BEGIN USER CONFIGURABLE SECTION
#-------------------------------------------------

#interscript command (now built in part of Felix package)
def runISCR(a):
  if buildall:
    xqt(ISCR + "--nocache " + a)
  else:
    xqt(ISCR + ' ' + a)

if "compiler" in options or "bytecode" in options or "olink" in options:
  OCAML_OBJDIR = "src"
  BYTECODE = not NATIVE_CODE_COMPILER or "bytecode" in options 
  if BYTECODE:
    if "profile" in options: 
      OCAMLOPT = OCAMLCP
      OCAMLC = OCAMLCP
    else: OCAMLOPT = OCAMLB
  else:
    OCAMLOPT = OCAMLC
    if "profile" in options:
      OCAMLOPT = OCAMLOPT+' -p '
  
  OCAMLOPT = OCAMLOPT + " -I " + OCAML_OBJDIR
  OCAMLC = OCAMLC + " -I " + OCAML_OBJDIR
  
  if "debug" in options:
    OCAMLOPT = OCAMLOPT + '-g '

  if "optimise_felix" in options:
    OCAMLOPT = OCAMLOPT + " -unsafe -noassert -inline 5 "

  if BYTECODE == 0:
    OCAML_OBJECT_EXTENSION = '.cmx'
    OCAML_LIB_EXTENSION = '.cmxa'
  else:
    OCAML_OBJECT_EXTENSION = '.cmo'
    OCAML_LIB_EXTENSION = '.cma'
    
# where gnu readline header files are
#READLINE_INCLUDE_DIRECTORY='/usr/include/readline'

#determine linkage model

LINK_MODEL = DEFAULT_LINK_MODEL
if "static" in options:
  LINK_MODEL = "static"
if "dynamic" in options:
  LINK_MODEL == "dynamic"

if LINK_MODEL == "dynamic" and not SUPPORT_DYNAMIC_LOADING:
  print "dynamic linkage not supported"
  sys.exit(1)

if LINK_MODEL == "static" and not SUPPORT_STATIC_LINKAGE:
  print "dynamic linkage not supported"
  sys.exit(1)

CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "
CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "

if LINK_MODEL == "dynamic":
  if CYGWIN:
    SHLX = ".dll"
  else:
    SHLX = ".so"
else:
  SHLX = ""

# for compiling mainlines
if "optimise_c" in options:
  CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-O3 -fomit-frame-pointer "
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-O3 -fomit-frame-pointer "
  CCOBJ_DLLIB = CCOBJ_DLLIB + "-O3 -fomit-frame-pointer "
  CCOBJ_DLMAIN = CCOBJ_DLMAIN + "-O3 -fomit-frame-pointer "

if "debug" in options:
  CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + " -g "
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + " -g "
  CCOBJ_DLLIB = CCOBJ_DLLIB + " -g "
  CCOBJ_DLMAIN = CCOBJ_DLMAIN + " -g "



CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + ' ' + CCMACS
CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + ' ' + CCMACS
CCOBJ_DLLIB = CCOBJ_DLLIB + ' ' + CCMACS
CCOBJ_DLMAIN = CCOBJ_DLMAIN + ' '+CCMACS


# ------------------------------------------------
# END USER CONFIGURABLE SECTION
#-------------------------------------------------

# where documentation gets put
WEAVER_DIRECTORY='doc/'
TUTORIAL_DIRECTORY='tut/'
TUTORIAL_DOC=TUTORIAL_DIRECTORY+'doc/'
TUTORIAL_EXAMPLES=TUTORIAL_DIRECTORY+'examples/'

# -------------------------------------------------
# BEGIN IMPLEMENTOR CONFIGURABLE SECTION
# ------------------------------------------------

# Elkhound stuffs

SMBASE = [
]

# These are the files actually needed at run time by Felix
SMRTL = [
  'sm_malloc_stub',
  'sm_nonport',
  'sm_autofile',
  'sm_bflatten',
  'sm_bit2d',
  'sm_bitarray',
  'sm_boxprint',
  'sm_breaker',
  'sm_crc',
  'sm_datablok',
  'sm_flatten',
  'sm_growbuf',
  'sm_gprintf',
  'sm_hashline',
  'sm_hashtbl',
  'sm_missing',
  'sm_mypopen',
  'sm_mysig',
  'sm_point',
  'sm_pprint',
  'sm_regexp',
  'sm_strdict',
  'sm_strhash',
  'sm_stringset',
  'sm_strtokp',
  'sm_strutil',
  'sm_svdict',
  'sm_unixutil',
  'sm_vdtllist',
  'sm_vptrmap',
  'sm_warn',
  'sm_cycles',
  'sm_srcloc',
  'sm_syserr',
  'sm_str',
  'sm_trace',
  'sm_trdelete',
  'sm_voidlist',
  'sm_exc',
]

ASTGEN = [
  'ast_gramlex',
  'ast_ccsstr',
  'ast_reporterr',
  'ast_embedded',
  'ast_asthelp',
  'ast_strtable',
  'ast_locstr',
]

ELKHOUND = [
  'elk_asockind',
  'elk_grammar',
  'elk_emitcode',
  'elk_mlsstr',
  'elk_genml',
  'elk_gramast.ast.gen',
  'elk_gramlex.yy',
  'elk_grampar',
  'elk_grampar.tab',
  'elk_gramexpl',
]

ELKRTL = [
  'elk_cyctimer',
  'elk_glr',
  'elk_parsetables',
  'elk_useract',
  'elk_ptreenode',
  'elk_ptreeact',
]

ELKRTL_INTERFACES = [
  'sm_array.h',
  'sm_objpool.h',
  'sm_sobjlist.h',
  'sm_trdelete.h',
  'sm_voidlist.h',
  'sm_macros.h',
  'sm_srcloc.h', 
  'sm_typ.h',
  'sm_xassert.h',
  'sm_objlist.h',
  'sm_str.h',
  'elk_lexerint.h',
  'elk_glrconfig.h',
  'elk_parsetables.h',
  'elk_glr.h',
  'elk_rcptr.h',
  'elk_useract.h',
]

# files containing ocamllex sources
CIL_LEXS = [ 'flx_cil_clexer', 'flx_cil_formatlex', ]
FLX_LEXS = [ 'flx_lex' ]
MISC_LEXS = []

# files containing ocamlyacc sources
MISC_PARSES = [ ]
CIL_PARSES = [ 'flx_cil_cparser', 'flx_cil_formatparse', ]
FLX_PARSES = [ 'flx_parse' ]

# ocaml modules = interfaces + implementation files

CIL_MODULES = [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
  'flx_cil_cilversion',
  'flx_cil_machdep',
  'flx_cil_pretty',
  'flx_cil_errormsg',
  'flx_cil_cabs_helper',
  'flx_cil_lexerhack',
  'flx_cil_escape',
  'flx_cil_cprint',
  'flx_cil_cparser',
  'flx_cil_clexer',
  'flx_cil_stats',
  'flx_cil_trace',
  'flx_cil_clist',
  'flx_cil_cil',
  'flx_cil_frontc',
  'flx_cil_rmtmps',
  'flx_cil_cabsvisit',
  'flx_cil_inthash',
  'flx_cil_formatparse',
  'flx_cil_formatlex',
  'flx_cil_util',
  'flx_cil_mergecil',
  'flx_cil_patch',
  'flx_cil_formatcil',
  'flx_cil_cilutil',
  'flx_cil_cabs2cil',
  'flx_cil_check',
]

MISC_MODULES = [
  'flx_filesys'      ,
]

FLX_MODULES = [
  'flx_mtypes1'      ,
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
  'flx_version'      ,
  'flx_ctype'        ,
  'flx_util'         ,
  'flx_dlst'         ,
  'flx_getopt'       ,
  'flx_mtypes2'      ,
  'flx_srcref'       ,
  'flx_typing'       ,
  'flx_exceptions'   ,
  'flx_string'       ,
  'flx_id'           ,
  'flx_print'        ,
  'flx_maps'         ,
  'flx_typing2'      ,
  'flx_unify'        ,
  'flx_charset'      ,
  'flx_constfld'     , 
  'flx_cexpr'        ,
  'flx_csubst'       , 
  'flx_macro'        , 
  'flx_parse'        ,
  'flx_keywords'     ,
  'flx_prelex'       ,
  'flx_lex1'         ,
  'flx_tok'          ,
  'flx_lexstate'     ,
  'flx_preproc'      ,
  'flx_lex'          ,
  'flx_pretok'       ,
  'flx_parse_ctrl'   ,
  'flx_dfa'          ,
  'flx_pat'          , 
  'flx_desugar'      , 
  'flx_mbind'        , 
  'flx_symtab'       , 
  'flx_name'         , 
  'flx_treg'         ,
  'flx_beta'         ,
  'flx_generic'      , 
  'flx_overload'     , 
  'flx_lookup'       , 
  'flx_bexe'         , 
  'flx_bbind'        , 
  'flx_label'        , 
  'flx_cflow'        , 
  'flx_call'         , 
  'flx_use'          , 
  'flx_useless'      , 
  'flx_child'        , 
  'flx_tailit'       , 
  'flx_inline'       , 
  'flx_stack_calls'  , 
  'flx_mkcls'        , 
  'flx_global'       , 
  'flx_inst'         , 
  'flx_tgen'         , 
  'flx_display'      , 
  'flx_ogen'         , 
  'flx_regen'        ,
  'flx_unravel'      , 
  'flx_pgen'         , 
  'flx_egen'         , 
  'flx_ctorgen'      , 
  'flx_elkgen'       , 
  'flx_gen'          , 
  'flx_flxopt'       , 
  'flx_terminate'    , 
]

OCS_MODULES = [
  'ocs_vartable', 
  'ocs_error', 
  'ocs_port', 
  'ocs_types', 
  'ocs_sym', 
  'ocs_env',
  'ocs_char', 
  'ocs_numaux', 
  'ocs_complex', 
  'ocs_num', 
  'ocs_numstr', 
  'ocs_lex',
  'ocs_misc',
  'ocs_read', 
  'ocs_eval', 
  'ocs_list', 
  'ocs_compile', 
  'ocs_macro', 
  'ocs_prim', 
  'ocs_string',
  'ocs_vector', 
  'ocs_print', 
  'ocs_io', 
  'ocs_contin', 
  'ocs_top', 
]

CIL_RAW_INTERFACES = [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
]

FLX_RAW_INTERFACES = [
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
] 

MISC_INTERFACES = MISC_MODULES
FLX_INTERFACES = FLX_MODULES
CIL_INTERFACES = CIL_MODULES

MISC_IMPLEMENTATIONS = MISC_INTERFACES
FLX_IMPLEMENTATIONS = FLX_INTERFACES
CIL_IMPLEMENTATIONS = CIL_INTERFACES
  
IMPLEMENTATIONS = MISC_IMPLEMENTATIONS + CIL_IMPLEMENTATIONS + FLX_IMPLEMENTATIONS 
INTERFACES = MISC_INTERFACES + CIL_INTERFACES + FLX_INTERFACES
RAW_INTERFACES = CIL_RAW_INTERFACES + FLX_RAW_INTERFACES

RTL_CPPS = [
  "rtl/flx_gc",
  "rtl/flx_collector",
  "rtl/flx_rtl",
  "rtl/flx_dynlink",
  "rtl/flx_i18n",
  "rtl/flx_ioutil",
]

DRIVERS = [
  ('rtl/flx_run','bin/flx_run'),
  ('test/flx_perf_drv1','test/flx_perf_drv1'),
  ('rtl/flx_stdin_drv','bin/flx_stdin_drv'),
]

# C files that we need to compile, with options required to build them
COBJECTS = {
}
# *.so/.a libraries
CLIBRARIES = ['nums']

# *.cmxa or .cma libraries
# and some hackery so we can if the source doesn't need
# ocaml-fileutils we can still build if it isn't found
OCAML_INCLUDES = ""
OLIBRARIES = ['nums','unix','misclib','cillib','flxlib']

OCAMLLIBS = [
  ('misclib',MISC_IMPLEMENTATIONS),
  ('cillib',CIL_IMPLEMENTATIONS),
  ('flxlib',FLX_IMPLEMENTATIONS),
]

# target executable programs to produce
MISC_EXES=[]
FLX_EXES = [
  'flxl',
  'flxp',
  'flxm',
  'flxd',
  'flxb',
  'flxg',
  'stub',
]

CIL_EXES = [ 'flxcc',]
EXES = MISC_EXES + CIL_EXES + FLX_EXES

if 1:
  s = ' -cclib "-Lsrc '
  for library in CLIBRARIES:
    s = s + ' -l'+library
  s = s + '"'
  LDFLAGS = s
  del s

if 1:
  o = ''
  for object in COBJECTS.keys():
    o = o + ' src/' + object + '.o'
  OBJECT_FILES = o
  del o

TESTS= USER_TESTS
BAD_TESTS = []

SPECIAL_TESTS = [
  ('bin/flx_run','test/flx_run_lib1.flx',''),
  ('test/flx_perf_drv1','test/flx_perf_lib1.flx','1000'),
  ('bin/flx_stdin_drv','test/flx_stdin_lib1.flx','<Makefile >tmp.tmp'),
]

# -------------------------------------------------
# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------

# ----------- Utilities ---------------------
class MakeError: pass

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except:
    t = 0
  return t

def erasefile(f):
  try:
    os.unlink(f)
  except:
    pass
# ----------- Here begins the actual build procedure ---------------------

buildall = "clean" in options or "force" in options
stop_on_error = "stop_on_error" in options
import glob

def copy_mli2ml():
  for f in RAW_INTERFACES:
    if filetime("src/"+f+".mli") > filetime("src/"+f+".ml"):
      os.system("cp src/"+f+".mli src/"+f+".ml")

def copy_elk2rtl():
  for f in ELKRTL_INTERFACES:
    if filetime("elk/"+f) > filetime("rtl/"+f):
      os.system("cp elk/"+f+" rtl/"+f)

def ocamlit(LEXS,PARSES,INTERFACES,IMPLEMENTATIONS,EXES):
  global buildall
  # STEP 2: Generate lexers
  for lex in LEXS:
    file = 'src/'+lex
    if buildall or filetime(file + '.mll') > filetime(file +'.ml'):
      buildall = 1
      xqt(OCAMLLEX + file + '.mll')

  # STEP 3: Generate parsers
  for parse in PARSES:
    file = 'src/'+parse
    if buildall or filetime(file + '.mly') > filetime(file +'.ml'):
      buildall = 1
      xqt(OCAMLYACC+ ' -v '+ file + '.mly')
      nxqt("grep conflict " + file + ".output")

  # STEP 4: Compile ocaml interfaces
  for interface in INTERFACES:
    file = 'src/'+interface
    if buildall or filetime(file + '.mli') > filetime(file+'.cmi'):
      buildall = 1
      xqt(OCAMLC + ' ' + OCAML_INCLUDES+' -c '+file+ '.mli')

  # STEP 5: Compile ocaml implementations
  for implementation in IMPLEMENTATIONS + EXES:
    file = 'src/'+implementation
    if buildall or filetime(file+ '.ml') > filetime(file+OCAML_OBJECT_EXTENSION):
      buildall = 1
      xqt(OCAMLOPT + ' '+ OCAML_INCLUDES+ ' -c ' + file +'.ml')


try:
  # STEP 0: run interscript
  if "weave" in options:
    print "WEAVING PROGRAM SOURCES"
    runISCR('--language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+WEAVER_DIRECTORY+' lpsrc/flx.pak')
  elif "doc" in options or "extract" in options:
    print "EXTRACTING PRINCIPAL CODEBASE"
    runISCR('lpsrc/flx.pak')

  if "doc" in options:
    print "GENERATING DOCUMENTATION"
    runISCR('lpsrc/flx.pak')
    copy_mli2ml()
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tutorial.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_macro.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_bind.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_migrate.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --passes=2 --weaver-directory=speed/ lpsrc/flx_perf.pak')
    xqt('cp doc/interscript.css speed/interscript.css')
  elif "extract" in options:
    print "EXTRATING SOURCES"
    runISCR('lpsrc/flx.pak')
    runISCR('lpsrc/sm.pak')
    runISCR('lpsrc/ast.pak')
    runISCR('lpsrc/elk.pak')
    runISCR('lpsrc/flx_perf.pak')
    copy_mli2ml()
    copy_elk2rtl()
    runISCR('lpsrc/flx_tutorial.pak')
    runISCR('lpsrc/flx_tut_macro.pak')
    runISCR('lpsrc/flx_tut_bind.pak')
    runISCR('lpsrc/flx_tut_migrate.pak')
    xqt('cp doc/interscript.css speed/interscript.css')
  os.system('rm -f tmp.tmp')

  if "doc" in options or "man" in options:
    print "GENERATING MAN PAGES"
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = string.split(file,".")[0]
        xqt(
          "man2html man/man1/" + file + 
          '| sed -e "s%<A HREF=\\"[^<]*cgi-bin/man/man2html?1+\(.*\)\\">%<A HREF=\\"\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "htmlman/" + basename+'_1.html'
        )
    except:pass
  
  if "doc" in options or "impldoc" in options:
    print "GENERATING OCAMLDOCS"
    xqt('rm -rf impldoc/*')
    try:
      xqt('ocamldoc -I src -d impldoc src/*.mli -html')
      xqt('ocamldoc -I src -o impldoc/flx_impl.tex src/*.mli -latex')
      xqt('(cd impldoc; latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex)')
    except: 
     pass # well ocamldoc is full of bugs ..

  if "regression" in options:
    TESTS = TESTS + glob.glob('test/rt*.flx')
    if LINK_MODEL == "dynamic":
      TESTS = TESTS + glob.glob('test/drt*.flx')

    BAD_TESTS = glob.glob('test/bt*.flx')

  if "tutorial" in options:
    TESTS = TESTS + glob.glob('tut/examples/tut*.flx')
    TESTS = TESTS + glob.glob('tut/examples/mac*.flx')
    TESTS = TESTS + glob.glob('tut/examples/mig*.flx')

  BAGLEY = []
  if "bagley" in options:
    BAGLEY = glob.glob('bagley/felix/bag*.flx')

  TESTS.sort()
  BAD_TESTS.sort()
  BAGLEY.sort()

  if "compiler" in options or "olink" in options:
    # STEP 1: Compile all compiler support C files
    for cobject in COBJECTS.keys():
      flags = COBJECTS[cobject]
      file = 'src/'+cobject
      if buildall or filetime(file +".c") > filetime(file +".o"):
        xqt(CCOMPILE +" -I "+OCAML_INCLUDE_DIRECTORY+" -Irtl "+flags+" "+file+".c")

    print "COMPILING MISC"
    ocamlit(MISC_LEXS,MISC_PARSES,MISC_INTERFACES,MISC_IMPLEMENTATIONS,MISC_EXES)
    if buildall or "felix" in options:
      print "COMPILING FELIX"
      ocamlit(FLX_LEXS,FLX_PARSES,FLX_INTERFACES,FLX_IMPLEMENTATIONS,FLX_EXES)
    if buildall or "flxcc" in options:
      print "COMPILING FLXCC"
      ocamlit(CIL_LEXS,CIL_PARSES,CIL_INTERFACES,CIL_IMPLEMENTATIONS,CIL_EXES)

    # STEP 6: Build FELIX Library
    if "olink" in options: buildall = 1
    for lib,IMPLEMENTATIONS in OCAMLLIBS:
      print "CREATING LIBRARY ",lib
      object_library_name = "src/" + lib + OCAML_LIB_EXTENSION
      linkstring = OCAMLOPT + " -a -o " + object_library_name + " "
      library_filetime = filetime(object_library_name)
      for implementation in IMPLEMENTATIONS:
        file = 'src/'+implementation
        if buildall or filetime(file+OCAML_OBJECT_EXTENSION) > library_filetime:
          for implementation in IMPLEMENTATIONS:
            file = 'src/'+implementation
            linkstring = linkstring + file +OCAML_OBJECT_EXTENSION +" "
          xqt(linkstring)
          buildall = 1
          break

    # STEP 8: Link executables
    print "LINKING EXECUTABLES"
    x = ''
    for library in OLIBRARIES:
      x = x + ' ' + library + OCAML_LIB_EXTENSION

    # finally, mainline *.cmx or cma files to link to executables
    for exe in EXES:
      if buildall or filetime(exe + OCAML_OBJECT_EXTENSION) > filetime(exe):
        xqt(OCAMLOPT + LDFLAGS + ' ' + OCAML_INCLUDES + ' -o bin/'+exe + x + OBJECT_FILES + ' src/flx_version_hook.ml ' + exe + OCAML_OBJECT_EXTENSION)

  # COMPILE RTL  
  if "rtl" in options:
    print "COMPILING RUN TIME LIBRARY COMPONENTS"
    if SUPPORT_DYNAMIC_LOADING:
      print " ++ DYNAMIC LINK VERSIONS"
      ars = ""

      # FELIX SUBLIBRARY
      print " .. FELIX RTL"
      for x in RTL_CPPS:
        if not "quiet" in options: print 'Compiling rtl object',x
        ars = ars + x + "_dynamic.o "
        xqt(CCOBJ_DLLIB + " -Irtl " + x + ".cpp -o " +x+"_dynamic.o")

      #ELKHOUND SUBLIBRARY
      print " .. ELKHOUND"
      for x in SMRTL+ELKRTL:
        if not "quiet" in options: print 'Compiling elkhound rtl object',x
        ars = ars + "rtl/" + x + "_dynamic.o "
        xqt(CCOBJ_DLLIB + " -D__UNIX__ -Ielk elk/" + x + ".cpp -o rtl/" +x+"_dynamic.o")

      # LINK RTL
      print " ** MAKING RTL (dynamic) "
      xqt(AR + " rtl/libflx_dynamic.a " + ars)
      xqt(RANLIB + " rtl/libflx_dynamic.a")

      if CYGWIN:
        print "Building RTL for CYGWIN dynamic linkage"
        cmd = (CCLINK_DLLIB + " -shared -o bin/cygflx_dynamic.dll " +
          "--export-all-symbols --enable-auto-import " +
          "--out-implib=rtl/libflx_dynamic.dll.a ")
        xqt(cmd)
      else:
        #the actual library
        xqt(CCLINK_DLLIB + "-Wl,-soname="+FLX_SONAME+" -o rtl/libflx_dynamic.so."+flx_version+' '+ars)

        # to link against at compile time using -lflx_dynamic
        xqt('(cd rtl && rm -f libflx_dynamic.so && ln -s libflx_dynamic.so.'+flx_version+' libflx_dynamic.so)')

        # what a program linked against the library will load at run time
        xqt('(cd rtl && rm -f '+FLX_SONAME+' && ln -s libflx_dynamic.so.'+flx_version+' '+FLX_SONAME+')')


    if SUPPORT_STATIC_LINKAGE:
      print " ++ STATIC LINK VERSIONS"
      ars = ""
      print " .. FELIX RTL"
      for x in RTL_CPPS:
        if not "quiet" in options: print 'Compiling rtl object',x
        ars = ars + x + "_static.o "
        xqt(CCOBJ_STATIC_LIB + " -Irtl " + x + ".cpp -o " +x+"_static.o")
      print " .. ELKHOUND"
      for x in SMRTL+ELKRTL:
        if not "quiet" in options: print 'Compiling elkhound rtl object',x
        ars = ars + "rtl/" + x + "_static.o "
        xqt(CCOBJ_STATIC_LIB + " -D__UNIX__ -Ielk elk/" + x + ".cpp -o rtl/" +x+"_static.o")
      print " ** MAKING RTL (static) "
      xqt(AR + " rtl/libflx_static.a " + ars)
      xqt(RANLIB + " rtl/libflx_static.a")
  
  # elkhound executable: no need for dynamic loading, always built static
  if "elkhound" in options:
    print "COMPILING ELKHOUND"
    ars = ""
    for x in SMBASE + SMRTL + ASTGEN + ELKHOUND + ELKRTL:
      if not "quiet" in options: print 'Compiling elkhound object',x
      ars = ars + "elk/"+x + "_static.o "
      xqt(CCOBJ_STATIC_LIB + " -D__UNIX__ -Ielk elk/" + x + ".cpp -o elk/" +x+"_static.o")
    xqt(AR + " elk/libelk_static.a " + ars)
    xqt(RANLIB + " elk/libelk_static.a")
    xqt(CCOBJ_STATIC_MAIN + " -D__UNIX__ -DGRAMANL_MAIN elk/elk_gramanl.cpp -o elk/elkhound.o")
    xqt(CCLINK_STATIC + " elk/elkhound.o elk/libelk_static.a -o bin/flx_elkhound")
 
  # COMPILE DRIVER PROGRAMS
  if "drivers" in options:
    if SUPPORT_STATIC_LINKAGE:
      print "COMPILING DRIVERS (static)"
      for i,j in DRIVERS:
        if not "quiet" in options: print 'Compiling driver object',i
        xqt(CCOBJ_STATIC_MAIN + " -Irtl " + i + ".cpp -o " +i+"_static.o")

    if SUPPORT_DYNAMIC_LOADING:
      print "COMPILING DRIVERS (dynamic)"
      for i,j in DRIVERS:
        if not "quiet" in options: print 'Compiling driver object',i
        xqt(CCOBJ_DLMAIN + " -Irtl " + i + ".cpp -o " +i+"_dynamic.o")

        if CYGWIN:
          xqt("g++ -o "+j+" -Wl,--enable-auto-import " + i + "_dynamic.o -Lrtl -lflx_dynamic")
        else:
          xqt(CCLINK_DLMAIN + " -o "+j+" -Lrtl -lflx_dynamic " +i+"_dynamic.o")

  # run tests
  try:
    results = []
    print "RUNNING TESTS"
    # GENERATE C++ FROM FELIX SOURCE
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)

    TX = TESTS+EXTRA+BAGLEY
    if len(TX)>0 or "regression" in options:
      print "TRANSLATING FELIX TEST CODE TO C++"
    if len(TX)>0:
      print " .. REGRESSION TESTS and TUTORIAL EXAMPLES"
    for testfile in TESTS+EXTRA+BAGLEY:
      #print 'Running Felix code generator on ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or \
        filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
        filetime('bin/flxg')> filetime(basename+'.cpp') or \
        filetime('lib/std.flx') > filetime(basename+'.cpp'):
        try:
          flxg('-Ilib ' +FLXFLAGS + basename,basename)
          #print 'TESTFILE -- generated ',basename
          results.append(("flxg",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+'.cpp')
          erasefile(basename+'.hpp')
          erasefile(basename+SHLX)
          if stop_on_error: raise MakeError
          results.append(("flxg",basename,'ERROR'))

    # FAILURE TESTS 
    if "regression" in options:
      print " .. ERROR HANDLING TESTS"
      for testfile in BAD_TESTS:
        #print 'Running Felix code generator on ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or \
          filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
          filetime('bin/flxg')> filetime(basename+'.cpp') or \
          filetime('lib/std.flx') > filetime(basename+'.cpp'):
          try:
            xqt('bin/flxg -e -Ilib ' + basename + " 2>&1 >/dev/null")
            #print 'TESTFILE -- failed as expected',basename
            results.append(("flxg",basename,'OK'))
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
          except MakeError:
            print 'TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED!',basename
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
            if stop_on_error: raise MakeError
            results.append(("flxg",basename,'ERROR'))

    # C++ COMPILE and static link tests
    # produces shared library or executable
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)
    TX = TESTS+EXTRA+BAGLEY
    if len(TX)>0:
      print "COMPILING GENERATED C++ TEST CODE"
      for testfile in TESTS+EXTRA+BAGLEY:
        #print 'Compiling generated code of ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or filetime(basename+ '.cpp') > filetime(basename+SHLX):
          try:
            if LINK_MODEL == "dynamic":
              if CYGWIN:
                xqt("g++ -w -ansi -g -o "+basename+SHLX+" -shared -Irtl "+cppfilename+" -Lrtl -lflx_dynamic -Wl,--enable-auto-import")
              else:
                xqt(CCOBJ_DLLIB+" -Irtl "+cppfilename + " -o " + basename + "_dynamic.o")
                xqt(CCLINK_DLLIB+" -Lrtl -lflx_dynamic -o "+ basename + SHLX + " "+basename+"_dynamic.o")
            else:
              xqt(CCOBJ_STATIC_LIB +" -Irtl "+cppfilename + " -o " + basename + "_static.o" )
              xqt(CCLINK_STATIC +" -Irtl ./rtl/flx_run_static.o "+basename+ "_static.o -Lrtl -lflx_static -o " + basename + SHLX )
            #print 'TESTFILE -- OK!',basename
            results.append(("g++",basename,'OK'))
          except MakeError:
            print 'TESTFILE -- ERROR!',basename
            erasefile(basename+SHLX)
            if stop_on_error: raise MakeError
            results.append(("g++",basename,'ERROR'))


    # run the tests
    if len(TESTS)>0:
      print "RUNNING TESTS"
      for testfile in TESTS:
        basename = string.split(testfile,'.')[0]
        if LINK_MODEL == "dynamic":
          testscript = "env LD_LIBRARY_PATH=./rtl:$LD_LIBRARY_PATH ./bin/flx_run ./"+basename+SHLX
        else:
          testscript = "./"+basename+SHLX

        if "log_output" in options:
          testscript = testscript + " >" + basename + ".output"

        elif "time_execution" in options:
          testscript = "time " + testscript 

        elif "check_output" in options:
          testscript = testscript + " >" + basename + ".output"
          testscript = testscript + " && diff -a -b " + basename + ".expect "+ basename + ".output"

        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append(("Exec",testscript,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append(("Exec",testscript,'ERROR'))
      
      if "test" in options or "tutorial" in options or "fcount" in options:
        tkind = "std"
        if "inline" in options: tkind="inline"
        stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "tut/examples/*.hpp"'
        run(stats)
        stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "test/*.hpp"'
        run(stats)
      
      if "pfcount" in options:
        stats = 'python script/pfcount.py misc/fcounts.stats'
        run(stats)

      if "pfcount_all" in options:
        stats = 'python script/pfcount.py misc/fcounts.stats all'
        run(stats)

    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS:
        test_basename = string.split(testfile,'.')[0]
        drv_basename = string.split(driver,'.')[0]
        if LINK_MODEL == "dynamic":
          testscript = "time ./"+drv_basename+ " ./"+test_basename+SHLX+" " + moreargs
        else:
          testscript = "time ./"+test_basename+SHLX+" " + moreargs
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append(("Exec Special",testscript,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append(("Exec Special",testscript,'ERROR'))

    if "speed" in options:
      runISCR('lpsrc/flx_perf.pak')
      os.system("python speed/measure.py")
      os.system("python speed/panal.py")
      xqt("gnuplot speed/mkjpgs.gpl")
      runISCR('--inhibit-sref=1 --language=en --weaver=web --passes=2 --weaver-directory=speed/ lpsrc/flx_perf.pak')

    print "RUN COMPLETE"
  finally:
    # REPORT FINAL RESULTS
    print
    print '**********************************'
    #print 'final results'
    total = 0
    bad = 0
    for x,y,z in results: 
      total = total + 1
      if "OK" == z: pass
      else:
        bad = bad + 1
        print x,y,z
    if total <> 0:
      if bad == 0: 
        print "ALL",total,"PASSED"
      else:
        print "Bad",bad,"/",total
    print '**********************************'

except MakeError:
  print "Terminating due to error"
  sys.exit(1)

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('CONFIG_ARGS=')
@tangle('PREFIX='+PREFIX)
@tangle('SHLIB_DIR=${PREFIX}/lib')
@tangle('SHINC_DIR=${PREFIX}/include')
@tangle('INSTALL_DIR=${PREFIX}/lib/felix')
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('BUILTIN_ISCR=env PYTHONPATH=. python -O interscript/bin/iscr.py --nocache')
@tangle('')
@tangle('all: dummy')
@tangle('\tpython script/maker extract compiler rtl elkhound drivers test log_output stop_on_error check_output optimise_c')
@tangle('\tmake tools libdoc')
@tangle('')

@tangle('all.quiet: dummy')
@tangle('\tpython script/maker quiet extract compiler rtl elkhound drivers test log_output stop_on_error check_output optimise_c')
@tangle('\tmake tools libdoc')
@tangle('')

@tangle('profile: dummy')
@tangle('\tpython script/maker compiler profile')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\tpython script/maker compiler bytecode')
@tangle('')
@tangle('bytecode.profile: dummy')
@tangle('\tpython script/maker compiler bytecode profile')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\tpython script/maker compiler bytecode debug')
@tangle('')
@tangle('extract_compiler: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx.pak')
@tangle('\tpython script/maker compiler')
@tangle('')
@tangle('extract: dummy')
@tangle('\tpython script/maker extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\tpython script/maker extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\tpython script/maker tutorial')
@tangle('')
@tangle('grammar: dummy')
@tangle('\tpython script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar')
@tangle('\tpython script/get_grammar src/flx_cil_cparser.mly >misc/flx_cil_cparser.grammar')
#@tangle('\tpython script/elk_flx_grgen misc/flx_parse.grammar >misc/elk_flx_gr.gr')
@tangle('\tpython script/flx_flx_grgen misc/flx_parse.grammar >lib/flx_grammar.flx')
#@tangle('\tpython script/elk_flx_lexgen misc/flx_parse.grammar >misc/elk_flx_lex.cc')
@tangle('\tpython script/flx_tokgen misc/flx_parse.grammar >lib/flx_token.flx')
@tangle('')
@tangle('compiler: dummy')
@tangle('\tpython script/maker compiler')
@tangle('')
@tangle('tools: grammar bin/flx_doc tools/lua_parser')
@tangle('')
@tangle('tools/lua_parser: tools/lua_parser.flx')
@tangle('\tbin/flx --test --static -c tools/lua_parser')
@tangle('')
@tangle('bin/flx_doc: tools/flx_doc.flx')
@tangle('\tbin/flx --test --static -c tools/flx_doc && mv tools/flx_doc bin/flx_doc')
@tangle('')
@tangle('doc: grammar tools libdoc')
@tangle('\tpython script/maker doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('doc.quiet: grammar tools libdoc')
@tangle('\tpython script/maker quiet doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('libdoc: grammar tools')
@tangle('\tbin/flx_doc --outdir=libdoc \\')
@tangle('\tlib/std.flx lib/stl.flx lib/flx_lex.flx \\')
@tangle('\tlib/flx_token.flx lib/flx_grammar.flx lib/lua.flx lib/lua_parse.flx')
@tangle('\tcp misc/flxdoc_style.css libdoc')
@tangle('')
@tangle('man: dummy')
@tangle('\tpython script/maker man')
@tangle('')
@tangle('test: dummy')
@tangle('\tpython script/maker test stop_on_error check_output')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('test.static: dummy')
@tangle('\tpython script/maker test static stop_on_error')
@tangle('')
@tangle('test.flx_ptf_static_pointer: dummy')
@tangle('\tpython script/maker test -DFLX_PTF_STATIC_POINTER stop_on_error')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\tpython script/maker inline test stop_on_error')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\tpython script/maker debug test stop_on_error')
@tangle('')
@tangle('test.lua_parser: dummy')
@tangle('\tfor i in misc/lua/*.lua; do tools/lua_parser $$i; done;')
@tangle('')
@tangle('tests: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('\tmake tests.bagley')
@tangle('\tmake test.lua_parser')
@tangle('')
@tangle('tests.verify: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\tpython script/maker test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\tpython script/maker inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\tpython script/maker performance')
@tangle('')
@tangle('performance: tests.performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\tpython script/maker regression')
@tangle('')
@tangle('tests.bagley: dummy')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('speed: dummy')
@tangle('\tpython script/maker speed')
@tangle('')
@tangle('pfcount.all:')
@tangle('\tpython script/maker pfcount_all')
@tangle('')
@tangle('pfcount:')
@tangle('\tpython script/maker pfcount')
@tangle('')
@tangle('rtl.debug: dummy')
@tangle('\tpython script/maker rtl debug')
@tangle('')
@tangle('rtl: dummy')
@tangle('\tpython script/maker rtl')
@tangle('')
@tangle('rtl.optimise: dummy')
@tangle('\tpython script/maker rtl optimise_c')
@tangle('')
@tangle('elkhound: dummy')
@tangle('\tpython script/maker elkhound')
@tangle('')
@tangle('expect.bagley: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tpython script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('expect: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tpython script/maker test log_output')
@tangle('\tpython script/mk_expect tut/examples > lpsrc/flx_tut_expect.ipk')
@tangle('\tpython script/mk_expect test > lpsrc/flx_test_expect.ipk')
@tangle('\tpython script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('drivers: dummy')
@tangle('\tpython script/maker drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('\tpython script/maker drivers debug')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.08.1 or better')
@tangle('\t#REQUIRES g++ 3.xx or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required priviledges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')

@tangle('src_tarball: extract debian/rules')
@tangle('\tchmod u+x debian/rules')
@tangle('\trm -f felix-'+flx_version)
@tangle('\tln -s . felix-'+flx_version)
@tangle('\ttar -cvf flx_'+flx_version+'_src.tar\\')
@tangle('\t\tfelix-'+flx_version+'/configure \\')
@tangle('\t\tfelix-'+flx_version+'/Makefile.debian_package_creator \\')
@tangle('\t\tfelix-'+flx_version+'/Makefile \\')
@tangle('\t\tfelix-'+flx_version+'/README \\')
@tangle('\t\tfelix-'+flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+flx_version+'/COPYING \\')
@tangle('\t\tfelix-'+flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+flx_version+'/debian/* \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/weavers/*.py ')
@# debian requires gzip -9
@tangle('\tgzip -9 flx_'+flx_version+'_src.tar')
@tangle('\tmv -f flx_'+flx_version+'_src.tar.gz flx_'+flx_version+'_src.tgz')
@tangle('')
@tangle('bin_tarball:')
@tangle('\trm -f felix-'+flx_version)
@tangle('\tln -s . felix-'+flx_version)
@tangle('\ttar -zcvf flx_'+flx_version+'_bin_linux.tgz\\')
@tangle('\t\tfelix-'+flx_version+'/configure\\')
@tangle('\t\tfelix-'+flx_version+'/Makefile\\')
@tangle('\t\tfelix-'+flx_version+'/README \\')
@tangle('\t\tfelix-'+flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+flx_version+'/COPYING\\')
@tangle('\t\tfelix-'+flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+flx_version+'/script/maker \\')
@tangle('\t\tfelix-'+flx_version+'/script/*\\')
@tangle('\t\tfelix-'+flx_version+'/src/*.ml \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mli \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mly \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mll \\')
@tangle('\t\tfelix-'+flx_version+'/tools/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/rtl/*.cpp\\')
@tangle('\t\tfelix-'+flx_version+'/rtl/*.hpp\\')
@tangle('\t\tfelix-'+flx_version+'/libdoc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/lib/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/lib/*.fsh \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.cpp \\')
@tangle('\t\tfelix-'+flx_version+'/tut/examples/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.tex \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.tex \\')
@tangle('\t\tfelix-'+flx_version+'/licences/*.txt \\')
@tangle('\t\tfelix-'+flx_version+'/debian/* \\')
@tangle('\t\tfelix-'+flx_version+'/misc/* \\')
@tangle('\t\tfelix-'+flx_version+'/htmlman/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/man/man1/*.1 \\')
@tangle('\t\tfelix-'+flx_version+'/impldoc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/www/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/bin/flx \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.gpl \\')
@tangle('\t\tfelix-'+flx_version+'/speed/exes/*/*.times \\')
@tangle('\t\tfelix-'+flx_version+'/speed/images/*.jpg \\')
@tangle('\t\tfelix-'+flx_version+'/speed/plotters/*.gpl \\')
@tangle('\t\tfelix-'+flx_version+'/speed/src/c/*.c \\')
@tangle('\t\tfelix-'+flx_version+'/speed/src/ocaml/*.ml \\')
@tangle('\t\tfelix-'+flx_version+'/speed/src/felix/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('tarball: src_tarball bin_tarball')
@tangle('')
@tangle('debian/rules: lpsrc/flx_debian.pak lpsrc/flx_maker.ipk')
@tangle('\trm -rf debian')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_debian.pak')
@tangle('\tchmod u+x debian/rules')
@tangle('')
@tangle('debian-package: debian/rules')
@tangle('\t(cd .. && make -f flx/Makefile.debian_package_creator package)')
@tangle('')
@tangle('www: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_sourceforge.pak')
@tangle('')
@tangle('clean: dummy')
@tangle('\trm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so tut/examples/*.dll tut/examples/*.par tut/examples/*.o tut/examples/*.output')
@tangle('\trm -rf test/*.cpp test/*.hpp test/*.so test/*.dll test/*.par test/*.o test/*.output')
@tangle('\trm -rf bagley/felix/*.cpp bagley/felix/*.hpp bagley/felix/*.so bagley/felix/*.dll bagley/felix/*.par bagley/felix/*.o')
@tangle('\trm -rf speed/exes/*')
@tangle('')
@tangle('distclean:')
@tangle('\trm -rf tut rtl test www src misc man bin doc lib impldoc htmlman tmp tmp.tmp')
@tangle('\trm -rf elk')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('\trm -rf bagley')
@tangle('\trm -rf doc_out libdoc tools')
@tangle('\trm -rf meta licences')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -rf interscript/*/*.pyo')
@tangle('\trm -rf interscript/*/*/*.pyo')
@tangle('\trm -rf speed/')
@tangle('')
@tangle('virgin: distclean')
@tangle('\tcp Makefile Makefile.old')
@tangle('\trm -rf script/')
@tangle('\trm -rf debian/')
@tangle('\trm -f README LICENCE VERSION CONTENTS INSTALL AUTHORS NEWS COPYING ChangeLog')
@tangle('')

@tangle('backup: dummy')
@tangle('\t(DATE=`date -I`;\\')
@tangle('\tmkdir -p "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.ipk "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.pak "lpbackup/$${DATE}";\\')
@tangle('\tcp homepage/*.html "lpbackup/$${DATE}"\\')
@tangle('\t)')
@tangle('')

@tangle('config: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_config.pak')
@tangle('\tpython -O script/make_config.py --quiet --prefix=${PREFIX} ${CONFIG_ARGS}')
@tangle('')
@tangle('config/config.py: config')
@tangle('')
@tangle('boot: config/config.py')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx.pak')
@for i in [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
  ]:
  tangle('\tcp src/'+i+'.mli src/'+i+'.ml')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tfor i in tmp/*.default; do cp $$i config/`basename $$i .default`; done')
@tangle('')
@tangle('wrappers.clean:')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('')
@tangle('config/cxx.flxcc: default_wrappers')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/c89.flxcc')
@tangle('\tbin/flxcc config/c99.flxcc')
@tangle('\tbin/flxcc config/gnu89.flxcc')
@tangle('\tbin/flxcc config/gnu99.flxcc')
@tangle('\tbin/flxcc config/cxx.flxcc')
@tangle('\tbin/flxcc config/cxx_sys.flxcc')
@tangle('\tbin/flxcc config/gnucxx.flxcc')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\t#"INSTALL_DIR=${INSTALL_DIR}"')
@tangle('\t#"EXEC_DIR=${EXEC_DIR}"')
@tangle('\t#"MAN_DIR=${MAN_DIR}"')
@tangle('\t#"SHLIB_DIR=${SHLIB_DIR}"')
@tangle('\t#"SHINC_DIR=${SHINC_DIR}"')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${SHLIB_DIR}')
@tangle('\tinstall -d ${SHINC_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/config')
@tangle('\tinstall -d ${INSTALL_DIR}/doc')
@tangle('\tinstall -d ${INSTALL_DIR}/htmlman')
@tangle('\tinstall config/*.py ${INSTALL_DIR}/config')
@tangle('\tinstall config/*.flxcc ${INSTALL_DIR}/config')
@tangle('\tinstall lib/* ${INSTALL_DIR}/lib')
@tangle('\tinstall rtl/*.hpp ${SHINC_DIR}')
@tangle('\tinstall rtl/* ${INSTALL_DIR}/rtl')
@if SUPPORT_STATIC_LINKAGE:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_static.a')
  tangle('\tinstall rtl/libflx_static.a ${SHLIB_DIR}')
  tangle('\t'+RANLIB+' ${SHLIB_DIR}/libflx_static.a')
@if SUPPORT_DYNAMIC_LOADING:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_dynamic.a')
  tangle('\tinstall rtl/libflx_dymamic.so ${SHLIB_DIR}')
  tangle('\tinstall rtl/libflx_dynamic.a ${SHLIB_DIR}')
  tangle('\t'+RANLIB+' ${SHLIB_DIR}/libflx_dynamic.a')
@tangle('\t(install doc/* ${INSTALL_DIR}/doc || exit 0) > /dev/null 2>&1')
@tangle('\t(install impldoc/* ${INSTALL_DIR}/impldoc || exit 0) > /dev/null 2>&1')
@tangle('\t(install htmlman/* ${INSTALL_DIR}/htmlman || exit 0) > /dev/null 2>&1')
@tangle('\tinstall bin/* ${EXEC_DIR}')
@tangle('\t(install man/man1/* ${MAN_DIR}/man1 || exit 0) > /dev/null 2>&1')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = string.replace(FLX_MAKER_CVS_ID,"$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle("# These targets are for SKALLER only")
@tangle("# they're used to upload stuff to sourceforge")
@tangle('upload_images:')
@tangle('\tscp homepage/images/*.jpg skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/images')
@tangle('')
@tangle('upload_homepage: dummy')
@tangle('\tscp homepage/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('upload_www: upload_homepage')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/current/www')
@tangle('')
@tangle('upload_src: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('upload: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('\tscp flx_'+flx_version+'_bin_linux.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')

@head(1,'configure')
A shell script to run the config step.
@select(tangler('configure'))
echo "Configuring Felix"
grab=1

PREFIX=$PREFIX
ARGS=""

while (( "$grab" == "1" ));
do
  case x$1 in
  x--prefix=*)
     PREFIX="`echo \"$1\" | sed 's/--prefix=\(.*\)/\\1/'`"
     shift
  ;;

  x--prefix)
    shift
    PREFIX="$1"
    shift
  ;;

  x)
    grab=0
  ;;

  x*)
    ARGS="${ARGS} $1"
    shift
  ;;


  esac
done

echo "Installing at PREFIX=$PREFIX"
make PREFIX=$PREFIX CONFIG_ARGS="$ARGS" config &&\
make PREFIX=$PREFIX boot &&\
make grammar &&\
make extract

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues Cassé

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors. The C parser is derived from
FrontC/CIL which is has BSD licence.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something .. 

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something .. 


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENCE   licence details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary
 
  Makefile   the makefile, mainly hooks into script/maker
 
  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  meta   -- contains various package manager meta-data files
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENCE')
@select(tangler('LICENCE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file 


lpsrc/flx_frontc.ipk
lpsrc/flx_cil.ipk

are covered by a BSD Licence, here is the copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.08.1 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace
   
@tangle('   tar -zxvf flx_'+flx_version+'_src.tgz')
@tangle('   cd felix_'+flx_version)

4. Bootstrap the system.

  ./configure

OR type

   make config
   make boot
   make extract

EDIT THE FILES

  config/*.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make 

6. Build the documentation and tutorial

   make doc 

7. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak 
  
                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  include "std";
  print "It works!"; endl;

and then run it:
  
  flx -Ilib mytest

@head(1,'.cvsignore')
This is actually put in the lpsrc directory to tell
cvs to ignore certain files.
@select(tangler('lpsrc/.cvsignore','data'))
*.cache
*.swp


@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.

@select(tangler('doc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('doc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)


@head(1,"fishcc")
Script to compile a C program generated by FISh.
@select(tangler("bin/fishcc"))
grab=1
CCFLAGS=""
while (( "$grab" == "1" ));
do
  case x$1 in
  x-*)
    CCFLAGS="$CCFLAGS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done
@tangle('cmd="'+CCLINK_STATIC+' $1 -O -o `basename $1 .c` `echo "$CCFLAGS"` -lflx_static"')
echo $cmd
`$cmd`

@head(1,'Run script')
@select(tangler('bin/flx'))
#!/bin/bash
# flx - felix script harness

# g++ compilation string
@tangle('CCOBJ_DLLIB="'+CCOBJ_DLLIB+'"')
@tangle('CCLINK_DLLIB="'+CCLINK_DLLIB+'"')
@tangle('CCOBJ_STATIC_LIB="'+CCOBJ_STATIC_LIB+'"')
@tangle('CCLINK_STATIC="'+CCLINK_STATIC+'"')
@tangle('VERSION="'+flx_version+'"')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=0
ECHO=0
TIME=0
@if DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""

grab=1

INCLUDE_DIRS=""

while (( "$grab" == "1" ));
do
  case x$1 in
  x--test)
    TESTMODE=1
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    ECHO=1
    shift
  ;;

  x--time)
    TIME=1
    shift
  ;;

  x--echo)
    ECHO=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline)
    INLINE=1
    shift
  ;;

  x--opt=1)
    INLINE=1
    CCFLAGS="-O1 $CCFLAGS"
    shift
  ;;

  x--opt=2)
    INLINE=1
    CCFLAGS="-O2 $CCFLAGS"
    shift
  ;;

  x--opt=3)
    INLINE=1
    CCFLAGS="-O3 $CCFLAGS"
    shift
  ;;

  x--optimise)
    INLINE=1
    CCFLAGS="-O3 -fomit-frame-pointer -finline $CCFLAGS"
    shift
  ;;

  x--optimize)
    INLINE=1
    CCFLAGS="-O3 -fomit-frame-pointer -finline $CCFLAGS"
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--help)
    man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done

if [ "$TESTMODE" = "1" -a "$ECHO" = "1" ]
then
  echo "TESTMODE: running felix from current directory"
fi

# make a list of any *.cpp files (or other g++ options ..)

cpps=""
cppos=""
grab=1
pkgs=""
while (( "$grab" == "1" ));
do
  case "$1" in
    *.cpp)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .cpp`.o"
      shift
    ;;

    *.cxx)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .cxx`.o"
      shift
    ;;

    *.c)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .c`.o"
      shift
    ;;

    *.o)
      cppos="$cppos `dirname $1`/`basename $1 .cpp`.o"
      shift
    ;;

    *.a)
      cppos="$cppos $1"
      shift
    ;;

    --pkg=*)
      pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
      shift
    ;;

# unknown flag .. pass to both compile and link
    -*)
      cpps="$cpps $1"
      cppos="$cppos $1"
      shift
    ;;

    *)
      grab=0
    ;;
  esac
done

if [ "x$pkgs" = "x" ]
then
  PKGS=""
else
  PKGS=`pkg-config --cflags --libs $pkgs`
fi

if [ "x$1" = "x" ]
then
  echo "usage: flx filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;

  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=""

case "$arg" in
  /*)
    base="$arg"
    ;;
  [^/]*/*)
    base="`pwd`/$arg"
    ;;
  *)
    for dir in `echo .:$PATH | sed 's/:/ /g'`
    do
      dir=$dir
      if [ -r "$dir/$arg.so" -o -r "$dir/$arg.flx" ]
      then
        base="$dir/$arg"
        break
      fi
    done
    ;;
esac

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

if [ "$TESTMODE" = "1" ]
then
  INCLUDE_DIR="./rtl"
  FLXG="env PATH=./bin:\$PATH ./bin/flxg"
  FLXLIB="./lib"
  FLXRUN="env LD_LIBRARY_PATH=./rtl:\$LD_LIBRARY_PATH ./bin/flx_run"
  FLXRTL="./rtl"
  FLXBIN="./bin"
else
  # Locate the felix installation
  prefix=""
  for dir in `echo $PATH | sed 's/:/ /g'`
  do
    dir=$dir
    if [ -x "$dir/flxg" ]
    then
      prefix="$dir/flxg"
      break
    fi
  done
  prefix="`echo $prefix | sed 's/\/bin\/flxg$//'`"
  INCLUDE_DIR="$prefix/lib/felix/rtl"
  FLXG="$prefix/bin/flxg"
  FLXRUN="$prefix/bin/flx_run"
  FLXLIB="$prefix/lib/felix/lib"
  FLXRTL="$prefix/lib/felix/rtl"
  FLXBIN="$prefix/bin"
fi
if [ "$DEBUG" = "1" ]; then FLXRUN="$FLXRUN --debug"; fi
STATIC_ENV=""
if [ "$DEBUG" = "1" ]; then STATIC_ENV="env FLX_DEBUG=1 "; fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base.so" -a "(" ! -r "$base.flx" -o "$base.so" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      if [ $ECHO = 1 ]; then echo "running $base.so"; fi
      `echo "$FLXRUN" "$base.so $args"`
    fi
    exit $?
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base" -a "(" ! -r "$base.flx" -o "$base" -nt "$base.flx" ")" ]
  then
    if [ $ECHO = 1 ]; then echo "running $base"; fi
    if [ $RUNIT = 1 ]
    then
      `echo "$STATIC_ENV $base $args"`
    fi
    exit $?
  fi
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]
then
  VERBOSE="-v"
  CCFLAGS="$CCFLAGS -g"
else
  VERBOSE="-q"
fi

if [ $INLINE = 1 ]
then
  FLXFLAGS="--inline"
else
  FLXFLAGS=""
fi

if [ $STATIC = 0 ]
then
  FCMD="$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"
  if [ $ECHO = 1 ]; then echo "$FCMD"; fi
  if `echo $FCMD`
  then
    CCMD="$CCOBJ_DLLIB $CCFLAGS -I$INCLUDE_DIR $INCLUDE_DIRS $PKGS $cpps $base.cpp -o $base.o"
    LCMD="$CCLINK_DLLIB $CCFLAGS $PKGS $cppos $base.o -o $base.so"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            `echo "time $FLXRUN" "$base.so" $args`
          else
            `echo "$FLXRUN" "$base.so" $args`
          fi
        fi
        exit $?
      else
        exit $?
      fi
    else
      exit $?
    fi
  fi
else
  FCMD="$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"
  if [ $ECHO = 1 ]; then echo "$FCMD"; fi
  if `echo $FCMD`
  then
    CCMD="$CCOBJ_STATIC_LIB $CCFLAGS -DFLX_STATIC_LINK -I$INCLUDE_DIR $INCLUDE_DIRS $PKGS $cpps $base.cpp -o $base.o"
    LCMD="$CCLINK_STATIC $FLXRTL/flx_run_static.o $PKGS $cppos $base.o $FLXRTL/libflx_static.a -o $base"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        # rm -f "$base.cpp"
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            `echo time $STATIC_ENV $base $args`
          else
            `echo $STATIC_ENV $base $args`
          fi
        fi
        exit $?
      else
        exit $?
      fi
    else
      exit $?
    fi
  fi
fi

@head(1,'Package Manager Meta Info')
@head(2,'GODI')
This is the Godiva file originally used to
create the GODI data. At the moment this is
the authoritative meta data. However,
godiva may not handle all the options
we need -- so the generated makefile
is included as well.

@select(tangler('meta/godiva/flx.godiva','data'))
Package: apps-felix
@tangle('Version: '+flx_version)
Revision: 0
Depends:
Build-Depends: godi-ocaml (> 3.08) 
@tangle('Sources: http://felix.sf.net/flx_'+flx_version+'_src.tgz')
@tangle('Unpacks-To: flx_'+flx_version)
Bytecode-Target: all
Opt-Target: all
Homepage: http://felix.sf.net
Maintainer: John Skaller <skaller@users.sf.net>
Options: configure
Description: Felix Compiler
Felix Compiler
.

@select(tangler('meta/godiva/flx.godiva_camlsyntax','data'))
name = "felix";
@tangle('version = "'+flx_version+'";')
revision = 0;
category = `apps;
depends = [];
build_depends = [`godi,"ocaml", Some (`gt, "3.08")];
sources_site ="http://felix.sf.net/";
@tangle('sources_basename= "flx_'+flx_version+'_src";')
sources_extension = ".tgz";
@tangle('sources_unpacksto = "flx_'+flx_version+'";')
all_target= "all";
opt_target= "all";
homepage= "http://felix.sf.net";
maintainer = "John Skaller <skaller@users.sf.net>";
options= [`configure];
short_desc = "Felix Compiler";
long_desc = "Felix Compiler";
confopts = [
  { 
    name = "SUPPORT_DYNAMIC_LOADING";
    default = "1";
    description = "Whether to support dlopen loading";
    implementation = `configarg "--SUPPORT_DYNAMIC_LOADING"
  }
];
specfile = "meta/godiva/flx.godiva_camlsyntax";
patches = [];
filesdir = None;

@select(tangler('meta/godi/DESCR','data'))
Felix Compiler and tools.

@doc()
This makefile only here for reference (don't use it,
it should be generated).

@select(tangler('meta/godi/Makefile','data'))
# This file was automatically generated by GODIVA
.include "../../mk/bsd.prefs.mk"
.include "../../mk/godi.pkg.mk"

@tangle('VERSION=        '+flx_version)
PKGNAME=        apps-felix-${VERSION}
@tangle('PKGREVISION=    '+godi_revision) 
@tangle('DISTNAME=       flx_'+flx_version)
@tangle('DISTFILES=      flx_'+flx_version+'_src.tgz')
CATEGORIES=     apps
MASTER_SITES=   http://felix.sf.net/
MAINTAINER=     John Skaller <skaller@users.sf.net>
HOMEPAGE=       http://felix.sf.net
COMMENT=        Felix Compiler

# confopt defaults:


AUTOGENERATE_PLIST = yes
PKG  =          apps-felix
MAKE_FLAGS=     PREFIX=${PREFIX}  



PATH:=          ${LOCALBASE}/bin:${PATH}
HAS_CONFIGURE = yes
CONFIGURE_ARGS+= --prefix ${PREFIX}
CONFIGURE_ENV+= ${BUILD_OCAMLFIND_ENV}
USE_GMAKE = yes

MAKE_ENV+=  ${BUILD_OCAMLFIND_ENV} PKGBASE=${PKGBASE:Q}

pre-configure-copy:
.	if exists(files)
	    cd files && ${PAX} -rw -pp . ${WRKSRC}
.	endif

pre-configure: pre-configure-copy

pre-install-mkdirs:
.	for d in bin lib/ocaml/pkg-lib doc share man etc info sbin include
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/${d}
.	endfor
.	for n in 1 2 3 4 5 6 7 8 9
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/man/man${n}
.	endfor

pre-install: pre-install-mkdirs

ALL_TARGET=     all
.if ${GODI_HAVE_OCAMLOPT} == "yes"
# ALL_TARGET+= all
.endif

post-install:
	mkdir -p ${PREFIX}/doc/${PKG}
.	for DOC in 
	    install -m 0644 ${WRKSRC}/${DOC} ${PREFIX}/doc/${PKG}
.	endfor

.include "../../mk/bsd.pkg.mk"

@head(1,'Finish up')
Just cleaning up script now.
@os.system('chmod u+x configure')
@os.system('chmod u+x bin/flx')
@os.system('chmod u+x bin/fishcc')
@os.system('cp doc/*.css tut/doc >/dev/null 2>&1')

