@head(1,'Maker')
@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################

# --------------------------------------------------
# IMPORT UTILITY RESOURCES
# ---------------------------------------------------
import os
import stat
import string
import sys
import re

def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  return result,output

def get_stdouterr(x):
  return get_stdout(x+" 2>&1")

# define our version of C's system() function
def xqt(x):
  if "silent" not in options: print x
  sys.stdin.flush()
  result,output = get_stdouterr(x)
  if "quiet" not in options:
    if result: print "  .. ERROR CODE",hex(result)
    if output: print string.join(output,"")
  sys.stdin.flush()

  if result:
    raise MakeError

def nxqt(x):
  if "silent" not in options: print x
  sys.stdin.flush()
  result,output = get_stdouterr(x)
  if "quiet" not in options:
    if output: print string.join(output,"")
  sys.stdin.flush()

  if not result:
    raise MakeError


# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

options = sys.argv[1:]
if "silent" in options: 
  options.append("quiet")

if options:
  print "OPTIONS: ", options

keyopt = {}
for o in options:
  try:
    key,value = string.split(o,"+=")
    old = keyopt.get(key,[])
    if type(old) == type(""): old = [old]
    keyopt[key] = old + [value]
  except:
    try:
      key,value = string.split(o,"=")
      keyopt[key]=value
    except: pass

USER_TESTS = keyopt.get("flx",[])
if type(USER_TESTS) == type(""):
  USER_TESTS = [USER_TESTS]

if "help" in options:
  print "extract - extract sources"
  print "compiler - build compiler"
  print "bytecode - build bytecode version of compiler"
  print "drivers - build drivers"
  print "regression - run regression tests"
  print "performance - run performance tests"
  print "tutorial - run tutorial examples"
  print "tests- regression and tutorial combined"
  print "clean - remove generated C++ and binaries from test locations"
  print "debug - build debugging versions of targets"
  print "optimise - build high performance versions of targets"
  print "refcnt - do not generate reference counting instructions"
  print "doc - build all user documentation"
  print "vim=gvim - set gvim as the vim editor"
  print "vimserver=FLX - set FLX as the editor server name"
  print "editor=vim - set vim as the editor class"
  print "editor=emacs - set emacs as the editor class"
  print "edit -- edit a file containing an error"

VIMSERVER = keyopt.get("vimserver","")
VIM = keyopt.get("vim","gvim")
EMACS = keyopt.get("emacs","xemacs")
EDITORCLASS = keyopt.get("editorclass","vim")
if EDITORCLASS == "vim":
  EDITOR = VIM
elif EDITORCLASS == "emacs":
  EDITOR = EMACS
else:
  EDITOR = EDITORCLASS

if "clean" in options:
  os.system("rm -rf test/*.cpp test/*.hpp test/*.so")
  os.system("rm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so")

if "tests" in options or "test" in options:
  options = options + ["regression","tutorial"]

# this command takes flxg output and looks for errors
# no action is taken if there are no errors
# if an error is found, and an original source
# reference is detected, the file is edited
#
# For vim the processs is:
# 1. get a list of servers
# 2. check if the nominated server is in the list
# 3. if it isn't, create it
# 4. tell the server to edit the file

def vimedit(file,line1,column1,line2,column2):
  SNAME = VIMSERVER
  if SNAME == "": SNAME = file
  os.system(VIM + " --servername " + SNAME + " --remote +" + str(line1) + " " + file)

def edit(*args):
  if EDITORCLASS == "vim": apply(vimedit,args)
  else: os.system(EDITOR + " " + args[0])

errpos_single = re.compile('In (.*): line (.*), cols (.*) to (.*)\\n')
errpos_multiple = re.compile('In (.*): line (.*) col (.*) to  line (.*) col (.*)\\n')

def find_src(s,file):
  m = errpos_single.match(s)
  if m:
    print "Matched single"
    f,l1,c1,c2 = m.group(1,2,3,4)
    l1=int(l1)
    c1=int(c1)
    l2=int(l1)
    c2=int(c2)
  else:
    m = errpos_multiple.match(s)
    if m:
      print "Matched multiple"
      f,l1,c1,l2,c2 = m.group(1,2,3,4,5)
      l1=int(l1)
      c1=int(c1)
      l2=int(l2)
      c2=int(c2)
    else:
      f,l1,c1,l2,c2="generated",0,0,0,0
  if f == "generated": f = file
  return f,l1,c1,l2,c2

def flxg(x,basename):
  x = './bin/flxg ' + x
  if "edit" in options:
    try: 
      xqt(x)
    except:
      x = x + ' | grep -x "In.*: line.*"'
      result,output = get_stdouterr(x)
      try:
        f,l1,c1,l2,c2 = find_src(output[0],basename+'.flx')
        edit(f,l1,c1,l2,c2)
      except:
        edit(basename+'.flx',0,0,0,0)
  else: 
    xqt(x)

# ------------------------------------------------
# BEGIN USER CONFIGURABLE SECTION
#-------------------------------------------------

#interscript command (now built in part of Felix package)
def ISCR(a):
  xqt('env PYTHONPATH=. python -O interscript/bin/iscr.py ' + a)

if "compiler" in options or "bytecode" in options:
  # invoke ocaml interface compiler
  OCAML_OBJDIR='src'
  try:
    xqt('ocamlopt.opt')
    OCAMLCC = 'ocamlopt.opt '
    OCAMLLEX = 'ocamllex.opt '
    OCAMLYACC = 'ocamlyacc '
    BYTECODE = 0
  except:
    try:
      xqt('ocamlopt')
      OCAMLCC = 'ocamlopt '
      OCAMLLEX = 'ocamllex '
      OCAMLYACC = 'ocamlyacc '
      BYTECODE = 0
    except:
      try:
        xqt('ocamlc')
        OCAMLCC = 'ocamlc '
        if "debug" in options:
          OCAMLCC = 'ocamlc -g '
        OCAMLLEX = 'ocamllex '
        BYTECODE = 1
        OCAMLYACC = 'ocamlyacc '
      except:
        BYTECODE = -1
        OCAMLCC = '#ocamlc '
        OCAMLLEX = '#ocamllex '
        OCAMLYACC = '#ocamlyacc '

  try:
    xqt('ocamlc.opt')
    OCAMLB = 'ocamlc.opt '
  except:
    try:
      xqt('ocamlc')
      OCAMLB = 'ocamlc '
    except:
      OCAMLB = '#ocamlc '

  if "debug" in options:
    OCAMLB = OCAMLB + "-g "

  if "bytecode" in options:
    OCAMLOPT= OCAMLB + ' -I '+OCAML_OBJDIR+' '
    if BYTECODE <> -1: BYTECODE = 1
  else:
    OCAMLOPT= OCAMLCC + ' -I '+OCAML_OBJDIR+' '

  if "optimise" in options:
    OCAMLOPT = OCAMLOPT + "-unsafe -noassert -inline 5 "

  #OCAMLC=OCAMLB + ' -I '+OCAML_OBJDIR+' -rectypes '
  OCAMLC=OCAMLB + ' -I '+OCAML_OBJDIR+' '

  if BYTECODE == 0:
    OCAML_OBJECT_EXTENSION = '.cmx'
    OCAML_LIB_EXTENSION = '.cmxa'
  else:
    OCAML_OBJECT_EXTENSION = '.cmo'
    OCAML_LIB_EXTENSION = '.cma'
  
  # where the ocaml is installed
  result,x = get_stdout(OCAMLC + " -where")
  OCAML_INCLUDE_DIRECTORY= x[0][0:-1]
  print "OCAML at",OCAML_INCLUDE_DIRECTORY

# where gnu readline header files are
#READLINE_INCLUDE_DIRECTORY='/usr/include/readline'

# for compiling mainlines
FLX_CPP_LINK = "g++ -w -ansi -rdynamic -ldl "
if "optimise" in options:
  FLX_CPP_LINK = FLX_CPP_LINK + "-O "

if "refcnt" in options:
  FLX_CPP_LINK = FLX_CPP_LINK + " -DFLX_REFCNT "

if "debug" in options:
 pass
else:
  FLX_CPP_LINK = FLX_CPP_LINK + " -DNDEBUG "

# for building shared libraries
#FLX_CPP_DYNLINK = "g++ -fomit-frame-pointer -Wno-long-long -D_GNU_SOURCE -ansi -shared -I."
FLX_CPP_DYNLINK = "g++ -w -ansi -shared -I."
if "optimise" in options:
  FLX_CPP_DYNLINK = FLX_CPP_DYNLINK + "-O "

if "refcnt" in options:
  FLX_CPP_DYNLINK = FLX_CPP_DYNLINK + " -DFLX_REFCNT "

if "debug" in options:
  pass
else:
  FLX_CPP_DYNLINK = FLX_CPP_DYNLINK + " -DNDEBUG "


# ------------------------------------------------
# END USER CONFIGURABLE SECTION
#-------------------------------------------------

# where documentation gets put
WEAVER_DIRECTORY='doc/'
TUTORIAL_DIRECTORY='tut/'
TUTORIAL_DOC=TUTORIAL_DIRECTORY+'doc/'
TUTORIAL_EXAMPLES=TUTORIAL_DIRECTORY+'examples/'

# where the garbage collector sources are
# (the collector is now a separate package)
FLX_GC_SRC='src/'

# -------------------------------------------------
# BEGIN IMPLEMENTOR CONFIGURABLE SECTION
# ------------------------------------------------

# files containing ocamllex sources
LEXS = ['flx_lex']

# files containing ocamlyacc sources
PARSES = ['flx_parse']

# ocaml modules = interfaces + implementation files

MODULES = [
  'flx_version'      ,
  'flx_util'         ,
  'flx_getopt'       ,
  'flx_mtypes'       ,
  'flx_srcref'       ,
  'flx_typing'       ,
  'flx_exceptions'   ,
  'flx_string'       ,
  'flx_id'           ,
  'flx_print'        ,
  'flx_maps'         ,
  'flx_typing2'      ,
  'flx_unify'        ,
  'flx_charset'      ,
  'flx_parse'        ,
  'flx_keywords'     ,
  'flx_lex'          ,
  'flx_pretok'       ,
  'flx_lex1'         ,
  'flx_tok'          ,
  'flx_parse_ctrl'   ,
  'flx_dfa'          ,
  'flx_pat'          , 
  'flx_constfld'     , 
  'flx_macro'        , 
  'flx_desugar'      , 
  'flx_mbind'        , 
  'flx_symtab'       , 
  'flx_csubst'       , 
  'flx_name'         , 
  'flx_treg'         ,
  'flx_beta'         ,
  'flx_generic'      , 
  'flx_lookup'       , 
  'flx_bexe'         , 
  'flx_bbind'        , 
  'flx_use'          , 
  'flx_inst'         , 
  'flx_cexpr'        ,
  'flx_tgen'         , 
  'flx_display'      , 
  'flx_ogen'         , 
  'flx_regen'        ,
  'flx_gen'          , 
  'flx_flxopt'       , 
  'flx_terminate'    , 
]

INTERFACES = [
  'flx_ast'        ,
  'flx_types'        ,
  'flx_ctypes'        ,
] + MODULES

IMPLEMENTATIONS = MODULES

DRIVERS = [
  ('rtl/flx_run','bin/flx_run'),
  ('test/flx_perf_drv1','test/flx_perf_drv1'),
  ('rtl/flx_stdin_drv','bin/flx_stdin_drv'),
]

# C files that we need to compile, with options required to build them
COBJECTS = {
}
# *.so/.a libraries
CLIBRARIES = ['nums']

# *.cmxa or .cma libraries
OLIBRARIES = ['nums','unix','flxlib']


# target executable programs to produce
EXES = [
  # compiler tools
  'flxl',
  'flxp',
  'flxm',
  'flxd',
  'flxb',
  'flxg',
  'stub',
]

if 1:
  s = ' -cclib "-Lsrc '
  for library in CLIBRARIES:
    s = s + ' -l'+library
  s = s + '"'
  LDFLAGS = s
  del s

if 1:
  o = ''
  for object in COBJECTS.keys():
    o = o + ' src/' + object + '.o'
  OBJECT_FILES = o
  del o

TESTS= USER_TESTS
BAD_TESTS = []

SPECIAL_TESTS = [
  ('bin/flx_run','test/flx_run_lib1.flx'),
  ('test/flx_perf_drv1','test/flx_perf_lib1.flx'),
  ('bin/flx_stdin_drv','test/flx_stdin_lib1.flx'),
]

# -------------------------------------------------
# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------

# ----------- Utilities ---------------------
class MakeError: pass

def filetime(f):
  try:
    return os.stat(f)[stat.ST_MTIME]
  except: return 0

def run(x):
  print x
  sys.stdin.flush()
  result = os.system(x)
  if result: print "  .. ERROR CODE",hex(result)
  sys.stdin.flush()

  if result:
    raise MakeError

def erasefile(f):
  try:
    os.unlink(f)
  except:
    pass
# ----------- Here begins the actual build procedure ---------------------

buildall = "clean" in options
stop_on_error = "stop_on_error" in options
import glob

try:
  # STEP 0: run interscript
  if "doc" in options:
    ISCR('--language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+WEAVER_DIRECTORY+' lpsrc/flx.pak')
    ISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tutorial.pak')
    ISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_macro.pak')
    ISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_bind.pak')
  elif "extract" in options:
    ISCR('lpsrc/flx.pak')
    ISCR('lpsrc/flx_tutorial.pak')
    ISCR('lpsrc/flx_tut_macro.pak')
    ISCR('lpsrc/flx_tut_bind.pak')
  os.system('rm -f tmp.tmp')

  if "doc" in options or "man" in options:
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = string.split(file,".")[0]
        xqt(
          "man2html man/man1/" + file + 
          '| sed -e "s%http://localhost/cgi-bin/man/man2html?1+\(.*\)\\">%\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "htmlman/" + basename+'_1.html'
        )
    except:pass

  if "regression" in options:
    TESTS = TESTS + glob.glob('test/rt*.flx')
    BAD_TESTS = glob.glob('test/bt*.flx')

  if "tutorial" in options:
    TESTS = TESTS + glob.glob('tut/examples/tut*.flx')
    TESTS = TESTS + glob.glob('tut/examples/mac*.flx')

  TESTS.sort()
  BAD_TESTS.sort()

  if "compiler" in options:
    # STEP 1: Compile all copiler support C files
    for cobject in COBJECTS.keys():
      flags = COBJECTS[cobject]
      file = 'src/'+cobject
      if buildall or filetime(file +".c") > filetime(file +".o"):
        xqt(CCOMPILE +" -I "+OCAML_INCLUDE_DIRECTORY+" -I. "+flags+" "+file+".c")

    # STEP 2: Generate lexers
    for lex in LEXS:
      file = 'src/'+lex
      if buildall or filetime(file + '.mll') > filetime(file +'.ml'):
        buildall = 1
        xqt(OCAMLLEX + file + '.mll')

    # STEP 3: Generate parsers
    for parse in PARSES:
      file = 'src/'+parse
      if buildall or filetime(file + '.mly') > filetime(file +'.ml'):
        buildall = 1
        xqt(OCAMLYACC+ ' -v '+ file + '.mly')
        nxqt("grep conflict " + file + ".output")

    # STEP 4: Compile ocaml interfaces
    for interface in INTERFACES:
      file = 'src/'+interface
      if buildall or filetime(file + '.mli') > filetime(file+'.cmi'):
        buildall = 1
        xqt(OCAMLC + ' -c '+file+ '.mli')

    # STEP 5: Compile ocaml implementations
    for implementation in IMPLEMENTATIONS + EXES:
      file = 'src/'+implementation
      if buildall or filetime(file+ '.ml') > filetime(file+OCAML_OBJECT_EXTENSION):
        buildall = 1
        xqt(OCAMLOPT + ' -c ' + file +'.ml')


    # STEP 6: Build FELIX Library
    object_library_name = "src/flxlib" + OCAML_LIB_EXTENSION
    linkstring = OCAMLOPT + " -a -o " + object_library_name + " "
    library_filetime = filetime(object_library_name)
    for implementation in IMPLEMENTATIONS:
      file = 'src/'+implementation
      if filetime(file+OCAML_OBJECT_EXTENSION) > library_filetime:
        for implementation in IMPLEMENTATIONS:
          file = 'src/'+implementation
          linkstring = linkstring + file +OCAML_OBJECT_EXTENSION +" "
        xqt(linkstring)
        buildall = 1
        break

    # STEP 8: Link executables
    x = ''
    for library in OLIBRARIES:
      x = x + ' ' + library + OCAML_LIB_EXTENSION

    # finally, mainline *.cmx or cma files to link to executables
    for exe in EXES:
      if buildall or filetime(exe + OCAML_OBJECT_EXTENSION) > filetime(exe):
        xqt(OCAMLOPT + LDFLAGS + ' -o bin/'+exe + x + OBJECT_FILES + ' src/flx_version_hook.ml ' + exe + OCAML_OBJECT_EXTENSION)

  # COMPILER DRIVER PROGRAMS
  if "drivers" in options:
    for testfile,outbin in DRIVERS:
        print 'Compiling driver program ',testfile
        try:
          xqt(FLX_CPP_LINK + " -I. " +
            "rtl/flx_gc.cpp " +
            "rtl/flx_collector.cpp " +
            "rtl/flx_rtl.cpp " +
            "rtl/flx_dynlink.cpp " +
            "rtl/flx_i18n.cpp " +
            "rtl/flx_ioutil.cpp " +
             testfile + ".cpp -o "+outbin)
        except MakeError:
          print "Unable to build driver"
          raise MakeError

  # run tests
  try:
    results = []

    # GENERATE C++ FROM FELIX SOURCE
    EXTRA = []
    if "performance" in options:
      for driver,testfile in SPECIAL_TESTS: EXTRA.append(testfile)
    for testfile in TESTS+EXTRA:
      #print 'Running Felix code generator on ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or \
        filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
        filetime('bin/flxg')> filetime(basename+'.cpp') or \
        filetime('lib/std.flx') > filetime(basename+'.cpp') or \
        filetime('lib/std.flx') > filetime(basename+'.cpp'):
        try:
          flxg('-Ilib ' + basename,basename)
          #print 'TESTFILE -- generated ',basename
          results.append(("flxg",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+'.cpp')
          erasefile(basename+'.hpp')
          erasefile(basename+'.so')
          if stop_on_error: raise MakeError
          results.append(("flxg",basename,'ERROR'))

    # FAILURE TESTS 
    if "regression" in options:
      for testfile in BAD_TESTS:
        #print 'Running Felix code generator on ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or \
          filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
          filetime('bin/flxg')> filetime(basename+'.cpp') or \
          filetime('lib/std.flx') > filetime(basename+'.cpp'):
          try:
            xqt('bin/flxg -e -Ilib ' + basename + " 2>&1 >/dev/null")
            #print 'TESTFILE -- failed as expected',basename
            results.append(("flxg",basename,'OK'))
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+'.so')
          except MakeError:
            print 'TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED!',basename
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+'.so')
            if stop_on_error: raise MakeError
            results.append(("flxg",basename,'ERROR'))

    # C++ COMPILE SHARED LIBRARIES
    EXTRA = []
    if "performance" in options:
      for driver,testfile in SPECIAL_TESTS: EXTRA.append(testfile)
    for testfile in TESTS+EXTRA:
      #print 'Compiling generated code of ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or filetime(basename+ '.cpp') > filetime(basename+'.so'):
        try:
          xqt(FLX_CPP_DYNLINK+" "+cppfilename + " -o " + basename + ".so" )
          #print 'TESTFILE -- OK!',basename
          results.append(("g++",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+'.so')
          if stop_on_error: raise MakeError
          results.append(("g++",basename,'ERROR'))


    for testfile in TESTS:
      basename = string.split(testfile,'.')[0]
      testscript = "./bin/flx_run ./"+basename+".so"
      if "log_output" in options:
        testscript = testscript + " >" + basename + ".output"
      #print 'Executing ',testscript
      try:
        run(testscript)
        #print 'TESTFILE -- OK!',testscript
        results.append(("Exec",testscript,'OK'))
      except MakeError:
        print 'TESTFILE -- ERROR!',testscript
        if stop_on_error: raise MakeError
        results.append(("Exec",testscript,'ERROR'))

    if "performance" in options:
      for driver,testfile in SPECIAL_TESTS:
        test_basename = string.split(testfile,'.')[0]
        drv_basename = string.split(driver,'.')[0]
        testscript = "./"+drv_basename+ " ./"+test_basename+".so"
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append(("Exec Special",testscript,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append(("Exec Special",testscript,'ERROR'))

    print "RUN COMPLETE"

  finally:
    # REPORT FINAL RESULTS
    print
    print '**********************************'
    #print 'final results'
    total = 0
    bad = 0
    for x,y,z in results: 
      total = total + 1
      if "OK" == z: pass
      else:
        bad = bad + 1
        print x,y,z
    if total <> 0:
      if bad == 0: 
        print "ALL",total,"PASSED"
      else:
        print "Bad",bad,"/",total
    print '**********************************'
    sys.exit(bad)

  sys.exit(0)

except MakeError:
  print "Terminating due to error"
  sys.exit(1)

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('makefile'))
@tangle('PREFIX=/usr/local')
@tangle('INSTALL_DIR=${PREFIX}/lib')
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('all: dummy')
@tangle('\tpython script/maker extract compiler drivers test')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\tpython script/maker compiler bytecode')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\tpython script/maker compiler bytecode debug')
@tangle('')
@tangle('extract: dummy')
@tangle('\tpython script/maker extract')
@tangle('')
@tangle('tut: dummy')
@tangle('\tpython script/maker tutorial')
@tangle('')
@tangle('compiler: dummy')
@tangle('\tpython script/maker compiler')
@tangle('')
@tangle('doc: dummy')
@tangle('\tpython script/maker doc')
@tangle('\tcp doc/*.css tut/doc &>/dev/null')
@tangle('')
@tangle('impldoc: dummy')
@tangle('\tocamldoc -I src -d impldoc src/*.mli -html')
@tangle('\tocamldoc -I src -o impldoc/flx_impl.tex src/*.mli -latex')
@tangle('\t(cd impldoc; latex flx_impl.tex; latex flx_impl.tex; latex flx_impl.tex)')
@tangle('')
@tangle('test: dummy')
@tangle('\tpython script/maker test stop_on_error')
@tangle('')
@tangle('test.refcnt: dummy')
@tangle('\tpython script/maker refcnt test stop_on_error')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\tpython script/maker debug test stop_on_error')
@tangle('')
@tangle('tests: dummy')
@tangle('\tpython script/maker test log_output')
@tangle('')
@tangle('tests.refcnt: dummy')
@tangle('\tpython script/maker refcnt test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\tpython script/maker performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\tpython script/maker regression')
@tangle('')
@tangle('drivers: dummy')
@tangle('\tpython script/maker drivers')
@tangle('')
@tangle('drivers.refcnt: dummy')
@tangle('\tpython script/maker refcnt drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('\tpython script/maker drivers debug')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources and this makefile')
@tangle('\t#DONT DO THIS UNLESS YOU HAVE PYTHON INSTALLED AND WORKING')
@tangle('\t#DONT DO THIS UNLESS YOU HAVE OCAML INSTALLED AND WORKING')
@tangle('\t#DONT DO THIS UNLESS YOU HAVE g++ INSTALLED AND WORKING')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.06 or better')
@tangle('\t#REQUIRES g++ 2.96 or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#REQUIRES g++ 2.96 or better')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#EDIT THIS MAKEFILE TO SET INSTALLATION DIRECTORIES')
@tangle('\t#SEE THE TOP OF THE MAKEFILE')
@tangle('\t#Obtain the required priviledges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('\t#or ask the priviledged person to do it for you')
@tangle('')
@tangle('tarball: dummy')
@tangle('\trm -f flx_'+flx_version)
@tangle('\tln -s . flx_'+flx_version)
@tangle('\ttar -zcvf flx_'+flx_version+'_src.tgz\\')
@tangle('\t\tflx_'+flx_version+'/makefile flx_'+flx_version+'/README flx_'+flx_version+'/CONTENTS flx_'+flx_version+'/INSTALL flx_'+flx_version+'/VERSION flx_'+flx_version+'/LICENSE \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.ipk\\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.pak\\')
@tangle('\t\tflx_'+flx_version+'/interscript/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.dat \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('\ttar -zcvf flx_'+flx_version+'_bin_linux.tgz\\')
@tangle('\t\tflx_'+flx_version+'/makefile flx_'+flx_version+'/README flx_'+flx_version+'/CONTENTS flx_'+flx_version+'/INSTALL flx_'+flx_version+'/VERSION flx_'+flx_version+'/LICENSE \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tflx_'+flx_version+'/script/maker \\')
@tangle('\t\tflx_'+flx_version+'/src/*.ml \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mli \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mly \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mll \\')
@tangle('\t\tflx_'+flx_version+'/rtl/*.cpp\\')
@tangle('\t\tflx_'+flx_version+'/rtl/*.hpp\\')
@tangle('\t\tflx_'+flx_version+'/lib/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/test/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/test/*.cpp \\')
@tangle('\t\tflx_'+flx_version+'/tut/examples/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.css \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.tex \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.css \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.tex \\')
@tangle('\t\tflx_'+flx_version+'/htmlman/*.html \\')
@tangle('\t\tflx_'+flx_version+'/man/man1/*.1 \\')
@tangle('\t\tflx_'+flx_version+'/impldoc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/bin/flx \\')
@tangle('\t\tflx_'+flx_version+'/bin/flxg \\')
@tangle('\t\tflx_'+flx_version+'/bin/flx_run \\')
@tangle('\t\tflx_'+flx_version+'/interscript/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.dat \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('www: dummy')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_sourceforge.pak')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_web.pak')
@tangle('')
@tangle('man: dummy')
@tangle('\tpython script/maker man')
@tangle('')
@tangle('upload_www: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('')
@tangle('upload: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('\tscp flx_'+flx_version+'_bin_linux.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('clean: dummy')
@tangle('\trm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so')
@tangle('\trm -rf test/rt*.cpp test/rt*.hpp test/rt*.so')
@tangle('')
@tangle('virgin: dummy')
@tangle('\trm -rf tut rtl test www src misc man script bin doc lib impldoc htmlman tmp.tmp')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf interscript/*.pyc')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -rf README LICENSE VERSION CONTENTS INSTALL')
@tangle('')

@tangle('backup: dummy')
@tangle('\t(DATE=`date -I`;\\')
@tangle('\tmkdir -p "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.ipk "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.pak "lpbackup/$${DATE}"\\')
@tangle('\t)')
@tangle('')

@tangle('boot: dummy')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx.pak')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_tutorial.pak')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_tut_macro.pak')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_tut_bind.pak')
@tangle('')

@tangle('test_lex: dummy')
@tangle('\t  ./lexl test_lex')
@tangle('\t  ./lexp test_lex')
@tangle('\t  ./lexd test_lex')
@tangle('')

@tangle('install: dummy')
@tangle('\t  #"INSTALL_DIR=${INSTALL_DIR}"')
@tangle('\t  #"EXEC_DIR=${EXEC_DIR}"')
@tangle('\t  #"MAN_DIR=${MAN_DIR}"')
@tangle('\t  install -d ${INSTALL_DIR}/felix/lib ${INSTALL_DIR}/felix/rtl')
@tangle('\t  install -d ${INSTALL_DIR}/felix/doc')
@tangle('\t  install -d ${INSTALL_DIR}/felix/htmlman')
@tangle('\t  (install lib/* ${INSTALL_DIR}/felix/lib || exit 0) &> /dev/null')
@tangle('\t  (install rtl/* ${INSTALL_DIR}/felix/rtl || exit 0) &> /dev/null')
@tangle('\t  (install doc/* ${INSTALL_DIR}/felix/doc || exit 0) &> /dev/null')
@tangle('\t  (install impldoc/* ${INSTALL_DIR}/felix/impldoc || exit 0) &> /dev/null')
@tangle('\t  (install htmlman/* ${INSTALL_DIR}/felix/htmlman || exit 0) &> /dev/null')
@tangle('\t  (install bin/* ${EXEC_DIR} || exit 0) &> /dev/null')
@tangle('\t  (install man/man1/* ${MAN_DIR}/man1 || exit 0) &> /dev/null')
@tangle('')

@tangle('dummy:')
@tangle('\t#felix make')
@tangle('')


@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..

@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

  makefile
@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENSE   license details

The directories are:

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed
  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENSE')
@select(tangler('LICENSE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the author
is not misrepresented in any way.


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.06 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace
   
@tangle('   tar -zxvf felix_'+flx_version+'_src.tgz')
@tangle('   cd felix_'+flx_version)

   make help -- gives help on make targets
   
for a quick build type:

  make virgin boot compiler drivers doc tests

  [does all the steps below except install]
  
4. Perform the initial source extraction:

   make boot
   
5. Build the compiler
   For systems where the Ocaml native code compiler
   is supported:

   make compiler drivers

   Otherwise you need to build a bytecode version
   of the compiler:

   make compiler.bytecode drivers

6. Build the documentation and tutorial

   make doc 

   developers can also do:

   make impldoc

7. Test the compiler

   make test

   This stops on the first error. Use

   make tests

   to run the force all the tests to run
   
8. Install the compiler

   EDIT THE MAKEFILE TO SET THE INSTALL POINTS

   By default, Felix installs in:

   /usr/local/bin/ -- the compiler executable
   /usr/local/man/ -- the man pages
   /usr/local/lib/ -- the rest of the package
   
   become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak 
  
                     -- re-extract sources, including makefile

HOW TO USE IT
-------------

make a sample program mytest.flx:

  include "std";
  print "It works!"; endl;

and then run it:
  
  flx -Ilib mytest

@head(1,'Ocamldoc Latex Style')
Taken from the distribution because ocamldoc
doesn't put this file in the right place
when it generates a tex file. (style sheets
for html are correctly dumped though ..)

@select(tangler('impldoc/ocamldoc.sty','data'))
%% Support macros for LaTeX documentation generated by ocamldoc.
%% This file is in the public domain; do what you want with it.

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{ocamldoc}
              [2001/12/04 v1.0 ocamldoc support]

\newenvironment{ocamldoccode}{%
  \bgroup
  \leftskip\@totalleftmargin
  \rightskip\z@skip
  \parindent\z@
  \parfillskip\@flushglue
  \parskip\z@skip 
  %\noindent
  \@@par\smallskip
  \@tempswafalse
  \def\par{%
    \if@tempswa
      \leavevmode\null\@@par\penalty\interlinepenalty
  \else
    \@tempswatrue
    \ifhmode\@@par\penalty\interlinepenalty\fi
  \fi}
  \obeylines
  \verbatim@font
  \let\org@prime~%
  \@noligs
  \let\org@dospecials\dospecials
  \g@remfrom@specials{\\}
  \g@remfrom@specials{\{}
  \g@remfrom@specials{\}}
  \let\do\@makeother
  \dospecials
  \let\dospecials\org@dospecials
  \frenchspacing\@vobeyspaces
  \everypar \expandafter{\the\everypar \unpenalty}}
{\egroup\par}

\def\g@remfrom@specials#1{%
  \def\@new@specials{}
  \def\@remove##1{%
    \ifx##1#1\else
    \g@addto@macro\@new@specials{\do ##1}\fi}
  \let\do\@remove\dospecials
  \let\dospecials\@new@specials
  }

\newenvironment{ocamldocdescription}
{\list{}{\rightmargin0pt \topsep0pt}\raggedright\item\relax}
{\endlist\medskip}

\newenvironment{ocamldoccomment}
{\list{}{\leftmargin 2\leftmargini \rightmargin0pt \topsep0pt}\raggedright\item\relax}
{\endlist}

\let\ocamldocvspace\vspace
\endinput


@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.

@select(tangler('doc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('doc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)

@head(1,'Run script')
@select(tangler('bin/flx'))
#!/bin/sh
# flx - felix script harness

# g++ compilation string
GPP="g++ -w -ansi "

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
grab=1

while (( "$grab" == "1" ));
do
  case x$1 in
  x--test)
    TESTMODE=1
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done

if [ "$TESTMODE" = "1" ]
then
  echo "TESTMODE: running felix from current directory"
fi

if [ "$DEBUG" = "0" ]
then
  GPP="$GPP -DNDEBUG"
fi

# make a list of any *.cpp files (or other g++ options ..)

grab=1
cpps=""
while (( "$grab" == "1" ));
do
  case "$1" in
    *.cpp)
      cpps="$cpps $1"
      shift
    ;;

    *.c)
      cpps="$cpps $1"
      shift
    ;;
     
    *.o)
      cpps="$cpps $1"
      shift
    ;;

    -*)
      cpps="$cpps $1"
      shift
    ;;
   
    *)
      grab=0
    ;;
  esac
done

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;
  
  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=""

case "$arg" in
  /*)
    base="$arg"
    ;;
  [^/]*/*)
    base="`pwd`/$arg"
    ;;
  *)
    for dir in `echo .:$PATH | sed 's/:/ /g'`
    do
      dir=$dir
      if [ -r "$dir/$arg.so" -o -r "$dir/$arg.flx" ]
      then
        base="$dir/$arg"
        break
      fi
    done
    ;;
esac

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

if [ "$TESTMODE" = "1" ]
then
  INCLUDE_DIR="."
  FLXG="./bin/flxg"
  FLXLIB="./lib"
  FLXRUN="./bin/flx_run"
else
  # Locate the felix installation
  prefix=""
  for dir in `echo $PATH | sed 's/:/ /g'`
  do
    dir=$dir
    if [ -x "$dir/flxg" ]
    then
      prefix="$dir/flxg"
      break
    fi
  done
  prefix="`echo $prefix | sed 's/\/bin\/flxg$//'`"
  INCLUDE_DIR="$prefix/lib/felix"
  FLXG="$prefix/bin/flxg"
  FLXRUN="$prefix/bin/flx_run"
  FLXLIB="$prefix/lib/felix/lib"
fi

# No need to compile, just run it

if [ $RECOMPILE = 0 -a -r "$base.so" -a "(" ! -r "$base.flx" -o "$base.so" -nt "$base.flx" ")" ]
then
  if [ $DEBUG = 1 ]; then echo "running $base.so"; fi
  "$FLXRUN" "$base.so"
  exit $?
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]; then echo "compiling $base.flx"; fi
if "$FLXG" -q -I"$FLXLIB" "$base"
then
  if `echo $GPP -shared -I"$INCLUDE_DIR" "$cpps" "$base.cpp" -o "$base.so"`
  then
    # rm -f "$base.cpp"
    "$FLXRUN" "$base.so"
    exit $?
  else
    exit $?
  fi
fi


@os.system('chmod a+x bin/flx')
@os.system('cp doc/*.css tut/doc &>/dev/null')

