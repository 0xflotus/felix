@head(1,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID

@h = tangler('script/detab.py','python')
@select(h)
import string
import sys

f = open(sys.argv[1])
data = f.readlines()
f.close()
f = open(sys.argv[1],"w")
for line in data:
  line = string.expandtabs(line)
  f.write(line)
f.close()

@h = tangler('script/mkocs.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/ocs-1.0/src/'

files = [
  'ocs_char.ml',
  'ocs_char.mli',
  'ocs_compile.ml',
  'ocs_compile.mli',
  'ocs_complex.ml',
  'ocs_complex.mli',
  'ocs_contin.ml',
  'ocs_contin.mli',
  'ocs_env.ml',
  'ocs_env.mli',
  'ocs_error.ml',
  'ocs_eval.ml',
  'ocs_eval.mli',
  'ocs_io.ml',
  'ocs_io.mli',
  'ocs_lex.ml',
  'ocs_lex.mli',
  'ocs_list.ml',
  'ocs_list.mli',
  'ocs_macro.ml',
  'ocs_macro.mli',
  'ocs_main.ml',
  'ocs_misc.ml',
  'ocs_misc.mli',
  'ocs_numaux.ml',
  'ocs_numaux.mli',
  'ocs_num.ml',
  'ocs_num.mli',
  'ocs_numstr.ml',
  'ocs_numstr.mli',
  'ocs_port.ml',
  'ocs_port.mli',
  'ocs_prim.ml',
  'ocs_prim.mli',
  'ocs_print.ml',
  'ocs_print.mli',
  'ocs_read.ml',
  'ocs_read.mli',
  'ocs_string.ml',
  'ocs_string.mli',
  'ocs_sym.ml',
  'ocs_sym.mli',
  'ocs_top.ml',
  'ocs_top.mli',
  'ocs_types.mli',
  'ocs_vartable.ml',
  'ocs_vartable.mli',
  'ocs_vector.ml',
  'ocs_vector.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'OCS')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mkcil.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/cil/'
files = [
  'src/check.ml',
  'src/check.mli',
  'src/cil.ml',
  'src/cil.mli',
  'src/cilutil.ml',
  'src/clist.ml',
  'src/clist.mli',
  'src/escape.ml',
  'src/escape.mli',
  'src/formatcil.ml',
  'src/formatcil.mli',
  'src/formatlex.mll',
  'src/formatparse.mly',
  'src/libmaincil.ml',
  'src/maincil.ml',
  'src/mergecil.ml',
  'src/mergecil.mli',
  'src/rmtmps.ml',
  'src/rmtmps.mli',
  'src/testcil.ml',
  'src/frontc/cabs2cil.ml',
  'src/frontc/cabs2cil.mli',
  'src/frontc/cabs.ml',
  'src/frontc/cabsvisit.ml',
  'src/frontc/cabsvisit.mli',
  'src/frontc/clexer.mli',
  'src/frontc/clexer.mll',
  'src/frontc/cparser.mly',
  'src/frontc/cprint.ml',
  'src/frontc/frontc.ml',
  'src/frontc/frontc.mli',
  'src/frontc/lexerhack.ml',
  'src/frontc/patch.ml',
  'src/frontc/patch.mli',
  'ocamlutil/errormsg.ml',
  'ocamlutil/errormsg.mli',
  'ocamlutil/inthash.ml',
  'ocamlutil/pretty.ml',
  'ocamlutil/pretty.mli',
  'ocamlutil/stats.ml',
  'ocamlutil/stats.mli',
  'ocamlutil/trace.ml',
  'ocamlutil/trace.mli',
  'ocamlutil/util.ml',
  'ocamlutil/util.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/flx_cil_'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')
  m = base[:i]
  mods[string.capitalize(m)]='Flx_cil_' + m

ms = mods.keys()
for k in ms:
  print mods[k]

print "@head(1,'CIL')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    for s in ms:
      r = mods[s]
      line = string.replace(line,s,r)
    print line,
      
@h = tangler('script/mk_fish','python')
@select(h)
import glob
glob = glob.glob

for i in glob("*.mli")+glob("*.mll")+glob("*.mly")+glob("*.ml"):
  if i not in ["parse_fish.ml","lex_fish.ml"]:
    print '@head(2,"'+i+'")'
    print i+"."
    print '@select(tangler("src/'+i+'"))'
    f = open(i)
    for j in f: print j,
    f.close()
    print

@h = tangler('script/mk_expect','python')
@select(h)
import glob
import sys
for k in sys.argv[1:]:
  files = glob.glob(k+'/*.output')
  print '@head(1,"Expected outputs for '+k+'")'
  for i in files:
    j = i[:-7]+'.expect'
    print '@head(2,"'+j+'")'
    print '@select(tangler("'+j+'","data"))'
    f = open(i,"r")
    for l in f: print l,
    f.close()

@h = tangler('script/get_grammar','python')
@select(h)
import string
import sys
f = open(sys.argv[1])
start = 0
count = 0
for l in f:
  if start:
    if l[:2]=='%%': start=0
    else:
      out = ""
      for ch in l:
        if ch == '{': count+=1
        elif ch == '}': count-=1
        elif count == 0: out += ch
      out = string.strip(out)
      if out: 
        if out[0]=='|': 
          out = string.strip(out[1:])
          if out=="": print "  | /* empty */"
          else: print "  | "+out
        elif out[-1]==':': 
          print 
          print out
        elif out==';': pass
        else: 
          print out
  elif l[:2]=='%%': start=1
f.close()


@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
@tangle("FLX_MAKER_CVS_ID='"+FLX_MAKER_CVS_ID+"'")
import os
import stat
import string
import sys
import re


try:
  execfile("config/config.py")
except:
  print "ERROR IN config/config.py"
  print "You must either"
  print "(a) edit config/config.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

FLXFLAGS = ""

# --------------------------------------------------
# IMPORT UTILITY RESOURCES
# ---------------------------------------------------
def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  return result,output

def get_stdouterr(x):
  return get_stdout(x+" 2>&1")

# define our version of C's system() function
def xqt(x):
  if "silent" not in options: print x
  try: sys.stdin.flush()
  except: pass
  result,output = get_stdouterr(x)
  if "quiet" not in options:
    if result: print "  .. ERROR CODE",hex(result)
    if output: print string.join(output,"")
  try: sys.stdin.flush()
  except: pass

  if result:
    raise MakeError

def nxqt(x):
  if "silent" not in options: print x
  try: sys.stdin.flush()
  except: pass
  result,output = get_stdouterr(x)
  if "quiet" not in options:
    if output: print string.join(output,"")
  try: sys.stdin.flush()
  except: pass

  if not result:
    raise MakeError


# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

options = sys.argv[1:]
if "silent" in options: 
  options.append("quiet")

if "bagley" in options: 
  options.append("time_execution")
  options.append("inline")

if "inline" in options:
  FLXFLAGS = FLXFLAGS + "--inline "
if options:
  print "OPTIONS: ", options

keyopt = {}
for o in options:
  try:
    key,value = string.split(o,"+=")
    old = keyopt.get(key,[])
    if type(old) == type(""): old = [old]
    keyopt[key] = old + [value]
  except:
    try:
      key,value = string.split(o,"=")
      keyopt[key]=value
    except: pass

USER_TESTS = keyopt.get("flx",[])
if type(USER_TESTS) == type(""):
  USER_TESTS = [USER_TESTS]

if "help" in options:
  print "extract - extract sources"
  print "compiler - build compiler"
  print "bytecode - build bytecode version of compiler"
  print "profile - build profiling version of compiler"
  print "drivers - build drivers"
  print "regression - run regression tests"
  print "performance - run performance tests"
  print "bagley - run bagley shootout performance tests"
  print "tutorial - run tutorial examples"
  print "tests- regression and tutorial combined"
  print "clean - remove generated C++ and binaries from test locations"
  print "debug - build debugging versions of targets"
  print "optimise - build high performance versions of targets"
  print "doc - build all user documentation"

if "clean" in options:
  os.system("rm -rf test/*.cpp test/*.hpp test/*.so test/*.par")
  os.system("rm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so tut/examples/*.par")
  os.system("rm -rf bagley/felix/*.cpp bagley/felix/*.hpp bagley/felix/*.so bagley/felix/*.par")

if "tests" in options or "test" in options:
  options = options + ["regression","tutorial"]

def flxg(x,basename):
  x = './bin/flxg ' + x
  xqt(x)

# ------------------------------------------------
# BEGIN USER CONFIGURABLE SECTION
#-------------------------------------------------

#interscript command (now built in part of Felix package)
def runISCR(a):
  if buildall:
    xqt(ISCR + "--nocache " + a)
  else:
    xqt(ISCR + ' ' + a)

if "compiler" in options or "bytecode" in options or "olink" in options:
  OCAML_OBJDIR = "src"
  BYTECODE = not NATIVE_CODE_COMPILER or "bytecode" in options 
  if BYTECODE:
    if "profile" in options: 
      OCAMLOPT = OCAMLCP
      OCAMLC = OCAMLCP
    else: OCAMLOPT = OCAMLB
  else:
    OCAMLOPT = OCAMLC
    if "profile" in options:
      OCAMLOPT = OCAMLOPT+' -p '
  
  OCAMLOPT = OCAMLOPT + " -I " + OCAML_OBJDIR
  OCAMLC = OCAMLC + " -I " + OCAML_OBJDIR
  
  if "debug" in options:
    OCAMLOPT = OCAMLOPT + '-g '

  if "optimise" in options:
    OCAMLOPT = OCAMLOPT + "-unsafe -noassert -inline 5 "

  if BYTECODE == 0:
    OCAML_OBJECT_EXTENSION = '.cmx'
    OCAML_LIB_EXTENSION = '.cmxa'
  else:
    OCAML_OBJECT_EXTENSION = '.cmo'
    OCAML_LIB_EXTENSION = '.cma'
    
# where gnu readline header files are
#READLINE_INCLUDE_DIRECTORY='/usr/include/readline'

#determine linkage model

LINK_MODEL = DEFAULT_LINK_MODEL
if "static" in options:
  LINK_MODEL = "static"
if "dynamic" in options:
  LINK_MODEL == "dynamic"

if LINK_MODEL == "dynamic" and not SUPPORT_DYNAMIC_LOADING:
  print "dynamic linkage not supported"
  sys.exit(1)

if LINK_MODEL == "static" and not SUPPORT_STATIC_LINKAGE:
  print "dynamic linkage not supported"
  sys.exit(1)

CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "
CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "

if LINK_MODEL == "dynamic":
  if CYGWIN:
    SHLX = ".dll"
  else:
    SHLX = ".so"
else:
  SHLX = ""

# for compiling mainlines
if "bagley" in options:
  CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-O3 "
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-O3 "
  CCOBJ_DLLIB = CCOBJ_DLLIB + "-O3 "
  CCOBJ_DLMAIN = CCOBJ_DLMAIN + "-O3 "
elif "optimise" in options:
  CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-O "
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-O "
  CCOBJ_DLLIB = CCOBJ_DLLIB + "-O "
  CCOBJ_DLMAIN = CCOBJ_DLMAIN + "-O "


# ------------------------------------------------
# END USER CONFIGURABLE SECTION
#-------------------------------------------------

# where documentation gets put
WEAVER_DIRECTORY='doc/'
TUTORIAL_DIRECTORY='tut/'
TUTORIAL_DOC=TUTORIAL_DIRECTORY+'doc/'
TUTORIAL_EXAMPLES=TUTORIAL_DIRECTORY+'examples/'

# where the garbage collector sources are
# (the collector is now a separate package)
FLX_GC_SRC='src/'

# -------------------------------------------------
# BEGIN IMPLEMENTOR CONFIGURABLE SECTION
# ------------------------------------------------

# files containing ocamllex sources
LEXS = [
  'lex_fish',
  'flx_cil_clexer',
  'flx_cil_formatlex',
  'flx_lex'
]

# files containing ocamlyacc sources
PARSES = [
  'parse_fish',
  'flx_cil_cparser',
  'flx_cil_formatparse',
  'flx_parse'
]

# ocaml modules = interfaces + implementation files

CIL_MODULES = [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
  'flx_cil_cilversion',
  'flx_cil_machdep',
  'flx_cil_pretty',
  'flx_cil_errormsg',
  'flx_cil_cabs_helper',
  'flx_cil_lexerhack',
  'flx_cil_escape',
  'flx_cil_cprint',
  'flx_cil_cparser',
  'flx_cil_clexer',
  'flx_cil_stats',
  'flx_cil_trace',
  'flx_cil_clist',
  'flx_cil_cil',
  'flx_cil_frontc',
  'flx_cil_rmtmps',
  'flx_cil_cabsvisit',
  'flx_cil_inthash',
  'flx_cil_formatparse',
  'flx_cil_formatlex',
  'flx_cil_util',
  'flx_cil_mergecil',
  'flx_cil_patch',
  'flx_cil_formatcil',
  'flx_cil_cilutil',
  'flx_cil_cabs2cil',
  'flx_cil_check',
]

MISC_MODULES = [
  'flx_filesys'      ,
]

FLX_MODULES = [
  'flx_mtypes1'      ,
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
  'flx_version'      ,
  'flx_ctype'        ,
  'flx_util'         ,
  'flx_dlst'         ,
  'flx_getopt'       ,
  'flx_mtypes2'      ,
  'flx_srcref'       ,
  'flx_typing'       ,
  'flx_exceptions'   ,
  'flx_string'       ,
  'flx_id'           ,
  'flx_print'        ,
  'flx_maps'         ,
  'flx_typing2'      ,
  'flx_unify'        ,
  'flx_charset'      ,
  'flx_constfld'     , 
  'flx_macro'        , 
  'flx_parse'        ,
  'flx_keywords'     ,
  'flx_prelex'       ,
  'flx_lex1'         ,
  'flx_tok'          ,
  'flx_lexstate'     ,
  'flx_preproc'      ,
  'flx_lex'          ,
  'flx_pretok'       ,
  'flx_parse_ctrl'   ,
  'flx_dfa'          ,
  'flx_pat'          , 
  'flx_desugar'      , 
  'flx_mbind'        , 
  'flx_symtab'       , 
  'flx_csubst'       , 
  'flx_name'         , 
  'flx_treg'         ,
  'flx_beta'         ,
  'flx_generic'      , 
  'flx_overload'     , 
  'flx_lookup'       , 
  'flx_bexe'         , 
  'flx_bbind'        , 
  'flx_label'        , 
  'flx_cflow'        , 
  'flx_call'         , 
  'flx_use'          , 
  'flx_useless'      , 
  'flx_inline'       , 
  'flx_stack_calls'  , 
  'flx_mkcls'        , 
  'flx_inst'         , 
  'flx_cexpr'        ,
  'flx_tgen'         , 
  'flx_display'      , 
  'flx_ogen'         , 
  'flx_regen'        ,
  'flx_unravel'      , 
  'flx_gen'          , 
  'flx_flxopt'       , 
  'flx_terminate'    , 
]

OCS_MODULES = [
  'ocs_vartable', 
  'ocs_error', 
  'ocs_port', 
  'ocs_types', 
  'ocs_sym', 
  'ocs_env',
  'ocs_char', 
  'ocs_numaux', 
  'ocs_complex', 
  'ocs_num', 
  'ocs_numstr', 
  'ocs_lex',
  'ocs_misc',
  'ocs_read', 
  'ocs_eval', 
  'ocs_list', 
  'ocs_compile', 
  'ocs_macro', 
  'ocs_prim', 
  'ocs_string',
  'ocs_vector', 
  'ocs_print', 
  'ocs_io', 
  'ocs_contin', 
  'ocs_top', 
]

FISH_MODULES = [
  'primitive_fish'     ,
  'types_fish'         ,
  'terms_fish'         ,
  'sugar_fish'         ,
  'environments_fish'  ,
  'type_subs_fish'     ,
  'substitution_fish'  ,
  'pretty_fish'        ,
  'util_fish'          ,
  'parse_fish'         ,
  'lex_fish'           ,
  'unify_fish'         ,
  'infer_fish'         ,
  'partial_ev_fish'    ,
  'turbot2C_fish'      ,
  'hook_fish'      ,
]

CIL_RAW_INTERFACES = [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
]

FLX_RAW_INTERFACES = [
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
] 

FISH_RAW_INTERFACES = [
  'ocs_types',
  'ocs_error'
]

OCS_RAW_INTERFACES = [
]

MISC_INTERFACES = MISC_MODULES
FLX_INTERFACES = FLX_MODULES
CIL_INTERFACES = CIL_MODULES
OCS_INTERFACES = OCS_MODULES
FISH_INTERFACES = FISH_MODULES

MISC_IMPLEMENTATIONS = MISC_INTERFACES
FLX_IMPLEMENTATIONS = FLX_INTERFACES
OCS_IMPLEMENTATIONS = OCS_INTERFACES
CIL_IMPLEMENTATIONS = CIL_INTERFACES
FISH_IMPLEMENTATIONS = FISH_INTERFACES
  
IMPLEMENTATIONS = MISC_IMPLEMENTATIONS + CIL_IMPLEMENTATIONS + FISH_IMPLEMENTATIONS + OCS_IMPLEMENTATIONS + FLX_IMPLEMENTATIONS 
INTERFACES = MISC_INTERFACES + CIL_INTERFACES + FISH_INTERFACES + OCS_INTERFACES + FLX_INTERFACES
RAW_INTERFACES = CIL_RAW_INTERFACES + FISH_RAW_INTERFACES + OCS_RAW_INTERFACES + FLX_RAW_INTERFACES

RTL_CPPS = [
  "rtl/flx_gc",
  "rtl/flx_collector",
  "rtl/flx_rtl",
  "rtl/flx_dynlink",
  "rtl/flx_i18n",
  "rtl/flx_ioutil",
  "rtl/printval_fish",
  "rtl/saveval_fish",
  "rtl/xmalloc_fish",
]

DRIVERS = [
  ('rtl/flx_run','bin/flx_run'),
  ('test/flx_perf_drv1','test/flx_perf_drv1'),
  ('rtl/flx_stdin_drv','bin/flx_stdin_drv'),
]

# C files that we need to compile, with options required to build them
COBJECTS = {
}
# *.so/.a libraries
CLIBRARIES = ['nums']

# *.cmxa or .cma libraries
# and some hackery so we can if the source doesn't need
# ocaml-fileutils we can still build if it isn't found
OCAML_INCLUDES = ""
OLIBRARIES = ['nums','unix','misclib','cillib','fishlib','ocslib','flxlib']

OCAMLLIBS = [
  ('misclib',MISC_IMPLEMENTATIONS),
  ('cillib',CIL_IMPLEMENTATIONS),
  ('fishlib',FISH_IMPLEMENTATIONS),
  ('ocslib',OCS_IMPLEMENTATIONS),
  ('flxlib',FLX_IMPLEMENTATIONS),
]

# target executable programs to produce
EXES = [
  # compiler tools
  'fish',
  'flxf',
  'flxl',
  'flxp',
  'flxm',
  'flxd',
  'flxb',
  'flxg',
  'flxcc',
  'stub',
  'ocs_main',
]

if 1:
  s = ' -cclib "-Lsrc '
  for library in CLIBRARIES:
    s = s + ' -l'+library
  s = s + '"'
  LDFLAGS = s
  del s

if 1:
  o = ''
  for object in COBJECTS.keys():
    o = o + ' src/' + object + '.o'
  OBJECT_FILES = o
  del o

TESTS= USER_TESTS
BAD_TESTS = []

SPECIAL_TESTS = [
  ('bin/flx_run','test/flx_run_lib1.flx',''),
  ('test/flx_perf_drv1','test/flx_perf_lib1.flx','1000'),
  ('bin/flx_stdin_drv','test/flx_stdin_lib1.flx','<Makefile >tmp.tmp'),
]

# -------------------------------------------------
# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------

# ----------- Utilities ---------------------
class MakeError: pass

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except:
    t = 0
  return t

def run(x):
  print x
  try: sys.stdin.flush()
  except: pass
  result = os.system(x)
  if result: print "  .. ERROR CODE",hex(result)
  try: sys.stdin.flush()
  except: pass

  if result:
    raise MakeError

def erasefile(f):
  try:
    os.unlink(f)
  except:
    pass
# ----------- Here begins the actual build procedure ---------------------

buildall = "clean" in options or "force" in options
stop_on_error = "stop_on_error" in options
import glob

def copy_mli2ml():
  for f in RAW_INTERFACES:
    if filetime("src/"+f+".mli") > filetime("src/"+f+".ml"):
      os.system("cp src/"+f+".mli src/"+f+".ml")


try:
  # STEP 0: run interscript
  if "doc" in options:
    runISCR('--language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+WEAVER_DIRECTORY+' lpsrc/flx.pak')
    copy_mli2ml()
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tutorial.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_macro.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_bind.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_migrate.pak')
  elif "extract" in options:
    runISCR('lpsrc/flx.pak')
    copy_mli2ml()
    runISCR('lpsrc/flx_tutorial.pak')
    runISCR('lpsrc/flx_tut_macro.pak')
    runISCR('lpsrc/flx_tut_bind.pak')
    runISCR('lpsrc/flx_tut_migrate.pak')
  os.system('rm -f tmp.tmp')

  if "doc" in options or "man" in options:
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = string.split(file,".")[0]
        xqt(
          "man2html man/man1/" + file + 
          '| sed -e "s%http://localhost/cgi-bin/man/man2html?1+\(.*\)\\">%\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "htmlman/" + basename+'_1.html'
        )
    except:pass
  
  if "doc" in options or "impldoc" in options:
    xqt('rm -rf impldoc/*')
    xqt('ocamldoc -I src -d impldoc src/*.mli -html')
    xqt('ocamldoc -I src -o impldoc/flx_impl.tex src/*.mli -latex')
    xqt('(cd impldoc; latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex)')

  if "regression" in options:
    TESTS = TESTS + glob.glob('test/rt*.flx')
    if LINK_MODEL == "dynamic":
      TESTS = TESTS + glob.glob('test/drt*.flx')

    BAD_TESTS = glob.glob('test/bt*.flx')

  if "tutorial" in options:
    TESTS = TESTS + glob.glob('tut/examples/tut*.flx')
    TESTS = TESTS + glob.glob('tut/examples/mac*.flx')
    TESTS = TESTS + glob.glob('tut/examples/mig*.flx')

  BAGLEY = []
  if "bagley" in options:
    BAGLEY = glob.glob('bagley/felix/bag*.flx')

  TESTS.sort()
  BAD_TESTS.sort()
  BAGLEY.sort()

  if "compiler" in options or "olink" in options:
    # STEP 1: Compile all compiler support C files
    for cobject in COBJECTS.keys():
      flags = COBJECTS[cobject]
      file = 'src/'+cobject
      if buildall or filetime(file +".c") > filetime(file +".o"):
        xqt(CCOMPILE +" -I "+OCAML_INCLUDE_DIRECTORY+" -Irtl "+flags+" "+file+".c")

    # STEP 2: Generate lexers
    for lex in LEXS:
      file = 'src/'+lex
      if buildall or filetime(file + '.mll') > filetime(file +'.ml'):
        buildall = 1
        xqt(OCAMLLEX + file + '.mll')

    # STEP 3: Generate parsers
    for parse in PARSES:
      file = 'src/'+parse
      if buildall or filetime(file + '.mly') > filetime(file +'.ml'):
        buildall = 1
        xqt(OCAMLYACC+ ' -v '+ file + '.mly')
        if file <> "src/parse_fish":
          nxqt("grep conflict " + file + ".output")

    # STEP 4: Compile ocaml interfaces
    for interface in INTERFACES:
      file = 'src/'+interface
      if buildall or filetime(file + '.mli') > filetime(file+'.cmi'):
        buildall = 1
        xqt(OCAMLC + ' ' + OCAML_INCLUDES+' -c '+file+ '.mli')

    # STEP 5: Compile ocaml implementations
    for implementation in IMPLEMENTATIONS + EXES:
      file = 'src/'+implementation
      if buildall or filetime(file+ '.ml') > filetime(file+OCAML_OBJECT_EXTENSION):
        buildall = 1
        xqt(OCAMLOPT + ' '+ OCAML_INCLUDES+ ' -c ' + file +'.ml')


    # STEP 6: Build FELIX Library
    if "olink" in options: buildall = 1
    for lib,IMPLEMENTATIONS in OCAMLLIBS:
      object_library_name = "src/" + lib + OCAML_LIB_EXTENSION
      linkstring = OCAMLOPT + " -a -o " + object_library_name + " "
      library_filetime = filetime(object_library_name)
      for implementation in IMPLEMENTATIONS:
        file = 'src/'+implementation
        if buildall or filetime(file+OCAML_OBJECT_EXTENSION) > library_filetime:
          for implementation in IMPLEMENTATIONS:
            file = 'src/'+implementation
            linkstring = linkstring + file +OCAML_OBJECT_EXTENSION +" "
          xqt(linkstring)
          buildall = 1
          break

    # STEP 8: Link executables
    x = ''
    for library in OLIBRARIES:
      x = x + ' ' + library + OCAML_LIB_EXTENSION

    # finally, mainline *.cmx or cma files to link to executables
    for exe in EXES:
      if buildall or filetime(exe + OCAML_OBJECT_EXTENSION) > filetime(exe):
        xqt(OCAMLOPT + LDFLAGS + ' ' + OCAML_INCLUDES + ' -o bin/'+exe + x + OBJECT_FILES + ' src/flx_version_hook.ml ' + exe + OCAML_OBJECT_EXTENSION)

  # COMPILE RTL  
  if "rtl" in options:
    if SUPPORT_DYNAMIC_LOADING:
      ars = ""
      for x in RTL_CPPS:
        print 'Compiling rtl object',x
        ars = ars + x + "_dynamic.o "
        xqt(CCOBJ_DLLIB + " -Irtl " + x + ".cpp -o " +x+"_dynamic.o")
      xqt(AR + " rtl/libflx_dynamic.a " + ars)
      xqt(RANLIB + " rtl/libflx_dynamic.a")

      if CYGWIN:
        print "Building RTL for CYGWIN dynamic linkage"
        cmd = (CCLINK_DLLIB + " -shared -o bin/cygflx_dynamic.dll " +
          "--export-all-symbols --enable-auto-import " +
          "--out-implib=rtl/libflx_dynamic.dll.a ")
        xqt(cmd)
      else:
        xqt(CCLINK_DLLIB + "-o rtl/libflx_dynamic.so "+ars)

    if SUPPORT_STATIC_LINKAGE:
      ars = ""
      for x in RTL_CPPS:
        print 'Compiling rtl object',x
        ars = ars + x + "_static.o"
        xqt(CCOBJ_STATIC_LIB + " -Irtl " + x + "cpp -o " +x+"_static.o")
      xqt(AR + " rtl/libflx_static.a " + ars)
      xqt(RANLIB + " rtl/libflx_static.a")

  # COMPILE DRIVER PROGRAMS
  if "drivers" in options:
    if SUPPORT_STATIC_LINKAGE:
      for i,j in DRIVERS:
        print 'Compiling driver object',i
        xqt(CCOBJ_STATIC_MAIN + " -Irtl " + i + ".cpp -o " +i+"_static.o")

    if SUPPORT_DYNAMIC_LOADING:
      for i,j in DRIVERS:
        print 'Compiling driver object',i
        xqt(CCOBJ_DLMAIN + " -Irtl " + i + ".cpp -o " +i+"_dynamic.o")

        if CYGWIN:
          xqt("g++ -o "+j+" -Wl,--enable-auto-import " + i + "_dynamic.o -Lrtl -lflx_dynamic")
        else:
          xqt(CCLINK_DLMAIN + " -o "+j+" -Lrtl -lflx_dynamic " +i+"_dynamic.o")

  # run tests
  try:
    results = []

    # GENERATE C++ FROM FELIX SOURCE
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)
    for testfile in TESTS+EXTRA+BAGLEY:
      #print 'Running Felix code generator on ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or \
        filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
        filetime('bin/flxg')> filetime(basename+'.cpp') or \
        filetime('lib/std.flx') > filetime(basename+'.cpp'):
        try:
          flxg('-Ilib ' +FLXFLAGS + basename,basename)
          #print 'TESTFILE -- generated ',basename
          results.append(("flxg",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+'.cpp')
          erasefile(basename+'.hpp')
          erasefile(basename+SHLX)
          if stop_on_error: raise MakeError
          results.append(("flxg",basename,'ERROR'))

    # FAILURE TESTS 
    if "regression" in options:
      for testfile in BAD_TESTS:
        #print 'Running Felix code generator on ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or \
          filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
          filetime('bin/flxg')> filetime(basename+'.cpp') or \
          filetime('lib/std.flx') > filetime(basename+'.cpp'):
          try:
            xqt('bin/flxg -e -Ilib ' + basename + " 2>&1 >/dev/null")
            #print 'TESTFILE -- failed as expected',basename
            results.append(("flxg",basename,'OK'))
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
          except MakeError:
            print 'TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED!',basename
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
            if stop_on_error: raise MakeError
            results.append(("flxg",basename,'ERROR'))

    # C++ COMPILE and static link tests
    # produces shared library or executable
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)
    for testfile in TESTS+EXTRA+BAGLEY:
      #print 'Compiling generated code of ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or filetime(basename+ '.cpp') > filetime(basename+SHLX):
        try:
          if LINK_MODEL == "dynamic":
            if CYGWIN:
              xqt("g++ -w -ansi -g -o "+basename+SHLX+" -shared -Irtl "+cppfilename+" -Lrtl -lflx_dynamic -Wl,--enable-auto-import")
            else:
              xqt(CCOBJ_DLLIB+" -Irtl "+cppfilename + " -o " + basename + "_dynamic.o")
              xqt(CCLINK_DLLIB+" -Lrtl -lflx_dynamic -o "+ basename + SHLX + " "+basename+"_dynamic.o")
          else:
            xqt(CCOBJ_STATIC_LIB +" -Irtl "+cppfilename + " -o " + basename + "_static.o" )
            xqt(CCLINK_STATIC +" -Irtl ./rtl/flx_run_static.o "+basename+ "_static.o -Lrtl -lflx_static -o " + basename + SHLX )
          #print 'TESTFILE -- OK!',basename
          results.append(("g++",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+SHLX)
          if stop_on_error: raise MakeError
          results.append(("g++",basename,'ERROR'))


    # run the tests
    for testfile in TESTS:
      basename = string.split(testfile,'.')[0]
      if LINK_MODEL == "dynamic":
        testscript = "env LD_LIBRARY_PATH=./rtl:$LD_LIBRARY_PATH ./bin/flx_run ./"+basename+SHLX
      else:
        testscript = "./"+basename+SHLX

      if "log_output" in options:
        testscript = testscript + " >" + basename + ".output"

      elif "time_execution" in options:
        testscript = "time " + testscript 

      elif "check_output" in options:
        testscript = testscript + " >" + basename + ".output"
        testscript = testscript + " && diff -a -b " + basename + ".expect "+ basename + ".output"

      #print 'Executing ',testscript
      try:
        run(testscript)
        #print 'TESTFILE -- OK!',testscript
        results.append(("Exec",testscript,'OK'))
      except MakeError:
        print 'TESTFILE -- ERROR!',testscript
        if stop_on_error: raise MakeError
        results.append(("Exec",testscript,'ERROR'))
    
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS:
        test_basename = string.split(testfile,'.')[0]
        drv_basename = string.split(driver,'.')[0]
        if LINK_MODEL == "dynamic":
          testscript = "env LD_LIBRARY_PATH=./rtl:$LD_LIBRARY_PATH time ./"+drv_basename+ " ./"+test_basename+SHLX+" " + moreargs
        else:
          testscript = "time ./"+test_basename+SHLX+" " + moreargs
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append(("Exec Special",testscript,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append(("Exec Special",testscript,'ERROR'))

    print "RUN COMPLETE"

  finally:
    # REPORT FINAL RESULTS
    print
    print '**********************************'
    #print 'final results'
    total = 0
    bad = 0
    for x,y,z in results: 
      total = total + 1
      if "OK" == z: pass
      else:
        bad = bad + 1
        print x,y,z
    if total <> 0:
      if bad == 0: 
        print "ALL",total,"PASSED"
      else:
        print "Bad",bad,"/",total
    print '**********************************'

except MakeError:
  print "Terminating due to error"
  sys.exit(1)

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('PREFIX='+PREFIX)
@tangle('SHLIB_DIR=${PREFIX}/lib')
@tangle('SHINC_DIR=${PREFIX}/include')
@tangle('INSTALL_DIR=${PREFIX}/lib/felix')
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('BUILTIN_ISCR=env PYTHONPATH=. python -O interscript/bin/iscr.py --nocache')
@tangle('')
@tangle('all: dummy')
@tangle('\tpython script/maker extract compiler rtl drivers test log_output check_output')
@tangle('')

@tangle('profile: dummy')
@tangle('\tpython script/maker compiler profile')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\tpython script/maker compiler bytecode')
@tangle('')
@tangle('bytecode.profile: dummy')
@tangle('\tpython script/maker compiler bytecode profile')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\tpython script/maker compiler bytecode debug')
@tangle('')
@tangle('extract: dummy')
@tangle('\tpython script/maker extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\tpython script/maker extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\tpython script/maker tutorial')
@tangle('')
@tangle('grammar: dummy')
@tangle('\tpython script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar')
@tangle('\tpython script/get_grammar src/flx_cil_cparser.mly >misc/flx_cil_cparser.grammar')
@tangle('\tpython script/get_grammar src/parse_fish.mly >misc/parse_fish.grammar')
@tangle('')
@tangle('compiler: dummy')
@tangle('\tpython script/maker compiler')
@tangle('')
@tangle('doc: grammar')
@tangle('\tpython script/maker doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('\tmake impldoc')
@tangle('')
@tangle('man: dummy')
@tangle('\tpython script/maker man')
@tangle('')
@tangle('test.fish: dummy')
@tangle('\tbin/flxf -Ilib -Irtl fish/tfish')
@tangle('')
@tangle('test: dummy')
@tangle('\tpython script/maker test stop_on_error')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('test.static: dummy')
@tangle('\tpython script/maker test static stop_on_error')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\tpython script/maker inline test stop_on_error')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\tpython script/maker debug test stop_on_error')
@tangle('')
@tangle('tests: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('tests.verify: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\tpython script/maker test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\tpython script/maker inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\tpython script/maker performance')
@tangle('')
@tangle('performance: tests.performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\tpython script/maker regression')
@tangle('')
@tangle('tests.bagley: dummy')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('rtl: dummy')
@tangle('\tpython script/maker rtl')
@tangle('')
@tangle('expect.bagley: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tpython script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('expect: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tpython script/maker test log_output')
@tangle('\tpython script/mk_expect tut/examples > lpsrc/flx_tut_expect.ipk')
@tangle('\tpython script/mk_expect test > lpsrc/flx_test_expect.ipk')
@tangle('\tpython script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('drivers: dummy')
@tangle('\tpython script/maker drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('\tpython script/maker drivers debug')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.08.1 or better')
@tangle('\t#REQUIRES g++ 3.xx or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#REQUIRES g++ 2.96 or better')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required priviledges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')

@tangle('tarball: dummy')
@tangle('\trm -f flx_'+flx_version)
@tangle('\tln -s . flx_'+flx_version)
@tangle('\ttar -zcvf flx_'+flx_version+'_src.tgz\\')
@tangle('\t\tflx_'+flx_version+'/configure\\')
@tangle('\t\tflx_'+flx_version+'/Makefile\\')
@tangle('\t\tflx_'+flx_version+'/README \\')
@tangle('\t\tflx_'+flx_version+'/CONTENTS \\')
@tangle('\t\tflx_'+flx_version+'/INSTALL \\')
@tangle('\t\tflx_'+flx_version+'/VERSION \\')
@tangle('\t\tflx_'+flx_version+'/LICENSE \\')
@tangle('\t\tflx_'+flx_version+'/NEWS \\')
@tangle('\t\tflx_'+flx_version+'/AUTHORS \\')
@tangle('\t\tflx_'+flx_version+'/COPYING\\')
@tangle('\t\tflx_'+flx_version+'/ChangeLog \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.ipk\\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.pak\\')
@tangle('\t\tflx_'+flx_version+'/interscript/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.dat \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('\ttar -zcvf flx_'+flx_version+'_bin_linux.tgz\\')
@tangle('\t\tflx_'+flx_version+'/configure\\')
@tangle('\t\tflx_'+flx_version+'/Makefile\\')
@tangle('\t\tflx_'+flx_version+'/README \\')
@tangle('\t\tflx_'+flx_version+'/CONTENTS \\')
@tangle('\t\tflx_'+flx_version+'/INSTALL \\')
@tangle('\t\tflx_'+flx_version+'/VERSION \\')
@tangle('\t\tflx_'+flx_version+'/LICENSE \\')
@tangle('\t\tflx_'+flx_version+'/NEWS \\')
@tangle('\t\tflx_'+flx_version+'/AUTHORS \\')
@tangle('\t\tflx_'+flx_version+'/COPYING\\')
@tangle('\t\tflx_'+flx_version+'/ChangeLog \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tflx_'+flx_version+'/script/maker \\')
@tangle('\t\tflx_'+flx_version+'/script/*\\')
@tangle('\t\tflx_'+flx_version+'/src/*.ml \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mli \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mly \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mll \\')
@tangle('\t\tflx_'+flx_version+'/rtl/*.cpp\\')
@tangle('\t\tflx_'+flx_version+'/rtl/*.hpp\\')
@tangle('\t\tflx_'+flx_version+'/lib/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/lib/*.fsh \\')
@tangle('\t\tflx_'+flx_version+'/test/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/test/*.cpp \\')
@tangle('\t\tflx_'+flx_version+'/tut/examples/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.css \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.tex \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.css \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.tex \\')
@tangle('\t\tflx_'+flx_version+'/licenses/*.txt \\')
@tangle('\t\tflx_'+flx_version+'/misc/* \\')
@tangle('\t\tflx_'+flx_version+'/htmlman/*.html \\')
@tangle('\t\tflx_'+flx_version+'/man/man1/*.1 \\')
@tangle('\t\tflx_'+flx_version+'/impldoc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/bin/flx \\')
@tangle('\t\tflx_'+flx_version+'/interscript/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.dat \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('www: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_sourceforge.pak')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_web.pak')
@tangle('')
@tangle('clean: dummy')
@tangle('\trm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so tut/examples/*.dll tut/examples/*.par tut/examples/*.o tut/examples/*.output')
@tangle('\trm -rf test/*.cpp test/*.hpp test/*.so test/*.dll test/*.par test/*.o test/*.output')
@tangle('\trm -rf bagley/felix/*.cpp bagley/felix/*.hpp bagley/felix/*.so bagley/felix/*.dll bagley/felix/*.par bagley/felix/*.o')
@tangle('')
@tangle('virgin: dummy')
@tangle('\tcp Makefile Makefile.old')
@tangle('\trm -rf tut rtl test www src misc man script bin doc lib impldoc htmlman tmp tmp.tmp')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('\trm -rf bagley')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf interscript/*.pyc')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -f README LICENSE VERSION CONTENTS INSTALL AUTHORS NEWS COPYING ChangeLog')
@tangle('')

@tangle('backup: dummy')
@tangle('\t(DATE=`date -I`;\\')
@tangle('\tmkdir -p "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.ipk "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.pak "lpbackup/$${DATE}"\\')
@tangle('\t)')
@tangle('')

@tangle('config: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_config.pak')
@tangle('\tpython -O script/make_config.py --quiet --prefix=${PREFIX}')
@tangle('')
@tangle('config/config.py: config')
@tangle('')
@tangle('boot: config/config.py')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx.pak')
@for i in [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
  ]:
  tangle('\tcp src/'+i+'.mli src/'+i+'.ml')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tfor i in tmp/*.default; do cp $$i config/`basename $$i .default`; done')
@tangle('')
@tangle('wrappers.clean:')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('')
@tangle('config/cxx.flxcc: default_wrappers')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/c89.flxcc')
@tangle('\tbin/flxcc config/c99.flxcc')
@tangle('\tbin/flxcc config/gnu89.flxcc')
@tangle('\tbin/flxcc config/gnu99.flxcc')
@tangle('\tbin/flxcc config/cxx.flxcc')
@tangle('\tbin/flxcc config/cxx_sys.flxcc')
@tangle('\tbin/flxcc config/gnucxx.flxcc')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\t#"INSTALL_DIR=${INSTALL_DIR}"')
@tangle('\t#"EXEC_DIR=${EXEC_DIR}"')
@tangle('\t#"MAN_DIR=${MAN_DIR}"')
@tangle('\t#"SHLIB_DIR=${SHLIB_DIR}"')
@tangle('\t#"SHINC_DIR=${SHINC_DIR}"')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${SHLIB_DIR}')
@tangle('\tinstall -d ${SHINC_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/config')
@tangle('\tinstall -d ${INSTALL_DIR}/doc')
@tangle('\tinstall -d ${INSTALL_DIR}/htmlman')
@tangle('\tinstall config/*.py ${INSTALL_DIR}/config')
@tangle('\tinstall config/*.flxcc ${INSTALL_DIR}/config')
@tangle('\tinstall lib/* ${INSTALL_DIR}/lib')
@tangle('\tinstall rtl/*.hpp ${SHINC_DIR}')
@tangle('\tinstall rtl/* ${INSTALL_DIR}/rtl')
@if SUPPORT_STATIC_LINKAGE:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_static.a')
  tangle('\tinstall rtl/libflx_static.a ${SHLIB_DIR}')
  tangle('\t'+RANLIB+' ${SHLIB_DIR}/libflx_static.a')
@if SUPPORT_DYNAMIC_LOADING:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_dynamic.a')
  tangle('\tinstall rtl/libflx_dynamic.so ${SHLIB_DIR}')
  tangle('\tinstall rtl/libflx_dynamic.a ${SHLIB_DIR}')
  tangle('\t'+RANLIB+' ${SHLIB_DIR}/libflx_dynamic.a')
@tangle('\t(install doc/* ${INSTALL_DIR}/doc || exit 0) > /dev/null 2>&1')
@tangle('\t(install impldoc/* ${INSTALL_DIR}/impldoc || exit 0) > /dev/null 2>&1')
@tangle('\t(install htmlman/* ${INSTALL_DIR}/htmlman || exit 0) > /dev/null 2>&1')
@tangle('\tinstall bin/* ${EXEC_DIR}')
@tangle('\t(install man/man1/* ${MAN_DIR}/man1 || exit 0) > /dev/null 2>&1')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = string.replace(FLX_MAKER_CVS_ID,"$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle("# These targets are for SKALLER only")
@tangle("# they're used to upload stuff to sourceforge")
@tangle('upload_www: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('')
@tangle('upload_src: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('upload: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('\tscp flx_'+flx_version+'_bin_linux.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')

@head(1,'configure')
A shell script to run the config step.
@select(tangler('configure'))
echo "Configuring Felix"
grab=1

PREFIX=$PREFIX
while (( "$grab" == "1" ));
do
  case x$1 in
  x--prefix=*)
     PREFIX="`echo \"$1\" | sed 's/--prefix=\(.*\)/\\1/'`"
     shift
  ;;

  x--prefix)
    shift
    PREFIX="$1"
    shift
  ;;

  x) 
    grab=0
  ;;
  esac
done

echo "Installing at PREFIX=$PREFIX"
make PREFIX=$PREFIX config
make PREFIX=$PREFIX boot
make grammar
make extract

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues Cassé

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors. The C parser is derived from
FrontC/CIL which is has BSD licence.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something .. 

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something .. 


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENSE   license details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary
 
  Makefile   the makefile, mainly hooks into script/maker
 
  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  meta   -- contains various package manager meta-data files
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENSE')
@select(tangler('LICENSE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file 


lpsrc/flx_frontc.ipk
lpsrc/flx_cil.ipk

are covered by a BSD Licence, here is the copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.08.1 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace
   
@tangle('   tar -zxvf flx_'+flx_version+'_src.tgz')
@tangle('   cd felix_'+flx_version)

4. Bootstrap the system.

  ./configure

OR type

   make config
   make boot
   make extract

EDIT THE FILES

  config/*.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make 

6. Build the documentation and tutorial

   make doc 

7. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak 
  
                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  include "std";
  print "It works!"; endl;

and then run it:
  
  flx -Ilib mytest

@head(1,'.cvsignore')
This is actually put in the lpsrc directory to tell
cvs to ignore certain files.
@select(tangler('lpsrc/.cvsignore','data'))
*.cache
*.swp


@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.

@select(tangler('doc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('doc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)


@head(1,"fishcc")
Script to compile a C program generated by FISh.
@select(tangler("bin/fishcc"))
grab=1
CCFLAGS=""
while (( "$grab" == "1" ));
do
  case x$1 in
  x-*)
    CCFLAGS="$CCFLAGS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done
@tangle('cmd="'+CCLINK_STATIC+' $1 -O -o `basename $1 .c` `echo "$CCFLAGS"` -lflx_static"')
echo $cmd
`$cmd`

@head(1,'Run script')
@select(tangler('bin/flx'))
#!/bin/bash
# flx - felix script harness

# g++ compilation string
@tangle('CCOBJ_DLLIB="'+CCOBJ_DLLIB+'"')
@tangle('CCLINK_DLLIB="'+CCLINK_DLLIB+'"')
@tangle('CCOBJ_STATIC_LIB="'+CCOBJ_STATIC_LIB+'"')
@tangle('CCLINK_STATIC="'+CCLINK_STATIC+'"')
@tangle('VERSION="'+flx_version+'"')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=0
ECHO=0
TIME=0
@if DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
cpps=""

grab=1

INCLUDE_DIRS=""

while (( "$grab" == "1" ));
do
  case x$1 in
  x--test)
    TESTMODE=1
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    ECHO=1
    shift
  ;;

  x--time)
    TIME=1
    shift
  ;;

  x--echo)
    ECHO=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline)
    INLINE=1
    shift
  ;;

  x--optimise)
    INLINE=1
    cpps="-O3 $cpps"
    shift
  ;;

  x--optimize)
    INLINE=1
    cpps="-O3 $cpps"
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--help)
    man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done

if [ "$TESTMODE" = "1" -a "$ECHO" = "1" ]
then
  echo "TESTMODE: running felix from current directory"
fi

# make a list of any *.cpp files (or other g++ options ..)

grab=1
pkgs=""
while (( "$grab" == "1" ));
do
  case "$1" in
    *.cpp)
      cpps="$cpps $1"
      shift
    ;;

    *.cxx)
      cpps="$cpps $1"
      shift
    ;;

    *.c)
      cpps="$cpps $1"
      shift
    ;;
     
    *.o)
      cpps="$cpps $1"
      shift
    ;;

    *.a)
      cpps="$cpps $1"
      shift
    ;;

    --pkg=*)
      pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
      shift
    ;;
    
    -*)
      cpps="$cpps $1"
      shift
    ;;
   
    *)
      grab=0
    ;;
  esac
done

if [ "x$pkgs" = "x" ] 
then
  PKGS=""
else
  PKGS=`pkg-config --cflags --libs $pkgs`
fi
 
if [ "x$1" = "x" ]
then
  echo "usage: flx filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;
  
  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=""

case "$arg" in
  /*)
    base="$arg"
    ;;
  [^/]*/*)
    base="`pwd`/$arg"
    ;;
  *)
    for dir in `echo .:$PATH | sed 's/:/ /g'`
    do
      dir=$dir
      if [ -r "$dir/$arg.so" -o -r "$dir/$arg.flx" ]
      then
        base="$dir/$arg"
        break
      fi
    done
    ;;
esac

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)  
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

if [ "$TESTMODE" = "1" ]
then
  INCLUDE_DIR="./rtl"
  FLXG="./bin/flxg"
  FLXLIB="./lib"
  FLXRUN="env LD_LIBRARY_PATH=./rtl:\$LD_LIBRARY_PATH ./bin/flx_run"
  FLXRTL="./rtl"
  FLXBIN="./bin"
else
  # Locate the felix installation
  prefix=""
  for dir in `echo $PATH | sed 's/:/ /g'`
  do
    dir=$dir
    if [ -x "$dir/flxg" ]
    then
      prefix="$dir/flxg"
      break
    fi
  done
  prefix="`echo $prefix | sed 's/\/bin\/flxg$//'`"
  INCLUDE_DIR="$prefix/lib/felix/rtl"
  FLXG="$prefix/bin/flxg"
  FLXRUN="$prefix/bin/flx_run"
  FLXLIB="$prefix/lib/felix/lib"
  FLXRTL="$prefix/lib/felix/rtl"
  FLXBIN="$prefix/bin"
fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base.so" -a "(" ! -r "$base.flx" -o "$base.so" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      if [ $ECHO = 1 ]; then echo "running $base.so"; fi
      `echo "$FLXRUN" "$base.so $args"`
    fi
    exit $?
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base" -a "(" ! -r "$base.flx" -o "$base" -nt "$base.flx" ")" ]
  then
    if [ $ECHO = 1 ]; then echo "running $base"; fi
    if [ $RUNIT = 1 ]
    then
      `echo "$base $args"`
    fi
    exit $?
  fi
fi

# Need Felix and c++ compile, then run it

if [ $ECHO = 1 ]
then 
  echo "compiling $base.flx"
fi

if [ $DEBUG = 1 ]
then 
  VERBOSE="-v"
  CCFLAGS="-g"
else
  VERBOSE="-q"
  CCFLAGS=""
fi

if [ $INLINE = 1 ]
then
  FLXFLAGS="--inline"
else
  FLXFLAGS=""
fi

if [ $STATIC = 0 ]
then
  if `echo "$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"` 
  then
    CMD=`echo $CCLINK_DLLIB $CCFLAGS -I"$INCLUDE_DIR" "$INCLUDE_DIRS" "$PKGS" "$cpps" "$base.cpp" -o "$base.so"`
    if [ $ECHO = 1 ] 
    then 
      echo "$CMD"
    fi
    if `$CMD`
    then
      # rm -f "$base.cpp"
      if [ $RUNIT = 1 ]
      then
        if [ $TIME = 1 ]
        then
          `echo "time $FLXRUN" "$base.so" $args`
        else
          `echo "$FLXRUN" "$base.so" $args`
        fi
      fi
      exit $?
    else
      exit $?
    fi
  fi
else
  if `echo "$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"` 
  then
    CMD=`echo $CCLINK_STATIC $CCFLAGS -DFLX_STATIC_LINK -I"$INCLUDE_DIR" "$INCLUDE_DIRS" $FLXRTL/flx_run_static.o "$PKGS" "$cpps" "$base.cpp" $FLXRTL/libflx_static.a -o "$base"`
    if [ $ECHO = 1 ] 
    then 
      echo "$CMD"
    fi

    if `$CMD`
    then
      # rm -f "$base.cpp"
      if [ $RUNIT = 1 ]
      then
        if [ $TIME ]
        then
          `echo time $base $args`
        else
          `echo $base $args`
        fi
      fi
      exit $?
    else
      exit $?
    fi
  fi
fi

@head(1,'Package Manager Meta Info')
@head(2,'GODI')
This is the Godiva file originally used to
create the GODI data. At the moment this is
the authoritative meta data. However,
godiva may not handle all the options
we need -- so the generated makefile
is included as well.

@select(tangler('meta/godiva/flx.godiva','data'))
Package: apps-felix
@tangle('Version: '+flx_version)
Revision: 0
Depends:
Build-Depends: godi-ocaml (> 3.08) 
@tangle('Sources: http://felix.sf.net/flx_'+flx_version+'_src.tgz')
@tangle('Unpacks-To: flx_'+flx_version)
Bytecode-Target: all
Opt-Target: all
Homepage: http://felix.sf.net
Maintainer: John Skaller <skaller@users.sf.net>
Options: configure
Description: Felix Compiler
Felix Compiler
.

@select(tangler('meta/godiva/flx.godiva_camlsyntax','data'))
name = "felix";
@tangle('version = "'+flx_version+'";')
revision = 0;
category = `apps;
depends = [];
build_depends = [`godi,"ocaml", Some (`gt, "3.08")];
sources_site ="http://felix.sf.net/";
@tangle('sources_basename= "flx_'+flx_version+'_src";')
sources_extension = ".tgz";
@tangle('sources_unpacksto = "flx_'+flx_version+'";')
all_target= "all";
opt_target= "all";
homepage= "http://felix.sf.net";
maintainer = "John Skaller <skaller@users.sf.net>";
options= [`configure];
short_desc = "Felix Compiler";
long_desc = "Felix Compiler";
confopts = [
  { 
    name = "SUPPORT_DYNAMIC_LOADING";
    default = "1";
    description = "Whether to support dlopen loading";
    implementation = `configarg "--SUPPORT_DYNAMIC_LOADING"
  }
];
specfile = "meta/godiva/flx.godiva_camlsyntax";
patches = [];
filesdir = None;

@select(tangler('meta/godi/DESCR','data'))
Felix Compiler and tools.

@doc()
This makefile only here for reference (don't use it,
it should be generated).

@select(tangler('meta/godi/Makefile','data'))
# This file was automatically generated by GODIVA
.include "../../mk/bsd.prefs.mk"
.include "../../mk/godi.pkg.mk"

@tangle('VERSION=        '+flx_version)
PKGNAME=        apps-felix-${VERSION}
@tangle('PKGREVISION=    '+godi_revision) 
@tangle('DISTNAME=       flx_'+flx_version)
@tangle('DISTFILES=      flx_'+flx_version+'_src.tgz')
CATEGORIES=     apps
MASTER_SITES=   http://felix.sf.net/
MAINTAINER=     John Skaller <skaller@users.sf.net>
HOMEPAGE=       http://felix.sf.net
COMMENT=        Felix Compiler

# confopt defaults:


AUTOGENERATE_PLIST = yes
PKG  =          apps-felix
MAKE_FLAGS=     PREFIX=${PREFIX}  



PATH:=          ${LOCALBASE}/bin:${PATH}
HAS_CONFIGURE = yes
CONFIGURE_ARGS+= --prefix ${PREFIX}
CONFIGURE_ENV+= ${BUILD_OCAMLFIND_ENV}
USE_GMAKE = yes

MAKE_ENV+=  ${BUILD_OCAMLFIND_ENV} PKGBASE=${PKGBASE:Q}

pre-configure-copy:
.	if exists(files)
	    cd files && ${PAX} -rw -pp . ${WRKSRC}
.	endif

pre-configure: pre-configure-copy

pre-install-mkdirs:
.	for d in bin lib/ocaml/pkg-lib doc share man etc info sbin include
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/${d}
.	endfor
.	for n in 1 2 3 4 5 6 7 8 9
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/man/man${n}
.	endfor

pre-install: pre-install-mkdirs

ALL_TARGET=     all
.if ${GODI_HAVE_OCAMLOPT} == "yes"
# ALL_TARGET+= all
.endif

post-install:
	mkdir -p ${PREFIX}/doc/${PKG}
.	for DOC in 
	    install -m 0644 ${WRKSRC}/${DOC} ${PREFIX}/doc/${PKG}
.	endfor

.include "../../mk/bsd.pkg.mk"

@head(1,'Finish up')
Just cleaning up script now.
@os.system('chmod u+x configure')
@os.system('chmod u+x bin/flx')
@os.system('chmod u+x bin/fishcc')
@os.system('cp doc/*.css tut/doc >/dev/null 2>&1')

