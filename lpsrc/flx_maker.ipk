@head(1,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID

@h = tangler('script/detab.py','python')
@select(h)
import string
import sys

f = open(sys.argv[1])
data = f.readlines()
f.close()
f = open(sys.argv[1],"w")
for line in data:
  line = string.expandtabs(line)
  f.write(line)
f.close()

@h = tangler('script/mkcil.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/cil/'
files = [
  'src/check.ml',
  'src/check.mli',
  'src/cil.ml',
  'src/cil.mli',
  'src/cilutil.ml',
  'src/clist.ml',
  'src/clist.mli',
  'src/escape.ml',
  'src/escape.mli',
  'src/formatcil.ml',
  'src/formatcil.mli',
  'src/formatlex.mll',
  'src/formatparse.mly',
  'src/libmaincil.ml',
  'src/maincil.ml',
  'src/mergecil.ml',
  'src/mergecil.mli',
  'src/rmtmps.ml',
  'src/rmtmps.mli',
  'src/testcil.ml',
  'src/frontc/cabs2cil.ml',
  'src/frontc/cabs2cil.mli',
  'src/frontc/cabs.ml',
  'src/frontc/cabsvisit.ml',
  'src/frontc/cabsvisit.mli',
  'src/frontc/clexer.mli',
  'src/frontc/clexer.mll',
  'src/frontc/cparser.mly',
  'src/frontc/cprint.ml',
  'src/frontc/frontc.ml',
  'src/frontc/frontc.mli',
  'src/frontc/lexerhack.ml',
  'src/frontc/patch.ml',
  'src/frontc/patch.mli',
  'ocamlutil/errormsg.ml',
  'ocamlutil/errormsg.mli',
  'ocamlutil/inthash.ml',
  'ocamlutil/pretty.ml',
  'ocamlutil/pretty.mli',
  'ocamlutil/stats.ml',
  'ocamlutil/stats.mli',
  'ocamlutil/trace.ml',
  'ocamlutil/trace.mli',
  'ocamlutil/util.ml',
  'ocamlutil/util.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/flx_cil_'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')
  m = base[:i]
  mods[string.capitalize(m)]='Flx_cil_' + m

ms = mods.keys()
for k in ms:
  print mods[k]

print "@head(1,'CIL')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    for s in ms:
      r = mods[s]
      line = string.replace(line,s,r)
    print line,
      
@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
@tangle("FLX_MAKER_CVS_ID='"+FLX_MAKER_CVS_ID+"'")
import os
import stat
import string
import sys
import re


try:
  execfile("config/config.py")
except:
  print "ERROR IN config/config.py"
  print "You must either"
  print "(a) edit config/config.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

FLXFLAGS = ""

# --------------------------------------------------
# IMPORT UTILITY RESOURCES
# ---------------------------------------------------
def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  return result,output

def get_stdouterr(x):
  return get_stdout(x+" 2>&1")

# define our version of C's system() function
def xqt(x):
  if "silent" not in options: print x
  try: sys.stdin.flush()
  except: pass
  result,output = get_stdouterr(x)
  if "quiet" not in options:
    if result: print "  .. ERROR CODE",hex(result)
    if output: print string.join(output,"")
  try: sys.stdin.flush()
  except: pass

  if result:
    raise MakeError

def nxqt(x):
  if "silent" not in options: print x
  try: sys.stdin.flush()
  except: pass
  result,output = get_stdouterr(x)
  if "quiet" not in options:
    if output: print string.join(output,"")
  try: sys.stdin.flush()
  except: pass

  if not result:
    raise MakeError


# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

options = sys.argv[1:]
if "silent" in options: 
  options.append("quiet")

if "inline" in options:
  FLXFLAGS = FLXFLAGS + "--inline "
if options:
  print "OPTIONS: ", options

keyopt = {}
for o in options:
  try:
    key,value = string.split(o,"+=")
    old = keyopt.get(key,[])
    if type(old) == type(""): old = [old]
    keyopt[key] = old + [value]
  except:
    try:
      key,value = string.split(o,"=")
      keyopt[key]=value
    except: pass

USER_TESTS = keyopt.get("flx",[])
if type(USER_TESTS) == type(""):
  USER_TESTS = [USER_TESTS]

if "help" in options:
  print "extract - extract sources"
  print "compiler - build compiler"
  print "bytecode - build bytecode version of compiler"
  print "drivers - build drivers"
  print "regression - run regression tests"
  print "performance - run performance tests"
  print "bagley - run bagley shootout performance tests"
  print "tutorial - run tutorial examples"
  print "tests- regression and tutorial combined"
  print "clean - remove generated C++ and binaries from test locations"
  print "debug - build debugging versions of targets"
  print "optimise - build high performance versions of targets"
  print "doc - build all user documentation"
  print "vim=gvim - set gvim as the vim editor"
  print "vimserver=FLX - set FLX as the editor server name"
  print "editor=vim - set vim as the editor class"
  print "editor=emacs - set emacs as the editor class"
  print "edit -- edit a file containing an error"

VIMSERVER = keyopt.get("vimserver","")
VIM = keyopt.get("vim","gvim")
EMACS = keyopt.get("emacs","xemacs")
EDITORCLASS = keyopt.get("editorclass","vim")
if EDITORCLASS == "vim":
  EDITOR = VIM
elif EDITORCLASS == "emacs":
  EDITOR = EMACS
else:
  EDITOR = EDITORCLASS

if "clean" in options:
  os.system("rm -rf test/*.cpp test/*.hpp test/*.so")
  os.system("rm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so")

if "tests" in options or "test" in options:
  options = options + ["regression","tutorial"]

# this command takes flxg output and looks for errors
# no action is taken if there are no errors
# if an error is found, and an original source
# reference is detected, the file is edited
#
# For vim the processs is:
# 1. get a list of servers
# 2. check if the nominated server is in the list
# 3. if it isn't, create it
# 4. tell the server to edit the file

def vimedit(file,line1,column1,line2,column2):
  SNAME = VIMSERVER
  if SNAME == "": SNAME = file
  os.system(VIM + " --servername " + SNAME + " --remote +" + str(line1) + " " + file)

def edit(*args):
  if EDITORCLASS == "vim": apply(vimedit,args)
  else: os.system(EDITOR + " " + args[0])

errpos_single = re.compile('In (.*): line (.*), cols (.*) to (.*)\\n')
errpos_multiple = re.compile('In (.*): line (.*) col (.*) to  line (.*) col (.*)\\n')

def find_src(s,file):
  m = errpos_single.match(s)
  if m:
    print "Matched single"
    f,l1,c1,c2 = m.group(1,2,3,4)
    l1=int(l1)
    c1=int(c1)
    l2=int(l1)
    c2=int(c2)
  else:
    m = errpos_multiple.match(s)
    if m:
      print "Matched multiple"
      f,l1,c1,l2,c2 = m.group(1,2,3,4,5)
      l1=int(l1)
      c1=int(c1)
      l2=int(l2)
      c2=int(c2)
    else:
      f,l1,c1,l2,c2="generated",0,0,0,0
  if f == "generated": f = file
  return f,l1,c1,l2,c2

def flxg(x,basename):
  x = './bin/flxg ' + x
  if "edit" in options:
    try: 
      xqt(x)
    except:
      x = x + ' | grep -x "In.*: line.*"'
      result,output = get_stdouterr(x)
      try:
        f,l1,c1,l2,c2 = find_src(output[0],basename+'.flx')
        edit(f,l1,c1,l2,c2)
      except:
        edit(basename+'.flx',0,0,0,0)
  else: 
    xqt(x)

# ------------------------------------------------
# BEGIN USER CONFIGURABLE SECTION
#-------------------------------------------------

#interscript command (now built in part of Felix package)
def runISCR(a):
  if buildall:
    xqt(ISCR + "--nocache " + a)
  else:
    xqt(ISCR + ' ' + a)

if "compiler" in options or "bytecode" in options:
  OCAML_OBJDIR = "src"
  BYTECODE = not NATIVE_CODE_COMPILER or "bytecode" in options
  if BYTECODE: OCAMLOPT = OCAMLB
  else: OCAMLOPT = OCAMLC
  OCAMLOPT = OCAMLOPT + " -I " + OCAML_OBJDIR
  OCAMLC = OCAMLC + " -I " + OCAML_OBJDIR
  
  if "debug" in options:
    OCAMLOPT = OCAMLOPT + '-g '

  if "optimise" in options:
    OCAMLOPT = OCAMLOPT + "-unsafe -noassert -inline 5 "

  if BYTECODE == 0:
    OCAML_OBJECT_EXTENSION = '.cmx'
    OCAML_LIB_EXTENSION = '.cmxa'
  else:
    OCAML_OBJECT_EXTENSION = '.cmo'
    OCAML_LIB_EXTENSION = '.cma'
    
# where gnu readline header files are
#READLINE_INCLUDE_DIRECTORY='/usr/include/readline'

#determine linkage model

LINK_MODEL = DEFAULT_LINK_MODEL
if "static" in options:
  LINK_MODEL = "static"
if "dynamic" in options:
  LINK_MODEL == "dynamic"

if LINK_MODEL == "dynamic" and not SUPPORT_DYNAMIC_LOADING:
  print "dynamic linkage not supported"
  sys.exit(1)

if LINK_MODEL == "static" and not SUPPORT_STATIC_LINKAGE:
  print "dynamic linkage not supported"
  sys.exit(1)

CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "
CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "

if LINK_MODEL == "dynamic":
  if CYGWIN:
    SHLX = ".dll"
  else:
    SHLX = ".so"
else:
  SHLX = ""

# for compiling mainlines
if "optimise" in options:
  CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-O "
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-O "
  CCOBJ_DLLIB = CCOBJ_DLLIB + "-O "
  CCOBJ_DLMAIN = CCOBJ_DLMAIN + "-O "


# ------------------------------------------------
# END USER CONFIGURABLE SECTION
#-------------------------------------------------

# where documentation gets put
WEAVER_DIRECTORY='doc/'
TUTORIAL_DIRECTORY='tut/'
TUTORIAL_DOC=TUTORIAL_DIRECTORY+'doc/'
TUTORIAL_EXAMPLES=TUTORIAL_DIRECTORY+'examples/'

# where the garbage collector sources are
# (the collector is now a separate package)
FLX_GC_SRC='src/'

# -------------------------------------------------
# BEGIN IMPLEMENTOR CONFIGURABLE SECTION
# ------------------------------------------------

# files containing ocamllex sources
LEXS = ['flx_cil_clexer','flx_cil_formatlex','flx_lex']

# files containing ocamlyacc sources
PARSES = ['flx_cil_cparser','flx_cil_formatparse','flx_parse']

# ocaml modules = interfaces + implementation files

MODULES = [
  'flx_version'      ,
  'flx_ctype'        ,
  'flx_cil_cilversion',
  'flx_cil_machdep',
  'flx_cil_pretty',
  'flx_cil_errormsg',
  'flx_cil_cabs_helper',
  'flx_cil_lexerhack',
  'flx_cil_escape',
  'flx_cil_cprint',
  'flx_cil_cparser',
  'flx_cil_clexer',
  'flx_cil_stats',
  'flx_cil_trace',
  'flx_cil_clist',
  'flx_cil_cil',
  'flx_cil_frontc',
  'flx_cil_rmtmps',
  'flx_cil_cabsvisit',
  'flx_cil_inthash',
  'flx_cil_formatparse',
  'flx_cil_formatlex',
  'flx_cil_util',
  'flx_cil_mergecil',
  'flx_cil_patch',
  'flx_cil_formatcil',
  'flx_cil_cilutil',
  'flx_cil_cabs2cil',
  'flx_cil_check',
  'flx_util'         ,
  'flx_getopt'       ,
  'flx_mtypes1'      ,
  'flx_mtypes2'      ,
  'flx_srcref'       ,
  'flx_typing'       ,
  'flx_exceptions'   ,
  'flx_string'       ,
  'flx_id'           ,
  'flx_print'        ,
  'flx_maps'         ,
  'flx_typing2'      ,
  'flx_unify'        ,
  'flx_charset'      ,
  'flx_constfld'     , 
  'flx_macro'        , 
  'flx_parse'        ,
  'flx_keywords'     ,
  'flx_prelex'       ,
  'flx_lex1'         ,
  'flx_tok'          ,
  'flx_lex'          ,
  'flx_pretok'       ,
  'flx_parse_ctrl'   ,
  'flx_dfa'          ,
  'flx_pat'          , 
  'flx_desugar'      , 
  'flx_mbind'        , 
  'flx_symtab'       , 
  'flx_csubst'       , 
  'flx_name'         , 
  'flx_treg'         ,
  'flx_beta'         ,
  'flx_generic'      , 
  'flx_overload'     , 
  'flx_lookup'       , 
  'flx_bexe'         , 
  'flx_bbind'        , 
  'flx_label'        , 
  'flx_call'         , 
  'flx_use'          , 
  'flx_inline'       , 
  'flx_inst'         , 
  'flx_cexpr'        ,
  'flx_tgen'         , 
  'flx_display'      , 
  'flx_ogen'         , 
  'flx_regen'        ,
  'flx_unravel'      , 
  'flx_gen'          , 
  'flx_flxopt'       , 
  'flx_terminate'    , 
]

RAW_INTERFACES = [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
] 

INTERFACES = RAW_INTERFACES + MODULES

IMPLEMENTATIONS = INTERFACES
  
RTL_CPPS = [
  "rtl/flx_gc",
  "rtl/flx_collector",
  "rtl/flx_rtl",
  "rtl/flx_dynlink",
  "rtl/flx_i18n",
  "rtl/flx_ioutil"
]

DRIVERS = [
  ('rtl/flx_run','bin/flx_run'),
  ('test/flx_perf_drv1','test/flx_perf_drv1'),
  ('rtl/flx_stdin_drv','bin/flx_stdin_drv'),
]

# C files that we need to compile, with options required to build them
COBJECTS = {
}
# *.so/.a libraries
CLIBRARIES = ['nums']

# *.cmxa or .cma libraries
OLIBRARIES = ['nums','unix','flxlib']


# target executable programs to produce
EXES = [
  # compiler tools
  'flxl',
  'flxp',
  'flxm',
  'flxd',
  'flxb',
  'flxg',
  'flxcc',
  'stub',
]

if 1:
  s = ' -cclib "-Lsrc '
  for library in CLIBRARIES:
    s = s + ' -l'+library
  s = s + '"'
  LDFLAGS = s
  del s

if 1:
  o = ''
  for object in COBJECTS.keys():
    o = o + ' src/' + object + '.o'
  OBJECT_FILES = o
  del o

TESTS= USER_TESTS
BAD_TESTS = []

SPECIAL_TESTS = [
  ('bin/flx_run','test/flx_run_lib1.flx',''),
  ('test/flx_perf_drv1','test/flx_perf_lib1.flx','1000'),
  ('bin/flx_stdin_drv','test/flx_stdin_lib1.flx','<Makefile >tmp.tmp'),
]

# -------------------------------------------------
# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------

# ----------- Utilities ---------------------
class MakeError: pass

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except:
    t = 0
  return t

def run(x):
  print x
  try: sys.stdin.flush()
  except: pass
  result = os.system(x)
  if result: print "  .. ERROR CODE",hex(result)
  try: sys.stdin.flush()
  except: pass

  if result:
    raise MakeError

def erasefile(f):
  try:
    os.unlink(f)
  except:
    pass
# ----------- Here begins the actual build procedure ---------------------

buildall = "clean" in options or "force" in options
stop_on_error = "stop_on_error" in options
import glob

def copy_mli2ml():
  for f in RAW_INTERFACES:
    if filetime("src/"+f+".mli") > filetime("src/"+f+".ml"):
      os.system("cp src/"+f+".mli src/"+f+".ml")


try:
  # STEP 0: run interscript
  if "doc" in options:
    runISCR('--language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+WEAVER_DIRECTORY+' lpsrc/flx.pak')
    copy_mli2ml()
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tutorial.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_macro.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_bind.pak')
  elif "extract" in options:
    runISCR('lpsrc/flx.pak')
    copy_mli2ml()
    runISCR('lpsrc/flx_tutorial.pak')
    runISCR('lpsrc/flx_tut_macro.pak')
    runISCR('lpsrc/flx_tut_bind.pak')
  os.system('rm -f tmp.tmp')

  if "doc" in options or "man" in options:
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = string.split(file,".")[0]
        xqt(
          "man2html man/man1/" + file + 
          '| sed -e "s%http://localhost/cgi-bin/man/man2html?1+\(.*\)\\">%\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "htmlman/" + basename+'_1.html'
        )
    except:pass
  
  if "doc" in options or "impldoc" in options:
    xqt('ocamldoc -I src -d impldoc src/*.mli -html')
    xqt('ocamldoc -I src -o impldoc/flx_impl.tex src/*.mli -latex')
    xqt('(cd impldoc; latex flx_impl.tex; latex flx_impl.tex; latex flx_impl.tex)')

  if "regression" in options:
    TESTS = TESTS + glob.glob('test/rt*.flx')
    BAD_TESTS = glob.glob('test/bt*.flx')

  if "tutorial" in options:
    TESTS = TESTS + glob.glob('tut/examples/tut*.flx')
    TESTS = TESTS + glob.glob('tut/examples/mac*.flx')

  if "bagley" in options:
    TESTS = TESTS + glob.glob('test/bag*.flx')

  TESTS.sort()
  BAD_TESTS.sort()

  if "compiler" in options:
    # STEP 1: Compile all copiler support C files
    for cobject in COBJECTS.keys():
      flags = COBJECTS[cobject]
      file = 'src/'+cobject
      if buildall or filetime(file +".c") > filetime(file +".o"):
        xqt(CCOMPILE +" -I "+OCAML_INCLUDE_DIRECTORY+" -I. "+flags+" "+file+".c")

    # STEP 2: Generate lexers
    for lex in LEXS:
      file = 'src/'+lex
      if buildall or filetime(file + '.mll') > filetime(file +'.ml'):
        buildall = 1
        xqt(OCAMLLEX + file + '.mll')

    # STEP 3: Generate parsers
    for parse in PARSES:
      file = 'src/'+parse
      if buildall or filetime(file + '.mly') > filetime(file +'.ml'):
        buildall = 1
        xqt(OCAMLYACC+ ' -v '+ file + '.mly')
        nxqt("grep conflict " + file + ".output")

    # STEP 4: Compile ocaml interfaces
    for interface in INTERFACES:
      file = 'src/'+interface
      if buildall or filetime(file + '.mli') > filetime(file+'.cmi'):
        buildall = 1
        xqt(OCAMLC + ' -c '+file+ '.mli')

    # STEP 5: Compile ocaml implementations
    for implementation in IMPLEMENTATIONS + EXES:
      file = 'src/'+implementation
      if buildall or filetime(file+ '.ml') > filetime(file+OCAML_OBJECT_EXTENSION):
        buildall = 1
        xqt(OCAMLOPT + ' -c ' + file +'.ml')


    # STEP 6: Build FELIX Library
    object_library_name = "src/flxlib" + OCAML_LIB_EXTENSION
    linkstring = OCAMLOPT + " -a -o " + object_library_name + " "
    library_filetime = filetime(object_library_name)
    for implementation in IMPLEMENTATIONS:
      file = 'src/'+implementation
      if filetime(file+OCAML_OBJECT_EXTENSION) > library_filetime:
        for implementation in IMPLEMENTATIONS:
          file = 'src/'+implementation
          linkstring = linkstring + file +OCAML_OBJECT_EXTENSION +" "
        xqt(linkstring)
        buildall = 1
        break

    # STEP 8: Link executables
    x = ''
    for library in OLIBRARIES:
      x = x + ' ' + library + OCAML_LIB_EXTENSION

    # finally, mainline *.cmx or cma files to link to executables
    for exe in EXES:
      if buildall or filetime(exe + OCAML_OBJECT_EXTENSION) > filetime(exe):
        xqt(OCAMLOPT + LDFLAGS + ' -o bin/'+exe + x + OBJECT_FILES + ' src/flx_version_hook.ml ' + exe + OCAML_OBJECT_EXTENSION)

  # COMPILE RTL  
  if "rtl" in options:
    if SUPPORT_DYNAMIC_LOADING:
      ars = ""
      for x in RTL_CPPS:
        print 'Compiling rtl object',x
        ars = ars + x + "_dynamic.o "
        xqt(CCOBJ_DLLIB + " -I. " + x + ".cpp -o " +x+"_dynamic.o")
      xqt(AR + " rtl/libflx_dynamic.a " + ars)
      xqt(RANLIB + " rtl/libflx_dynamic.a")

      if CYGWIN:
        print "Building RTL for CYGWIN dynamic linkage"
        cmd = (CCLINK_DLLIB + " -shared -o bin/cygflx_dynamic.dll " +
          "--export-all-symbols --enable-auto-import " +
          "--out-implib=rtl/libflx_dynamic.dll.a ")
        xqt(cmd)
      else:
        xqt(CCLINK_DLLIB + "-o rtl/libflx_dynamic.so "+ars)

    if SUPPORT_STATIC_LINKAGE:
      ars = ""
      for x in RTL_CPPS:
        print 'Compiling rtl object',x
        ars = ars + x + "_static.o "
        xqt(CCOBJ_STATIC_LIB + " -I. " + x + ".cpp -o " +x+"_static.o")
      xqt(AR + " rtl/libflx_static.a " + ars)
      xqt(RANLIB + " rtl/libflx_static.a")

  # COMPILE DRIVER PROGRAMS
  if "drivers" in options:
    if SUPPORT_STATIC_LINKAGE:
      for i,j in DRIVERS:
        print 'Compiling driver object',i
        xqt(CCOBJ_STATIC_MAIN + " -I. " + i + ".cpp -o " +i+"_static.o")

    if SUPPORT_DYNAMIC_LOADING:
      for i,j in DRIVERS:
        print 'Compiling driver object',i
        xqt(CCOBJ_DLMAIN + " -I. " + i + ".cpp -o " +i+"_dynamic.o")

        if CYGWIN:
          xqt("g++ -o "+j+" -Wl,--enable-auto-import " + i + "_dynamic.o -Lrtl -lflx_dynamic")
        else:
          xqt(CCLINK_DLMAIN + " -o "+j+" -Lrtl -lflx_dynamic " +i+"_dynamic.o")

  # run tests
  try:
    results = []

    # GENERATE C++ FROM FELIX SOURCE
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)
    for testfile in TESTS+EXTRA:
      #print 'Running Felix code generator on ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or \
        filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
        filetime('bin/flxg')> filetime(basename+'.cpp') or \
        filetime('lib/std.flx') > filetime(basename+'.cpp'):
        try:
          flxg('-Ilib ' +FLXFLAGS + basename,basename)
          #print 'TESTFILE -- generated ',basename
          results.append(("flxg",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+'.cpp')
          erasefile(basename+'.hpp')
          erasefile(basename+SHLX)
          if stop_on_error: raise MakeError
          results.append(("flxg",basename,'ERROR'))

    # FAILURE TESTS 
    if "regression" in options:
      for testfile in BAD_TESTS:
        #print 'Running Felix code generator on ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or \
          filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
          filetime('bin/flxg')> filetime(basename+'.cpp') or \
          filetime('lib/std.flx') > filetime(basename+'.cpp'):
          try:
            xqt('bin/flxg -e -Ilib ' + basename + " 2>&1 >/dev/null")
            #print 'TESTFILE -- failed as expected',basename
            results.append(("flxg",basename,'OK'))
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
          except MakeError:
            print 'TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED!',basename
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
            if stop_on_error: raise MakeError
            results.append(("flxg",basename,'ERROR'))

    # C++ COMPILE and static link tests
    # produces shared library or executable
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)
    for testfile in TESTS+EXTRA:
      #print 'Compiling generated code of ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or filetime(basename+ '.cpp') > filetime(basename+SHLX):
        try:
          if LINK_MODEL == "dynamic":
            if CYGWIN:
              xqt("g++ -w -ansi -g -o "+basename+SHLX+" -shared -I. "+cppfilename+" -Lrtl -lflx_dynamic -Wl,--enable-auto-import")
            else:
              xqt(CCOBJ_DLLIB+" -I. "+cppfilename + " -o " + basename + "_dynamic.o")
              xqt(CCLINK_DLLIB+" -Lrtl -lflx_dynamic -o "+ basename + SHLX + " "+basename+"_dynamic.o")
          else:
            xqt(CCOBJ_STATIC_LIB +" -I. "+cppfilename + " -o " + basename + "_static.o" )
            xqt(CCLINK_STATIC +" -I. ./rtl/flx_run_static.o "+basename+ "_static.o -Lrtl -lflx_static -o " + basename + SHLX )
          #print 'TESTFILE -- OK!',basename
          results.append(("g++",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+SHLX)
          if stop_on_error: raise MakeError
          results.append(("g++",basename,'ERROR'))


    # run the tests
    for testfile in TESTS:
      basename = string.split(testfile,'.')[0]
      if LINK_MODEL == "dynamic":
        testscript = "env LD_LIBRARY_PATH=./rtl:$LD_LIBRARY_PATH ./bin/flx_run ./"+basename+SHLX
      else:
        testscript = "./"+basename+SHLX

      if "log_output" in options:
        testscript = testscript + " >" + basename + ".output"
      #print 'Executing ',testscript
      try:
        run(testscript)
        #print 'TESTFILE -- OK!',testscript
        results.append(("Exec",testscript,'OK'))
      except MakeError:
        print 'TESTFILE -- ERROR!',testscript
        if stop_on_error: raise MakeError
        results.append(("Exec",testscript,'ERROR'))

    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS:
        test_basename = string.split(testfile,'.')[0]
        drv_basename = string.split(driver,'.')[0]
        if LINK_MODEL == "dynamic":
          testscript = "env LD_LIBRARY_PATH=./rtl:$LD_LIBRARY_PATH time ./"+drv_basename+ " ./"+test_basename+SHLX+" " + moreargs
        else:
          testscript = "time ./"+test_basename+SHLX+" " + moreargs
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append(("Exec Special",testscript,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append(("Exec Special",testscript,'ERROR'))

    print "RUN COMPLETE"

  finally:
    # REPORT FINAL RESULTS
    print
    print '**********************************'
    #print 'final results'
    total = 0
    bad = 0
    for x,y,z in results: 
      total = total + 1
      if "OK" == z: pass
      else:
        bad = bad + 1
        print x,y,z
    if total <> 0:
      if bad == 0: 
        print "ALL",total,"PASSED"
      else:
        print "Bad",bad,"/",total
    print '**********************************'
    sys.exit(bad)

  sys.exit(0)

except MakeError:
  print "Terminating due to error"
  sys.exit(1)

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('PREFIX='+PREFIX)
@tangle('SHLIB_DIR=${PREFIX}/lib')
@tangle('SHINC_DIR=${PREFIX}/include')
@tangle('INSTALL_DIR=${PREFIX}/lib/felix')
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@try:
   tangle('SWIGDEVDIR='+SWIGDEVDIR)
 except: pass
@tangle('')
@tangle('all: dummy')
@tangle('\tpython script/maker extract compiler rtl drivers test')
@tangle('')

@tangle('bytecode: dummy')
@tangle('\tpython script/maker compiler bytecode')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\tpython script/maker compiler bytecode debug')
@tangle('')
@tangle('extract: dummy')
@tangle('\tpython script/maker extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\tpython script/maker extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\tpython script/maker tutorial')
@tangle('')
@tangle('compiler: dummy')
@tangle('\tpython script/maker compiler')
@tangle('')
@tangle('doc: dummy')
@tangle('\tpython script/maker doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('\tmake impldoc')
@tangle('')
@tangle('man: dummy')
@tangle('\tpython script/maker man')
@tangle('')
@tangle('test: dummy')
@tangle('\tpython script/maker test stop_on_error')
@tangle('')
@tangle('test.static: dummy')
@tangle('\tpython script/maker test static stop_on_error')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\tpython script/maker inline test stop_on_error')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\tpython script/maker debug test stop_on_error')
@tangle('')
@tangle('tests: dummy')
@tangle('\tpython script/maker test log_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\tpython script/maker test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\tpython script/maker inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\tpython script/maker performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\tpython script/maker regression')
@tangle('')
@tangle('rtl: dummy')
@tangle('\tpython script/maker rtl')
@tangle('')
@tangle('drivers: dummy')
@tangle('\tpython script/maker drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('\tpython script/maker drivers debug')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.07 or better')
@tangle('\t#REQUIRES g++ 2.96 or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#REQUIRES g++ 2.96 or better')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required priviledges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')

@tangle('tarball: dummy')
@tangle('\trm -f flx_'+flx_version)
@tangle('\tln -s . flx_'+flx_version)
@tangle('\ttar -zcvf flx_'+flx_version+'_src.tgz\\')
@tangle('\t\tflx_'+flx_version+'/Makefile\\')
@tangle('\t\tflx_'+flx_version+'/README \\')
@tangle('\t\tflx_'+flx_version+'/CONTENTS \\')
@tangle('\t\tflx_'+flx_version+'/INSTALL \\')
@tangle('\t\tflx_'+flx_version+'/VERSION \\')
@tangle('\t\tflx_'+flx_version+'/LICENSE \\')
@tangle('\t\tflx_'+flx_version+'/NEWS \\')
@tangle('\t\tflx_'+flx_version+'/AUTHORS \\')
@tangle('\t\tflx_'+flx_version+'/COPYING\\')
@tangle('\t\tflx_'+flx_version+'/ChangeLog \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.ipk\\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.pak\\')
@tangle('\t\tflx_'+flx_version+'/interscript/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.dat \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('\ttar -zcvf flx_'+flx_version+'_bin_linux.tgz\\')
@tangle('\t\tflx_'+flx_version+'/Makefile\\')
@tangle('\t\tflx_'+flx_version+'/README \\')
@tangle('\t\tflx_'+flx_version+'/CONTENTS \\')
@tangle('\t\tflx_'+flx_version+'/INSTALL \\')
@tangle('\t\tflx_'+flx_version+'/VERSION \\')
@tangle('\t\tflx_'+flx_version+'/LICENSE \\')
@tangle('\t\tflx_'+flx_version+'/NEWS \\')
@tangle('\t\tflx_'+flx_version+'/AUTHORS \\')
@tangle('\t\tflx_'+flx_version+'/COPYING\\')
@tangle('\t\tflx_'+flx_version+'/ChangeLog \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tflx_'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tflx_'+flx_version+'/script/maker \\')
@tangle('\t\tflx_'+flx_version+'/src/*.ml \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mli \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mly \\')
@tangle('\t\tflx_'+flx_version+'/src/*.mll \\')
@tangle('\t\tflx_'+flx_version+'/rtl/*.cpp\\')
@tangle('\t\tflx_'+flx_version+'/rtl/*.hpp\\')
@tangle('\t\tflx_'+flx_version+'/lib/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/test/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/test/*.cpp \\')
@tangle('\t\tflx_'+flx_version+'/tut/examples/*.flx \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.css \\')
@tangle('\t\tflx_'+flx_version+'/tut/doc/*.tex \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.css \\')
@tangle('\t\tflx_'+flx_version+'/doc/*.tex \\')
@tangle('\t\tflx_'+flx_version+'/htmlman/*.html \\')
@tangle('\t\tflx_'+flx_version+'/man/man1/*.1 \\')
@tangle('\t\tflx_'+flx_version+'/impldoc/*.html \\')
@tangle('\t\tflx_'+flx_version+'/bin/flx \\')
@tangle('\t\tflx_'+flx_version+'/bin/flxg \\')
@tangle('\t\tflx_'+flx_version+'/bin/flx_run \\')
@tangle('\t\tflx_'+flx_version+'/interscript/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/encoding/*.dat \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tflx_'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('www: dummy')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_sourceforge.pak')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_web.pak')
@tangle('')
@tangle('clean: dummy')
@tangle('\trm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so tut/examples/*.dll')
@tangle('\trm -rf test/rt*.cpp test/rt*.hpp test/rt*.so test/rt*.dll')
@tangle('')
@tangle('virgin: dummy')
@tangle('\tcp Makefile Makefile.old')
@tangle('\trm -rf tut rtl test www src misc man script bin doc lib impldoc htmlman flxcc_out tmp.tmp')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf interscript/*.pyc')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -f README LICENSE VERSION CONTENTS INSTALL AUTHORS NEWS COPYING ChangeLog')
@tangle('')

@tangle('backup: dummy')
@tangle('\t(DATE=`date -I`;\\')
@tangle('\tmkdir -p "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.ipk "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.pak "lpbackup/$${DATE}"\\')
@tangle('\t)')
@tangle('')

@tangle('config: dummy')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_config.pak')
@tangle('\tpython -O script/make_config.py quiet')
@tangle('')

@tangle('boot: dummy')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx_config.pak')
@tangle('\tpython -O script/make_config.py quiet')
@tangle('\tenv PYTHONPATH=. python -O interscript/bin/iscr.py --nocache lpsrc/flx.pak')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tcp config/usr_include.flxcc.default config/usr_include.flxcc')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\t#"INSTALL_DIR=${INSTALL_DIR}"')
@tangle('\t#"EXEC_DIR=${EXEC_DIR}"')
@tangle('\t#"MAN_DIR=${MAN_DIR}"')
@tangle('\t#"SHLIB_DIR=${SHLIB_DIR}"')
@tangle('\t#"INC_DIR=${INC_DIR}"')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${SHLIB_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/doc')
@tangle('\tinstall -d ${INSTALL_DIR}/htmlman')
@tangle('\tinstall lib/* ${INSTALL_DIR}/lib')
@tangle('\tinstall rtl/* ${INSTALL_DIR}/rtl')
@if SUPPORT_STATIC_LINKAGE:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_static.a')
  tangle('\tinstall rtl/libflx_static.a ${SHLIB_DIR}')
  tangle('\t'+RANLIB+' ${SHLIB_DIR}/libflx_static.a')
@if SUPPORT_DYNAMIC_LOADING:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_dynamic.a')
  tangle('\tinstall rtl/libflx_dynamic.so ${SHLIB_DIR}')
  tangle('\tinstall rtl/libflx_dynamic.a ${SHLIB_DIR}')
  tangle('\t'+RANLIB+' ${SHLIB_DIR}/libflx_dynamic.a')
@tangle('\t(install doc/* ${INSTALL_DIR}/doc || exit 0) > /dev/null 2>&1')
@tangle('\t(install impldoc/* ${INSTALL_DIR}/impldoc || exit 0) > /dev/null 2>&1')
@tangle('\t(install htmlman/* ${INSTALL_DIR}/htmlman || exit 0) > /dev/null 2>&1')
@tangle('\tinstall bin/* ${EXEC_DIR}')
@tangle('\t(install man/man1/* ${MAN_DIR}/man1 || exit 0) > /dev/null 2>&1')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = string.replace(FLX_MAKER_CVS_ID,"$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle("# These targets are for SKALLER only")
@tangle("# they're used to upload stuff to sourceforge")
@tangle('upload_www: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('')
@tangle('upload_src: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('upload: dummy')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('\tscp flx_'+flx_version+'_bin_linux.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues Cassé

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something .. 

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something .. 


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENSE   license details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary
 
  Makefile   the makefile, mainly hooks into script/maker
 
  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENSE')
@select(tangler('LICENSE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file 

lpsrc/flx_frontc.ipk

are covered by this copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.07 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace
   
@tangle('   tar -zxvf felix_'+flx_version+'_src.tgz')
@tangle('   cd felix_'+flx_version)

4. Bootstrap the system.

  make boot

EDIT THE FILE

  config/config.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make compiler rtl drivers

6. Build the documentation and tutorial

   make doc 

   developers can also do:

   make impldoc

7. Test the compiler

   make test

   This stops on the first error. Use

   make tests

   to run the force all the tests to run
   
8. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak 
  
                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  include "std";
  print "It works!"; endl;

and then run it:
  
  flx -Ilib mytest

@head(1,'.cvsignore')
This is actually put in the lpsrc directory to tell
cvs to ignore certain files.
@select(tangler('lpsrc/.cvsignore','data'))
*.cache
*.swp


@head(1,'Ocamldoc Latex Style')
Taken from the distribution because ocamldoc
doesn't put this file in the right place
when it generates a tex file. (style sheets
for html are correctly dumped though ..)

@select(tangler('impldoc/ocamldoc.sty','data'))
%% Support macros for LaTeX documentation generated by ocamldoc.
%% This file is in the public domain; do what you want with it.

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{ocamldoc}
              [2001/12/04 v1.0 ocamldoc support]

\newenvironment{ocamldoccode}{%
  \bgroup
  \leftskip\@totalleftmargin
  \rightskip\z@skip
  \parindent\z@
  \parfillskip\@flushglue
  \parskip\z@skip 
  %\noindent
  \@@par\smallskip
  \@tempswafalse
  \def\par{%
    \if@tempswa
      \leavevmode\null\@@par\penalty\interlinepenalty
  \else
    \@tempswatrue
    \ifhmode\@@par\penalty\interlinepenalty\fi
  \fi}
  \obeylines
  \verbatim@font
  \let\org@prime~%
  \@noligs
  \let\org@dospecials\dospecials
  \g@remfrom@specials{\\}
  \g@remfrom@specials{\{}
  \g@remfrom@specials{\}}
  \let\do\@makeother
  \dospecials
  \let\dospecials\org@dospecials
  \frenchspacing\@vobeyspaces
  \everypar \expandafter{\the\everypar \unpenalty}}
{\egroup\par}

\def\g@remfrom@specials#1{%
  \def\@new@specials{}
  \def\@remove##1{%
    \ifx##1#1\else
    \g@addto@macro\@new@specials{\do ##1}\fi}
  \let\do\@remove\dospecials
  \let\dospecials\@new@specials
  }

\newenvironment{ocamldocdescription}
{\list{}{\rightmargin0pt \topsep0pt}\raggedright\item\relax}
{\endlist\medskip}

\newenvironment{ocamldoccomment}
{\list{}{\leftmargin 2\leftmargini \rightmargin0pt \topsep0pt}\raggedright\item\relax}
{\endlist}

\let\ocamldocvspace\vspace
\endinput


@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.

@select(tangler('doc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('doc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)

@head(1,'Run script')
@select(tangler('bin/flx'))
#!/bin/bash
# flx - felix script harness

# g++ compilation string
@tangle('CCOBJ_DLLIB="'+CCOBJ_DLLIB+'"')
@tangle('CCLINK_DLLIB="'+CCLINK_DLLIB+'"')
@tangle('CCOBJ_STATIC_LIB="'+CCOBJ_STATIC_LIB+'"')
@tangle('CCLINK_STATIC="'+CCLINK_STATIC+'"')
@tangle('VERSION="'+flx_version+'"')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=0
@if DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1

grab=1

INCLUDE_DIRS=""

while (( "$grab" == "1" ));
do
  case x$1 in
  x--test)
    TESTMODE=1
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline)
    INLINE=1
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--help)
    man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done

if [ "$TESTMODE" = "1" ]
then
  echo "TESTMODE: running felix from current directory"
fi

# make a list of any *.cpp files (or other g++ options ..)

grab=1
cpps=""
pkgs=""
while (( "$grab" == "1" ));
do
  case "$1" in
    *.cpp)
      cpps="$cpps $1"
      shift
    ;;

    *.cxx)
      cpps="$cpps $1"
      shift
    ;;

    *.c)
      cpps="$cpps $1"
      shift
    ;;
     
    *.o)
      cpps="$cpps $1"
      shift
    ;;

    *.a)
      cpps="$cpps $1"
      shift
    ;;

    --pkg=*)
      pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
      shift
    ;;
    
    -*)
      cpps="$cpps $1"
      shift
    ;;
   
    *)
      grab=0
    ;;
  esac
done

if [ "x$pkgs" = "x" ] 
then
  PKGS=""
else
  PKGS=`pkg-config --cflags --libs $pkgs`
fi
 
if [ "x$1" = "x" ]
then
  echo "usage: flx filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;
  
  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=""

case "$arg" in
  /*)
    base="$arg"
    ;;
  [^/]*/*)
    base="`pwd`/$arg"
    ;;
  *)
    for dir in `echo .:$PATH | sed 's/:/ /g'`
    do
      dir=$dir
      if [ -r "$dir/$arg.so" -o -r "$dir/$arg.flx" ]
      then
        base="$dir/$arg"
        break
      fi
    done
    ;;
esac

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)  
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

if [ "$TESTMODE" = "1" ]
then
  INCLUDE_DIR="."
  FLXG="./bin/flxg"
  FLXLIB="./lib"
  FLXRUN="env LD_LIBRARY_PATH=./rtl:\$LD_LIBRARY_PATH ./bin/flx_run"
  FLXRTL="./rtl"
  FLXBIN="./bin"
else
  # Locate the felix installation
  prefix=""
  for dir in `echo $PATH | sed 's/:/ /g'`
  do
    dir=$dir
    if [ -x "$dir/flxg" ]
    then
      prefix="$dir/flxg"
      break
    fi
  done
  prefix="`echo $prefix | sed 's/\/bin\/flxg$//'`"
  INCLUDE_DIR="$prefix/lib/felix"
  FLXG="$prefix/bin/flxg"
  FLXRUN="$prefix/bin/flx_run"
  FLXLIB="$prefix/lib/felix/lib"
  FLXRTL="$prefix/lib/felix/rtl"
  FLXBIN="$prefix/bin"
fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base.so" -a "(" ! -r "$base.flx" -o "$base.so" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      if [ $DEBUG = 1 ]; then echo "running $base.so"; fi
      `echo "$FLXRUN" "$base.so $args"`
    fi
    exit $?
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base" -a "(" ! -r "$base.flx" -o "$base" -nt "$base.flx" ")" ]
  then
    if [ $DEBUG = 1 ]; then echo "running $base"; fi
    if [ $RUNIT = 1 ]
    then
      `echo "$base $args"`
    fi
    exit $?
  fi
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]
then 
  echo "compiling $base.flx"
  VERBOSE="-v"
  CCFLAGS="-g"
else
  VERBOSE="-q"
  CCFLAGS=""
fi

if [ $INLINE = 1 ]
then
  FLXFLAGS="--inline"
else
  FLXFLAGS=""
fi

if [ $STATIC = 0 ]
then
  if `echo "$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"` 
  then
    if `echo $CCLINK_DLLIB $CCFLAGS -I"$INCLUDE_DIR" "$INCLUDE_DIRS" "$PKGS" "$cpps" "$base.cpp" -o "$base.so"`
    then
      # rm -f "$base.cpp"
      if [ $RUNIT = 1 ]
      then
        `echo "$FLXRUN" "$base.so" $args`
      fi
      exit $?
    else
      exit $?
    fi
  fi
else
  if `echo "$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"` 
  then
    if `echo $CCLINK_STATIC $CCFLAGS -DFLX_STATIC_LINK -I"$INCLUDE_DIR" "$INCLUDE_DIRS" $FLXBIN/flx_run_static.o "$PKGS" "$cpps" "$base.cpp" $FLXRTL/flx_static.a -o "$base"`
    then
      # rm -f "$base.cpp"
      if [ $RUNIT = 1 ]
      then
        `echo $base $args`
      fi
      exit $?
    else
      exit $?
    fi
  fi
fi

@os.system('chmod u+x bin/flx')
@os.system('cp doc/*.css tut/doc >/dev/null 2>&1')

