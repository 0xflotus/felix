@head(2,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID

@head(2,'CVS LOG')
$Log$
Revision 1.171  2005/10/28 04:08:43  skaller
Test in ocaml config for -w xy options needed for 3.09,
extend handling of user defined infix operators to allow
keywords.

Revision 1.170  2005/10/27 18:19:33  skaller
add -W y option to suppress Ocaml 3.09 warning Y

Revision 1.169  2005/10/27 16:46:27  skaller
Add user defined infix operators.

Revision 1.168  2005/10/24 08:29:10  skaller
Blah

Revision 1.167  2005/10/23 04:11:50  skaller
Fixed inlining bug, removed special useless call eliminator

Revision 1.166  2005/10/22 00:57:16  skaller
Implemented Service Control Requests

Revision 1.165  2005/10/19 08:32:58  skaller
Added <- operator and more OO stuff.

Revision 1.164  2005/10/19 01:28:32  rfistman
fixed problem in cygwin build, seemed that the while loop in the configure
script was actually wrong under cygwin, a syntax error.

Revision 1.163  2005/10/16 17:38:42  skaller
Add cclass wrapper construction to sugar up
wrapping C++ classes. At this stage, four member types are
supported: val, var, fun, and proc all corresponding to
non-static members. Constructors are not yet supported.

Revision 1.162  2005/10/13 20:43:09  skaller
Added --static to Windows flx script

Revision 1.161  2005/10/13 19:42:24  skaller
Add a Windows version of the 'flx' script called bin/flx.bat

Revision 1.160  2005/10/09 00:59:25  skaller
Experiment with group extraction in regexps using Inria code.

Revision 1.159  2005/10/07 18:07:11  skaller
Fix win32 build bugs .. again ..

Revision 1.158  2005/10/06 15:21:24  skaller
Refactoring build system.

Revision 1.157  2005/10/05 06:29:31  skaller
More work on type constraints, more OO in build system.

Revision 1.156  2005/10/03 18:58:11  skaller
Basic type constraints now working.

Revision 1.155  2005/09/30 19:01:19  skaller
Rewrote the lookup to use a single record for recursion stopper,
repairs on type functions so type matches reduce properly,
preparation for type constraints.

Revision 1.154  2005/09/24 21:46:33  skaller
More pathname fixes (/ vs \, using os.sep ..) and DIFF fix

Revision 1.153  2005/09/24 20:46:13  skaller
Fix static RTL to be built by the TARGET C++ compiler, not
the HOST C++ compiler.

Revision 1.152  2005/09/23 23:17:55  skaller
Fix PYTHONPATH problems; add typeset and intersection types

Revision 1.151  2005/09/21 01:26:53  skaller
Change headers and bodies to use C strings as "no substitution"
so $ etc in comments don't cause trouble.

Revision 1.150  2005/09/15 18:19:53  skaller
Minor fixes to new system on Linux

Revision 1.149  2005/09/15 14:29:13  skaller
Full native Win32 version running (no Cygwin at all)

Revision 1.148  2005/09/14 09:43:59  skaller
win32 and nocywin work, cygwin still doesn't

Revision 1.147  2005/09/12 17:59:24  skaller
Win32 build working

Revision 1.146  2005/09/12 16:32:10  skaller
Win32 build

Revision 1.145  2005/09/11 16:25:21  skaller
Add WIN32 check for running tests, don't use LD_LIBRARY_PATH

Revision 1.144  2005/09/11 16:22:30  skaller
Most of Win32 running now

Revision 1.143  2005/09/11 04:45:09  skaller
win32 build

Revision 1.142  2005/09/10 04:44:00  skaller
Remove ocamlopt -cc-lib flags (seems to work without these)

Revision 1.141  2005/09/10 04:30:22  skaller
Win32 build

Revision 1.140  2005/09/08 19:11:09  skaller
change obj_extension to EXT_OBJ

Revision 1.139  2005/09/07 17:38:51  skaller
Get -mno-cygwin to work

Revision 1.138  2005/09/06 19:13:25  skaller
Add a new option to 'flx' bash script: --nofelix prevents flxg running,
allowing a hand modified C++ program to be compiled (and run) without
needing to figure out all the flags.

Revision 1.137  2005/09/06 18:44:47  skaller
Due to inane incompatibilities in bash, Cygwin requires
quotes around the argument to env, whereas
Linux will not accept them.

Revision 1.136  2005/09/06 16:44:12  skaller
More fiddling. Optimisation is now the default!

Revision 1.135  2005/09/05 15:38:10  skaller
Fix build bug where dynamic linkage wasn't supported.

Revision 1.134  2005/09/04 17:40:21  skaller
Make the tests run in 'all' actually run all 4 combinations
of optimisation and linkage.

Revision 1.133  2005/09/03 19:35:39  skaller
New object based toolchain support system

Revision 1.132  2005/08/31 06:55:34  skaller
Make a link for Linux for the RTL so the loader finds the library.

Revision 1.131  2005/08/31 06:24:19  skaller
More cygwin fiddling

Revision 1.130  2005/08/30 19:56:30  skaller
more fiddling g++ switches

Revision 1.129  2005/08/30 02:10:05  skaller
Put -Lrtl -lflx_dynamic on the end of --test mode bin/flx dynamic link command line

Revision 1.128  2005/08/29 16:15:19  skaller
Clean up a bit, fix incorrect gc usage indicator, and
finally eliminate the collector_t &gc; statement altogether.
Add a new combinator `BEXPR_apply_struct which handles
calls to struct, cstruct, a nonconst_ctor type constructors
distinctly from applications of primitives and Felix functions.

Revision 1.127  2005/08/27 18:54:45  skaller
Get more of the python class based cross-compilation support
scripts to work. g++ class now works for the main build and tests.
bin/flx is not yet supported by this mechanism and may never be,
since it would introduce a dependence on Python to run it,
however this may be necessary for Windows anyhow, since bin/flx
is a bash script.

Revision 1.126  2005/08/26 06:11:47  skaller
Start new build method using Python class for C++ compiler.

Revision 1.125  2005/08/21 15:48:10  skaller
Fix bug in flx script in --test mode with dynamic linkage for Cygwin environment.

Revision 1.124  2005/08/18 14:29:15  rfistman
added dynamic linking for os x. uses dlcompat which may have only been
introduced in 10.3. will probably need more work for 10.2, 10.1

Revision 1.123  2005/08/08 16:23:53  skaller
Add #error preprocessor directive, fix make script to send output
to NUL in Win32 where it goes to /dev/null in unix.

Revision 1.122  2005/08/05 03:10:29  skaller
Cleaned up sm.pak so __UNIX__ flag no longer needed

Revision 1.121  2005/08/02 17:15:15  haeleth
Dynamic loading for Cygwin

Revision 1.120  2005/08/02 16:09:40  skaller
Add FLX_EXPORT to exported function declarations.

Revision 1.119  2005/08/01 07:54:26  skaller
Fixed PATH with spaces problem (however more related problems with
other variables such as include paths probably remain)

Revision 1.118  2005/07/29 08:34:50  skaller
Make config script a bit more platform independent by using os.sep,
python filecopy routine replacing cp

Revision 1.117  2005/07/28 22:11:09  skaller
Get log to work ..


@head(2,'Utilities')
Hack up the tutorial: phase 1 of conversion to texinfo format.
@h = tangler('script/mktitut.sed','python')
@select(h)
s/@set_title('\(.*\)')/\\input texinfo\n@settitle \1/
s/@head(1,'\(.*\)')/@node \1\n@chapter \1/
s/@head(1,"\(.*\)")/@node \1\n@chapter \1/
s/@head(2,'\(.*\)')/@node \1\n@section \1/
s/@head(2,"\(.*\)")/@node \1\n@section \1/
s/@head(3,'\(.*\)')/@node \1\n@subsection \1/
s/@head(3,"\(.*\)")/@node \1\n@subsection \1/
s/@p()//
s/@select.*/@verbatim/
s/@doc()/@end verbatim/
s/@begin_displayed_code()/@verbatim/
s/@end_displayed_code()/@end verbatim/
s/@tdir =.*//
s/@execfile.*//
s/@h=//
s/@begin_table("\(.*\)","\(.*\)","\(.*\)")/@multitable @columnfractions .33 .33 .33\n@headitem \1 @tab \2 @tab \3/
s/@begin_table("\(.*\)","\(.*\)")/@multitable @columnfractions .5 .5\n@headitem \1 @tab \2/
s/@end_table()/@end multitable/
s/@table_row("\(.*\)","\(.*\)","\(.*\)")/@item \1 @tab \2 @tab \3/
s/@table_row("\(.*\)","\(.*\)")/@item \1 @tab \2/
s/\\uXXXX/@verb{ \\uXXXX }/
s/\\UXXXXXXXX/@verb{ \\UXXXXXXXX }/
s/\\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f/@verb{ \\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f }/
s/'else {}'\./@verb{.else {}.}/
s/"{" /@verb{ { }/
s/"}" /@verb{ } }/
@doc()
Now phase 2, a python script. There are some caveats
on what it can handle: it generates just one menu.
@h = tangler('script/mktitut.py','python')
@select(h)
# modify an texinfo file to add a menu of all the nodes
# read from stdin, write to stout
import sys

crap1 = """
@@copying
This manual is for Felix version 1.1.0. 
Copyright @copyright{} 2005 John Skaller
@@quotation
All rights relinquished, you can do whatever you
like with this manual.
@@end quotation
@@end copying

@@titlepage
@@title Felix Overview
@@subtitle A quick guide to the basic ideas
@@author John Skaller
@@page
@@vskip 0pt plus 1filll
@@insertcopying
@@end titlepage
@@contents

@@ifnottex
"""

crap2 = """
@@top Overview

@@insertcopying
@@end ifnottex
"""

cache = []
menu = []

def nav(node):
  for i in xrange(0,n):
    if node == menu[i]:
      if i == 0: prev = "Top"
      else: prev = menu[i-1]
      if i == n-1: next = "Top"
      else: next = menu[i+1]
      return next,prev

flag = 0
for line in sys.stdin:
  if flag == 0:
    if '@node ' == line[:6]:
      node = line[6:-1]
      flag = 1
      cache.append(line)
    else:
      cache.append(line)
  else:
    if '@chapter' == line[:8]:
      #print "chapter"
      menu.append(node)
    elif '@section' == line[:8]:
      #print "section"
      menu.append(node)
    elif '@subsection' == line[:11]:
      #print "subsection"
      menu.append(node)
    else:
      print "ERROR, need chapter section or subsection here"
      print "got ",line,
      raise "error" 
    cache.append('@section\n')
    flag = 0
  
  
n = len(menu)

for line in cache:
  if '@settitle' == line[:9]:
    print '@setfilename ' + sys.argv[1] # the filename
    print line,
    print crap1
    print "@node Top, "+menu[0]+", "+menu[n-1]+",(dir)"
    print crap2
    print '@menu'
    for item in menu:
      print "* " + item+":: "+item
    print '@end menu'
  elif '@node ' == line[:6]:
    node = line[6:-1]
    next,prev = nav(node)
    print '@node '+node+', '+next+', '+prev+', Top'
  else:
    print line,
print

@doc()
This is input to equiv-build, which makes
a dummy ocaml-3.08.3 package to satisfy
the debian package dependencies.
@h = tangler('misc/ocaml-nox-3.08.3-equiv','data')
@select(h)
Source: ocaml-nox-3.08.3
Section: devel
Priority: optional
Maintainer: John Skaller <skaller@users.sourceforge.net>
Standards-Version: 3.6.1

Package: ocaml-nox-3.08.3
Architecture: any
Description: hack to tell system 0caml3.08.3 is installed

@h = tangler('script/fcount.py','python')
@select(h)
import glob
import os
import sys
if '' not in sys.path: sys.path = ['']+sys.path
import flxbuild
from flxbuild.flxutil import *

try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

try:
  key = sys.argv[2]
except:
  key = "std"

try:
  globspec = sys.argv[3]
except:
  globspec = "tut/examples/*.hpp"

print "function counter: STATS FILE",filename, "KEY", key, "GLOB",globspec
dict = {}
try:
  execfile (filename)
except:pass

files = glob.glob(globspec)

for file in files:
  cmd = 'egrep "//PROC|//FUNCTION" ' + file + ' | wc -l'
  result,output = get_stdout(cmd)
  output = output[0][:-1]
  x = int(output)
  try:
    d= dict[file]
  except:
    dict[file]={}
    d = dict[file]
  d[key]=x

f = open(filename,"w")
f.write("dict="+repr(dict))
f.close()

@h = tangler('script/pfcount.py','python')
@select(h)
import glob
import os
import sys
try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

only_nonopt = 0
try:
  x = sys.argv[2]
except:
  only_nonopt = 1

dict = {}
try:
  execfile (filename)
except:pass

keys = {}
i = 0
for k in dict.keys():
  i = max(i,len(k))
  d = dict[k]
  for key in d.keys():
    keys[key]=None

keys = keys.keys()
j=0
for k in keys:
  j = max(j,len(k))

print "Function counts for test programs"
print "================================="
print
print ("%-"+str(i+2)+"s") % "File" + "    ",
for t in keys:
  print ("%"+str(j+2)+"s") % t,
print
print "--------"

skeys = dict.keys()
skeys.sort()

for k in skeys:
  d = dict[k]
  x= ("%-"+str(i+2)+"s") % k + "..  "
  discard = 0
  for t in keys:
    v = d.get(t,-1)
    if v == -1:
      v = ""
    elif (v == 1 or v == 0) and t == "inline" and only_nonopt: 
      discard = 1
      break
    else:
      v = str(v)
    v = ("%"+str(j+2)+"s") % v
    x = x+v
  if not discard: print x


@h = tangler('script/detab.py','python')
@select(h)
import string
import sys

f = open(sys.argv[1])
data = f.readlines()
f.close()
f = open(sys.argv[1],"w")
for line in data:
  line = string.expandtabs(line)
  f.write(line)
f.close()

@h = tangler('script/mktre.py','python')
@select(h)

import string
import os
import sys

prefix = '/work/tre-0.7.2/lib/'

tre_files = [
  'gettext.h',
  'regcomp.c',
  'regerror.c',
  'regexec.c',
  'regex.h',
  'tre-ast.c',
  'tre-ast.h',
  'tre-compile.c',
  'tre-compile.h',
  'tre-config.h',
  'tre-filter.c',
  'tre-filter.h',
  'tre-internal.h',
  'tre-match-approx.c',
  'tre-match-backtrack.c',
  'tre-match-parallel.c',
  'tre-match-utils.h',
  'tre-mem.c',
  'tre-mem.h',
  'tre-parse.c',
  'tre-parse.h',
  'tre-stack.c',
  'tre-stack.h',
  'xmalloc.h',
  'xmalloc.c',
  ]

mods = {}
tgts = [] 

for fn in tre_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[0:4]=='tre-':
    target = 'tre/tre_'+base[4:]
  else:
    target = 'tre/tre_'+base
  if target[-1:]=='c':
    target = target[:-1]+'cpp'
  elif target[-1:]=='h':
    target = target[:-1]+'hpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'tre')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in tre_files:
        dot = index(fl,".")
        if dot > 0:
          fl = fl[:dot]
          fl = fl+'.hpp'
        if fl[0:4]=="tre-":
          print '#include "tre_'+fl[4:]+'"'
        else:
          print '#include "tre_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 

@h = tangler('script/mksm.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/smbase/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
  'point.cc',
  'pprint.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

mods = {}
tgts = [] 

for fn in sm_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/sm_'+base
  if target[-2:]=='cc': 
    target = target[:-2]+'cpp'
  elif target[-1:]=='c':
    target = target[:-1]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'smbase')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkast.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/ast/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
#  'mypopen.h',
#  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
#  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
#  'mypopen.c',
#  'mysig.cc',
  'point.cc',
  'pprint.cc',
#  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]


ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]
mods = {}
tgts = [] 

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""


for fn in ast_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/ast_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

print "@head(1,'ast')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkelk.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/elkhound/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
#  'mypopen.h',
#  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
#  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
#  'mypopen.c',
#  'mysig.cc',
  'point.cc',
  'pprint.cc',
#  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]

elk_files = [
  'gramlex.lex',
  'grampar.y',
  'asockind.h',
  'emitcode.h',
  'flatutil.h',
  'genml.h',
  'glrconfig.h',
  'glr.h',
  'gramanl.h',
  'gramast.ast.gen.h',
  'grammar.h',
  'grampar.codes.h',
  'grampar.h',
  'grampar.tab.h',
  'lexerint.h',
  'mlsstr.h',
  'ownerspec.h',
  'parsetables.h',
  'ptreeact.h',
  'ptreenode.h',
  'rcptr.h',
  'useract.h',
  'util.h',
  'asockind.cc',
  'emitcode.cc',
  'genml.cc',
  'glr.cc',
  'gramanl.cc',
  'gramast.ast.gen.cc',
  'gramlex.yy.cc',
  'grampar.cc',
  'grampar.tab.cc',
  'grammar.cc',
  'mlsstr.cc',
  'parsetables.cc',
  'ptreeact.cc',
  'ptreenode.cc',
  'useract.cc',
  'gramexpl.cc'
]
mods = {}
tgts = [] 


for fn in elk_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/elk_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'elkhound')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      elif fl in elk_files:
        print '#include "elk_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkocs.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/ocs-1.0/src/'

files = [
  'ocs_char.ml',
  'ocs_char.mli',
  'ocs_compile.ml',
  'ocs_compile.mli',
  'ocs_complex.ml',
  'ocs_complex.mli',
  'ocs_contin.ml',
  'ocs_contin.mli',
  'ocs_env.ml',
  'ocs_env.mli',
  'ocs_error.ml',
  'ocs_eval.ml',
  'ocs_eval.mli',
  'ocs_io.ml',
  'ocs_io.mli',
  'ocs_lex.ml',
  'ocs_lex.mli',
  'ocs_list.ml',
  'ocs_list.mli',
  'ocs_macro.ml',
  'ocs_macro.mli',
  'ocs_main.ml',
  'ocs_misc.ml',
  'ocs_misc.mli',
  'ocs_numaux.ml',
  'ocs_numaux.mli',
  'ocs_num.ml',
  'ocs_num.mli',
  'ocs_numstr.ml',
  'ocs_numstr.mli',
  'ocs_port.ml',
  'ocs_port.mli',
  'ocs_prim.ml',
  'ocs_prim.mli',
  'ocs_print.ml',
  'ocs_print.mli',
  'ocs_read.ml',
  'ocs_read.mli',
  'ocs_string.ml',
  'ocs_string.mli',
  'ocs_sym.ml',
  'ocs_sym.mli',
  'ocs_top.ml',
  'ocs_top.mli',
  'ocs_types.mli',
  'ocs_vartable.ml',
  'ocs_vartable.mli',
  'ocs_vector.ml',
  'ocs_vector.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'OCS')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/lua-5.0.2/src/'

files = [
  'lapi.c',
  'lapi.h',
  'lcode.c',
  'lcode.h',
  'ldebug.c',
  'ldebug.h',
  'ldo.c',
  'ldo.h',
  'ldump.c',
  'lfunc.c',
  'lfunc.h',
  'lgc.c',
  'lgc.h',
  'llex.c',
  'llex.h',
  'llimits.h',
  'lmem.c',
  'lmem.h',
  'lobject.c',
  'lobject.h',
  'lopcodes.c',
  'lopcodes.h',
  'lparser.c',
  'lparser.h',
  'lstate.c',
  'lstate.h',
  'lstring.c',
  'lstring.h',
  'ltable.c',
  'ltable.h',
  'ltests.c',
  'ltm.c',
  'ltm.h',
  'lundump.c',
  'lundump.h',
  'lvm.c',
  'lvm.h',
  'lzio.c',
  'lzio.h',
  'lib/lauxlib.c',
  'lib/lbaselib.c',
  'lib/ldblib.c',
  'lib/liolib.c',
  'lib/lmathlib.c',
  'lib/loadlib.c',
  'lib/lstrlib.c',
  'lib/ltablib.c',
  'luac/luac.c',
  'lua/lua.c',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[-1]=='c' :
    target = 'lua/'+base+'pp'
  else:
    target = 'lua/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'Lua')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua_scripts.py','python')
@select(h)

import string
import os
import glob

prefix = '/usr/local/src/lua-5.0.2/test/'
files = glob.glob(prefix+'*.lua')
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'misc/lua/'+base
  tgts.append((fn,target))

print "@head(1,'Lua test scripts')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mkcil.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/cil/'
files = [
  'src/check.ml',
  'src/check.mli',
  'src/cil.ml',
  'src/cil.mli',
  'src/cilutil.ml',
  'src/clist.ml',
  'src/clist.mli',
  'src/escape.ml',
  'src/escape.mli',
  'src/formatcil.ml',
  'src/formatcil.mli',
  'src/formatlex.mll',
  'src/formatparse.mly',
  'src/libmaincil.ml',
  'src/maincil.ml',
  'src/mergecil.ml',
  'src/mergecil.mli',
  'src/rmtmps.ml',
  'src/rmtmps.mli',
  'src/testcil.ml',
  'src/frontc/cabs2cil.ml',
  'src/frontc/cabs2cil.mli',
  'src/frontc/cabs.ml',
  'src/frontc/cabsvisit.ml',
  'src/frontc/cabsvisit.mli',
  'src/frontc/clexer.mli',
  'src/frontc/clexer.mll',
  'src/frontc/cparser.mly',
  'src/frontc/cprint.ml',
  'src/frontc/frontc.ml',
  'src/frontc/frontc.mli',
  'src/frontc/lexerhack.ml',
  'src/frontc/patch.ml',
  'src/frontc/patch.mli',
  'ocamlutil/errormsg.ml',
  'ocamlutil/errormsg.mli',
  'ocamlutil/inthash.ml',
  'ocamlutil/pretty.ml',
  'ocamlutil/pretty.mli',
  'ocamlutil/stats.ml',
  'ocamlutil/stats.mli',
  'ocamlutil/trace.ml',
  'ocamlutil/trace.mli',
  'ocamlutil/util.ml',
  'ocamlutil/util.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/flx_cil_'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')
  m = base[:i]
  mods[string.capitalize(m)]='Flx_cil_' + m

ms = mods.keys()
for k in ms:
  print mods[k]

print "@head(1,'CIL')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    for s in ms:
      r = mods[s]
      line = string.replace(line,s,r)
    print line,
      
@h = tangler('script/mk_fish','python')
@select(h)
import glob
glob = glob.glob

for i in glob("*.mli")+glob("*.mll")+glob("*.mly")+glob("*.ml"):
  if i not in ["parse_fish.ml","lex_fish.ml"]:
    print '@head(2,"'+i+'")'
    print i+"."
    print '@select(tangler("src/'+i+'"))'
    f = open(i)
    for j in f: print j,
    f.close()
    print

@h = tangler('script/mk_expect','python')
@select(h)
import glob
import sys
for k in sys.argv[1:]:
  files = glob.glob(k+'/*.output')
  print '@head(1,"Expected outputs for '+k+'")'
  for i in files:
    j = i[:-7]+'.expect'
    print '@head(2,"'+j+'")'
    print '@select(tangler("'+j+'","data"))'
    f = open(i,"r")
    for l in f: print l,
    f.close()

@h = tangler('script/elk_flx_grgen','python')
@select(h)
import string
import sys

ts ={}
nt = ""
d = {}

def isterminal(w):
  return w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def isnonterminal(w): 
  return not isterminal(w)

def check_symbol(w):
  if isterminal(w): ts[w]=1

def cvt_symbol(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/': 
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state: 
      if l <> "\n":
        handle_line(l[:-1])
    else: 
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

ts['WSTRING']=1
ts['USTRING']=1
ts = ts.keys()
ts.sort()
print "terminals {"
print "   0 : TOK_EOF;"
j = 1
for k in ts:
  print ' ',"%4d" % j,': TOK_'+k,';'
  j = j + 1
print
attrtoks = ["CSTRING","STRING","WSTRING","USTRING","NAME","FLOAT","INTEGER"]
for k in attrtoks:
  print "  token(void*) TOK_"+k+";"

print "}"
print 
 
print "context_class Flx_Elk_Parser : public UserActions {};"
print
print "nonterm(void*) top {"
print "  -> _1:compilation_unit { return _1; }"
print "}"
print
ntno = 1
for k in d.keys():
  print "nonterm(void*)",k," {"
  v = d[k]
  for p in v:
    print "  -> ",
    acnt = 0
    for w in p:
      s = cvt_symbol(w)
      if w in attrtoks or not isterminal(s):
        acnt = acnt + 1
        print "_"+str(acnt)+":"+s,
      else:
        print cvt_symbol(w),
    print "  {"
    print "     void **data = (void**)malloc(sizeof(void*)*"+str(acnt+1)+");"
    print "     data[0] = (void*)"+str(acnt)+";"
    for i in range(1,acnt+1):
      print "     data["+str(i)+"] = _"+str(i)+";"
    print "     return (void*)data;"
    print "  }"
  print "}"
  print
 
@h = tangler('script/flx_flx_grgen','python')
@select(h)
import string
import sys

ts ={}
nt = ""
d = {}

def isterminal(w):
  return w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def isnonterminal(w):
  return not isterminal(w)

def check_symbol(w):
  if isterminal(w): ts[w]=1

def cvt_symbol(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return w

def cvt_symbol2(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return "nt_"+w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/':
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state:
      if l <> "\n":
        handle_line(l[:-1])
    else:
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

attrtok_map = {
  "CSTRING":'string',
  "STRING":'string',
  "WSTRING":'string',
  "USTRING":'string',
  "NAME":'string',
  "FLOAT":'string',
  "INTEGER":'(string * string)',
}
attrtoks = attrtok_map.keys()

print 'include "std";'
print 'include "flx_token";'
print
print 'module flx_grammar'
print '{'
print '  open flx_token;'

print

print '  '+"nonterm top:compilation_unit_t ="
print '  '+"  | _1:nt_compilation_unit =>  _1 "
print '  '+";"
print
for k in d.keys():
  print '  '+"union",k+"_t ="
  v = d[k]
  pno = 0
  nps = len(v)
  for p in v:
    pno = pno + 1
    s = "  |  "
    acnt = 0
    l = len (p)
    j = 0
    s= "  | " + k+"_"+str(pno)
    lead = " of "
    for w in p:
      ss = cvt_symbol(w)
      if w in attrtoks:
        s = s + lead +attrtok_map[w]
        lead = " * "
      elif not isterminal(w):
        acnt = acnt + 1
        s=s+ lead + ss+ "_t"
        lead = " * "
      j = j + 1
    print '  '+s
  print '  '+";"
  print

  print '  '+"nonterm nt_"+k,":",k+"_t ="
  v = d[k]
  pno = 0
  nps = len(v)
  for p in v:
    pno = pno + 1
    s = "  |  "
    acnt = 0
    l = len (p)
    j = 0
    for w in p:
      ss = cvt_symbol2(w)
      if w in attrtoks or not isterminal(w):
        acnt = acnt + 1
        s=s+ "_"+str(acnt)+":"+ss
      else:
        s=s+ss
      j = j + 1
      if j != l:
        s=s+" "
    print '  '+s

    s= "    => " + k+"_"+str(pno)
    if acnt > 0: s=s+"("
    for i in range(1,acnt+1):
      s = s + "_"+str(i)
      if i != acnt:
        s= s + ", "
    if acnt > 0: s=s+")"
    print '  '+s
    if pno != nps: print
  print '  '+";"
  print
print "}"

@h = tangler('script/flx_tokgen','python')
@select(h)
import string
import sys
import os
execfile ("config"+os.sep+"flx_data.py")
ts ={}
for k,t in flx_keywords: ts[t]=1
for t,l in flx_1_char_syms: ts[t]=1
for t,l in flx_2_char_syms: ts[t]=1
for t,l in flx_3_char_syms: ts[t]=1
ts['ERROR']=1

nt = ""
d = {}

def isterminal(w):
  return w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def isnonterminal(w): 
  return not isterminal(w)

def check_symbol(w):
  if isterminal(w): ts[w]=1

def cvt_symbol(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return w

def cvt_symbol2(w):
  if isterminal(w):
    return "TOK_" + w
  else:
    return "nt_"+w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/': 
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state: 
      if l <> "\n":
        handle_line(l[:-1])
    else: 
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

attrtok_map = {
  "ERROR":'string',
  "CSTRING":'string',
  "STRING":'string',
  "WSTRING":'string',
  "USTRING":'string',
  "NAME":'string',
  "FLOAT":'string',
  "INTEGER":'(string * string)',
}
attrtoks = attrtok_map.keys()

ts['WSTRING']=1
ts['USTRING']=1
ts = ts.keys()
ts.sort()
print 'include "std";'
print 
print 'module flx_token'
print '{'

print "  union flx_token_t = "
print "    | TOK_EOF                                 //0"
j = 1
for k in ts:
  s = '  | TOK_'+k
  if k in attrtoks:
    s = s + " of " + attrtok_map[k]
  print '  '+(s  + " " *45)[:45]+'//'+str(j)
  j = j + 1
print '  '+";"
print 
print "}" 

@h = tangler('script/elk_flx_lexgen','python')
@select(h)
import string
import sys

ts ={}
nt = ""
d = {}

def check_symbol(w):
  if w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
    ts[w]=1

def cvt_symbol(w):
  if w[0] in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
    return "TOK_" + w
  else:
    return w

def handle_line(l):
  global nt
  if l == '  | /* empty */':
    d[nt]=d[nt]+[[]]
  elif l[0]<>' ':
    nt = l[:-1]
    d[nt]=[]
  else:
    x = string.split(l)[1:]
    for w in x: check_symbol(w)
    d[nt]=d[nt]+[x]


f = open(sys.argv[1])
state = 1
for l in f:
  if l[:2] == '/*' and l[-3:-1]=='*/': 
    #print "skipping",l,
    pass
  else:
    if l[:2]=='/*': state = 0
    if state: 
      if l <> "\n":
        handle_line(l[:-1])
    else: 
      #print "skippy",l,
      pass
    if l[:2]=='*/': state = 1
f.close()

ts['WSTRING']=1
ts['USTRING']=1
ts = ts.keys()
ts.sort()
print '#include "elk_flx_lexer.h"'
print '#include "stdio.h"'
print '#include "string.h"'
print
print "enum Elk_Flx_Lexcode {"
print "  TOK_EOF,                    //0"
j=1
for k in ts:
    print ('  TOK_'+k+',                        ')[:30]+'//'+str(j)
    j = j + 1
print "};"
print 

print "char *Elk_Flx_Lexcode_Desc[] = {"
print '  "TOK_EOF",                    //0'
j=1
for k in ts:
  print ('  "TOK_'+k+'",                        ')[:30]+'//'+str(j)
  j = j + 1
print "};"
print 

n = len(ts)+1
print "static int const ntoks = "+str(n)+";"


print r"""
string Elk_Flx_Lexer::tokenDesc() const
{
  switch (type) {
    case TOK_NAME:   
    case TOK_INTEGER:   
    case TOK_FLOAT:   
    case TOK_STRING:   
    case TOK_CSTRING:   
    case TOK_WSTRING:   
    case TOK_USTRING:   
    {
      char buffer[200];
      strcpy(buffer,tokenKindDesc(type));
      strcat(buffer,"=");
      strcat(buffer,(char*)sval);
      return buffer;
    }
    default:               return tokenKindDesc(type);
  }
}

string Elk_Flx_Lexer::tokenKindDesc(int kind) const {
  return Elk_Flx_Lexcode_Desc[kind];
}

void Elk_Flx_Lexer::nextToken(LexerInterface *lex) {
  char buffer[100];
  if (fgets(buffer,100,stdin)) {
    int n = strlen(buffer) - 1; //skip the newline
    memmove(buffer+4,buffer,n); 
    memcpy(buffer,"TOK_",4);
    n+=4;
    buffer[n]=0;
    buffer[n+1]=0;
    char *extra = buffer;
    // skip non white
    while(*extra && *extra != ' ')++extra;
    
    // terminate token
    *extra++ = 0;

    // skip white
    while(*extra && *extra == ' ')++extra;
    
    int k;
    for(k=0; k<ntoks; ++k)
      if(strcmp(Elk_Flx_Lexcode_Desc[k],buffer)==0)
        break;
    if(k==ntoks) {
      printf("Invalid token '%s'",buffer); 
      abort();
    }
    lex->type = k;
    lex->sval = (SemanticValue)extra;
  }
  else {
    lex->type = TOK_EOF;
    lex->sval = NULL;
  }
  return;
}


#ifdef TEST_LEXER
int main()
{
  Elk_Flx_Lexer lexer;
  for (;;) {
    lexer.getTokenFunc()(&lexer);    // first call yields a function pointer
                                                                                
    // print the returned token
    string desc = lexer.tokenDesc();
    printf("%s\n", (char const*)desc);
                                                                                
    if (lexer.type == TOK_ENDMARKER) {
      break;
    }
  }
                                                                                
  return 0;
}
#endif // TEST_LEXER
"""

@h = tangler('misc/elk_flx_lexer.h')
@select(h)
#ifndef ELK_FLX_LEXER
#define ELK_FLX_LEXER

#include "lexerint.h"
// read characters from stdin, yield tokens for the parser
class Elk_Flx_Lexer : public LexerInterface {
public:
  // function that retrieves the next token from
  // the input stream
  static void nextToken(LexerInterface *lex);
  virtual NextTokenFunc getTokenFunc() const
    { return &Elk_Flx_Lexer::nextToken; }
 
  // debugging assistance functions
  string tokenDesc() const;
  string tokenKindDesc(int kind) const;
};

#endif

@h = tangler('script/get_grammar','python')
@select(h)
import string
import sys
f = open(sys.argv[1])
start = 0
count = 0
for l in f:
  if start:
    if l[:2]=='%%': start=0
    else:
      out = ""
      for ch in l:
        if ch == '{': count+=1
        elif ch == '}': count-=1
        elif count == 0: out += ch
      out = string.strip(out)
      if out: 
        if out[0]=='|': 
          out = string.strip(out[1:])
          if out=="": print "  | /* empty */"
          else: print "  | "+out
        elif out[-1]==':': 
          print 
          print out
        elif out==';': pass
        else: 
          print out
  elif l[:2]=='%%': start=1
f.close()


@h = tangler('script/load_grammar','python')
@select(h)
# get ocamlyacc grammar and store as Python
# the header part is between %{ and %}
# the prelude is after that and before %%
# then comes the grammar up to %% 
# then the trailer

import string
import sys
f = open(sys.argv[1])
lines = [line for line in f]

i = 0
def upto(prefix=None):
  global i
  s = []
  while 1:
    line = f[i]
    i = i + 1
    if prefix == None and 
      i == len(lines) or
      prefix =- line[:len(prefix)]:
      return s
    s = s.append(line)
  
head = upto('%}')
prelude = upto('%%')
grammr = upto('%%')
footer = upto()

print "head:"
print head
print "prelude"
print prelude
print "body"
print body
print "footer"
print footer
sys.exit(0)

start = 0
count = 0
for l in f:
  if start:
    if l[:2]=='%%': start=0
    else:
      out = ""
      for ch in l:
        if ch == '{': count+=1
        elif ch == '}': count-=1
        elif count == 0: out += ch
      out = string.strip(out)
      if out: 
        if out[0]=='|': 
          out = string.strip(out[1:])
          if out=="": print "  | /* empty */"
          else: print "  | "+out
        elif out[-1]==':': 
          print 
          print out
        elif out==';': pass
        else: 
          print out
  elif l[:2]=='%%': start=1
f.close()


@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
@tangle("FLX_MAKER_CVS_ID='"+FLX_MAKER_CVS_ID+"'")
import os
import glob
import stat
import string
import sys
import re
import traceback
if '' not in sys.path: sys.path=['']+sys.path
import flxbuild
from flxbuild.flxutil import *

try:
  execfile("config"+os.sep+"config.py")
except:
  xt,xv,tb = sys.exc_info()
  print "ERROR IN config/config.py"
  traceback.print_exception(xt,xv,tb)
  print "You must either"
  print "(a) edit config/config.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

FLXFLAGS = ""

if os.name == 'nt': # build system is Windows Python
  DIFF = "FC /L /W "
  GREP = "#grep "
else:
  DIFF = "diff -a -b " # build system is Unix Python
  GREP = "grep "

# --------------------------------------------------
# IMPORT UTILITY RESOURCES
# ---------------------------------------------------

get_stdouterr = get_stdout

def flush():
  try: sys.stdin.flush()
  except: pass

def run(x):
  print x
  flush()
  result = os.system(ENV+x)
  if result: print "  .. ERROR CODE",hex(result)
  flush()

  if result:
    raise MakeError


def xqt(x):
  if "quiet" not in options: print x
  flush()
  result,output = get_stdouterr(x)
  if result: 
    if "quiet" in options: print x
    print "  .. ERROR CODE",hex(result)
  if output: 
    if result or "quiet" not in options:
      print string.join(output,"")
  flush()

  if result:
    raise MakeError

# quiet execution
def xqtq(x):
  if "quiet" not in options: print x
  flush()
  result,output = get_stdouterr(x)
  if result: 
    if "quiet" in options: print x
    print "  .. ERROR CODE",hex(result)
    raise MakeError


if os.name=="nt":
  ENV="set PATH=bin;%PATH%&&"
else:
  if CYGWIN or WIN32:
    ENV = 'env PATH=bin:"$PATH" PYTHONPATH=.:"$PYTHONPATH" '
  else:
    ENV = 'PATH=bin:"$PATH" LD_LIBRARY_PATH=rtl:"$LD_LIBRARY_PATH" '

def exqt(x): xqt(ENV+x)

# used when a negative result is expected (return code is supposed to be nonzero)
# used for a grep which is supposed to fail
def nxqt(x):
  x = ENV+x
  if "quiet" not in options: print x
  flush()
  result,output = get_stdouterr(x)
  if not result:
    if output: print string.join(output,"")
  flush()

  if not result:
    raise MakeError

# ----------- Utilities ---------------------
class MakeError: pass

# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

options = sys.argv[1:]
if not options: 
  options = ["extract","compiler","rtl","drivers","elkhound","optimise_c"]

CCMACS=""
for i in options:
  if i[0:2]=="-D": CCMACS=CCMACS+i+" "

if "silent" in options: 
  options.append("quiet")

if "bagley" in options: 
  options.append("time_execution")
  options.append("inline")

if "inline" in options:
  FLXFLAGS = FLXFLAGS + "--inline "
if "noinline" in options:
  FLXFLAGS = FLXFLAGS + "--noinline "
if options:
  print "OPTIONS: ", options

if "compiler" in options or "bytecode" in options or "olink" in options:
  #options.append("flxcc")
  options.append("felix")

keyopt = {}
for o in options:
  try:
    key,value = string.split(o,"+=")
    old = keyopt.get(key,[])
    if type(old) == type(""): old = [old]
    keyopt[key] = old + [value]
  except:
    try:
      key,value = string.split(o,"=")
      keyopt[key]=value
    except: pass

USER_TESTS = keyopt.get("flx",[])
if type(USER_TESTS) == type(""):
  USER_TESTS = [USER_TESTS]

if "help" in options:
  print "extract - extract sources"
  print "compiler - build compiler"
  print "bytecode - build bytecode version of compiler"
  print "profile - build profiling version of compiler"
  print "drivers - build drivers"
  print "regression - run regression tests"
  print "performance - run performance tests"
  print "bagley - run bagley shootout performance tests"
  print "tutorial - run tutorial examples"
  print "tests- regression and tutorial combined"
  print "clean - remove generated C++ and binaries from test locations"
  print "debug - build debugging versions of targets"
  print "optimise_c - build high performance versions of c++ targets"
  print "optimise_felix - build high performance versions of ocaml targets NOT RECOMMENDED!"
  print "doc - build all user documentation"

if "clean" in options:
  for d in [ "test","tut"+os.sep+"examples","bagley"+os.sep+"felix"]:
    for e in ["*.hpp","*.so","*.dll","*.cpp","*.hpp","*.par","*.output","*.o","*.obj","*.exp","*.lib"]:
      for f in glob.glob(d + os.sep + e):
        erasefile(f)

if "tests" in options or "test" in options:
  options = options + ["regression","tutorial"]

def flxg(x,basename):
  x = 'bin'+os.sep+'flxg ' + x
  exqt(x)

# ------------------------------------------------
# BEGIN USER CONFIGURABLE SECTION
#-------------------------------------------------

#interscript command (now built in part of Felix package)
def runISCR(a):
  if buildall:
    exqt(ISCR + "--nocache " + a)
  else:
    exqt(ISCR + ' ' + a)

if "compiler" in options or "bytecode" in options or "olink" in options:
  OCAML_OBJDIR = "src"
  BYTECODE = not NATIVE_CODE_COMPILER or "bytecode" in options 
  if BYTECODE:
    if "profile" in options: 
      OCAMLOPT = OCAMLCP
      OCAMLC = OCAMLCP
    else: OCAMLOPT = OCAMLB
  else:
    OCAMLOPT = OCAMLC
    if "profile" in options:
      OCAMLOPT = OCAMLOPT+' -p '
  
  OCAMLOPT = OCAMLOPT + " -I " + OCAML_OBJDIR
  OCAMLC = OCAMLC + " -I " + OCAML_OBJDIR
  
  if "debug" in options:
    OCAMLOPT = OCAMLOPT + '-g '

  if "optimise_felix" in options:
    OCAMLOPT = OCAMLOPT + " -unsafe -noassert -inline 5 "

  if BYTECODE == 0:
    OCAML_OBJECT_EXTENSION = '.cmx'
    OCAML_LIB_EXTENSION = '.cmxa'
  else:
    OCAML_OBJECT_EXTENSION = '.cmo'
    OCAML_LIB_EXTENSION = '.cma'
    
#determine linkage model

LINK_MODEL = DEFAULT_LINK_MODEL
if "static" in options:
  LINK_MODEL = "static"
if "dynamic" in options:
  LINK_MODEL == "dynamic"

if LINK_MODEL == "dynamic" and not SUPPORT_DYNAMIC_LOADING:
  print "dynamic linkage not supported"
  sys.exit(1)

if LINK_MODEL == "static" and not SUPPORT_STATIC_LINKAGE:
  print "dynamic linkage not supported"
  sys.exit(1)

CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "
CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "

if LINK_MODEL == "dynamic":
  SHLX = EXT_SHLIB
else:
  SHLX = ""


if CCMACS:
  CCOBJ_STATIC_RTL = CCOBJ_STATIC_RTL + CCMACS
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + CCMACS
  CCOBJ_STATIC_FLX = CCOBJ_STATIC_FLX + CCMACS

  CCOBJ_DYNAMIC_RTL = CCOBJ_DYNAMIC_MAIN + CCMACS
  CCOBJ_DYNAMIC_MAIN = CCOBJ_DYNAMIC_MAIN + CCMACS
  CCOBJ_DYNAMIC_FLX = CCOBJ_DYNAMIC_FLX + CCMACS


# ------------------------------------------------
# END USER CONFIGURABLE SECTION
#-------------------------------------------------

# where documentation gets put
WEAVER_DIRECTORY='doc/'
TUTORIAL_DIRECTORY='tut/'
TUTORIAL_DOC=TUTORIAL_DIRECTORY+'doc/'
TUTORIAL_EXAMPLES=TUTORIAL_DIRECTORY+'examples/'

# -------------------------------------------------
# BEGIN IMPLEMENTOR CONFIGURABLE SECTION
# ------------------------------------------------

# Elkhound stuffs

SMBASE = [
]

# These are the files actually needed at run time by Felix
SMRTL = [
  'sm_malloc_stub',
  'sm_nonport',
  'sm_autofile',
  'sm_bflatten',
  'sm_bit2d',
  'sm_bitarray',
  'sm_boxprint',
  'sm_breaker',
  'sm_crc',
  'sm_datablok',
  'sm_flatten',
  'sm_growbuf',
  'sm_gprintf',
  'sm_hashline',
  'sm_hashtbl',
  'sm_missing',
#  'sm_mypopen',
#  'sm_mysig',
  'sm_point',
  'sm_pprint',
#  'sm_regexp',
  'sm_strdict',
  'sm_strhash',
  'sm_stringset',
  'sm_strtokp',
  'sm_strutil',
  'sm_svdict',
  'sm_vdtllist',
  'sm_vptrmap',
  'sm_warn',
  'sm_srcloc',
  'sm_syserr',
  'sm_str',
  'sm_trace',
  'sm_trdelete',
  'sm_voidlist',
  'sm_exc',
]

ASTGEN = [
  'ast_gramlex',
  'ast_ccsstr',
  'ast_reporterr',
  'ast_embedded',
  'ast_asthelp',
  'ast_strtable',
  'ast_locstr',
]

ELKHOUND = [
  'elk_asockind',
  'elk_grammar',
  'elk_emitcode',
  'elk_mlsstr',
  'elk_genml',
  'elk_gramast.ast.gen',
  'elk_gramlex.yy',
  'elk_grampar',
  'elk_grampar.tab',
  'elk_gramexpl',
]

ELKRTL = [
  'elk_glr',
  'elk_parsetables',
  'elk_useract',
  'elk_ptreenode',
  'elk_ptreeact',
]

ELKRTL_INTERFACES = [
  'sm_array.h',
  'sm_objpool.h',
  'sm_sobjlist.h',
  'sm_trdelete.h',
  'sm_voidlist.h',
  'sm_macros.h',
  'sm_srcloc.h', 
  'sm_typ.h',
  'sm_xassert.h',
  'sm_objlist.h',
  'sm_str.h',
  'elk_lexerint.h',
  'elk_glrconfig.h',
  'elk_parsetables.h',
  'elk_glr.h',
  'elk_rcptr.h',
  'elk_useract.h',
]

# files containing ocamllex sources
CIL_LEXS = [ 'flx_cil_clexer', 'flx_cil_formatlex', ]
FLX_LEXS = [ 'flx_lex' ]
MISC_LEXS = []

# files containing ocamlyacc sources
MISC_PARSES = [ ]
CIL_PARSES = [ 'flx_cil_cparser', 'flx_cil_formatparse', ]
FLX_PARSES = [ 'flx_parse' ]

# ocaml modules = interfaces + implementation files

CIL_MODULES = [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
  'flx_cil_cilversion',
  'flx_cil_machdep',
  'flx_cil_pretty',
  'flx_cil_errormsg',
  'flx_cil_cabs_helper',
  'flx_cil_lexerhack',
  'flx_cil_escape',
  'flx_cil_cprint',
  'flx_cil_cparser',
  'flx_cil_clexer',
  'flx_cil_stats',
  'flx_cil_trace',
  'flx_cil_clist',
  'flx_cil_cil',
  'flx_cil_frontc',
  'flx_cil_rmtmps',
  'flx_cil_cabsvisit',
  'flx_cil_inthash',
  'flx_cil_formatparse',
  'flx_cil_formatlex',
  'flx_cil_util',
  'flx_cil_mergecil',
  'flx_cil_patch',
  'flx_cil_formatcil',
  'flx_cil_cilutil',
  'flx_cil_cabs2cil',
  'flx_cil_check',
]

MISC_MODULES = [
  'flx_filesys'      ,
]

FLX_MODULES = [
  'inria_table'      ,
  'inria_cset'      ,
  'inria_syntax'      ,
  'inria_lexgen'      ,
  'flx_mtypes1'      ,
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
  'flx_version'      ,
  'flx_ctype'        ,
  'flx_util'         ,
  'flx_dlst'         ,
  'flx_getopt'       ,
  'flx_mtypes2'      ,
  'flx_srcref'       ,
  'flx_typing'       ,
  'flx_exceptions'   ,
  'flx_string'       ,
  'flx_id'           ,
  'flx_print'        ,
  'flx_maps'         ,
  'flx_typing2'      ,
  'flx_unify'        ,
  'flx_charset'      ,
  'flx_constfld'     , 
  'flx_cexpr'        ,
  'flx_csubst'       , 
  'flx_macro'        , 
  'flx_parse'        ,
  'flx_keywords'     ,
  'flx_prelex'       ,
  'flx_lex1'         ,
  'flx_tok'          ,
  'flx_lexstate'     ,
  'flx_preproc'      ,
  'flx_lex'          ,
  'flx_pretok'       ,
  'flx_parse_ctrl'   ,
  'flx_dfa'          ,
  'flx_pat'          , 
  'flx_desugar'      , 
  'flx_mbind'        , 
  'flx_symtab'       , 
  'flx_name'         , 
  'flx_treg'         ,
  'flx_beta'         ,
  'flx_tpat'         , 
  'flx_tconstraint'  ,
  'flx_generic'      , 
  'flx_overload'     , 
  'flx_lookup'       , 
  'flx_bexe'         , 
  'flx_bbind'        , 
  'flx_label'        , 
  'flx_cflow'        , 
  'flx_call'         , 
  'flx_use'          , 
  'flx_child'        , 
  'flx_tailit'       , 
  'flx_inline'       , 
  'flx_stack_calls'  , 
  'flx_mkcls'        , 
  'flx_global'       , 
  'flx_inst'         , 
  'flx_tgen'         , 
  'flx_display'      , 
  'flx_ogen'         , 
  'flx_regen'        ,
  'flx_unravel'      , 
  'flx_pgen'         , 
  'flx_egen'         , 
  'flx_ctorgen'      , 
  'flx_elkgen'       , 
  'flx_gen'          , 
  'flx_flxopt'       , 
  'flx_terminate'    , 
]

OCS_MODULES = [
  'ocs_vartable', 
  'ocs_error', 
  'ocs_port', 
  'ocs_types', 
  'ocs_sym', 
  'ocs_env',
  'ocs_char', 
  'ocs_numaux', 
  'ocs_complex', 
  'ocs_num', 
  'ocs_numstr', 
  'ocs_lex',
  'ocs_misc',
  'ocs_read', 
  'ocs_eval', 
  'ocs_list', 
  'ocs_compile', 
  'ocs_macro', 
  'ocs_prim', 
  'ocs_string',
  'ocs_vector', 
  'ocs_print', 
  'ocs_io', 
  'ocs_contin', 
  'ocs_top', 
]

CIL_RAW_INTERFACES = [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
]

FLX_RAW_INTERFACES = [
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
] 

MISC_INTERFACES = MISC_MODULES
FLX_INTERFACES = FLX_MODULES
CIL_INTERFACES = CIL_MODULES

MISC_IMPLEMENTATIONS = MISC_INTERFACES
FLX_IMPLEMENTATIONS = FLX_INTERFACES
CIL_IMPLEMENTATIONS = CIL_INTERFACES
  
IMPLEMENTATIONS =  MISC_IMPLEMENTATIONS + CIL_IMPLEMENTATIONS + FLX_IMPLEMENTATIONS 
  
INTERFACES = MISC_INTERFACES + CIL_INTERFACES + FLX_INTERFACES
RAW_INTERFACES = CIL_RAW_INTERFACES + FLX_RAW_INTERFACES

RTL_CPPS = [
  "rtl/flx_gc",
  "rtl/flx_collector",
  "rtl/flx_rtl",
  "rtl/flx_dynlink",
  "rtl/flx_i18n",
  "rtl/flx_ioutil",
]

DRIVERS = [
  ('rtl/flx_run','bin/flx_run'),
  ('test/flx_perf_drv1','test/flx_perf_drv1'),
  ('rtl/flx_stdin_drv','bin/flx_stdin_drv'),
  ('test/micky_mouse','bin/micky_mouse'),
]

# C files that we need to compile, with options required to build them
COBJECTS = {
}
# *.so/.a libraries
CLIBRARIES = ['nums']

# *.cmxa or .cma libraries
# and some hackery so we can if the source doesn't need
# ocaml-fileutils we can still build if it isn't found
OCAML_INCLUDES = ""
OLIBRARIES = [
  'nums',
  'unix',
  'misclib',
  'cillib',
  'flxlib']

OCAMLLIBS = [
  ('misclib',MISC_IMPLEMENTATIONS),
  ('cillib',CIL_IMPLEMENTATIONS),
  ('flxlib',FLX_IMPLEMENTATIONS),
]

# target executable programs to produce
MISC_EXES=[]
FLX_EXES = [
  'flxl',
  'flxp',
  'flxm',
  'flxd',
  'flxb',
  'flxg',
  'stub',
]

CIL_EXES = [ 
  'flxcc',
]

EXES = MISC_EXES + CIL_EXES + FLX_EXES

if 0:
  s = ' -cclib "-Lsrc '
  for library in CLIBRARIES:
    s = s + ' -l'+library
  s = s + '"'
  LDFLAGS = s
  del s
else:
  LDFLAGS = ""

if 1:
  o = ''
  for object in COBJECTS.keys():
    o = o + ' src/' + object + '.o'
  OBJECT_FILES = o
  del o

TESTS= USER_TESTS
BAD_TESTS = []

SPECIAL_TESTS = [
  ('bin'+os.sep+'flx_run','test'+os.sep+'flx_run_lib1.flx',''),
  ('test'+os.sep+'flx_perf_drv1','test'+os.sep+'flx_perf_lib1.flx','1000'),
  ('bin'+os.sep+'flx_stdin_drv','test'+os.sep+'flx_stdin_lib1.flx','<Makefile >tmp.tmp'),
]

# -------------------------------------------------
# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------


# ----------- Here begins the actual build procedure ---------------------

buildall = "clean" in options or "force" in options
stop_on_error = "stop_on_error" in options
import glob

def copy_mli2ml():
  for f in RAW_INTERFACES:
    if filetime("src"+os.sep+f+".mli") > filetime("src"+os.sep+f+".ml"):
      filecopy("src"+os.sep+f+".mli","src"+os.sep+f+".ml")

def copy_elk2rtl():
  for f in ELKRTL_INTERFACES:
    if filetime("elk"+os.sep+f) > filetime("rtl"+os.sep+f):
      filecopy("elk"+os.sep+f,"rtl"+os.sep+f)

def ocamlit(LEXS,PARSES,INTERFACES,IMPLEMENTATIONS,EXES):
  global buildall
  # STEP 2: Generate lexers
  for lex in LEXS:
    file = 'src'+os.sep+lex
    if buildall or filetime(file + '.mll') > filetime(file +'.ml'):
      buildall = 1
      xqt(OCAMLLEX + file + '.mll')

  # STEP 3: Generate parsers
  for parse in PARSES:
    file = 'src'+os.sep+parse
    if buildall or filetime(file + '.mly') > filetime(file +'.ml'):
      buildall = 1
      xqt(OCAMLYACC+ ' -v '+ file + '.mly')
      nxqt(GREP+"conflict " + file + ".output")

  # STEP 4: Compile ocaml interfaces
  for interface in INTERFACES:
    file = 'src'+os.sep+interface
    if buildall or filetime(file + '.mli') > filetime(file+'.cmi'):
      buildall = 1
      xqt(OCAMLC + ' ' + OCAML_INCLUDES+' -c '+file+ '.mli')

  # STEP 5: Compile ocaml implementations
  for implementation in IMPLEMENTATIONS + EXES:
    file = 'src'+os.sep+implementation
    if buildall or filetime(file+ '.ml') > filetime(file+OCAML_OBJECT_EXTENSION):
      buildall = 1
      xqt(OCAMLOPT + ' '+ OCAML_INCLUDES+ ' -c ' + file +'.ml')


try:
  # STEP 0: run interscript
  if "doc" in options:
    print "GENERATING DOCUMENTATION"
    runISCR('lpsrc/flx_config.pak')
    runISCR('lpsrc/flx.pak')
    copy_mli2ml()
    runISCR('--language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+WEAVER_DIRECTORY+' lpsrc/flx.pak')
  if "tutdoc" in options:
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tutorial.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_macro.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_bind.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' lpsrc/flx_tut_migrate.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --passes=2 --weaver-directory=speed/ lpsrc/flx_perf.pak')
    filecopy('doc'+os.sep+'interscript.css','speed'+os.sep+'interscript.css')
  if "extract" in options:
    packages = [
      'flx','sm','ast','elk','flx_perf','flx_tutorial','flx_tut_macro',
      'flx_tut_bind','flx_tut_migrate','flx_config'
      ]
    print "EXTRATING SOURCES"
    args = ""
    for p in packages:
      args = args + " lpsrc/"+p+".pak"
    runISCR(args)
    copy_mli2ml()
    copy_elk2rtl()
    filecopy('doc'+os.sep+'interscript.css','speed'+os.sep+'interscript.css')
  erasefile('tmp.tmp')

  if "man" in options:
    print "GENERATING MAN PAGES"
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = string.split(file,".")[0]
        xqt(
          "man2html man/man1/" + file + 
          '| sed -e "s%<A HREF=\\"[^<]*cgi-bin/man/man2html?1+\(.*\)\\">%<A HREF=\\"\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "htmlman/" + basename+'_1.html'
        )
    except:pass
  
  if "impldoc" in options:
    print "GENERATING OCAMLDOCS"
    erasedir('impldoc')
    os.mkdir('impldoc')
    try:
      xqt('ocamldoc -I src -d impldoc src/*.mli -html')
      xqt('ocamldoc -I src -o impldoc/flx_impl.tex src/*.mli -latex')
      xqt('(cd impldoc; latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex)')
    except: 
     pass # well ocamldoc is full of bugs ..

  if "regression" in options:
    TESTS = TESTS + glob.glob('test'+os.sep+'rt*.flx')
    if LINK_MODEL == "dynamic":
      TESTS = TESTS + glob.glob('test'+os.sep+'drt*.flx')

    BAD_TESTS = glob.glob('test'+os.sep+'bt*.flx')

  if "tutorial" in options:
    TESTS = TESTS + glob.glob('tut'+os.sep+'examples'+os.sep+'tut*.flx')
    TESTS = TESTS + glob.glob('tut'+os.sep+'examples'+os.sep+'mac*.flx')
    TESTS = TESTS + glob.glob('tut'+os.sep+'examples'+os.sep+'mig*.flx')

  BAGLEY = []
  if "bagley" in options:
    BAGLEY = glob.glob('bagley'+os.sep+'felix'+os.sep+'bag*.flx')

  TESTS.sort()
  BAD_TESTS.sort()
  BAGLEY.sort()

  if "compiler" in options or "olink" in options:
    # STEP 1: Compile all compiler support C files
    #for cobject in COBJECTS.keys():
    #  flags = COBJECTS[cobject]
    #  file = 'src/'+cobject
    #  if buildall or filetime(file +".c") > filetime(file +".o"):
    #    xqt(CCOMPILE +" -I "+OCAML_INCLUDE_DIRECTORY+" -Irtl "+flags+" "+file+".c")

    print "COMPILING MISC"
    ocamlit(MISC_LEXS,MISC_PARSES,MISC_INTERFACES,MISC_IMPLEMENTATIONS,MISC_EXES)
    if buildall or "felix" in options:
      print "COMPILING FELIX"
      ocamlit(FLX_LEXS,FLX_PARSES,FLX_INTERFACES,FLX_IMPLEMENTATIONS,FLX_EXES)
    if buildall or "flxcc" in options:
      print "COMPILING FLXCC"
      ocamlit(CIL_LEXS,CIL_PARSES,CIL_INTERFACES,CIL_IMPLEMENTATIONS,CIL_EXES)

    # STEP 6: Build FELIX Library
    if "olink" in options: buildall = 1
    for lib,IMPLEMENTATIONS in OCAMLLIBS:
      print "CREATING LIBRARY ",lib
      object_library_name = "src" + os.sep + lib + OCAML_LIB_EXTENSION
      linkstring = OCAMLOPT + " -a -o " + object_library_name + " "
      library_filetime = filetime(object_library_name)
      for implementation in IMPLEMENTATIONS:
        file = 'src' + os.sep +implementation
        if buildall or filetime(file+OCAML_OBJECT_EXTENSION) > library_filetime:
          for implementation in IMPLEMENTATIONS:
            file = 'src'+os.sep+implementation
            linkstring = linkstring + file +OCAML_OBJECT_EXTENSION +" "
          xqt(linkstring)
          buildall = 1
          break

    # STEP 8: Link executables
    print "LINKING EXECUTABLES"
    x = ''
    for library in OLIBRARIES:
      x = x + ' ' + library + OCAML_LIB_EXTENSION

    # finally, mainline *.cmx or cma files to link to executables
    for exe in EXES:
      if buildall or filetime(exe + OCAML_OBJECT_EXTENSION) > filetime(exe):
        xqt(OCAMLOPT + LDFLAGS + ' ' + OCAML_INCLUDES + ' -o bin'+os.sep+exe + x + OBJECT_FILES + ' src/flx_version_hook.ml ' + exe + OCAML_OBJECT_EXTENSION)

  # COMPILE RTL  
  if "rtl" in options:
    print "COMPILING RUN TIME LIBRARY COMPONENTS"
    if SUPPORT_DYNAMIC_LOADING:
      print " ++ DYNAMIC LINK VERSIONS"
      ars = ""

      # FELIX SUBLIBRARY
      print " .. FELIX RTL"
      for x in RTL_CPPS:
        if not "quiet" in options: print 'Compiling rtl object',x
        ars = ars + x + "_dynamic.o "
        dir,base = string.split(x,'/')
        TARGET_CXX.compile_shared_rtl(xqt,dir,base,dir,include_path=['rtl'],optimise=1,macros=["FLX_BUILD_DYNAMIC_RTL"])

      #ELKHOUND SUBLIBRARY
      print " .. ELKHOUND"
      for x in SMRTL+ELKRTL:
        if not "quiet" in options: print 'Compiling elkhound rtl object',x
        ars = ars + "rtl/" + x + "_dynamic.o "
        TARGET_CXX.compile_shared_rtl(xqt,"elk",x,"rtl",include_path=['rtl','elk'],optimise=1,macros=["FLX_BUILD_DYNAMIC_RTL"])

      # LINK RTL
      print " ** MAKING RTL (dynamic) "
      tmp = string.split(ars)
      objs=[]
      for i in tmp:
        objs.append(i[:-2]) # chop off the .o
      TARGET_CXX.link_shared_rtl(xqt,objs,SHLIB_DIR+os.sep+"libflx_dynamic")

    if SUPPORT_STATIC_LINKAGE:
      print " ++ STATIC LINK VERSIONS"
      ars = ""
      print " .. FELIX RTL"
      for x in RTL_CPPS:
        if not "quiet" in options: print 'Compiling rtl object',x
        ars = ars + x + "_static.o "
        dir,base = string.split(x,'/')
        TARGET_CXX.compile_static_rtl(xqt,dir,base,dir,include_path=['rtl'],macros=["FLX_STATIC_LINK"],optimise=1)

      print " .. ELKHOUND"
      for x in SMRTL+ELKRTL:
        if not "quiet" in options: print 'Compiling elkhound rtl object',x
        ars = ars + "rtl/" + x + "_static.o "
        TARGET_CXX.compile_static_rtl(xqt,"elk",x,"rtl",include_path=['rtl','elk'],optimise=1,macros=["FLX_STATIC_LINK"])

      print " ** MAKING RTL (static) "
      tmp = string.split(ars)
      objs=[]
      for i in tmp:
        objs.append(i[:-2]) # chop off the .o
      TARGET_CXX.link_static_archive(xqt,objs,"rtl/libflx_static")
  
  # elkhound executable: no need for dynamic loading, always built static
  if "elkhound" in options:
    print "COMPILING ELKHOUND"
    ars = ""
    for x in SMBASE + SMRTL + ASTGEN + ELKHOUND + ELKRTL:
      if not "quiet" in options: print 'Compiling elkhound object',x
      ars = ars + "elk/"+x + "_static.o "
      HOST_CXX.compile_static_rtl(xqt,"elk",x,"elk",include_path=["rtl","elk"],macros=["FLX_STATIC_LINK"])
    tmp = string.split(ars)
    objs=[]
    for i in tmp:
      objs.append(i[:-2]) # chop off the .o
    HOST_CXX.link_static_archive(xqt,objs,"elk/libelk_static")
    HOST_CXX.compile_static_main(xqt,"elk","elk_gramanl","elk",include_path=["rtl","elk"],macros=["FLX_STATIC_LINK"])
    HOST_CXX.link_static_program(xqt,["elk/elk_gramanl_static"],"bin/flx_elkhound",lib_path=["elk"],libs=["elk_static"])
 
  # COMPILE DRIVER PROGRAMS
  if "drivers" in options:
    if SUPPORT_STATIC_LINKAGE:
      print "COMPILING DRIVERS (static)"
      for i,j in DRIVERS:
        if not "quiet" in options: print 'Compiling driver object',i
        d,b = string.split(i,'/')
        TARGET_CXX.compile_static_main(xqt,d,b,d,include_path=["rtl"],macros=["FLX_STATIC_LINK"],optimise=1)

    if SUPPORT_DYNAMIC_LOADING:
      print "COMPILING DRIVERS (dynamic)"
      for i,j in DRIVERS:
        if not "quiet" in options: print 'Compiling driver object',i
        d,b = string.split(i,'/')
        TARGET_CXX.compile_shared_main(xqt,d,b,d,include_path=["rtl"],optimise=1)

        #if CYGWIN:
        #  #xqt("g++ -o "+j+" -Wl,--enable-auto-import " + i + "_dynamic.o -Lrtl -lflx_dynamic")
        #  #JMS: seems to be same now, except for order
        #  xqt(CCLINK_DLMAIN+" -o "+j+" " + i + "_dynamic.o -Lrtl -lflx_dynamic")
        #elif MACOSX:
        #  #RF: os x likes the same order as cygwin
        #  xqt(CCLINK_DLMAIN+" -o "+j+" "+i+"_dynamic.o"+" -Lrtl -lflx_dynamic " )
        #else:
        TARGET_CXX.link_dynamic_program(xqt,[i+"_dynamic"],j,lib_path=[SHLIB_DIR],libs=["flx_dynamic"])

  # run tests
  try:
    results = []
    print "RUNNING TESTS"
    # GENERATE C++ FROM FELIX SOURCE
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)

    TX = TESTS+EXTRA+BAGLEY
    if len(TX)>0 or "regression" in options:
      print "TRANSLATING FELIX TEST CODE TO C++ "+FLXFLAGS
    if len(TX)>0:
      print " .. REGRESSION TESTS and TUTORIAL EXAMPLES"
    for testfile in TESTS+EXTRA+BAGLEY:
      #print 'Running Felix code generator on ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      if buildall or \
        filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
        filetime('bin'+os.sep+'flxg')> filetime(basename+'.cpp') or \
        filetime('lib'+os.sep+'std.flx') > filetime(basename+'.cpp'):
        try:
          flxg('-Ilib ' +FLXFLAGS + basename,basename)
          #print 'TESTFILE -- generated ',basename
          results.append(("flxg",basename,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',basename
          erasefile(basename+'.cpp')
          erasefile(basename+'.hpp')
          erasefile(basename+SHLX)
          if stop_on_error: raise MakeError
          results.append(("flxg",basename,'ERROR'))

    # FAILURE TESTS 
    if "regression" in options:
      print " .. ERROR HANDLING TESTS"
      for testfile in BAD_TESTS:
        #print 'Running Felix code generator on ',testfile
        basename = string.split(testfile,'.')[0]
        cppfilename = basename + ".cpp"
        if buildall or \
          filetime(basename+ '.flx') > filetime(basename+'.cpp') or \
          filetime('bin'+os.sep+'flxg')> filetime(basename+'.cpp') or \
          filetime('lib'+os.sep+'std.flx') > filetime(basename+'.cpp'):
          try:
            xqtq('bin'+os.sep+'flxg -e -Ilib ' + basename)
            #print 'TESTFILE -- failed as expected',basename
            results.append(("flxg",basename,'OK'))
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
          except MakeError:
            print 'TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED!',basename
            erasefile(basename+'.cpp')
            erasefile(basename+'.hpp')
            erasefile(basename+SHLX)
            if stop_on_error: raise MakeError
            results.append(("flxg",basename,'ERROR'))

    # C++ COMPILE and static link tests
    # produces shared library or executable
    EXTRA = []
    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS: 
        EXTRA.append(testfile)
    TX = TESTS+EXTRA+BAGLEY
    if len(TX)>0:
      optimise= "optimise_c" in options
      mode = "std"
      if optimise: mode = "Optimised"
      print "COMPILING GENERATED C++ TEST CODE: " + mode+ " " + LINK_MODEL
      for testfile in TESTS+EXTRA+BAGLEY:
        #print 'Compiling generated code of ',testfile
        basename = string.split(testfile,'.')[0]
        path = string.split(basename,'/')
        indir = string.join(path[:-1],os.sep)
        infile= path[-1]
        cppfilename = basename + ".cpp"
        if buildall or filetime(basename+ '.cpp') > filetime(basename+SHLX):
          try:
            if LINK_MODEL == "dynamic":
              TARGET_CXX.compile_felix_dll(xqt,indir,infile,indir,include_path=["rtl"],optimise=optimise)
              TARGET_CXX.link_felix_dll(xqt,[basename+"_dynamic"],basename,lib_path=[SHLIB_DIR],libs=["flx_dynamic"])
            else: # static
              TARGET_CXX.compile_felix_static(xqt,indir,infile,indir,include_path=["rtl"],optimise=optimise,macros=["FLX_STATIC_LINK"])
              TARGET_CXX.link_static_program(xqt,["rtl/flx_run_static",basename+"_static"],basename,lib_path=["rtl"],libs=["flx_static"])
            #print 'TESTFILE -- OK!',basename
            results.append(("g++",basename,'OK'))
          except MakeError:
            print 'TESTFILE -- ERROR!',basename
            erasefile(basename+SHLX)
            if stop_on_error: raise MakeError
            results.append(("g++",basename,'ERROR'))


    # run the tests
    if len(TESTS)>0:
      print "RUNNING TESTS"
      for testfile in TESTS:
        basename = string.split(testfile,'.')[0]
        if LINK_MODEL == "dynamic":
            testscript = "bin"+os.sep+"flx_run ./"+basename+SHLX
        else:
          testscript = basename+SHLX

        if "log_output" in options:
          testscript = testscript + " >" + basename + ".output"

        elif "time_execution" in options:
          testscript = "time " + testscript 

        elif "check_output" in options:
          testscript = testscript + " >" + basename + ".output"
          testscript = testscript + " && "+DIFF+ basename + ".expect "+ basename + ".output"

        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append(("Exec",testscript,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append(("Exec",testscript,'ERROR'))
      
      if os.name != 'nt': # requires posix
        if "test" in options or "tutorial" in options or "fcount" in options:
          tkind = "std"
          if "inline" in options: tkind="inline"
          elif "noinline" in options: tkind="noinline"
          stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "tut/examples/*.hpp"'
          run(stats)
          stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "test/*.hpp"'
          run(stats)
      
        if "pfcount" in options:
          stats = 'python script/pfcount.py misc/fcounts.stats'
          run(stats)

        if "pfcount_all" in options:
          stats = 'python script/pfcount.py misc/fcounts.stats all'
          run(stats)

    if "performance" in options:
      for driver,testfile,moreargs in SPECIAL_TESTS:
        test_basename = string.split(testfile,'.')[0]
        drv_basename = string.split(driver,'.')[0]
        if LINK_MODEL == "dynamic":
          testscript = "time ./"+drv_basename+ " ./"+test_basename+SHLX+" " + moreargs
        else:
          testscript = "time ./"+test_basename+SHLX+" " + moreargs
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
          results.append(("Exec Special",testscript,'OK'))
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          if stop_on_error: raise MakeError
          results.append(("Exec Special",testscript,'ERROR'))

    if "speed" in options:
      runISCR('lpsrc/flx_perf.pak')
      run("python speed/measure.py")
      run("python speed/panal.py")
      run("gnuplot speed/mkjpgs.gpl")
      runISCR('--inhibit-sref=1 --language=en --weaver=web --passes=2 --weaver-directory=speed/ lpsrc/flx_perf.pak')

    print "RUN COMPLETE"
  finally:
    # REPORT FINAL RESULTS
    print
    print '**********************************'
    #print 'final results'
    total = 0
    bad = 0
    for x,y,z in results: 
      total = total + 1
      if "OK" == z: pass
      else:
        bad = bad + 1
        print x,y,z
    if total <> 0:
      if bad == 0: 
        print "ALL",total,"PASSED"
      else:
        print "Bad",bad,"/",total
    print '**********************************'

except MakeError:
  print "Terminating due to error"
  sys.exit(1)

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('CONFIG_ARGS=')
@tangle('PREFIX='+PREFIX)
@tangle('LIB_DIR=${PREFIX}/lib')
@tangle('SHLIB_DIR=${PREFIX}/'+SHLIB_DIR)
@tangle('SHINC_DIR=${PREFIX}/include')
@tangle('INSTALL_DIR=${PREFIX}/lib/felix')
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('BUILTIN_ISCR=python -O interscript/bin/iscr.py --nocache')
@tangle('')
@tangle('all: dummy')
@tangle('\tpython script/maker extract compiler rtl elkhound drivers optimise_c')
@tangle('\t#make tools libdoc')
@tangle('\tpython script/maker clean test log_output stop_on_error check_output')
@tangle('\tpython script/maker clean test static log_output stop_on_error check_output')
@tangle('\tpython script/maker clean test optimise_c inline log_output stop_on_error check_output')
@tangle('\tpython script/maker clean test optimise_c inline static log_output stop_on_error check_output')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')

@tangle('all.quiet: dummy')
@tangle('\tpython script/maker quiet extract compiler rtl elkhound drivers test log_output stop_on_error check_output optimise_c')
@tangle('\tmake tools libdoc')
@tangle('')

@tangle('profile: dummy')
@tangle('\tpython script/maker compiler profile')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\tpython script/maker compiler bytecode')
@tangle('')
@tangle('bytecode.profile: dummy')
@tangle('\tpython script/maker compiler bytecode profile')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\tpython script/maker compiler bytecode debug')
@tangle('')
@tangle('extract_compiler: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx.pak')
@tangle('\tpython script/maker compiler')
@tangle('')
@tangle('extract: dummy')
@tangle('\tpython script/maker extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\tpython script/maker extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\tpython script/maker tutorial')
@tangle('')
@tangle('grammar: dummy')
@tangle('\tenv PYTHONPATH=. python script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar')
@tangle('\tenv PYTHONPATH=. python script/get_grammar src/flx_cil_cparser.mly >misc/flx_cil_cparser.grammar')
#@tangle('\tenv PYTHONPATH=. python script/elk_flx_grgen misc/flx_parse.grammar >misc/elk_flx_gr.gr')
@tangle('\tenv PYTHONPATH=. python script/flx_flx_grgen misc/flx_parse.grammar >lib/flx_grammar.flx')
#@tangle('\tenv PYTHONPATH=. python script/elk_flx_lexgen misc/flx_parse.grammar >misc/elk_flx_lex.cc')
@tangle('\tenv PYTHONPATH=. python script/flx_tokgen misc/flx_parse.grammar >lib/flx_token.flx')
@tangle('')
@tangle('compiler: dummy')
@tangle('\tpython script/maker compiler')
@tangle('')
@tangle('tools: grammar tools/lua_parser')
@tangle('')
@tangle('#tools: grammar bin/flx_doc tools/lua_parser')
@tangle('')
@tangle('tools/lua_parser: tools/lua_parser.flx')
@tangle('\tbin/flx --test --static -c tools/lua_parser')
@tangle('')
@tangle('bin/flx_doc: tools/flx_doc.flx')
@tangle('\tbin/flx --test --static -c tools/flx_doc && mv tools/flx_doc bin/flx_doc')
@tangle('')
@tangle('doc: grammar tools man impldoc tutdoc tutstyle')
@tangle('')
@tangle('#doc: grammar tools libdoc man impldoc tutdoc tutstyle')
@tangle('')
@tangle('impldoc: dummy')
@tangle('\tpython script/maker impldoc')
@tangle('')
@tangle('tutdoc: dummy')
@tangle('\tpython script/maker doc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('doc.quiet: grammar tools libdoc')
@tangle('\tpython script/maker quiet doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('libdoc: grammar tools')
@tangle('\tbin/flx_doc --outdir=libdoc \\')
@tangle('\tlib/std.flx lib/stl.flx lib/flx_lex.flx \\')
@tangle('\tlib/flx_token.flx lib/flx_grammar.flx lib/lua.flx lib/lua_parse.flx')
@tangle('\tcp misc/flxdoc_style.css libdoc')
@tangle('')
@tangle('man: dummy')
@tangle('\tpython script/maker man')
@tangle('')
@tangle('test: dummy')
@tangle('\tpython script/maker test stop_on_error check_output')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('test.static: dummy')
@tangle('\tpython script/maker test static stop_on_error')
@tangle('')
@tangle('test.flx_ptf_static_pointer: dummy')
@tangle('\tpython script/maker test -DFLX_PTF_STATIC_POINTER stop_on_error')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\tpython script/maker inline test stop_on_error')
@tangle('')
@tangle('test.inline.static: dummy')
@tangle('\tpython script/maker inline test static stop_on_error')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\tpython script/maker debug test stop_on_error')
@tangle('')
@tangle('test.lua_parser: dummy')
@tangle('\tfor i in misc/lua/*.lua; do tools/lua_parser $$i; done;')
@tangle('')
@tangle('tests: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('\tmake tests.bagley')
@tangle('\tmake test.lua_parser')
@tangle('')
@tangle('tests.verify: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\tpython script/maker test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\tpython script/maker inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\tpython script/maker performance')
@tangle('')
@tangle('performance: tests.performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\tpython script/maker regression')
@tangle('')
@tangle('tests.bagley: dummy')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('speed: dummy')
@tangle('\tpython script/maker speed')
@tangle('')
@tangle('pfcount.all:')
@tangle('\tpython script/maker pfcount_all')
@tangle('')
@tangle('pfcount:')
@tangle('\tpython script/maker pfcount')
@tangle('')
@tangle('rtl.debug: dummy')
@tangle('\tpython script/maker rtl debug')
@tangle('')
@tangle('rtl: dummy')
@tangle('\tpython script/maker rtl')
@tangle('')
@tangle('rtl.optimise: dummy')
@tangle('\tpython script/maker rtl optimise_c')
@tangle('')
@tangle('elkhound: dummy')
@tangle('\tpython script/maker elkhound')
@tangle('')
@tangle('expect.bagley: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tenv PYTHONPATH=. python script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('expect: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tpython script/maker test log_output')
@tangle('\tenv PYTHONPATH=. python script/mk_expect tut/examples > lpsrc/flx_tut_expect.ipk')
@tangle('\tenv PYTHONPATH=. python script/mk_expect test > lpsrc/flx_test_expect.ipk')
@tangle('\tenv PYTHONPATH=. python script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('drivers: dummy')
@tangle('\tpython script/maker drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('\tpython script/maker drivers debug')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.08.1 or better')
@tangle('\t#REQUIRES g++ 3.xx or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required priviledges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')

@tangle('src_tarball: extract ')
@tangle('\trm -f felix-'+flx_version)
@tangle('\tln -s . felix-'+flx_version)
@tangle('\ttar -cvf flx_'+flx_version+'_src.tar\\')
@tangle('\t\tfelix-'+flx_version+'/configure \\')
@tangle('\t\tfelix-'+flx_version+'/win32env.bat \\')
@tangle('\t\tfelix-'+flx_version+'/win32iscr.bat \\')
@tangle('\t\tfelix-'+flx_version+'/win32make.bat \\')
@tangle('\t\tfelix-'+flx_version+'/win32config.bat \\')
@tangle('\t\tfelix-'+flx_version+'/Makefile \\')
@tangle('\t\tfelix-'+flx_version+'/README \\')
@tangle('\t\tfelix-'+flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+flx_version+'/COPYING \\')
@tangle('\t\tfelix-'+flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/weavers/*.py ')
@# debian requires gzip -9
@tangle('\tgzip -9 flx_'+flx_version+'_src.tar')
@tangle('\tmv -f flx_'+flx_version+'_src.tar.gz flx_'+flx_version+'_src.tgz')
@tangle('')
@tangle('bin_tarball:')
@tangle('\trm -f felix-'+flx_version)
@tangle('\tln -s . felix-'+flx_version)
@tangle('\ttar -zcvf flx_'+flx_version+'_bin_linux.tgz\\')
@tangle('\t\tfelix-'+flx_version+'/configure\\')
@tangle('\t\tfelix-'+flx_version+'/Makefile\\')
@tangle('\t\tfelix-'+flx_version+'/README \\')
@tangle('\t\tfelix-'+flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+flx_version+'/COPYING\\')
@tangle('\t\tfelix-'+flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+flx_version+'/script/maker \\')
@tangle('\t\tfelix-'+flx_version+'/script/*\\')
@tangle('\t\tfelix-'+flx_version+'/src/*.ml \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mli \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mly \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mll \\')
@tangle('\t\tfelix-'+flx_version+'/tools/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/rtl/*.cpp\\')
@tangle('\t\tfelix-'+flx_version+'/rtl/*.hpp\\')
@tangle('\t\tfelix-'+flx_version+'/libdoc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/lib/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.cpp \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.expect \\')
@tangle('\t\tfelix-'+flx_version+'/tut/examples/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/tut/examples/*.expect \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.tex \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.tex \\')
@tangle('\t\tfelix-'+flx_version+'/licences/*.txt \\')
@tangle('\t\tfelix-'+flx_version+'/misc/* \\')
@tangle('\t\tfelix-'+flx_version+'/htmlman/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/man/man1/*.1 \\')
@tangle('\t\tfelix-'+flx_version+'/impldoc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/www/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/bin/flx \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.gpl \\')
@tangle('\t\tfelix-'+flx_version+'/speed/images/rosella/*.jpg \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('tarball: src_tarball bin_tarball')
@tangle('')
@tangle('debian/rules: lpsrc/flx_debian.pak lpsrc/flx_maker.ipk')
@tangle('\trm -rf debian')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_debian.pak')
@tangle('\tchmod u+x debian/rules')
@tangle('')
@tangle('debian-package: debian/rules')
@tangle('\t(cd .. && make -f flx/Makefile.debian_package_creator package)')
@tangle('')
@tangle('www: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_sourceforge.pak')
@tangle('')
@tangle('clean: dummy')
@tangle('\trm -rf tut/examples/*.cpp tut/examples/*.hpp tut/examples/*.so tut/examples/*.dll tut/examples/*.par tut/examples/*.o tut/examples/*.output')
@tangle('\trm -rf test/*.cpp test/*.hpp test/*.so test/*.dll test/*.par test/*.o test/*.output')
@tangle('\trm -rf bagley/felix/*.cpp bagley/felix/*.hpp bagley/felix/*.so bagley/felix/*.dll bagley/felix/*.par bagley/felix/*.o')
@tangle('\trm -rf speed/exes/*')
@tangle('')
@tangle('distclean:')
@tangle('\trm -rf tut rtl test www src misc man bin doc lib impldoc htmlman tmp tmp.tmp')
@tangle('\trm -rf elk')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('\trm -rf bagley')
@tangle('\trm -rf doc_out libdoc tools')
@tangle('\trm -rf meta licences')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -rf interscript/*/*.pyo')
@tangle('\trm -rf interscript/*/*/*.pyo')
@tangle('\trm -rf speed/')
@tangle('')
@tangle('virgin: distclean')
@tangle('\tcp Makefile Makefile.old')
@tangle('\trm -rf script/')
@tangle('\trm -rf debian/')
@tangle('\trm -f README LICENCE VERSION CONTENTS INSTALL AUTHORS NEWS COPYING ChangeLog')
@tangle('')

@tangle('backup: dummy')
@tangle('\t(DATE=`date -I`;\\')
@tangle('\tmkdir -p "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.ipk "lpbackup/$${DATE}";\\')
@tangle('\tcp lpsrc/*.pak "lpbackup/$${DATE}";\\')
@tangle('\tcp homepage/*.html "lpbackup/$${DATE}"\\')
@tangle('\t)')
@tangle('')

@tangle('config: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_config.pak')
@tangle('\tenv PYTHONPATH=. python -O script/make_config.py --quiet --prefix=${PREFIX} ${CONFIG_ARGS}')
@tangle('')
@tangle('config/config.py: config')
@tangle('')
@tangle('boot: config/config.py')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx.pak')
@for i in [
  'flx_cil_machdep_type',
  'flx_cil_cabs',
  'flx_ast'          ,
  'flx_types'        ,
  'flx_ctypes'       ,
  ]:
  tangle('\tcp src/'+i+'.mli src/'+i+'.ml')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tfor i in tmp/*.default; do cp $$i config/`basename $$i .default`; done')
@tangle('')
@tangle('wrappers.clean:')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('')
@tangle('config/cxx.flxcc: default_wrappers')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/c89.flxcc')
@tangle('\tbin/flxcc config/c99.flxcc')
@tangle('\tbin/flxcc config/gnu89.flxcc')
@tangle('\tbin/flxcc config/gnu99.flxcc')
@tangle('\tbin/flxcc config/cxx.flxcc')
@tangle('\tbin/flxcc config/cxx_sys.flxcc')
@tangle('\tbin/flxcc config/gnucxx.flxcc')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\t#"INSTALL_DIR=${INSTALL_DIR}"')
@tangle('\t#"EXEC_DIR=${EXEC_DIR}"')
@tangle('\t#"MAN_DIR=${MAN_DIR}"')
@tangle('\t#"SHLIB_DIR=${SHLIB_DIR}"')
@tangle('\t#"LIB_DIR=${LIB_DIR}"')
@tangle('\t#"SHINC_DIR=${SHINC_DIR}"')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${SHLIB_DIR}')
@tangle('\tinstall -d ${LIB_DIR}')
@tangle('\tinstall -d ${SHINC_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/config')
@tangle('\tinstall -d ${INSTALL_DIR}/doc')
@tangle('\tinstall -d ${INSTALL_DIR}/htmlman')
@tangle('\tinstall config/*.py ${INSTALL_DIR}/config')
@tangle('\tinstall config/*.flxcc ${INSTALL_DIR}/config')
@tangle('\tinstall lib/* ${INSTALL_DIR}/lib')
@tangle('\tinstall rtl/*.hpp ${SHINC_DIR}')
@tangle('\tinstall rtl/* ${INSTALL_DIR}/rtl')
@if SUPPORT_STATIC_LINKAGE:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_static.a')
  tangle('\tinstall rtl/libflx_static.a ${LIB_DIR}')
  tangle('\t'+RANLIB+' ${LIB_DIR}/libflx_static.a')
@if SUPPORT_DYNAMIC_LOADING:
  if CYGWIN:
    # static link thunk for bin/cygflx_dynamic.dll
    #tangle('\tinstall rtl/libflx_dynamic.dll.a ${SHLIB_DIR}')
    # not used now, dll goes in 'bin'
    pass
  else:
    tangle('\tinstall rtl/libflx_dynamic.so.'+flx_version+' ${SHLIB_DIR}')
    tangle('\tinstall rtl/libflx_dynamic.so.'+flx_version_major+' ${SHLIB_DIR}')
    tangle('\tinstall rtl/libflx_dynamic.so ${SHLIB_DIR}')
@tangle('\t(install doc/* ${INSTALL_DIR}/doc || exit 0) > /dev/null 2>&1')
@tangle('\t(install impldoc/* ${INSTALL_DIR}/impldoc || exit 0) > /dev/null 2>&1')
@tangle('\t(install htmlman/* ${INSTALL_DIR}/htmlman || exit 0) > /dev/null 2>&1')
@tangle('\tinstall bin/* ${EXEC_DIR}')
@tangle('\t(install man/man1/* ${MAN_DIR}/man1 || exit 0) > /dev/null 2>&1')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = string.replace(FLX_MAKER_CVS_ID,"$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle("# These targets are for SKALLER only")
@tangle("# they're used to upload stuff to sourceforge")
@tangle('upload_images:')
@tangle('\tscp homepage/images/*.jpg skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/images')
@tangle('')
@tangle('upload_homepage: dummy')
@tangle('\tscp homepage/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('upload_www: upload_homepage')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/current/www')
@tangle('')
@tangle('upload_src: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('upload_speed: dummy')
@tangle('\tscp -r speed/*.html speed/images skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/current/speed')
@tangle('')
@tangle('upload: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('\tscp flx_'+flx_version+'_bin_linux.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')

@head(1,'configure')
A shell script to run the config step.
@select(tangler('configure'))
export PYTHONPATH=.:$PYTHONPATH
echo "Configuring Felix"
grab=1

PREFIX=$PREFIX
ARGS=""

#while (( "$grab" == "1" ));	# not working under cygwin bash
while  [ "$grab" -eq 1 ]
do
  case x$1 in
  x--prefix=*)
     PREFIX="`echo \"$1\" | sed 's/--prefix=\(.*\)/\\1/'`"
     shift
  ;;

  x--prefix)
    shift
    PREFIX="$1"
    shift
  ;;

  x)
    grab=0
  ;;

  x*)
    ARGS="${ARGS} $1"
    shift
  ;;


  esac
done

echo "Installing at PREFIX=$PREFIX"
make PREFIX=$PREFIX CONFIG_ARGS="$ARGS" config &&\
make PREFIX=$PREFIX boot &&\
make grammar &&\
make extract

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues Cassé

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors. The C parser is derived from
FrontC/CIL which is has BSD licence.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something .. 

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something .. 


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENCE   licence details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary
 
  Makefile   the makefile, mainly hooks into script/maker
 
  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  meta   -- contains various package manager meta-data files
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENCE')
@select(tangler('LICENCE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file 


lpsrc/flx_frontc.ipk
lpsrc/flx_cil.ipk

are covered by a BSD Licence, here is the copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.08.1 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace
   
@tangle('   tar -zxvf flx_'+flx_version+'_src.tgz')
@tangle('   cd felix_'+flx_version)

4. Bootstrap the system.

  ./configure

OR type

   make config
   make boot
   make extract

EDIT THE FILES

  config/*.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make 

6. Build the documentation and tutorial

   make doc 

7. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak 
  
                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  include "std";
  print "It works!"; endl;

and then run it:
  
  flx -Ilib mytest

@head(1,'.cvsignore')
This is actually put in the lpsrc directory to tell
cvs to ignore certain files.
@select(tangler('lpsrc/.cvsignore','data'))
*.cache
*.swp


@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.

@select(tangler('doc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('doc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)


@head(1,"fishcc")
Script to compile a C program generated by FISh.
@select(tangler("bin/fishcc"))
grab=1
CCFLAGS=""
while (( "$grab" == "1" ));
do
  case x$1 in
  x-*)
    CCFLAGS="$CCFLAGS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done
@tangle('cmd="'+CCLINK_STATIC+' $1 -O -o `basename $1 .c` `echo "$CCFLAGS"` -lflx_static"')
echo $cmd
`$cmd`

@head(1,'Run script')
@select(tangler('bin/flx.bat','data'))
@@echo off
SETLOCAL
SET RUNIT=1
SET DOFLXG=1
SET DOECHO=0
SET FID=%FLX_INSTALL_DIR%
SET STATIC=0

:DOARGS
IF "-c" EQU "%1" (
SET RUNIT=0
SHIFT
GOTO DOARGS
)

IF "--nofelix" EQU "%1" (
SET DOFLXG=0
SHIFT
GOTO DOARGS
)

IF "--echo" EQU "%1" (
echo on
SET DOECHO=1
SHIFT
GOTO DOARGS
)

IF "--test" EQU "%1" (
SET FID=.
SHIFT
GOTO DOARGS
)

IF "--static" EQU "%1" (
SET STATIC=1
SHIFT
GOTO DOARGS
)

"%FID%\BIN\FLXG" -I"%FID%\LIB" %1 >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
if %STATIC% EQU 0 (
cl /nologo /MD /c /EHs /w  /I"%FID%\RTL" %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MT /LD %1.obj /Fe%1.dll /link /LIBPATH:"%FID%\BIN" /DEFAULTLIB:libflx_dynamic >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1.exp
del %1.lib
IF %RUNIT% EQU 1 (
"%FID%\bin\flx_run" %1 %2 %3 %4 %5 %6 %7 %8 %9  
)
) else (
cl /nologo /MT /c /EHs /w  /I"%FID%\RTL" /DFLX_STATIC_LINK %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MT "%FID%\rtl\flx_run_static.obj" %1.obj /Fe%1.exe /link /LIBPATH:"%FID%\RTL" /DEFAULTLIB:libflx_static >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%1 %2 %3 %4 %5 %6 %7 %8 %9
)
GOTO FINISHED
:ERROR
ECHO SOME KIND OF ERROR OCCURED, rerun with --echo
type %1.LOG
EXIT /B 1
:FINISHED
ENDLOCAL

@select(tangler('bin/flx','data'))
#!/usr/bin/env bash
# flx - felix script harness

@tangle("CYGWIN="+str(CYGWIN))
@tangle("WIN32="+str(WIN32))
@tangle("HAVE_GXX="+str(HAVE_GXX))
@tangle("HAVE_MSVC="+str(HAVE_MSVC))
@tangle('CCOBJ_DLLIB="'+CCOBJ_DYNAMIC_FLX+'"')
@tangle('CCLINK_DLLIB="'+CCLINK_DYNAMIC_FLX+'"')
@tangle('CCOBJ_STATIC_LIB="'+CCOBJ_STATIC_FLX+'"')
@tangle('CCLINK_STATIC="'+CCLINK_STATIC+'"')
@tangle('VERSION="'+flx_version+'"')
@tangle('EXT_LIB="'+EXT_LIB+'"')
@tangle('EXT_OBJ="'+EXT_OBJ+'"')
@tangle('EXT_EXE="'+EXT_EXE+'"')
@tangle('EXT_SHLIB="'+EXT_SHLIB+'"')
@tangle('SPEC_OBJ_FILENAME="'+SPEC_OBJ_FILENAME+'"')
@tangle('SPEC_EXE_FILENAME="'+SPEC_EXE_FILENAME+'"')
@tangle('OPTIMISE="'+OPTIMISE+'"')
@tangle('DEBUG_FLAGS="'+DEBUG_FLAGS+'"')
@if HAVE_MSVC:
  tangle("DYNLINK_STRING='/link /LIBPATH:bin /DEFAULTLIB:libflx_dynamic'")
 elif CYGWIN or WIN32:
  tangle("DYNLINK_STRING='-Lbin -lflx_dynamic'")
 else:
  tangle("DYNLINK_STRING='-Lrtl -lflx_dynamic'")

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=10
ECHO=0
TIME=0
@if DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""
FELIX=1
grab=1

INCLUDE_DIRS=""

while (( "$grab" == "1" ));
do
  case x$1 in
  x--test)
    TESTMODE=1
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    ECHO=1
    shift
  ;;

  x--time)
    TIME=1
    shift
  ;;

  x--echo)
    ECHO=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline=*)
    INLINE=${1:9}
    shift
  ;;

  x--inline)
    INLINE=50
    shift
  ;;

  x--noinline)
    INLINE=0
    shift
  ;;

  x--opt=1)
    INLINE=10
    CCFLAGS="-O1 $CCFLAGS"
    shift
  ;;

  x--opt=2)
    INLINE=20
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--opt=3)
    INLINE=50
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--optimise)
    INLINE=10
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--optimize)
    INLINE=10
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--help)
    man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x--nofelix)
    FELIX=0
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done

if [ "$TESTMODE" = "1" -a "$ECHO" = "1" ]
then
  echo "TESTMODE: running felix from current directory"
fi

# make a list of any *.cpp files (or other g++ options ..)

cpps=""
cppos=""
grab=1
pkgs=""
while (( "$grab" == "1" ));
do
  case "$1" in
    *.cpp)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .cpp`$EXT_OBJ"
      shift
    ;;

    *.cxx)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .cxx`$EXT_OBJ"
      shift
    ;;

    *.c)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .c`$EXT_OBJ"
      shift
    ;;

    *.o)
      cppos="$cppos `dirname $1`/`basename $1 .o`$EXT_OBJ"
      shift
    ;;

    *.obj)
      cppos="$cppos `dirname $1`/`basename $1 .obj`$EXT_OBJ"
      shift
    ;;

    *.a)
      cppos="$cppos $1"
      shift
    ;;

    *.lib)
      cppos="$cppos $1"
      shift
    ;;

    --pkg=*)
      pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
      shift
    ;;

# unknown flag .. pass to both compile and link
    -*)
      cpps="$cpps $1"
      cppos="$cppos $1"
      shift
    ;;

    *)
      grab=0
    ;;
  esac
done

if [ "x$pkgs" = "x" ]
then
  PKGS=""
else
  PKGS=`pkg-config --cflags --libs $pkgs`
fi

if [ "x$1" = "x" ]
then
  echo "usage: flx filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;

  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=$arg

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

if [ "$TESTMODE" = "1" ]
then
  INCLUDE_DIR="./rtl"
  FLXLIB="./lib"
  if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
  then
    # bash is a heap of crap! The escaped quotes here are
    # required in case the PATH has a filename with spaces
    # However this actually fails on Linux!
    FLXG="env \"PATH=./bin:\$PATH\" ./bin/flxg"
    FLXRUN="env \"PATH=./bin:\$PATH\" ./bin/flx_run"
  else
    FLXG="env PATH=./bin:\$PATH ./bin/flxg"
    FLXRUN="env LD_LIBRARY_PATH=./rtl:\$LD_LIBRARY_PATH ./bin/flx_run"
  fi
  FLXRTL="./rtl"
  FLXBIN="./bin"
  FLXAR="./rtl"
  if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
  then
    FLXSHLIB="./bin"
  else
    FLXSHLIB="./rtl"
  fi
else
  # Locate the felix installation
  prefix=""
  for dir in `echo "$PATH" | sed 's/:/ /g'`
  do
    dir=$dir
    if [ -x "$dir/flxg" ]
    then
      prefix="$dir/flxg"
      break
    fi
  done
  prefix="`echo $prefix | sed 's/\/bin\/flxg$//'`"
  INCLUDE_DIR="$prefix/lib/felix/rtl"
  FLXG="$prefix/bin/flxg"
  FLXRUN="$prefix/bin/flx_run"
  FLXLIB="$prefix/lib/felix/lib"
  FLXRTL="$prefix/lib/felix/lib"
  FLXBIN="$prefix/bin"
  FLXAR="$prefix/lib"
  if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
  then
    FLXSHLIB="$prefix/bin"
  else
    FLXSHLIB="$prefix/lib"
  fi
fi
if [ "$DEBUG" = "1" ]; then FLXRUN="$FLXRUN --debug"; fi
STATIC_ENV=""
if [ "$DEBUG" = "1" ]; then STATIC_ENV="env FLX_DEBUG=1 "; fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base$EXT_SHLIB" -a "(" ! -r "$base.flx" -o "$base$EXT_SHLIB" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      cmd="$FLXRUN $base$EXT_SHLIB $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
    fi
    exit $?
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base$EXT_EXE" -a "(" ! -r "$base.flx" -o "$base$EXT_EXE" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      cmd="$STATIC_ENV $base $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
    fi
    exit $?
  fi
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]
then
  VERBOSE="-v"
  CCFLAGS="$CCFLAGS$DEBUG_FLAGS"
else
  VERBOSE="-q"
fi

FLXFLAGS="--inline=$INLINE"

if [ $STATIC = 0 ]
then
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    CCMD="$CCOBJ_DLLIB $CCFLAGS -I$INCLUDE_DIR $INCLUDE_DIRS $PKGS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_DLLIB $CCFLAGS $PKGS $cppos $base$EXT_OBJ $SPEC_EXE_FILENAME$base$EXT_SHLIB $DYNLINK_STRING"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $FLXRUN $base$EXT_SHLIB $args"
          else
            cmd="$FLXRUN $base$EXT_SHLIB $args"
          fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
        exit $?
      else
        exit $?
      fi
    else
      exit $?
    fi
  fi
else
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS -I$FLXLIB $INCLUDE_DIRS $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    CCMD="$CCOBJ_STATIC_LIB $CCFLAGS -DFLX_STATIC_LINK -I$INCLUDE_DIR $INCLUDE_DIRS $PKGS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_STATIC $FLXRTL/flx_run_static$EXT_OBJ $PKGS $cppos $base$EXT_OBJ $FLXAR/libflx_static$EXT_LIB $SPEC_EXE_FILENAME$base$EXT_EXE"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        # rm -f "$base.cpp"
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $STATIC_ENV $base $args"
          else
            cmd="$STATIC_ENV $base $args"
          fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
        exit $?
      else
        exit $?
      fi
    else
      exit $?
    fi
  fi
fi

@head(1,'Package Manager Meta Info')
@head(2,'GODI')
This is the Godiva file originally used to
create the GODI data. At the moment this is
the authoritative meta data. However,
godiva may not handle all the options
we need -- so the generated makefile
is included as well.

@select(tangler('meta/godiva/flx.godiva','data'))
Package: apps-felix
@tangle('Version: '+flx_version)
Revision: 0
Depends:
Build-Depends: godi-ocaml (> 3.08) 
@tangle('Sources: http://felix.sf.net/flx_'+flx_version+'_src.tgz')
@tangle('Unpacks-To: flx_'+flx_version)
Bytecode-Target: all
Opt-Target: all
Homepage: http://felix.sf.net
Maintainer: John Skaller <skaller@users.sf.net>
Options: configure
Description: Felix Compiler
Felix Compiler
.

@select(tangler('meta/godiva/flx.godiva_camlsyntax','data'))
name = "felix";
@tangle('version = "'+flx_version+'";')
revision = 0;
category = `apps;
depends = [];
build_depends = [`godi,"ocaml", Some (`gt, "3.08")];
sources_site ="http://felix.sf.net/";
@tangle('sources_basename= "flx_'+flx_version+'_src";')
sources_extension = ".tgz";
@tangle('sources_unpacksto = "flx_'+flx_version+'";')
all_target= "all";
opt_target= "all";
homepage= "http://felix.sf.net";
maintainer = "John Skaller <skaller@users.sf.net>";
options= [`configure];
short_desc = "Felix Compiler";
long_desc = "Felix Compiler";
confopts = [
  { 
    name = "SUPPORT_DYNAMIC_LOADING";
    default = "1";
    description = "Whether to support dlopen loading";
    implementation = `configarg "--SUPPORT_DYNAMIC_LOADING"
  }
];
specfile = "meta/godiva/flx.godiva_camlsyntax";
patches = [];
filesdir = None;

@select(tangler('meta/godi/DESCR','data'))
Felix Compiler and tools.

@doc()
This makefile only here for reference (don't use it,
it should be generated).

@select(tangler('meta/godi/Makefile','data'))
# This file was automatically generated by GODIVA
.include "../../mk/bsd.prefs.mk"
.include "../../mk/godi.pkg.mk"

@tangle('VERSION=        '+flx_version)
PKGNAME=        apps-felix-${VERSION}
@tangle('PKGREVISION=    '+godi_revision) 
@tangle('DISTNAME=       flx_'+flx_version)
@tangle('DISTFILES=      flx_'+flx_version+'_src.tgz')
CATEGORIES=     apps
MASTER_SITES=   http://felix.sf.net/
MAINTAINER=     John Skaller <skaller@users.sf.net>
HOMEPAGE=       http://felix.sf.net
COMMENT=        Felix Compiler

# confopt defaults:


AUTOGENERATE_PLIST = yes
PKG  =          apps-felix
MAKE_FLAGS=     PREFIX=${PREFIX}  



PATH:=          ${LOCALBASE}/bin:"${PATH}"
HAS_CONFIGURE = yes
CONFIGURE_ARGS+= --prefix ${PREFIX}
CONFIGURE_ENV+= ${BUILD_OCAMLFIND_ENV}
USE_GMAKE = yes

MAKE_ENV+=  ${BUILD_OCAMLFIND_ENV} PKGBASE=${PKGBASE:Q}

pre-configure-copy:
.	if exists(files)
	    cd files && ${PAX} -rw -pp . ${WRKSRC}
.	endif

pre-configure: pre-configure-copy

pre-install-mkdirs:
.	for d in bin lib/ocaml/pkg-lib doc share man etc info sbin include
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/${d}
.	endfor
.	for n in 1 2 3 4 5 6 7 8 9
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/man/man${n}
.	endfor

pre-install: pre-install-mkdirs

ALL_TARGET=     all
.if ${GODI_HAVE_OCAMLOPT} == "yes"
# ALL_TARGET+= all
.endif

post-install:
	mkdir -p ${PREFIX}/doc/${PKG}
.	for DOC in 
	    install -m 0644 ${WRKSRC}/${DOC} ${PREFIX}/doc/${PKG}
.	endfor

.include "../../mk/bsd.pkg.mk"

@head(1,'Finish up')
Just cleaning up script now.
@try:
   os.system('chmod u+x configure')
   os.system('chmod u+x bin/flx')
   os.system('chmod u+x bin/fishcc')
 except:pass

for f in glob.glob('doc'+os.sep+'*.css'):
  filecopy2dir(f, 'tut'+os.sep+'doc')

