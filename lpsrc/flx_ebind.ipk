@head(1,"Name Binding: expressions")
Name binding, pass 1.

@h = tangler("src/flx_ebind.mli")
@select(h)
open Flx_types
val bind_expression :
  symbol_table_t ->
  bound_symbol_table_t ->
  env_t ->
  int list ->
  expr_t ->
  tbexpr_t

val typeofindex :
  symbol_table_t ->
  bound_symbol_table_t ->
  int list ->
  range_srcref ->
  int ->
  btypecode_t

val unify:
  symbol_table_t ->
  bound_symbol_table_t ->
  btypecode_t ->
  btypecode_t ->
  btypecode_t

@h = tangler("src/flx_ebind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_srcref
open Flx_overload
open Flx_lookup
open List
open Flx_srcref
open Flx_env

let rec cal_apply dfns tbe1 tbe2 : tbexpr_t =
  match tbe1,tbe2 with (_,t1),(_,t2) ->
  let rest =
    match t1 with
    | BTYP_function (argt,rest) ->
      if argt = t2 then rest
      else failwith "[ebind:cal_apply] Function argument doesn't agree with function type"

    (* HACKERY TO SUPPORT STRUCT CONSTRUCTORS *)
    | BTYP_name index -> 
      let _,_,_,entry = Hashtbl.find dfns index in
      begin match entry with
      | SYMDEF_dcl (DCL_struct cs) -> t1
      | _ -> 
        failwith 
        (
          "Attempt to apply non-struct " ^
          string_of_btypecode dfns t1 ^
          " as constructor"
        )
      end
    | _ -> 
      failwith 
      (
        "Attempt to apply non-function type " ^
        string_of_btypecode dfns t1
      )
  in
  (*
  print_endline 
  (
    "---------------------------------------" ^
    "\nApply type " ^ string_of_btypecode dfns t1 ^
    "\nto argument of type " ^ string_of_btypecode dfns t2 ^ 
    "\nresult type is " ^ string_of_btypecode dfns rest ^
    "\n-------------------------------------"
  );
  *)
  BEXPR_apply (tbe1, tbe2),rest

and unify dfns bdfns it mt = 
  let u it mt = unify dfns bdfns it mt in
  match it,mt with
  | BTYP_name index,t -> BTYP_binding (index,t)

  | BTYP_function (a,b), BTYP_function(c,d) ->
    BTYP_function (u a c, u b d)

  | BTYP_pointer a, BTYP_pointer b ->
    BTYP_pointer (u a b)

  | BTYP_tuple a, BTYP_tuple b ->
    BTYP_tuple (List.map2 u a b)

  | BTYP_void, BTYP_void -> BTYP_void
  | BTYP_none, BTYP_none -> BTYP_none
  | _ -> 
    failwith 
    (
      "Can't unify type " ^ 
      string_of_btypecode dfns it ^ 
      " with " ^
      string_of_btypecode dfns mt
    )
  
and koenig_lookup dfns bdfns sra exclude id' name_map fn t2 =
  let entries =  
    try Hashtbl.find name_map fn 
    with Not_found -> 
      failwith 
      (
        "Koenig lookup: can't find name "^
        fn^ " in " ^ 
        (match id' with 
        | "" -> "top level module"
        | _ -> "module '" ^ id' ^ "'"
        )
      )
  in 
  match entries with
  | FunctionEntry fs ->
    (* print_endline ("Got candidates: "); List.iter (fun x -> print_endline ("  " ^ string_of_int x)) fs ; *)
    begin match resolve_overload dfns fs fn t2 with
    | Some (Simple index'') ->
      (* print_endline "Overload resolution OK"; *)
      BEXPR_closure index'',
      (
        match 
          try typeofindex dfns bdfns exclude sra index'' 
          with _ -> failwith "typeofindex failed"
        with
        | BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[bind_expression]: Koenig lookup: closure operator expected '"^
            fn ^"' to be function definition, got '"^
            string_of_btypecode dfns t
            ^"', " ^ short_string_of_src sra
          )
      )
    | Some (Bound _ ) -> failwith "[koenig lookup] Can't handle bound result yet"
    | None ->
        let n = ref 0 
        in Hashtbl.iter (fun _ _ -> incr n) name_map; 
        print_endline ("module defines " ^ string_of_int !n^ " entries");
        failwith 
        (
          "[flx_ebind] Koenig lookup: Can't find match for " ^ fn ^ " in " ^
          short_string_of_src sra
        )
    end
  | NonFunctionEntry _ -> failwith "Koenig lookup expected function"

and bind_expression dfns bdfns env exclude e : tbexpr_t = 
  let be e = bind_expression dfns bdfns env exclude e in
  let lu sr qn = lookup_qn_in_env dfns env sr qn in
  let bt t = bind_type dfns env [] t in
  (*
  print_endline ("Binding expression " ^ string_of_expression e);
  *)
  match e with
  | AST_coercion (sr,(m,t)) -> 
    print_endline "Coercion!";
    let m' = be m in
    print_endline "Bound src module";
    let t' = bt t in
    print_endline "Bound src interface";
    BEXPR_coercion (m',t'),t'

  | AST_lazy _ -> assert false
  | AST_get_n (sr,(n,e')) -> 
    let expr,typ = be e' in
    let ctyp = match typ with 
    | BTYP_tuple ts -> 
      let len = List.length ts in
      if n<0 or n>len-1
      then failwith 
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1) ^
          " in " ^
          short_string_of_src sr
        )
      else List.nth ts n
    | _ -> 
      failwith 
      (
        "[bind_expression] Expected tuple " ^ 
        string_of_expression e' ^ 
        " to have tuple type, got " ^ 
        string_of_btypecode dfns typ ^
        " in " ^
        short_string_of_src sr
      )
    in 
      BEXPR_get_n (n, (expr,typ)), ctyp
    
  | AST_name (sr,(qn,suf)) -> 
    begin match suf with
    | TYP_none ->
      begin match lu sr qn with
      | NonFunctionEntry (Simple index) -> 
        let t = typeofindex dfns bdfns exclude sr index in
        (*
        print_endline 
        (
          "Name " ^ string_of_qualified_name qn ^ 
          " has simple type " ^
          string_of_btypecode dfns t 
        );
        *)
        BEXPR_name index, t

      | NonFunctionEntry Bound(i,m) ->
        let it = typeofindex dfns bdfns exclude sr i in
        let mt = typeofindex dfns bdfns exclude sr m in
        let t = unify dfns bdfns it mt in
        (*
        print_endline 
        (
          "Name " ^ string_of_qualified_name qn ^ 
          " has bound type " ^
          string_of_btypecode dfns t 
        );
        *)
        BEXPR_name m, t


      | FunctionEntry _ -> 
        (* This case should have been handled by bind_expression,
           with case AST_apply (AST_name (...), ...)
        *)
        failwith 
        (
          "unsuffixed name "^
          string_of_qualified_name qn ^
          " must not bind to function (except as first argument of an application or call)" ^
          short_string_of_src sr
        )
      end
    | _ -> 
      let bound_suffix =  bt suf in
      match lu sr qn with
      | NonFunctionEntry _ -> failwith "Suffixed name must bind to function overload set"
      | FunctionEntry fs ->
        let name = string_of_qualified_name qn in
        let suf' = bt suf in
        let index = 
          match resolve_overload dfns fs name suf' with
          | Some (Simple i) -> i
          | Some (Bound _) -> failwith "[bind_expression:name] Can't handle bound result, yett"
          | None -> 
            failwith 
            (
              "[flx_ebind] Can't find match for " ^ string_of_qualified_name qn ^ " in " ^
              short_string_of_src sr ^ 
              "\nCandidates are " ^
              (String.concat "\n"
                (List.map
                  (function Simple i | Bound (i,_)  ->
                    string_of_int i ^ "==> " ^ 
                    string_of_btypecode dfns (typeofindex dfns bdfns [] sr i)
                  )
                  fs
                )
              )
            )
        in
        BEXPR_closure index, typeofindex dfns bdfns exclude sr index
    end

  | AST_ref (srr,AST_name (srn,(qn,suf))) -> 
    begin match lu srn qn with
    | NonFunctionEntry (Simple index) -> 
      let id,sr,parent,entry = Hashtbl.find dfns index in
      begin match entry with
      | SYMDEF_dcl (DCL_var _)
      | SYMDEF_dcl (DCL_var_typeof _)
      | SYMDEF_parameter (TYP_pointer _) -> 
        BEXPR_ref index, 
        BTYP_pointer (typeofindex dfns bdfns exclude srn index)
      | SYMDEF_parameter _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          ": Address value parameter " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | SYMDEF_dcl (DCL_val _)
      | SYMDEF_dcl (DCL_val_typeof _) ->
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Can't address a value " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      end
    | NonFunctionEntry _ ->
      failwith
      (
        "[ebind] Expected simple nonfunction entry"
      )
    
    | FunctionEntry _ -> 
      failwith 
      (
        "[bind_expression] " ^
        short_string_of_src srr ^
        ": Address function " ^ string_of_qualified_name qn
      )
    end

  | AST_ref (_,(AST_deref (sr,e))) -> be e
  
  | AST_ref (sr,(AST_dot (_,(e,id)))) ->
    let ref_name = "ref_" ^ id in
    be 
    (
      AST_apply 
      (
        sr,
        (
          name_of_string sr ref_name,
          AST_ref (sr,e)
        )
      )
    )

  | AST_ref (sr,_) -> 
    failwith 
    (
      short_string_of_src sr ^
      ": Can't take address of expression"
    )

  | AST_deref (_,AST_ref (sr,e)) -> be e

  | AST_deref (_,e) -> 
    let e,t = be e in
    begin match t with 
    | BTYP_pointer t -> BEXPR_deref (e,t),t
    | _ -> failwith "Dereference non pointer"
    end

  | AST_literal (sr,v) -> 
    let t = typeof_literal dfns env sr v in
    BEXPR_literal v, t

  | AST_method_apply (sra,(fn,e2)) -> 
    let be2,t2 = be e2 in
    let tbe1 = 
      begin match t2 with
      | BTYP_name index ->
        let id,sr,parent,entry = Hashtbl.find dfns index in
        begin match parent with
        | None -> failwith "Koenig lookup: No parent for method apply (can't handle global yet)"
        | Some index' ->
          let id',sr',parent',entry' = Hashtbl.find dfns index' in
          match entry' with
          | SYMDEF_module name_map ->
            koenig_lookup dfns bdfns sra exclude id' name_map fn t2

          | SYMDEF_interface name_map ->
            koenig_lookup dfns bdfns sra exclude id' name_map fn t2

          | _ -> failwith ("Koenig lookup: parent for method apply not module")
        end
      | _ -> failwith "apply method to nongenerative type"
      end
    in
      cal_apply dfns tbe1 (be2, t2)

  | AST_apply (sra,(AST_name (srn,sn),e2)) -> 
    begin match sn with
    | (qn,TYP_none) -> (* OVERLOADING *)
      let name = string_of_qualified_name qn in
      let be2,t2 = be e2 in
      let tbe1 = 
        match lu srn qn with
        | NonFunctionEntry (Simple index) ->
          BEXPR_name index, 
          typeofindex dfns bdfns exclude srn index
        | NonFunctionEntry _ ->
          failwith "[ebind:apply] expected simple nonfunction entry"

        | FunctionEntry fs -> 
          (* print_endline ("Simple overload: function "^name^" found"); *)
          match resolve_overload dfns fs name t2 with
          | Some (Bound (i,j) ) -> 
            print_endline "[bind_expression:apply] handle opaque function";
            let it =
              match typeofindex dfns bdfns exclude srn i with
              | BTYP_function _ as t -> t
              | t -> 
                failwith 
                (
                  "[bind_expression]: closure operator expected '"^
                  name^"' to be function definition, got '"^
                  string_of_btypecode dfns t
                  ^"', " ^ short_string_of_src sra
                )
            and mt =
              match typeofindex dfns bdfns exclude srn j with
              | BTYP_function _ as t -> t
              | t -> 
                failwith 
                (
                  "[bind_expression]: closure operator expected '"^
                  name^"' to be function definition, got '"^
                  string_of_btypecode dfns t
                  ^"', " ^ short_string_of_src sra
                )
            in
              BEXPR_closure j,
              unify dfns bdfns it mt
            
          | Some (Simple index) -> 
            BEXPR_closure index,
            (
              match typeofindex dfns bdfns exclude srn index with
              | BTYP_function _ as t -> t
              | t -> 
                failwith 
                (
                  "[bind_expression]: closure operator expected '"^name^"' to be function definition, got '"^
                  string_of_btypecode dfns t
                  ^"', " ^ short_string_of_src sra
                )
            )
          | None -> 
            failwith 
            (
              "[flx_ebind] Can't find match for " ^ name ^ " in " ^
              short_string_of_src srn ^
              "\nArgtype is " ^ string_of_btypecode dfns t2 ^
              "\nCandidates are:\n" ^
              (String.concat "\n"
                (List.map
                  (function Simple i | Bound (i,_)->
                    string_of_int i ^ "==> " ^ 
                    string_of_btypecode dfns (typeofindex dfns bdfns [] sra i)
                  )
                  fs
                )
              )
            )
      in
      (* print_endline ("Simple overload: function "^name^" bound"); *)
      cal_apply dfns tbe1 (be2,t2)

    | _ -> 
      let tbe1 = be (AST_name (srn,sn)) 
      and tbe2 = be e2 
      in cal_apply dfns tbe1 tbe2
    end

  | AST_apply (_,(e1,e2)) -> 
    let tbe1 = be e1 and tbe2 = be e2 in
    cal_apply dfns tbe1 tbe2 

  | AST_tuple (_,es) -> 
    let bets = List.map be es in
    let _, bts = List.split bets in
    BEXPR_tuple bets, BTYP_tuple bts

  | AST_dot (sr,(e,id)) ->
    let get_name = "get_" ^ id in
    be (AST_method_apply (sr,(get_name,e)))

  | AST_match_ctor (sr,(qn,e)) ->
    let ctor, prefix = match List.rev qn with 
      | h::t -> h,List.rev t 
      | [] -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src sr ^
          ": Empty qualified name in AST_match_ctor"
        )
    in
    (* print_endline ("Matching ctor " ^ string_of_qualified_name qn ^
      " with " ^ string_of_expression e
    );
    *)
    be (AST_apply (
      sr,
      (
        AST_name (sr,(prefix @ ["_match_ctor_" ^ ctor],TYP_none)),
        e
      )
    ))
    
  | AST_ctor_arg (sr,(qn,e)) ->
   let ctor, prefix = match List.rev qn with 
     | h::t -> h, List.rev t 
     | [] -> 
       failwith 
       (
        "[bind_expression] " ^
         short_string_of_src sr ^
         ": Empty qualified name in AST_ctor_arg"
       )
    in
    be (AST_apply (sr,
      (
        AST_name (sr,(prefix @ ["ctor_arg_" ^ ctor],TYP_none)),
        e
      )
    ))
   
  | AST_lambda (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "[Compiler error] Unexpected lambda binding expression"
    )

(*
let add_unique table key value =
  try 
    Hashtbl.find table key;
    failwith ("Duplicate key " ^ key)
  with Not_found -> Hashtbl.add table key (NonFunctionEntry value)
*)
