@head(1,'Flxcc wrapper generator')
@execfile('config'+os.sep+'flx_data.py')
@h = tangler('spkgs/flxcc.py')
@select(h)
FLXCC_EXES = [ 'src/flxcc', ]
caml_exes = FLXCC_EXES
caml_require_libs = ['nums','unix','misclib','cillib','flxcclib','flxlib']
pkg_requires = ['cil']
caml_include_paths = ['src', 'src/cil']
iscr_source = ["lpsrc/flx_flxcc.pak"]
weaver_directory = 'doc/flxcc/'

@h= tangler("src/flxcc.ml")
@select(h)
open List
open Flx_util
open Flx_types
open Flx_version
open Flx_mtypes1
open Flx_cil_cabs
open Flx_cil_cil
open Flxcc_util
;;

let force_open_in place f = 
  try 
    open_in f 
  with 
  |  _ -> failwith ("[" ^ place ^ "] Can't open " ^ f ^ " for input")

let force_open_out place f = 
  try 
    open_out f 
  with 
  |  _ -> failwith ("[" ^ place ^ "] Can't open " ^ f ^ " for output")

type stab_t = {
  stab_cfile: string;
  stab_flxfile: string;
  stab_flxinclude: string;
  stab_module: string;

  aliases: (string,string) Hashtbl.t;
  struct_aliases: (string,string) Hashtbl.t;
  abstract_types: (string,string) Hashtbl.t;
  incomplete_types: (string,string) Hashtbl.t;
  mutable xtyps: (string,string) Hashtbl.t;
  mutable udt: (string,unit) Hashtbl.t;
  mutable ict: (string,string) Hashtbl.t;
  used_types: (string,unit) Hashtbl.t;
  variables : (string,string) Hashtbl.t;
  functions: (string * typsig list * string,string * string) Hashtbl.t;
  fields: (string,string * string) Hashtbl.t;
  cstructs : (string,(string * string) list) Hashtbl.t;
  procedures: (string * typsig list * string,string * string) Hashtbl.t;
  callback_types: (string,typ * int) Hashtbl.t;
  callback_clients: (string,typ * string * int * int) Hashtbl.t;
  enums: (string,string) Hashtbl.t;
  registry: (typsig, string * string) Hashtbl.t;
  mutable includes: StringSet.t;
  counter: int ref
}
;;

let isprefix p s =
  let pn = String.length p in
  String.length s >= pn &&
  String.sub s 0 pn = p
;;

exception Next
;;
type control_t = {
  mutable control_filename: string;
  mutable flxg_command: string;
  mutable prein_filename: string;
  mutable preout_filename: string;
  mutable log_filename: string;
  mutable language: Flx_cil_cabs.lang_t;
  mutable preprocessor: string;
  mutable raw_includes: StringSet.t;
  mutable raw_include_dirs : StringSet.t;
  mutable include_path: string list;
  mutable noincludes: string list;
  mutable merge_files: (string * string) list;
  mutable rev_merge_files: (string,string list) Hashtbl.t;
  mutable outdir: string;
  mutable repl_prefix: (string * string) list;
  stabs : (string,stab_t) Hashtbl.t;
  all_types : (string,string) Hashtbl.t;
  incomplete_types_cache: (string,string * string list) Hashtbl.t;
  mutable files: StringSet.t;
  replacements : (string,string) Hashtbl.t;
  nontype_replacements : (string,string) Hashtbl.t;
  rejects: (string,unit) Hashtbl.t;
  mutable root_includes: string list;
  mutable root_rec_includes: string list;
  mutable root_excludes : string list;
}
;;

let control = {
  control_filename = Sys.argv.(1);
  flxg_command = "";
  prein_filename = Sys.argv.(1) ^ ".h";
  preout_filename = Sys.argv.(1) ^ ".i";
  log_filename = Sys.argv.(1) ^ ".log";
  language = `C;
@tangle('  preprocessor ="'+FLXCC_CPP+'";')
  noincludes = [];
  raw_includes = StringSet.empty;
  raw_include_dirs = StringSet.empty;
  include_path = [];
  merge_files = [];
  rev_merge_files = Hashtbl.create 97;
  outdir = "flxcc_out";
  repl_prefix = [];
  stabs  = Hashtbl.create 97;
  all_types = Hashtbl.create 97;
  incomplete_types_cache = Hashtbl.create 97;
  files = StringSet.empty;
  replacements = Hashtbl.create 97;
  nontype_replacements = Hashtbl.create 97;
  rejects = Hashtbl.create 97;
  root_rec_includes = [];
  root_includes = [];
  root_excludes = [];
}
;;

(* map the name of a #include file which is
  intended to be a physical part of another
  into that filename. 
  
  The mapping is used to prevent
  a Felix include file or module being
  created for definitions in this file,
  but it should *only* be used when a file
  is uniquely included by another

  When we're scanning for includes,
  we need all the physical (unmapped)
  filenames as inputs to find the transitive
  closure. Once that is done, the transitive
  closure itself must be mapped to avoid
  references to non-existent Felix modules.
*)

let rec glob dir recurse level =
  if not (mem dir control.root_excludes) then
  let spaces = String.make level ' ' in
  try
    let f = Unix.opendir dir in
    control.raw_include_dirs <- StringSet.add dir control.raw_include_dirs;
    begin 
      try 
        while true do let m = Unix.readdir f in
          let path = Filename.concat dir m in
          let st = 
            try Unix.lstat path
            with _ -> failwith ("Can't lstat " ^ path)
          in
          match st.Unix.st_kind with
          | Unix.S_REG ->
            if not (mem path control.root_excludes) 
            then begin
              control.raw_includes <- StringSet.add path control.raw_includes;
              control.files <- StringSet.add path control.files
            end
            
          | Unix.S_DIR ->
            if recurse then
            if not (isprefix "." m) then
            begin
              glob path recurse (level + 1)
            end
            
          | _ -> ()
        done 
      with End_of_file -> Unix.closedir f
    end
  with Unix.Unix_error _ ->
    failwith ("Can't find directory " ^ dir)
;;

let pattern = ref "*.h" 
;;

let rec parse_control_file filename =
  let f = force_open_in "parse_control_file" filename 
  in
  let rec aux () =
    try 
      let line = input_line f in
      let n = String.length line in
      let i = ref 0 in
      try
          (* skip white *)
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then raise Next;

          (* detect C++ style comment *)
          if isprefix "//" (String.sub line !i (n - !i))
          then raise Next
          ;
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let keyword = String.sub line j (!i-j) in

          match keyword with
          | "#include" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "outdir statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            parse_control_file fn;
            raise Next

          | "outdir" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "outdir statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            control.outdir <- String.sub line j (!i-j);
            raise Next

          | "prein" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "prein statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            control.prein_filename <- String.sub line j (!i-j);
            raise Next

          | "preout" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "preout statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            control.preout_filename <- String.sub line j (!i-j);
            raise Next

          | "language" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "preout statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let x = String.sub line j (!i-j) in
            control.language <- 
              (
                match x with
                | "C" | "c" -> `C
                | "C++" | "c++" | "cxx" -> `Cxx
                | _ -> failwith ("Unknown language " ^ x ^", must be C or C++")
              )
            ;
            raise Next
          
          | "flx_compiler" ->
            while !i < n && line.[!i]=' ' do incr i done;
            let j = !i in
            while !i < n do incr i done;
            control.flxg_command <- String.sub line j (!i-j);
            raise Next

          | "preprocessor" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "preprocessor statement requires arguments";
            let j = !i in
            while !i < n do incr i done;
            control.preprocessor <- String.sub line j (!i-j);
            raise Next

          | "noheader" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "noinclude statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            control.noincludes <- fn :: control.noincludes;
            raise Next

          | "incdir" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "incdir statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            control.root_includes <- fn :: control.root_includes;
            raise Next

          | "incfile" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "incfile statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            control.raw_includes <- StringSet.add fn control.raw_includes;
            raise Next

          | "recincdir" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "incdir statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            control.root_rec_includes <- fn :: control.root_rec_includes;
            raise Next

          | "path" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "path statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            control.include_path <- control.include_path @ [fn];
            raise Next

          | "exclude" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "exclude statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            control.root_excludes<- fn :: control.root_excludes;
            raise Next

          | "prefix" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "prefix statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn1 = String.sub line j (!i-j) in

            while !i < n && line.[!i]=' ' do incr i done;
            let fn2 =
              if !i = n then "" 
              else begin
                let j = !i in
                while !i < n && line.[!i]<>' ' do incr i done;
                String.sub line j (!i-j)
              end
            in
            control.repl_prefix <- (fn1, fn2) :: control.repl_prefix;
            raise Next

          | "merge" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "merge statement requires filename";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn1 = String.sub line j (!i-j) in

            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "merge statement requires 2 filenames";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn2 = String.sub line j (!i-j) in
            control.merge_files <- (fn1,fn2) :: control.merge_files;
            let x = 
              try Hashtbl.find control.rev_merge_files fn2 
              with Not_found -> [] 
            in Hashtbl.replace control.rev_merge_files fn2 (fn1::x)
            ; 
            raise Next

          | "rename" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "rename statement requires name";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn1 = String.sub line j (!i-j) in

            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "rename statement requires 2 names";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn2 = String.sub line j (!i-j) in
            Hashtbl.add control.replacements fn1 fn2;
            raise Next

          | "rename_nontype" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "rename_nontype statement requires name";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn1 = String.sub line j (!i-j) in

            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "rename_nontype statement requires 2 names";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn2 = String.sub line j (!i-j) in
            Hashtbl.add control.nontype_replacements fn1 fn2;
            raise Next

          | "ignore" ->
            while !i < n && line.[!i]=' ' do incr i done;
            if !i = n then failwith "ignore statement requires name";
            let j = !i in
            while !i < n && line.[!i]<>' ' do incr i done;
            let fn = String.sub line j (!i-j) in
            Hashtbl.add control.rejects fn ();
            raise Next

          | _ -> failwith ("Unknown keyword " ^keyword^ " in control file")

      with Next -> aux()
    with End_of_file -> ()
  in 
    aux ();
    close_in f
;;
parse_control_file control.control_filename
;;

iter
(fun s -> glob s false 0)
control.root_includes
;;

iter
(fun s -> glob s true 0)
control.root_rec_includes
;;

let autocreate x =
  try open_out x 
  with | _ ->
  let rec mkpath x  =
    let d = Filename.dirname x in
    if d <> "" then begin
      try Unix.mkdir d 0o777 
      with _ -> 
        mkpath d;
        try Unix.mkdir d 0o777 
        with _ -> failwith ("[autocreate] Can't create (p=0777) directory " ^ d)
    end
  in
  mkpath x;
  force_open_out "autocreate" x

;;

let f = autocreate control.prein_filename in
StringSet.iter 
(fun s ->
  output_string f ("#include \"" ^ s ^ "\"\n")
)
control.raw_includes
;
close_out f
;;

let precmd = 
  let path = ref "" in
  (*
  StringSet.iter
  (fun s -> path := !path ^ "-I" ^ s ^ " ")
  control.raw_include_dirs
  ;
  *)
  path := 
  (
    String.concat " " 
    (
      map 
      (fun s-> "-I"^s^" ")
      control.include_path
    )
  ) ^ " " ^ !path
  ;
  
  control.preprocessor ^ " " ^ 
  !path ^ " " ^
  control.prein_filename ^ 
  " >" ^control.preout_filename
;;

print_endline "PREPROCESSOR COMMAND:";
print_endline precmd
;;

Unix.system precmd
;;

let format_time tm = 
  si (tm.Unix.tm_year + 1900) ^ "/" ^
  si (tm.Unix.tm_mon + 1) ^ "/" ^
  si tm.Unix.tm_mday ^ " " ^
  si tm.Unix.tm_hour ^ ":" ^
  si tm.Unix.tm_min ^ ":" ^
  si tm.Unix.tm_sec 
;;

let compile_start = Unix.time () 
let compile_start_gm = Unix.gmtime compile_start 
let compile_start_local = Unix.localtime compile_start 
let compile_start_gm_string = format_time compile_start_gm ^ " UTC" 
let compile_start_local_string = format_time compile_start_local ^ " (local)" 
;;

Flx_cil_cil.initCIL()
;;

let lexbuf = Flx_cil_clexer.init control.preout_filename control.language;;
let cabs = Flx_cil_cparser.file Flx_cil_clexer.initial lexbuf
;;
Flx_cil_clexer.finish()
;;

(*
Flx_cil_cprint.print_defs cabs;;
*)

let ns (s,_,_,_) = s
;;
let is_def = function | Some _ -> "complete" | None -> "incomplete"
;;
let type_of_se = function
| SpecType ts -> 
  begin match ts with
  | Tnamed s -> print_endline ("type " ^ s)
  | Tstruct (s,fglo,_) -> 
    print_endline ("struct " ^ s ^ " " ^ is_def fglo)
  | Tunion (s,fglo,_) -> 
    print_endline ("union " ^ s ^ " " ^ is_def fglo)
  | Tenum (s,fglo,_) -> 
    print_endline ("enum " ^ s ^ " " ^ is_def fglo)
  | _ -> ()
  end
| _ -> ()

let types_in sp = List.iter type_of_se sp
;;

let cil = Flx_cil_cabs2cil.convFile (control.preout_filename, cabs)
;;


(*
dumpFile defaultCilPrinter stdout cil ;;
*)

let {fileName=f; globals=gs} = cil
;;

(* files not corresponding to a module *)
let excludes : string list ref = ref
[
]
;;

let rpltname s = 
  try Hashtbl.find control.replacements s 
  with Not_found -> s

let rplname s = 
  try Hashtbl.find control.nontype_replacements s 
  with Not_found -> 
  try Hashtbl.find control.replacements s 
  with Not_found -> s

let strexp n = "0" (* cheat *)
;;

let remove_pnames t = match t with
| TPtr (TFun (t,Some ps,b,a),a') ->
  let ps = map (fun (_,t,a)->"",t,a) ps in
  TPtr (TFun (t,Some ps,b,a),a')
| _ -> t

(* strip multiple spaces and newlines out *)
let reformatc s = 
  let s' = ref "" in
  let n = String.length s in
  for i=0 to n - 1 do
    let 
      ch = s.[i] and 
      ch2 = if i < n-2 then s.[i+1] else '\000' 
    in
    if 
      ch = ' ' && 
        (ch2=' ' ||ch2=',' || ch2=';' || ch2=')' || ch2='\n') 
    then ()
    else if ch='\n' then s' := !s' ^ " "
    else s' := !s' ^ String.make 1 ch
  done;
  let n = ref (String.length !s' - 1) in
  while !n >= 0 && !s'.[!n]=' ' do decr n done;
  String.sub !s' 0 (!n+1)

let choose_alias stab s =
  let ss = ref [] in
  begin try
    let s' = Hashtbl.find stab.aliases s in
    ss := s' :: !ss
  with Not_found -> ()
  end
  ;

  begin try
    let s' = Hashtbl.find stab.struct_aliases s in
    ss := s' :: !ss
  with Not_found -> ()
  end
  ;

  (* just pick the shortest name *)
  let s = s :: !ss in
  let s = map (fun x -> String.length x,x) s in
  let s = sort compare s in 
  let _,p = hd s in
  p
  
let prefered_alias stab s = choose_alias stab s


let rec sot stab t = match t with
| TVoid a -> "void_t"
| TInt (ik,a) -> soi ik
| TFloat (fk,a) -> sof fk
| TPtr (TVoid a',a) -> (cvqual a')^"address"
| TPtr (TFun _,a) ->
  let t' = typeSig t in
  begin try 
    fst (Hashtbl.find stab.registry t')
  with
    Not_found ->
    let name = stab.stab_module ^"_cft_" ^ si !(stab.counter) in
    incr stab.counter;
    let sr = locUnknown in
    let t = remove_pnames t in
    let si = {tname=name;ttype=t;treferenced=true } in
    let gt =  GType (si,sr) in
    let d = defaultCilPrinter#pGlobal () gt in
    let s = Flx_cil_pretty.sprint 65 d in
    let s = reformatc s in
    Hashtbl.add stab.registry t' (name,s);
    name
  end
   
| TPtr (t',a) -> cvqual (attrof t') ^ "ptr[" ^ sot stab t'^ "]"
| TArray (t',Some n,a)-> 
  cvqual (attrof t') ^ "ptr[" ^ sot stab t'^ "]"

| TArray (t',None,a)-> 
  cvqual (attrof t') ^ "ptr[" ^ sot stab t' ^ "]"

| TFun (t',Some ps,false,a) ->
  let ret = sot stab t'
  and args = 
    if length ps = 0 then "1" 
    else String.concat " * " (List.map (soa stab) ps) 
  in args ^ " -> " ^ ret
    
| TFun (t',None,false,a) -> 
  let ret = sot stab t'
  and args = "1"
  in args ^ " -> " ^ ret

| TFun (t',_,_,a) -> "CANT HANDLE THIS FUN"

| TNamed (ti,a) -> 
  let name = ptname ti in 
  let name = prefered_alias stab name in
  Hashtbl.add stab.used_types name ();
  rpltname name
  
| TComp (ci,a) ->  
  let name = pci ci in 
  let name = prefered_alias stab name in
  Hashtbl.add stab.used_types name ();
  rpltname name

| TEnum (ei,a) -> "int"
| TBuiltin_va_list a -> "__builtin_va_list"

and ptdef registry ti:string = match ti with
{ttype=tt} -> sot registry tt

and soa stab (name,t,a) = sot stab t

and sov registry vi = match vi with
{vname=vname; vtype=vtype} ->
"const " ^ vname ^ ": " ^ sot registry vtype

let pe x = print_endline x
;;

(* name with replacement *)
let flx_name x = match flx_name' x with 
| Some x -> Some (rplname x)
| None -> None

(* type name with replacement *)
let flx_tname x = match flx_name' x with 
| Some x -> rpltname x
| None -> "error!!"

let can_gen_ctype cstruct cfields =  cstruct &&
  fold_left 
  (fun t {fname=fname; ftype=ftype} -> 
    t && not (isanont ftype) && ispublic fname &&
    is_cstruct_field ftype
  )
  true cfields 

let chop_extension f =
  let b = Filename.basename f in
  let d = Filename.dirname f in
  let b = try Filename.chop_extension b with _ -> b in
  if d = "." then b else Filename.concat d b

let replace_prefix x ls =
  let x = ref x in
  iter
  (fun (a,b) ->
    if isprefix a !x then
    let n = String.length a in
    let m = String.length !x in
    x := b ^ String.sub !x n (m-n)
  )
  ls
  ;
  !x
let map_filename f = 
  let f = replace_prefix f control.merge_files in
  f

let flxinclude_of_cfile cfilename =
  let x = map_filename cfilename in
  let x = replace_prefix x control.repl_prefix in
  let x = chop_extension x ^ "_lib" in
  let x = if isprefix "/" x then String.sub x 1 (String.length x - 1) else x in
  let x = if isprefix "." x then String.sub x 1 (String.length x - 1) else x in
  x

let flxfile_of_cfile cfilename =
  let base = flxinclude_of_cfile cfilename in
  Filename.concat (control.outdir)  (base ^ ".flx")

let srepl s c1 c2 =
  for i = 0 to String.length s - 1 do
    if s.[i]=c1 then s.[i] <- c2
  done
;;

let module_of_cfilename s = 
  let module_of_filename fname =
    let x = String.copy fname in
    let fixup x =
      srepl x '.' '_';
      srepl x ' ' '_';
      srepl x '/' '_';
      srepl x '-' '_';
      srepl x '+' '_';
      srepl x ':' '_';
    in
    let mname = 
      try 
        let x = (chop_extension x) in
        let x = 
          let m = String.length x in
          if m>0 && x.[0] = '/' then String.sub x 1 (m-1) else x
        in
        fixup x;
        x ^ "_h"
      with Invalid_argument _ ->
        print_endline ("Weird (C++??) filename " ^ fname ^ " without extension");
        fixup x;
        x
    in rplname mname (* apply user renaming to modules too *)
  in
  let s = map_filename s in
  let s = replace_prefix s control.repl_prefix in
  module_of_filename s

;;

let mk_stab cfile = 
{
  stab_cfile = cfile;
  stab_flxfile = flxfile_of_cfile cfile;
  stab_flxinclude = flxinclude_of_cfile cfile;
  stab_module = module_of_cfilename cfile;

  aliases= Hashtbl.create 97;
  struct_aliases= Hashtbl.create 97;
  abstract_types= Hashtbl.create 97;
  incomplete_types= Hashtbl.create 97;
  used_types= Hashtbl.create 97;
  variables= Hashtbl.create 97;
  functions= Hashtbl.create 97;
  fields= Hashtbl.create 97;
  cstructs = Hashtbl.create 97;
  procedures= Hashtbl.create 97;
  callback_types = Hashtbl.create 97;
  callback_clients = Hashtbl.create 97;
  enums= Hashtbl.create 97;
  registry= Hashtbl.create 97;
  includes = StringSet.empty;
  xtyps = Hashtbl.create 97;
  ict = Hashtbl.create 97;
  udt = Hashtbl.create 97;
  counter = ref 1
}
;;

let getstab s = 
  let lfn = map_filename s in
  try Hashtbl.find control.stabs lfn
  with Not_found ->
    let x = mk_stab s in
    Hashtbl.add control.stabs lfn x;
    x

let getreg {file=s} = getstab s 

let oplist = [
  "+","add";
  "-","sub";
  "*","mul";
  "/","div";
  "%","mod";

  "<","lt";
  ">","gt";
  "<=","le";
  ">=","ge";
  "==","eq";
  "!=","ne";

  "=","_set";

  "||","lor";
  "&&","land";
  "!","lnot";

  "^","bxor";
  "|","bor";
  "&","band";
  "~","compl";

  "+=","pluseq";
  "-=","minuseq";
  "*=","muleq";
  "/=","diveq";
  "%=","modeq";
  "^=","careteq";
  "|=","vbareq";
  "&=","ampereq";
  "~=","tildeeq";
  "<<=","leftshifteq";
  ">>=","rightshifteq";

  "++","incr";
  "--","decr";
  "[]","subscript";
]
;;
let operators = Hashtbl.create 97
;;
List.iter
(fun (k,v)-> Hashtbl.add operators ("operator"^k) v)
oplist
;;

let fixsym k = 
  try  (* hackery .. won't work with qualified names *)
    Hashtbl.find operators k 
  with Not_found ->
    let k = String.copy k in
    srepl k ':' '_';
    k

let rpl {file=s} which = 
  let stab = getstab s in
  match which with
  | `aliases (k,v) -> 
    let k = fixsym k in
    Hashtbl.replace stab.aliases k v;
    Hashtbl.replace control.all_types k s
  
  | `struct_aliases(k,v)  -> 
    let k = fixsym k in
    Hashtbl.replace stab.struct_aliases k v;
    Hashtbl.replace control.all_types k s

  | `abstract_types (k,v)  -> 
    let k = fixsym k in
    Hashtbl.replace stab.abstract_types k v;
    Hashtbl.replace control.all_types k s

  | `incomplete_types (k,v)  -> 
    let k = fixsym k in
    Hashtbl.replace stab.incomplete_types k v

  | `variables(k,v)  ->  
    let k = fixsym k in
    Hashtbl.replace stab.variables k v

  | `functions((k,ts,cv),v)  -> 
    let k = fixsym k in
    Hashtbl.replace stab.functions (k,ts,cv) v

  | `fields(k,v)  -> 
    let k = fixsym k in
    Hashtbl.replace stab.fields k v

  | `cstruct (k,v)  -> 
    let k = fixsym k in
    Hashtbl.replace control.all_types k k;
    Hashtbl.replace stab.cstructs k v

  | `procedures((k,ts,cv),v)  -> 
    let k = fixsym k in
    Hashtbl.replace stab.procedures (k,ts,cv) v

  | `enums(k,v)  -> 
    let k = fixsym k in
    Hashtbl.replace stab.enums k v

  | `callback_type (s,(t,i))  -> 
    Hashtbl.replace stab.callback_types s (t,i)

  | `callback_client (s,(t,cbt,i,j))  -> 
    Hashtbl.replace stab.callback_clients s (t,cbt,i,j)

;;

let add_file fname =
  control.files <- StringSet.add fname control.files
;;

let add_loc {file=fname} = 
  add_file fname
;;

(* find all the void* in an argument list *)
let find_voidps ps = 
  let voids = ref [] in
  let i = ref 0 in
  List.iter
  (fun (_,t,_) ->
    (match unrollType t with 
    | TPtr (TVoid _,[]) -> voids := !i :: !voids 
    | _ -> ()
    ); 
    incr i
  )
  ps
  ;
  !voids

(* check if a function pointer is a callback, by
seeing if it contains exactly one void * argument 
*)
let is_callbackp t = 
  match t with
  | TPtr (TFun (_,Some ps,false,_),_) ->
    List.length (find_voidps ps) = 1
  | _ -> false

(* Find all the arguments which are callbacks *)
let find_callbackps ps =
  let callbacks = ref [] in
  let i = ref 0 in
  List.iter
  (fun (_,t,_) -> 
    if is_callbackp t 
    then callbacks := !i :: !callbacks
    ;
    incr i
  )
  ps
  ;
  !callbacks

(* get the indices in an argument list of the callback
and client data pointer, and the index of the client
data pointer in the callback type as well, return None
if they can't be uniquely identified
*)

let get_callback_data ps =
  let callbacks = find_callbackps ps in
  let voids = find_voidps ps in
  match callbacks, voids with
  | [cbc_i], [cbc_adri] -> 
    begin match List.nth ps cbc_i with
    | _,TPtr (TFun (_,Some ps,false,_),_),_ ->
      begin match find_voidps ps with
      | [cbi] -> Some (cbc_i,cbc_adri,cbi)
      | _ -> assert false
      end
    | _ -> assert false
    end
  | _ -> None

let check_callback t = match t with
  | TFun (_,Some ps,false,_) ->
    begin match get_callback_data ps with
    | Some (cbc_i, cbc_adri,cbi) ->
      let _,cbt,_ = List.nth ps cbc_i in
      Some (cbc_i, cbc_adri,cbi, cbt)
    | None -> None
    end
  | TFun _ -> None
  | _ -> failwith "Check for callbacks in non-function"

let handle_callback_maybe ft registry key key' fname loc =
  match check_callback ft with
  | None -> ()
  | Some (cbc_i, cbc_adri, cbi, cbt) ->
    (*
    print_endline 
    (
      "Found callback client " ^ fname ^
      "\n  callback index = " ^ string_of_int cbc_i ^ 
      "\n  client data index = " ^ string_of_int cbc_adri ^
      "\n  callback type = " ^ sot registry cbt ^
      "\n  callback type client data index = " ^ string_of_int cbi
    )
    ;
    *)
    let s = sot registry cbt in
    rpl loc (`callback_type (s,(cbt,cbi)));
    rpl loc (`callback_client (fname,(ft,s,cbc_i,cbc_adri)))

let ptr key a =
  cvqual a ^ "ptr[" ^ key ^ "]"

let handle_global_fun ft registry key key' fname loc =
  handle_callback_maybe ft registry key key' fname loc; 
  match ft with
  | TFun (TVoid _,Some ps,false,a) ->
    let tsig = map (fun (_,t,a) -> typeSig t) ps in
    let args = 
      if length ps = 0 then "1" 
      else String.concat " * " (List.map (soa registry) ps) 
    in
    let cv = cvqual a in
    let ct = if key = key' then "" else key'^"($a);" in
    rpl loc (`procedures ((key,tsig,cv), (args,ct)))

  | TFun (TVoid _,None,false,a) ->
    let args = "1" in
    let cv = cvqual a in
    rpl loc (`procedures ((key,[],cv), (args,key'^"();")))

  | TFun (TVoid _,Some _,true,a) ->
    let cv = cvqual a in
    let ct = if key = key' then "" else key'^"($a);" in
    rpl loc (`procedures ((key^"[t]",[],cv), ("t",ct)))

  | TFun (ret,Some ps,false,a) ->
    let ftb =
      let ret = sot (getreg loc) ret
      and args = List.map (soa registry) ps
      and ct = if key = key' then "" else key'^"($a)"
      in 
      (
        (
          if length ps = 0 
          then "1" 
          else String.concat " * " args
        ) 
        ^ 
        " -> " ^ ret,ct
      )
    in 
      let tsig = map (fun (_,t,a) -> typeSig t) ps in
      let cv = cvqual a in
      rpl loc (`functions ((key,tsig,cv), ftb))

  | TFun (ret,None,false,a) ->
    let ret = sot (getreg loc) ret in
    let ftb =  "1 -> " ^ ret,key'^"()" in
    let cv = cvqual a in
    rpl loc (`functions ((key,[],cv), ftb))

  | TFun (ret,Some _,true,a) ->
    let ftb =
      let ret = sot (getreg loc) ret in 
      "t -> " ^ ret,key'^"($a)"
    in 
      let cv = cvqual a in
      rpl loc (`functions ((key^"[t]",[],cv), ftb))

  | _ -> assert false

let handle_method ft registry key fname loc =
  match ft with
  (* procedures *)
  | (TVoid _,Some ps,false,a) ->
    let key = ptr (fixsym key) a in
    let args = 
      if length ps = 0 then key 
      else String.concat " * " (key :: (List.map (soa registry) ps)) 
    in
      let tsig = map (fun (_,t,a) -> typeSig t) ps in
      let cv = cvqual a in
      rpl loc (`procedures ((fname,tsig,cv), (args,"$1->"^fname^"($b);")))

  (* no type arg = void *)
  | (TVoid _,None,false,a) ->
    let key = ptr key a in
    let args = key in
    let cv = cvqual a in
    rpl loc (`procedures ((fname,[],cv), (args,"$1->"^fname^"();")))

  (* variadic *)
  | (TVoid _,Some t,true,a) ->
    let key = ptr key a in
    let cv = cvqual a in
    rpl loc (`procedures ((fname^"[t]",[],cv), ("t","$1->"^fname^"($b);")))

  (* functions *)
  | (ret,Some ps,false,a) ->
    let key = ptr key a in
    let ftb =
      let ret = sot (getreg loc) ret
      and args = List.map (soa registry) ps
      in 
      (
        (
          if length ps = 0 
          then key 
          else String.concat " * " (key :: args)
        ) 
        ^ 
        " -> " ^ ret,"$1->"^fname^"($a)"
      )
    in 
      let tsig = map (fun (_,t,a) -> typeSig t) ps in
      let cv = cvqual a in
      rpl loc (`functions ((fname,tsig,cv), ftb))

  (* no type arg = void *)
  | (ret,None,false,a) ->
    let key = ptr key a in
    let ret = sot (getreg loc) ret in
    let ftb =  key ^ " -> " ^ ret,"$1->"^fname^"()" in
    let cv = cvqual a in
    rpl loc (`functions ((fname,[],cv), ftb))

  (* variadic *)
  | (ret,Some _,true,a) ->
    let key = ptr key a in
    let ftb =
      let ret = sot (getreg loc) ret in 
      "t -> " ^ ret,"$1->"^fname^"($b)"
    in 
      let cv = cvqual a in
      rpl loc (`functions ((fname^"[t]",[],cv), ftb))

  (* can't be both variadic and have no arguments *)
  | (_,None,true,_) -> assert false

let handle_field registry key fname ftype loc =
  match ftype with
  | TFun (a,b,c,d) -> handle_method (a,b,c,d) registry key fname loc

  | _ ->
    let t = key ^ " -> " ^ sot registry ftype in
    rpl loc (`fields (("get_"^fname), (t,"$1->"^fname)))
 
let gen_cstruct registry loc key cname cfields =
  let flds = ref [] in
  iter
  (fun {fname=fname; ftype=ftype} -> 
    let t = sot registry ftype in
    flds := (rplname fname,t) :: !flds
  )
  cfields
  ;
  let flds = rev !flds in
  rpl loc (`cstruct (cname, flds));
  if key <> cname then
    rpl loc (`aliases (key, cname))

let handle_global g =  let loc = get_globalLoc g in 
  add_loc loc;
  let type_name = flx_tname g in
  match isanon g,flx_name g,flx_name' g with
  | _,None,_ 
  | true,_,_ ->
    begin match g with

    (* enum { .. }; *)
    | GEnumTag (ei,_) -> 
      begin match ei with { eitems=eitems } ->
        iter
        (fun (s,_,_) -> 
          if ispublic s then rpl loc (`enums (rplname s,s))
        )
        eitems
      end
    | _ -> ()
    end

  | _,Some _,None -> assert false
  | false,Some key,Some key' ->
  if not (Hashtbl.mem control.rejects key) then
  match g with
  | GType (ti,loc) -> 
    let registry = getreg loc in
    begin
      match ti with {ttype=ttype} ->
      match  ttype with 
      | TComp (ci,_) -> 
        let anon= achk (ciname ci) in
        (*
        begin match ci with { cname=cname; cfields=cfields } ->
        iter
        (fun {fname=fname; ftype=ftype} -> 
          if not (isanont ftype) && ispublic fname then
          handle_field registry key fname ftype loc
        )
        cfields
        end
        ;
        *)
        if anon then
          rpl loc (`abstract_types (type_name, key'))
        else
          let v = ptdef registry ti in
          rpl loc (`struct_aliases (type_name, v))
   
      | TEnum (ei,_) -> 
        begin match ei with { eitems=eitems } ->
        iter
        (fun (s,_,_) -> if ispublic s then rpl loc (`enums (rplname s,s)))
        eitems
        end
        ;
        if achk (einame ei) then
          rpl loc (`abstract_types (type_name, key'))
        else
          rpl loc (`aliases (type_name, (ptdef registry ti)))

      | TFun (_,_,true,_) -> 
        (* HACK: varargs function typedef *)
        rpl loc (`abstract_types (type_name, key'))

      | t ->
        if isanont t then
          rpl loc (`abstract_types (type_name, key'))
        else
          let v = ptdef registry ti in
          rpl loc (`aliases (type_name, v))
    end

  | GCompTag (ci,loc) -> 
    let registry = getreg loc in
    begin match ci with { 
      cname=cname; 
      cfields=cfields; 
      cstruct=cstruct 
    } ->
      if can_gen_ctype cstruct cfields then 
        gen_cstruct registry loc type_name cname cfields
      else begin
        rpl loc (`abstract_types (type_name, (pcci ci)));
        iter
        (fun {fname=fname; ftype=ftype} -> 
          if not (isanont ftype) && ispublic fname then
          handle_field registry type_name fname ftype loc
        )
        cfields
      end
    end

    
  | GCompTagDecl (ci,loc) -> 
    rpl loc (`incomplete_types (type_name, (pcci ci)))
    
  | GEnumTag (ei,loc) -> 
    rpl loc (`aliases (type_name, "int"));
    begin match ei with { eitems=eitems } ->
    iter
    (fun (s,_,_) -> if ispublic s then rpl loc (`enums (rplname s,s)))
    eitems
    end

  | GEnumTagDecl (ci,loc) -> rpl loc (`aliases (type_name, "int"))
  
  | GVar (vi,_,loc) 
  | GFun ({svar=vi},loc)
  | GVarDecl (vi,loc) ->
    let registry = getreg loc in
    let vname, vtype=
      match vi with {vname=vname; vtype=vtype}->vname,vtype 
    in
    if ispublic vname then
    begin match vtype with
    | TFun _ -> handle_global_fun vtype registry key key' vname loc
    | _ ->
      rpl loc (`variables (key, (sot (getreg loc) vtype)))
    end

  | GAsm _ -> print_endline "GASM"
  | GPragma _ -> print_endline "PRAGMA"
  | GText _ -> print_endline "TEXT"
;;

List.iter handle_global gs
;;

let is_nonempty h = 
  try 
    Hashtbl.iter (fun _ -> raise Not_found) h; 
    false
   with Not_found -> true
;;

exception Found of string

let pathname_of f =
  try 
    iter 
    (fun s -> 
      let x = Filename.concat s f in 
      if Sys.file_exists x then raise (Found x)
    )
    control.include_path;
    raise Not_found
  with Found s -> s
;;

let rec find_includes' includes fname =
  if not (StringSet.mem fname !includes) then
    let f = force_open_in "find_includes'" fname in
    includes := StringSet.add fname !includes;
    begin try 
      let rec aux () =
        let line = input_line f in
        let n = String.length line in
        let i = ref 0 in

        try
          (* skip white *)
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then raise Next;

          (* check # *)
          if line.[!i]<>'#' then raise Next;
          incr i;

          (* skip white *)
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then raise Next;

          (* check include *)
          if !i+String.length "include" > n then raise Next;
          let li = String.length "include" in
          if (String.sub line !i li)  <> "include" then raise Next;
          i := !i + li;

          (* skip white *)
          while !i < n && line.[!i]=' ' do incr i done;

          (* check < or '"' *)
          if line.[!i]<>'"' && line.[!i]<>'<' then raise Next;
          incr i;

          (* skip to > or '"' *)
          let j = !i in
          while !i < n && line.[!i]<>'>' && line.[!i]<>'"' do incr i done;

          (* extract filename *)
          let filename = String.sub line j (!i-j) in


          (* lookup full path name *)
          let filename = 
            if not (Filename.is_relative filename) then filename else
            try pathname_of filename
            with Not_found -> 
              (*
              print_endline 
              (
                "[include_file'] Can't resolve " ^ filename ^
                " included from " ^ fname
              );
              *)
              raise Next
          in
          add_file filename;

          (* if not already known, put transitive closure in set *)
          if StringSet.mem filename !includes then raise Next;
          includes := StringSet.add filename !includes;
          find_includes' includes filename;

          (* next line *)
          raise Next
        with Next -> aux ()
      in 
        aux()
    with End_of_file -> close_in f
    end
;;

let find_includes fname =
  let includes = ref StringSet.empty in
  find_includes' includes fname;
  let extras = 
    try Hashtbl.find control.rev_merge_files fname 
    with Not_found -> [] 
  in
  iter (find_includes' includes) extras
  ;
  stringset_map map_filename !includes
;;

let global_includes = ref StringSet.empty
;;

Hashtbl.iter
begin 
  fun fname stab ->
  let includes = ref (find_includes stab.stab_cfile) in
  let ict = Hashtbl.create 97 in
  let xtyps = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v ->
    if not (Hashtbl.mem stab.abstract_types k) then 
    try 
      let file = Hashtbl.find control.all_types k in
      includes := StringSet.add file !includes;
      Hashtbl.add xtyps k file;

    with Not_found ->
      Hashtbl.add ict k v;
      let v',ms = 
        try Hashtbl.find control.incomplete_types_cache k 
        with Not_found -> v,[]
      in
      if v'<>v then 
      failwith ("Inconsistent type " ^k^"->"^ v ^ " <> " ^ v')
      ;
      Hashtbl.replace control.incomplete_types_cache k (v,stab.stab_module::ms)
    else
      ()
  )
  stab.incomplete_types
  ;

  let udt = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v ->
    let k = rplname k in
    if not (Hashtbl.mem control.rejects k) then
    try 
      let file = Hashtbl.find control.all_types k in
      includes := StringSet.add file !includes;
    with Not_found ->
      if not (Hashtbl.mem control.incomplete_types_cache k) then
      Hashtbl.add udt k v
  )
  stab.used_types
  ;
  stab.includes <- !includes;
  global_includes := StringSet.union !global_includes !includes;
  stab.udt <- udt;
  stab.ict <- ict;
  stab.xtyps <- xtyps
end
control.stabs
;;

(* closure for stabs .. *)
StringSet.iter
(fun s -> ignore(getstab s))
!global_includes
;;

StringSet.iter
(fun s -> 
   let filename = 
     if not (Filename.is_relative s) then s else
     try pathname_of s
     with Not_found -> 
       print_endline ( "Can't resolve primary file " ^ s);
       print_endline ("in path: ");
       iter
       (fun s -> print_endline s)
       control.include_path
       ;
       print_endline "Try adding path statement to control file";
       failwith ("Filename resolution error")
   in
     ignore(getstab filename)
)
control.raw_includes
;;

let rec find_macros fname =
  let macros = ref [] in
  begin
    try
      let f = open_in fname in
      begin 
        try 
          let rec aux () =
            let line = input_line f in
            let n = String.length line in
            let i = ref 0 in

            try
              (* skip white *)
              while !i < n && line.[!i]=' ' do incr i done;
              if !i = n then raise Next;

              (* check # *)
              if line.[!i]<>'#' then raise Next;
              incr i;

              (* skip white *)
              while !i < n && line.[!i]=' ' do incr i done;
              if !i = n then raise Next;

              (* check include *)
              let li = String.length "define" in
              if !i+li > n then raise Next;
              if (String.sub line !i li)  <> "define" then raise Next;
              i := !i + li;

              (* skip white *)
              while !i < n && line.[!i]=' ' do incr i done;
              let m = String.sub line !i (n - !i) in
              macros := m :: !macros;

              (* next line *)
              raise Next
            with Next -> aux ()
          in 
            aux()
        with End_of_file -> close_in f
      end
    with _ -> ()
  end
  ;
  !macros
;;
exception Equal
exception Not_equal
;;
let fnames = ref [];;
Hashtbl.iter
(fun f _ -> fnames := f :: !fnames)
control.stabs
;;
let fnames = List.sort compare !fnames
;;
iter begin 
  fun fname ->
  let stab = Hashtbl.find control.stabs fname in
  let outname = stab.stab_flxfile in
  let mode, outf =
    if Sys.file_exists outname then 
      `tmp, force_open_out "generate_file" "tmp.tmp" 
    else
      `orig,autocreate outname 
  in
  let pe s = output_string outf (s ^ "\n") in

  pe ("//Module        : " ^ stab.stab_module);
  pe ("//Timestamp     : " ^ compile_start_gm_string);
  pe ("//Timestamp     : " ^ compile_start_local_string);
  pe ("//Raw Header    : " ^ fname);
  pe ("//Preprocessor  : " ^ control.preprocessor);
  pe ("//Input file: " ^ control.preout_filename);
  pe ("//Flxcc Control : " ^ control.control_filename);
  pe ("//Felix Version : " ^ !version_data.version_string);
  pe ("include 'std';");
  pe "";
  let macros = find_macros fname in
  iter 
  (fun s-> pe ("//#define " ^ s))
  macros
  ;
  if not (mem fname control.noincludes) then
    pe ("header '#include \"" ^ fname^"\"';")
  else
    pe ("//NOT INCLUDED: \"" ^ fname^"\"")
  ;

    
  begin 
    try
      Hashtbl.iter
      (fun k v-> 
        match Hashtbl.find control.incomplete_types_cache k with
        | (_,[_]) -> ()
        | _ -> 
          pe ("include \"_incomplete_types_cache\";");
          raise Not_found
      )
      stab.ict 
    with Not_found -> ()
  end
  ;


  let include_depends = 
    let x = stringset_map map_filename stab.includes in
    let x = stringset_map flxinclude_of_cfile x in
    StringSet.remove stab.stab_flxinclude x
  in
  let module_depends = 
    let x = stringset_map map_filename stab.includes in
    let x = stringset_map (fun s -> module_of_cfilename s) x in
    StringSet.remove stab.stab_module x
  in

  if StringSet.cardinal include_depends > 0 then
  begin
    pe "";
    pe "//INCLUDES";
    StringSet.iter
    (fun incname -> 
      pe ("include \"" ^ incname^ "\";")
    )
    include_depends
  end
  ;

  pe "";
  pe ("module " ^ stab.stab_module ^ "\n{");
  begin
    let pe s = output_string outf ("  " ^ s ^ "\n") in
    pe "open C_hack;";
    if StringSet.cardinal module_depends > 0 then
    begin
      StringSet.iter
      (fun modulename' -> 
        pe ("open " ^ modulename' ^";")
      )
      module_depends
    end
    ;

    if is_nonempty stab.abstract_types then
    begin
      pe "";
      pe "//ABSTRACT TYPES";
      Hashtbl.iter
      (fun k v-> 
        pe ("type " ^ k ^ " = '" ^ v ^ "';")
      )
      stab.abstract_types
    end
    ;

    if is_nonempty stab.cstructs then
    begin
      pe "";
      pe "//CSTRUCTS ";
      Hashtbl.iter
      (fun k flds -> 
        pe ("cstruct " ^ k ^ " {");
        iter (fun (fld,typ) ->
          pe ("  " ^ fld ^": " ^ typ^ ";")
        )
        flds
        ;
        pe ("}")
      )
      stab.cstructs
    end
    ;

    if is_nonempty stab.registry then
    begin
      pe "";
      pe "//C FUNCTION POINTER TYPES";
      Hashtbl.iter
      (fun _ (name,tdef)-> 
        pe ("header '''" ^ tdef ^ "''';");
        pe ("type " ^ name ^ " = '" ^ name ^ "';")
      )
      stab.registry
    end
    ;

    if is_nonempty stab.xtyps then
    begin
      pe "";
      pe "//EXTERNALLY COMPLETED TYPES";
      Hashtbl.iter
      (fun k v-> 
        let m = module_of_cfilename v in
        pe ("//type " ^ k ^ " defined in "^m^"='" ^ v ^ "';")
      )
      stab.xtyps 
    end
    ;

    if is_nonempty stab.ict then
    begin
      pe "";
      pe "//PURE INCOMPLETE TYPES";
      Hashtbl.iter
      (fun k v-> 
        match Hashtbl.find control.incomplete_types_cache k with
        | (_,[_]) ->
          pe ("type " ^ k ^ " = '" ^ v ^ "'; //local")
        | (_,ls) -> 
          pe ("typedef " ^ k ^ " = _incomplete_types::" ^ k ^ ";//shared");
          iter (fun s->pe ("//shared by: " ^ s)) ls
      )
      stab.ict 
    end
    ;

    if is_nonempty stab.udt then
    begin
      pe "";
      pe "//TYPES WE CAN'T FIND";
      Hashtbl.iter
      (fun k _ -> 
        pe ("//type " ^ k ^ " ??")
      )
      stab.udt 
    end
    ;

    if is_nonempty stab.struct_aliases then
    begin
      pe "";
      pe "//STRUCT or UNION TAG ALIASES";
      Hashtbl.iter
      (fun k v-> 
        (* va_list is already defined in the standard library *)
        if k <> "va_list" then
        (* hack to fiddle typedef X {} X *)
        if not (Hashtbl.mem stab.cstructs k) then
        pe ("typedef " ^ k ^ " = " ^ v ^ ";")
      )
      stab.struct_aliases
    end
    ;

    if is_nonempty stab.aliases then
    begin
      pe "";
      pe "//TYPE ALIASES";
      Hashtbl.iter
      (fun k v-> 
        (* va_list is already defined in the standard library *)
        if k <> "va_list" then
        pe ("typedef " ^ k ^ " = " ^ v ^ ";")
      )
      stab.aliases
    end
    ;

    if is_nonempty stab.variables then
    begin
      pe "";
      pe "//VARIABLES";
      Hashtbl.iter
      (fun k v-> 
        pe ("const " ^ k ^ ": " ^v^ " = '" ^ k ^ "';")
      )
      stab.variables
    end
    ;

    if is_nonempty stab.enums then
    begin
      pe "";
      pe "//ENUMERATION CONSTANTS";
      Hashtbl.iter
      (fun k v -> 
        pe ("const " ^ k ^ ": int = '" ^ v ^ "';")
      )
      stab.enums
    end
    ;

    if is_nonempty stab.procedures then
    begin
      pe "";
      pe "//PROCEDURES";
      let ps = ref [] in
      Hashtbl.iter 
      (fun (k,_,_) v -> ps := (k,v):: !ps)
      stab.procedures
      ;
      let ps = sort compare !ps in
      iter
      (fun (k, (v,b)) -> 
        if b = "" then 
         pe ("proc " ^ k ^ ": " ^v^ ";")
        else
         pe ("proc " ^ k ^ ": " ^v^ " = '"^b^"';")
      )
      ps
    end
    ;

    if is_nonempty stab.functions then
    begin
      pe "";
      pe "//FUNCTIONS";
      let ps = ref [] in
      Hashtbl.iter
      (fun (k,_,_) v -> ps := (k,v):: !ps)
      stab.functions
      ;
      let ps = sort compare !ps in
      iter
      (fun (k, (v,b))-> 
        if b = "" then
          pe ("fun " ^ k ^ ": " ^v^ ";")
        else
          pe ("fun " ^ k ^ ": " ^v^ " = '" ^ b ^ "';")
      )
      ps
    end
    ;

    if is_nonempty stab.callback_types then
    begin
      let sot t = sot stab t in
      let soa a = soa stab a in
      pe "";
      pe "//CALLBACK TYPE WRAPPERS";
      Hashtbl.iter
      (fun tname (t, cbi)-> 
        pe ("//callback type " ^ tname ^ ", client data at " ^ string_of_int cbi);
        let ccbt = "_ccbt_" ^ tname in
        let fcbt = "_fcbt_" ^ tname in
        let fcbat = "_fcbat_" ^ tname in
        let fcbw = "_fcbw_" ^ tname in
        match t with
        | TPtr (TFun (ret,Some ps, false,a),_) ->
          (* fix arg names *)
          let i = ref 0 in
          let ps = 
            map
            (fun (_,t,a) -> 
              incr i;
              let pn = "a"^ string_of_int !i in
              pn,t,a
            )
            ps
          in
          let t' = TFun (ret,Some ps, false,a) in
          (* get the non-client data arguments *)
          let ps' = ref [] in
          let i = ref 0 in
          iter
          (fun x -> if cbi = !i then () else ps' := x :: !ps'; incr i)
          ps
          ;
          let ps' = rev !ps' in
          (* make a typedef for the felix callback type 
          mainly as documentation [since the client will
          declare a function of this type, the actual
          typedef isn't that useful]
          *)

          begin match ret with
          | TVoid _ -> 
            let args = 
             if length ps' = 0 then "1" 
            else String.concat " * " (List.map soa ps') 
            in
            pe ("typedef " ^ fcbat ^ " = " ^ args ^ "; ");
            pe ("export type (" ^ fcbat ^ ") as \""^fcbat^"\";");
            pe ("typedef " ^ fcbt ^ " = " ^ args ^ " -> void; ");
            pe ("export type (" ^ fcbt ^ ") as \""^fcbt^"\";");
            let sr = {line=0;file="";byte=0} in
            let vi = 
              {
                vname=fcbw; vtype=t'; vattr=[]; vglob=true;
                vinline=false; vdecl=sr; vid=0; vaddrof=false;
                vreferenced=true; vstorage=NoStorage
              } 
            in
            let g =  GVarDecl (vi,sr) in
            let d = defaultCilPrinter#pGlobal () g in
            let s = Flx_cil_pretty.sprint 65 d in
            let s = reformatc s in
            pe ("header '''" ^ s ^ "''';\n");
            pe ("const "^fcbw^": " ^ tname ^ " = \"" ^ fcbw ^ "\";");

            (* hack: elide trailing semicolon *)
            let s = String.sub s 0 (String.length s - 1) in
            pe ("body '''\n  " ^ s ^ "{");
            let oargs = ref [] in
            iter 
            (fun i -> if i <> cbi then 
              oargs := ("a" ^ string_of_int (i+1)) :: !oargs
            )
            (nlist (length ps))
            ;
            pe (
              "  con_t *p  = (("^fcbt^")a" ^ string_of_int (cbi+1) ^
              ")->call(" ^
              if List.length !oargs > 1 then 
                "0, " ^fcbat^"(" ^ String.concat ", " (rev !oargs)^"));"
              else
                String.concat ", " ("0" :: rev !oargs)^");"
            );
            pe ("  while(p) p=p->resume();");
            pe ("}''';\n");

          | _ -> 
            let args = 
             if length ps' = 0 then "1" 
            else String.concat " * " (List.map soa ps') 
            in
            let args = 
             if length ps' = 0 then "1" 
            else String.concat " * " (List.map soa ps') 
            in
            pe ("typedef " ^ fcbat ^ " = "^ args ^ ";");
            pe ("export type (" ^ fcbat ^ ") as \""^fcbat^"\";");
            pe ("typedef " ^ fcbt ^ " = "^ args ^ " -> "^sot ret^"; ");
            pe ("export type (" ^ fcbt ^ ") as \""^fcbt^"\";");
            let sr = {line=0;file="";byte=0} in
            let vi = 
              {
                vname=fcbw; vtype=t'; vattr=[]; vglob=true;
                vinline=false; vdecl=sr; vid=0; vaddrof=false;
                vreferenced=true; vstorage=NoStorage
              } 
            in
            let g =  GVarDecl (vi,sr) in
            let d = defaultCilPrinter#pGlobal () g in
            let s = Flx_cil_pretty.sprint 65 d in
            let s = reformatc s in
            pe ("header '''" ^ s ^ "''';\n");
            pe ("const "^fcbw^": " ^ tname ^ " = \"" ^ fcbw ^ "\";");
            
            (* hack: elide trailing semicolon *)
            let s = String.sub s 0 (String.length s - 1) in
            pe ("body '''\n  " ^ s ^ "{");
            let oargs = ref [] in
            iter 
            (fun i -> if i <> cbi then 
              oargs := ("a" ^ string_of_int (i+1)) :: !oargs
            )
            (nlist (length ps))
            ;
            pe (
              "  return (("^fcbt^")a" ^ string_of_int (cbi+1) ^
              ")->apply(" ^
              if List.length !oargs > 1 then 
                fcbat^"(" ^
                String.concat ", " (rev !oargs)^"));"
              else  
                String.concat ", " (rev !oargs)^");"
            );
            pe ("}''';\n");

          end
          ;
        | _ -> assert false
      )
      stab.callback_types
    end
    ;

    if is_nonempty stab.callback_clients then
    begin
      let sot t = sot stab t in
      let soa a = soa stab a in
      pe "";
      pe "//CALLBACK CLIENT WRAPPERS";
      Hashtbl.iter
      (fun fname (t, cbt, cbi,adri)-> 
        pe ("//callback client " ^ fname ^ ", client data at " ^ string_of_int cbi ^ ", callback at " ^ string_of_int adri);
        match t with
        | TFun (ret,Some ps, false,a) ->
          (* fix arg names *)
          let i = ref 0 in
          let args = ref [] in
          iter
          (fun (_,t,a) -> 
            if !i <> adri then begin
              let pn = "a"^ string_of_int (!i+1) in
              let t = 
                if !i = cbi then "_fcbt_" ^ sot t 
                else sot t 
              in
              args := (pn,t) :: !args
            end
            ;
            incr i
          )
          ps
          ;
          let args = rev !args in
          let params = 
            catmap ", " 
            (fun (n,t) -> n ^ ": " ^ t) 
            args 
          in
          let call_args = ref [] in
          let i = ref 0 in
          for j = 0 to length ps - 1 do
            call_args := 
              begin 
                if j = adri then 
                  ("C_hack::cast[address]a"^ string_of_int (cbi+1))
                else if j = cbi then 
                  ("_fcbw_" ^ cbt)
                else begin
                  while !i=cbi || !i=adri do incr i done;
                  let a = "a"^ string_of_int (!i+1) in
                  incr i;
                  a
                end
              end 
            :: 
            !call_args
          done
          ;
          begin match ret with
          | TVoid _ -> 
            pe ("proc wrapper_" ^ fname ^ "(" ^ params ^ ") {");
            pe ("  " ^fname^"(" ^ String.concat ", " (rev !call_args) ^ ");");
            pe ("}")

          | ret -> 
            let ret = sot ret in
            pe ("fun wrapper_" ^ fname ^ "(" ^ params ^ "): "^ret^"= {");
            pe ("  return " ^fname^"(" ^ String.concat ", " (rev !call_args) ^ ");");
            pe ("}")

          end

        | _ -> assert false
      )
      stab.callback_clients
    end
    ;

    if is_nonempty stab.fields then
    begin
      pe "";
      pe "//STRUCT and UNION FIELDS";
      Hashtbl.iter
      (fun k (v,b)-> 
        pe ("fun " ^ k ^ ": " ^v^ " = '" ^ b ^ "';")
      )
      stab.fields
    end
  end
  ;
  pe "}";
  close_out outf
  ;
  match mode with
  | `orig -> print_endline ("New file " ^ outname); ()
  | `tmp ->
    let f1 = force_open_in "new_file" "tmp.tmp" in
    let f2 = force_open_in "changed_file" outname in
    for i = 1 to 6 do (* skip timestamps when comparing *)
      ignore(input_line f1); 
      ignore(input_line f2)
    done
    ;
    try 
      while true do
        let in1 = try Some (input_line f1) with End_of_file -> None in
        let in2 = try Some (input_line f2) with End_of_file -> None in
        match in1,in2 with
        | None, None -> raise Equal
        | Some i, Some j when i = j -> ()
        | _ -> raise Not_equal
      done
    with 
      | Not_equal -> 
        begin 
          print_endline ("Changed file .. " ^ outname);
          close_in f1; close_in f2; 
          let f1 = force_open_in "changed_file" "tmp.tmp" in
          let f2 = force_open_out "change_file" outname in
          try while true do output_string f2 ((input_line f1) ^ "\n")
          done with End_of_file ->
          close_in f1; close_out f2
        end

      | Equal -> 
        print_endline ("Unchanged file .. " ^ outname);
        close_in f2; 
        close_in f1
end
fnames
;;

if is_nonempty control.incomplete_types_cache then
  let outname = 
    Filename.concat (control.outdir)  
    ("_incomplete_types_cache.flx") 
  in
  let outf = autocreate outname in
  let print_endline s = output_string outf (s ^ "\n") in
  print_endline "//incomplete type cache";
  print_endline "module _incomplete_types {";
  Hashtbl.iter
  (fun k (v,m) ->
    match m with
    | [_] -> ()
    | _ ->
      print_endline ("incomplete type " ^ k ^ " = '" ^v^ "';");
      List.iter
      (fun s -> print_endline ("  // used by " ^ s)
      )
      m
  )
  control.incomplete_types_cache
  ;
  print_endline "}";
  close_out outf
;;

let flx f = 
  if control.flxg_command <> "" then begin
    let cmd = control.flxg_command ^ " -I"^control.outdir^" -c " ^f in
    print_endline cmd;
    Unix.system(cmd)
  end
  else Unix.WEXITED 0 (* cheat *) 
;;

let fnames = ref []
;;

let rec dflx dir =
  try
    let f = Unix.opendir dir in
    begin 
      try 
        while true do let m = Unix.readdir f in
          let path = Filename.concat dir m in
          let st = 
            try Unix.lstat path
            with _ -> failwith ("Can't lstat " ^ path)
          in
          match st.Unix.st_kind with
          | Unix.S_REG ->
            if Filename.check_suffix path ".flx" then
            let fn = Filename.chop_suffix path ".flx" in
            fnames := fn :: !fnames

          | Unix.S_DIR -> 
            if not (isprefix "." m) then dflx path 
          | _ -> ()
        done 
      with End_of_file -> Unix.closedir f
    end
  with Unix.Unix_error _ ->
    failwith ("Can't find directory " ^ dir)
;;

dflx control.outdir
;;

let fnames = List.sort compare !fnames 
;;
let faulty = ref [];; 
let good = ref [];;

iter 
begin fun fn ->
  let result = flx fn in
  match result with
  | Unix.WEXITED 0 -> good := fn :: !good 
  | Unix.WEXITED i -> 
    faulty := fn :: !faulty;
    print_endline ("***** Failed, error " ^ string_of_int i)
  | Unix.WSIGNALED i 
  | Unix.WSTOPPED i -> 
    failwith ("SIGNAL " ^ string_of_int i)
end
fnames
;;

let f = open_out control.log_filename in
  iter 
  (fun fn -> 
    output_string f ("FAILED   : " ^ fn ^ "\n")
  ) 
  (rev !faulty)
  ;
  iter 
  (fun fn -> 
    output_string f ("SUCCEEDED: " ^ fn ^ "\n")
  ) 
  (rev !good)
  ;
  close_out f
;;

@h=tangler("config/felix.flxcc","data")
@select(h)
// Felix: language and core library wrapper control
//
// rename Felix keywords
@for k,j in flx_keywords:
  tangle('rename '+k+' '+k+'_')
//
// We need to rename any C++ keywords too
rename namespace namespace_
rename namespace namespace_
//
// remap C types to Felix standard library types
rename size_t size
rename wchar_t wchar

// ignore definitions of Felix standard library types
@for k in tmap.keys():
  tangle('ignore '+k)
ignore wchar

@h = tangler("tmp/gnu_c_search_path.flxcc.default","data")
@select(h)
path /usr/local/include
@if not MACOSX:
  tangle('path /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include')
path /usr/include

@h = tangler("tmp/gnu_cxx_search_path.flxcc.default","data")
@select(h)
path /usr/include/c++/4.0.0
path /usr/include/c++/4.0.0/backward
path /usr/include/c++/3.2.2
path /usr/include/c++/3.2.2/backward
path /usr/local/include
@if not MACOSX:
  tangle('path /usr/include/c++/4.0.0/i386-redhat-linux')
  tangle('path /usr/include/c++/3.2.2/i386-redhat-linux')
  tangle('path /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include')
path /usr/include

@h = tangler("tmp/gnu_headers.flxcc.default","data")
@select(h)
// This file contains annotations to control
// use of GNU system header files, and some other
// essential system resources

// Some files say:
//
// extern struct X X(..
//
// which defines a function of the same name as
// a struct tag -- this is OK in C, problematic
// in C++, and definitely out for Felix
//
// Such functions are renamed by appending a trailin underscore
// without changing the name of the type
//
// NOTE: this is a serious pain because Felix cstructs
// automatically get constructors of the same name
// so the client using such a name may get an overload
// error (or even worse, a program that has the wrong semantics)

rename_nontype sigaltstack sigaltstack_
rename_nontype sigstack sigstack_
rename_nontype sigvec sigvec_
rename_nontype mallinfo mallinfo_
rename_nontype vtimes vtimes_
rename_nontype statfs statfs_ 
rename_nontype timezone timezone_

@if MACOSX:
  tangle('#include config/gnu_macosx_headers.flxcc')
 else:
  tangle('#include config/gnu_linux_macosx_headers.flxcc')

@h = tangler("tmp/gnu_macosx_headers.flxcc.default","data")
@select(h)

@h = tangler("tmp/gnu_linux_headers.flxcc.default","data")
@select(h)
// Some files are designed as implementation details
// and not intended to be used directly
// We therefore prevent C level #includes like
//
// header '#include <file>'; 
//
// from being generated
//
// This related to the merge specifications below,
// but the two facilities are independent

noheader /usr/include/bits/byteswap.h
noheader /usr/include/bits/cmathcalls.h
noheader /usr/include/bits/confname.h
noheader /usr/include/bits/dirent.h
noheader /usr/include/bits/dlfcn.h
noheader /usr/include/bits/elfclass.h
noheader /usr/include/bits/endian.h
noheader /usr/include/bits/environments.h
noheader /usr/include/bits/fcntl.h
noheader /usr/include/bits/fenv.h
noheader /usr/include/bits/huge_val.h
noheader /usr/include/bits/in.h
noheader /usr/include/bits/ioctls.h
noheader /usr/include/bits/ioctl-types.h
noheader /usr/include/bits/ipc.h
noheader /usr/include/bits/ipctypes.h
noheader /usr/include/bits/locale.h
noheader /usr/include/bits/mathcalls.h
noheader /usr/include/bits/mathdef.h
noheader /usr/include/bits/mathinline.h
noheader /usr/include/bits/mman.h
noheader /usr/include/bits/msq.h
noheader /usr/include/bits/nan.h
noheader /usr/include/bits/netdb.h
noheader /usr/include/bits/poll.h
noheader /usr/include/bits/posix1_lim.h
noheader /usr/include/bits/posix2_lim.h
noheader /usr/include/bits/pthreadtypes.h
noheader /usr/include/bits/resource.h
noheader /usr/include/bits/sched.h
noheader /usr/include/bits/select.h
noheader /usr/include/bits/sem.h
noheader /usr/include/bits/setjmp.h
noheader /usr/include/bits/shm.h
//noheader /usr/include/bits/sigset.h
//noheader /usr/include/bits/sigaction.h
//noheader /usr/include/bits/sigcontext.h
//noheader /usr/include/bits/siginfo.h
//noheader /usr/include/bits/sigstack.h
//noheader /usr/include/bits/sigthread.h
noheader /usr/include/bits/sockaddr.h
noheader /usr/include/bits/socket.h
noheader /usr/include/bits/statfs.h
noheader /usr/include/bits/stat.h
noheader /usr/include/bits/statvfs.h
noheader /usr/include/bits/stdio.h
noheader /usr/include/bits/stdio_lim.h
noheader /usr/include/bits/string2.h
noheader /usr/include/bits/string.h
noheader /usr/include/bits/stropts.h
noheader /usr/include/bits/syscall.h
noheader /usr/include/bits/sys_errlist.h
noheader /usr/include/bits/termios.h
noheader /usr/include/bits/time.h
noheader /usr/include/bits/types.h
noheader /usr/include/bits/typesizes.h
noheader /usr/include/bits/uio.h
noheader /usr/include/bits/ustat.h
noheader /usr/include/bits/utmp.h
noheader /usr/include/bits/utmpx.h
noheader /usr/include/bits/utsname.h
noheader /usr/include/bits/waitflags.h
noheader /usr/include/bits/waitstatus.h
noheader /usr/include/bits/xopen_lim.h
noheader /usr/include/bits/xtitypes.h

// Some files have aliases created by
// symlinks and others include details
// that should really be treated as if they're
// physically included in the file, rather than
// a separate module -- see above comments on
// the related noheader command
//
// We use merge specification to say that any
// text found in the first file is treated as
// if it were physically part of the second one

merge /usr/include/bits/sigset.h /usr/include/signal.h
merge /usr/include/bits/sigaction.h /usr/include/signal.h
merge /usr/include/bits/sigcontext.h /usr/include/signal.h
merge /usr/include/bits/siginfo.h /usr/include/signal.h
merge /usr/include/bits/sigstack.h /usr/include/signal.h
merge /usr/include/bits/sigthread.h /usr/include/pthread.h
merge /usr/include/bits/sched.h /usr/include/sched.h
merge /usr/include/bits/pthreadtypes.h /usr/include/sys/types.h
merge /usr/include/bits/confname.h /usr/include/unistd.h
merge /usr/include/bits/time.h /usr/include/time.h

merge /usr/include/bits/byteswap.h /usr/include/byteswap.h
merge /usr/include/bits/cmathcalls.h /usr/include/complex.h
merge /usr/include/bits/dirent.h /usr/include/dirent.h
merge /usr/include/bits/dlfcn.h /usr/include/dlfcn.h
merge /usr/include/bits/elfclass.h /usr/include/link.h
merge /usr/include/bits/endian.h /usr/include/endian.h
merge /usr/include/bits/errno.h /usr/include/errno.h
merge /usr/include/bits/environments.h /usr/include/unistd.h
merge /usr/include/bits/fcntl.h /usr/include/fcntl.h
merge /usr/include/bits/fenv.h /usr/include/fenv.h
merge /usr/include/bits/huge_val.h /usr/include/math.h
merge /usr/include/bits/in.h /usr/include/netinet/in.h
merge /usr/include/bits/ioctls.h /usr/include/sys/ioctl.h
merge /usr/include/bits/ioctl-types.h /usr/include/sys/ioctl.h
merge /usr/include/bits/ipc.h /usr/include/sys/ipc.h
merge /usr/include/bits/ipctypes.h /usr/include/sys/ipc.h
merge /usr/include/bits/locale.h /usr/include/locale.h
merge /usr/include/bits/mathcalls.h /usr/include/math.h
merge /usr/include/bits/mathdef.h /usr/include/math.h
merge /usr/include/bits/mathinline.h /usr/include/math.h
merge /usr/include/bits/mman.h /usr/include/sys/mman.h
merge /usr/include/bits/msq.h /usr/include/sys/msg.h
merge /usr/include/bits/nan.h /usr/include/math.h
merge /usr/include/bits/netdb.h /usr/include/netdb.h
merge /usr/include/bits/poll.h /usr/include/sys/poll.h
merge /usr/include/bits/posix1_lim.h /usr/include/limits.h
merge /usr/include/bits/posix2_lim.h /usr/include/limits.h
merge /usr/include/bits/resource.h /usr/include/sys/resource.h
merge /usr/include/bits/select.h /usr/include/sys/select.h
merge /usr/include/bits/sem.h /usr/include/sys/sem.h
merge /usr/include/bits/setjmp.h /usr/include/setjmp.h
merge /usr/include/bits/shm.h /usr/include/sys/shm.h
merge /usr/include/bits/sockaddr.h /usr/include/sys/socket.h
merge /usr/include/bits/socket.h /usr/include/sys/socket.h
merge /usr/include/bits/statfs.h /usr/include/sys/statfs.h
merge /usr/include/bits/stat.h /usr/include/sys/stat.h
merge /usr/include/bits/statvfs.h /usr/include/sys/statvfs.h
merge /usr/include/bits/stdio.h /usr/include/stdio.h
merge /usr/include/bits/stdio_lim.h /usr/include/stdio.h
merge /usr/include/bits/string2.h /usr/include/string.h
merge /usr/include/bits/string.h /usr/include/string.h
merge /usr/include/bits/stropts.h /usr/include/stropts.h
merge /usr/include/bits/syscall.h /usr/include/sys/syscall.h
merge /usr/include/bits/sys_errlist.h /usr/include/stdio.h
merge /usr/include/bits/termios.h /usr/include/termios.h
merge /usr/include/bits/types.h /usr/include/sys/types.h
merge /usr/include/bits/typesizes.h /usr/include/sys/types.h
merge /usr/include/bits/uio.h /usr/include/sys/uio.h
merge /usr/include/bits/ustat.h /usr/include/sys/ustat.h
merge /usr/include/bits/utmp.h /usr/include/utmp.h
merge /usr/include/bits/utmpx.h /usr/include/utmpx.h
merge /usr/include/bits/utsname.h /usr/include/sys/utsname.h
merge /usr/include/bits/waitflags.h /usr/include/sys/wait.h
merge /usr/include/bits/waitstatus.h /usr/include/sys/wait.h
merge /usr/include/bits/xopen_lim.h /usr/include/limits.h
merge /usr/include/bits/xtitypes.h /usr/include/stropts.h

@h=tangler("tmp/c89.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_c_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir c89 
prefix /usr/include 
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
preprocessor gcc -E -std=c89
language C

//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 

incfile assert.h
incfile ctype.h
incfile errno.h
incfile fenv.h
incfile float.h
//incfile iso646.h: c99 only
incfile limits.h
incfile locale.h
incfile math.h
incfile setjmp.h
incfile signal.h
incfile stdarg.h
incfile stddef.h
incfile stdio.h
incfile stdlib.h
incfile string.h
incfile time.h
incfile wchar.h
incfile wctype.h

rename String String_

@h=tangler("tmp/gnu89.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_c_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir gnu89 
prefix /usr/include 
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
preprocessor gcc -E -std=gnu89
language C
//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 
flx_compiler bin/flxg -Ilib

incfile assert.h
incfile ctype.h
incfile errno.h
incfile fenv.h
incfile float.h
//incfile inttypes.h: c99 only
//incfile iso646.h: c99 only
incfile limits.h
incfile locale.h
incfile math.h
incfile setjmp.h
incfile signal.h
incfile stdarg.h
//incfile stdbool.h: c99 only
incfile stddef.h
//incfile stdint.h: c99 only
incfile stdio.h
incfile stdlib.h
incfile string.h
//incfile tgmath.h: c99 only
incfile time.h
incfile wchar.h
incfile wctype.h

rename String String_

@h=tangler("tmp/c99.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_c_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir c99 
prefix /usr/include 
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
preprocessor gcc -E -std=c99
language C

incfile assert.h
incfile ctype.h
incfile complex.h
incfile errno.h
incfile fenv.h
incfile float.h
incfile inttypes.h 
//incfile iso646.h: just macros
incfile limits.h
incfile locale.h
incfile math.h
incfile setjmp.h
incfile signal.h
incfile stdarg.h
incfile stdbool.h
incfile stddef.h
incfile stdint.h
incfile stdio.h
incfile stdlib.h
incfile string.h
@if not MACOSX:
  tangle('incfile tgmath.h')
incfile time.h
incfile wchar.h
incfile wctype.h

rename String String_

@h=tangler("tmp/gnu99.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_c_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir gnu99
prefix /usr/include 
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
preprocessor gcc -E -std=gnu99
language C
//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 

incfile assert.h
incfile ctype.h
incfile complex.h
incfile errno.h
incfile fenv.h
incfile float.h
incfile inttypes.h 
//incfile iso646.h: just macros
incfile limits.h
incfile locale.h
incfile math.h
incfile setjmp.h
incfile signal.h
incfile stdarg.h
incfile stdbool.h
incfile stddef.h
incfile stdint.h
incfile stdio.h
incfile stdlib.h
incfile string.h
@if not MACOSX:
  tangle('incfile tgmath.h')
incfile time.h
incfile wchar.h
incfile wctype.h

rename String String_

@h=tangler("tmp/cxx.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_cxx_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir cxx 
prefix /usr/include
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
preprocessor g++ -E -I/usr/include/g++-3
language C++

//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 

incfile cctype
incfile cerrno
//incfile cfenv: cfenv.h is c99, we expect this to come to C++
incfile cfloat
incfile climits
incfile clocale
incfile cmath
incfile csetjmp
incfile csignal
incfile cstdarg
incfile cstddef
//incfile cstdint
incfile cstdio
incfile cstdlib
incfile cstring
incfile ctime
incfile cwchar
incfile cwctype

rename String String_

@h=tangler("tmp/cxx_sys.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_cxx_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir cxx_sys
prefix /usr/include
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
preprocessor g++ -E -I/usr/include/g++-3
language C++

//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 

incfile cctype
incfile cerrno
//incfile cfenv: cfenv.h is c99, we expect this to come to C++
incfile cfloat
incfile climits
incfile clocale
incfile cmath
incfile csetjmp
incfile csignal
incfile cstdarg
incfile cstddef
//incfile cstdint
incfile cstdio
incfile cstdlib
incfile cstring
incfile ctime
incfile cwchar
incfile cwctype
incdir /usr/include/sys

rename String String_

@h=tangler("tmp/gnucxx.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_cxx_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir gnucxx 
prefix /usr/include
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
preprocessor g++ -E -I/usr/include/g++-3
language C++

//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 

incfile cctype
incfile cerrno
incfile cfloat
incfile climits
incfile clocale
incfile cmath
incfile csetjmp
incfile csignal
incfile cstdarg
incfile cstddef
//incfile cstdint
incfile cstdio
incfile cstdlib
incfile cstring
incfile ctime
incfile cwchar
incfile cwctype

rename String String_

@h=tangler("tmp/usr_include.flxcc.default","data")
@select(h)
#include config/felix.flxcc
#include config/gnu_headers.flxcc
#include config/gnu_cxx_search_path.flxcc
flx_compiler bin/flxg -Ilib

outdir flxcc_out
prefix /usr/include
prefix /usr/local/include
prefix /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include
prefix /usr/lib/glib/include/ glib
preprocessor g++ -E 
language C

//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 

path /usr/include/atk-1.0 
path /usr/include/bonobo-activation-2.0 
path /usr/include/eel-2 
path /usr/include/gail-1.0 
path /usr/include/gal-1.0 
path /usr/include/gconf/2 
path /usr/include/gtk-2.0 
path /usr/lib/gtk-2.0/include 
path /usr/include/X11
path /usr/include/glib-2.0 
path /usr/lib/glib-2.0/include 
path /usr/lib/glib/include 
path /usr/include/gnome-vfs-2.0 
path /usr/lib/gnome-vfs-2.0/include 
path /usr/include/gnome-vfs-module-2.0 
path /usr/include/gtkhtml-1.1 
path /usr/include/gdk-pixbuf-1.0 
path /usr/include/gnome-1.0 
path /usr/include/freetype2 
path /usr/lib/gnome-libs/include 
path /usr/include/gnome-xml 
path /usr/include/libglade-1.0 
path /usr/include/libart-2.0 
path /usr/include/libbonobo-2.0 
path /usr/include/libbonoboui-2.0 
path /usr/include/libglade-2.0 
path /usr/include/libgnome-2.0 
path /usr/include/libgnomecanvas-2.0 
path /usr/include/libgnomeui-2.0 
path /usr/include/libgsf-1 
path /usr/include/libIDL-2.0 
path /usr/include/metacity-1 
path /usr/include/panel-2.0 
path /usr/include/libpng12 
path /usr/include/librsvg-2 
path /usr/include/libxml2 
path /usr/include/linc-1.0 
path /usr/kerberos/include 
path /usr/include/orbit-2.0 
path /usr/include/orbit-2.0/orbit-idl 
path /usr/include/pango-1.0 

incdir /usr/include
incdir /usr/include/sys
incdir /usr/include/gtk-2.0/gdk
incdir /usr/include/gtk-2.0/gdk-pixbuf
incdir /usr/include/gtkhtml-1.1
recincdir /usr/include/libIDL-2.0
incfile /usr/include/gtk-2.0/gtk/gtk.h
recincdir /usr/local/include/python2.3

exclude /usr/include/af_vfs.h
exclude /usr/include/disptmpl.h
exclude /usr/include/bits
exclude /usr/include/asm
exclude /usr/include/linux
exclude /usr/include/glib-1.2
exclude /usr/include/orbit-1.0
exclude /usr/include/c++
exclude /usr/include/g++-3
exclude /usr/include/libglade-1.0
exclude /usr/include/gtk-1.2
exclude /usr/include/glib-2.0/gobject
exclude /usr/include/FlexLexer.h
exclude /usr/include/swig.h
exclude /usr/include/Imlib.h
exclude /usr/include/Imlib_private.h
exclude /usr/include/Imlib_types.h
exclude /usr/include/rle_config.h
exclude /usr/include/md5.h
exclude /usr/include/pcap-namedb.h
exclude /usr/include/regexp.h
exclude /usr/include/hmac-md5.h
exclude /usr/include/jmorecfg.h
exclude /usr/include/jconfig.h
exclude /usr/local/include/python2.3/pymactoolbox.h
exclude /usr/include/libmng.h
exclude /usr/include/mp.h
exclude /usr/include/pammap.h

rename String String_

rename_nontype _ns_flagdata _ns_flagdata_
rename_nontype usb_device usb_device_
rename_nontype tcpd_context tcpd_context_

merge /usr/X11R6/include/X11 /usr/include/X11


