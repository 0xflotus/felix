@head(1,"Typeclass checker")
@h = tangler("src/flx_typeclass.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_child

val typeclass_instance_check:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  child_map_t ->
  unit

val fixup_typeclass_instance:
  sym_state_t -> 
  int ->
  btypecode_t list ->
  int * btypecode_t list
 
@h = tangler("src/flx_typeclass.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child

let vs2ts vs = map (fun (s,i) -> `BTYP_var (i,`BTYP_type)) vs

(* drop first n elements of list l *)
let rec drop l n = 
  if n = 0 then l else drop (tl l) (n-1)

let check_instance syms (bbdfns:fully_bound_symbol_table_t) (child_map:child_map_t)
  (inst:int) (inst_id: string) inst_vs inst_sr inst_props tc inst_ts 
=
  let tc_id, _, tc_sr, tc_entry = Hashtbl.find bbdfns tc in
  match tc_entry with
  | `BBDCL_typeclass (tc_props, tc_bvs) ->
    (*
    print_endline ("Found " ^ inst_id ^ "<"^si inst ^ ">" ^
    "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "]" ^
    " to be instance of typeclass " ^ tc_id ^ "<"^si tc^">")
    ;
    print_endline ("Typeclass vs = " ^ 
      catmap "," (fun (s,j) -> s^"<"^si j^">") tc_bvs
    );
    *)
    if length tc_bvs <> length inst_ts then
      clierr2 inst_sr tc_sr 
      ("Wrong number of arguments, expected match for " ^
        catmap "," (fun (s,j) -> s^"<"^si j^">") tc_bvs ^
       "\nbut got " ^
       "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "]" 
      )
    ;

    let tc_kids = try Hashtbl.find child_map tc with Not_found -> [] in
    let inst_kids = try Hashtbl.find child_map inst with Not_found -> [] in
    (*
    print_endline ("Typeclass kids " ^ catmap "," si tc_kids);
    print_endline ("Instance kids " ^ catmap "," si inst_kids);
    *)
    let inst_map = fold_left (fun acc i-> 
      let id,_,_,entry = Hashtbl.find bbdfns i in
      match entry with
      | `BBDCL_fun (_,bvs,params,ret,_,_,_) ->
        let argt  : btypecode_t= typeoflist params in
        let qt = bvs,`BTYP_function (argt,ret) in
        (id,(i,qt)) :: acc

      | `BBDCL_proc (_,bvs,params,_,_) ->
        let argt  : btypecode_t= typeoflist params in
        let qt = bvs,`BTYP_function (argt,`BTYP_void) in
        (id,(i,qt)) :: acc
        
      | `BBDCL_procedure (_,bvs,bps,_) ->
        let argt : btypecode_t = typeoflist (typeofbps_traint bps) in
        let qt = bvs,`BTYP_function (argt,`BTYP_void) in
        (id,(i,qt)) :: acc

      | `BBDCL_function (_,bvs,bps,ret,_) -> 
        let argt : btypecode_t = typeoflist (typeofbps_traint bps) in
        let qt = bvs,`BTYP_function (argt,ret) in
        (id,(i,qt)) :: acc

      | _ -> acc
      ) [] inst_kids
    in
    let check_binding tck sr id tck_bvs tctype =
      let entries = filter (fun (name,x) -> name = id) inst_map in
      match entries with
      | [] -> clierr sr ("Cannot find typeclass virtual " ^ id ^ " in instance")
      | [_,(i,(inst_funbvs,t))] -> 
        (*
        print_endline ("Typeclass " ^ tc_id ^ "<" ^ si tc ^">" ^ print_bvs tc_bvs);
        print_endline ("Typeclass function " ^ id ^ "<" ^ si tck ^ ">" ^ 
          print_bvs tck_bvs ^ ":" ^ sbt syms.dfns tctype
        );

        print_endline ("Instance vs = " ^ print_bvs inst_vs);
        print_endline ("Instance ts = " ^ catmap "," (sbt syms.dfns) inst_ts);
        print_endline ("Instance function " ^ id ^ "<"^si i^">" ^ print_bvs inst_funbvs ^
        ":" ^ sbt syms.dfns t);
        *)

        let tc_ptv = length tck_bvs - length tc_bvs in
        (*
        print_endline ("Typeclass fun has " ^ si tc_ptv ^ " private type variables");
        *)

        let inst_ptv = length inst_funbvs - length inst_vs in
        (*
        print_endline ("Instance fun has " ^ si inst_ptv ^ " private type variables");
        *)

        if inst_ptv <> tc_ptv then
        clierr sr ("Wrong number of type parameters in instance fun!\n" ^
          "Expected " ^ si tc_ptv ^ "\n" ^
          "Got " ^ si inst_ptv 
        );

        let inst_funts = inst_ts @ vs2ts (drop inst_funbvs (length inst_vs)) in
        
        assert (length tck_bvs = length inst_funts);

        let tct = reduce_type (tsubst tck_bvs inst_funts tctype) in
        (*
        print_endline ("Typeclass function (instantiated) " ^ id ^ "<" ^ si tck ^ ">" ^ 
          ":" ^ sbt syms.dfns tct
        );
        *)

        let matches =  type_match syms.dfns tct t  && type_match syms.dfns t tct in
        if matches then 
          (*
          print_endline "Matches!";
          *)
          ()
        else
          clierr sr "Sole instance doesn't match virtual"
         ; 
        if Hashtbl.mem syms.typeclass_to_instance (tck,inst_ts) 
        then 
          clierr sr "Instance already registered??"
        ;
        Hashtbl.add syms.typeclass_to_instance (tck,inst_ts) i;
        (*
        print_endline ("Register mapping " ^ si tck ^ 
           "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "] -> " ^ si i
        );
        *)

      | _ -> clierr sr ("Felix can't handle overloads in typeclass instances yet, " ^ id ^ " is overloaded")
    in
    iter
    (fun tck -> 
      let tckid,tckparent,tcksr,tckentry = Hashtbl.find bbdfns tck in
      match tckentry with
      | `BBDCL_fun (props,bvs,params,ret,ct,breq,prec) ->
        if ct == `Virtual then
          let ft = `BTYP_function (typeoflist params,ret) in
          check_binding tck tcksr tckid bvs ft
        (*
        clierr tcksr "Typeclass requires virtual function";
        *)

      | `BBDCL_proc (props,bvs,params,ct,breq) ->
        if ct == `Virtual then 
          let ft = `BTYP_function (typeoflist params,`BTYP_void) in
          check_binding tck tcksr tckid bvs ft
        (*
        clierr tcksr "Typeclass requires virtual procedure";
        *)
        
      | `BBDCL_function _ 
      | `BBDCL_procedure _
      | `BBDCL_insert _ -> ()
      | _ -> clierr tcksr "Typeclass entry must be virtual function or procedure"
    )
    tc_kids


  | _ -> 
    clierr2 inst_sr tc_sr ("Expected " ^ inst_id ^ "<"^si inst ^ ">" ^
    "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "]" ^
    " to be typeclass instance, but" ^ tc_id ^ "<"^si tc^">, " ^
    "is not a typeclass" 
    )
  
let typeclass_instance_check syms bbdfns child_map = 
Hashtbl.iter
(fun i (id,_,sr,entry) -> match entry with
  | `BBDCL_instance (props, vs, tc, ts) ->
     check_instance syms bbdfns child_map i id vs sr props tc ts

  | _ -> ()
)
bbdfns

(* try to find a match for i,ts .. if it doesn't work,
   remove the last type on the list and retry.
   When found, return instance plus the removed
   tail, which are arguments to the functions personal
   type variables
*)
let fixup_typeclass_instance syms i ts =
  let rec aux ts1 ts2 = match ts1 with
    | [] -> i,ts (* not found *)
    | h::t ->
      match try 
        Some (Hashtbl.find syms.typeclass_to_instance (i,rev ts1)) 
        with Not_found -> None
      with
      | Some i -> i,ts2
      | None -> aux t (h::ts2)
  in aux (rev ts) []

