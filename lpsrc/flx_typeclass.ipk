@head(1,"Typeclass checker")
@h = tangler("src/flx_typeclass.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_child

val typeclass_instance_check:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  child_map_t ->
  unit

val fixup_typeclass_instance:
  sym_state_t -> 
  int ->
  btypecode_t list ->
  int * btypecode_t list
 
@h = tangler("src/flx_typeclass.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child

let vs2ts vs = map (fun (s,i) -> `BTYP_var (i,`BTYP_type)) vs

(* drop first n elements of list l *)
let rec drop l n = 
  if n = 0 then l else drop (tl l) (n-1)

let check_instance syms (bbdfns:fully_bound_symbol_table_t) (child_map:child_map_t)
  (inst:int) (inst_id: string) inst_vs inst_sr inst_props tc inst_ts 
=
  let tc_id, _, tc_sr, tc_entry = Hashtbl.find bbdfns tc in
  match tc_entry with
  | `BBDCL_typeclass (tc_props, tc_bvs) ->
    (*
    print_endline ("Found " ^ inst_id ^ "<"^si inst ^ ">" ^
    "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "]" ^
    " to be instance of typeclass " ^ tc_id ^ "<"^si tc^">")
    ;
    print_endline ("Typeclass vs = " ^ 
      catmap "," (fun (s,j) -> s^"<"^si j^">") tc_bvs
    );
    *)
    if length tc_bvs <> length inst_ts then
      clierr2 inst_sr tc_sr 
      ("Wrong number of arguments, expected match for " ^
        catmap "," (fun (s,j) -> s^"<"^si j^">") tc_bvs ^
       "\nbut got " ^
       "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "]" 
      )
    ;

    let tc_kids = try Hashtbl.find child_map tc with Not_found -> [] in
    let inst_kids = try Hashtbl.find child_map inst with Not_found -> [] in
    (*
    print_endline ("Typeclass kids " ^ catmap "," si tc_kids);
    print_endline ("Instance kids " ^ catmap "," si inst_kids);
    *)
    let inst_map = fold_left (fun acc i-> 
      let id,_,_,entry = Hashtbl.find bbdfns i in
      match entry with
      | `BBDCL_fun (_,bvs,params,ret,_,_,_) ->
        let argt  : btypecode_t= typeoflist params in
        let qt = bvs,`BTYP_function (argt,ret) in
        (id,(i,qt)) :: acc

      | `BBDCL_proc (_,bvs,params,_,_) ->
        let argt  : btypecode_t= typeoflist params in
        let qt = bvs,`BTYP_function (argt,`BTYP_void) in
        (id,(i,qt)) :: acc
        
      | `BBDCL_procedure (_,bvs,bps,_) ->
        let argt : btypecode_t = typeoflist (typeofbps_traint bps) in
        let qt = bvs,`BTYP_function (argt,`BTYP_void) in
        (id,(i,qt)) :: acc

      | `BBDCL_function (_,bvs,bps,ret,_) -> 
        let argt : btypecode_t = typeoflist (typeofbps_traint bps) in
        let qt = bvs,`BTYP_function (argt,ret) in
        (id,(i,qt)) :: acc

      | _ -> acc
      ) [] inst_kids
    in
    let check_binding tck sr id tck_bvs tctype =
      let entries = filter (fun (name,x) -> name = id) inst_map in
      match entries with
      | [] -> clierr sr ("Cannot find typeclass virtual " ^ id ^ " in instance")
      | [_,(i,(inst_funbvs,t))] -> 
        (*
        print_endline ("Typeclass " ^ tc_id ^ "<" ^ si tc ^">" ^ print_bvs tc_bvs);
        print_endline ("Typeclass function " ^ id ^ "<" ^ si tck ^ ">" ^ 
          print_bvs tck_bvs ^ ":" ^ sbt syms.dfns tctype
        );

        print_endline ("Instance vs = " ^ print_bvs inst_vs);
        print_endline ("Instance ts = " ^ catmap "," (sbt syms.dfns) inst_ts);
        print_endline ("Instance function " ^ id ^ "<"^si i^">" ^ print_bvs inst_funbvs ^
        ":" ^ sbt syms.dfns t);
        *)

        let tc_ptv = length tck_bvs - length tc_bvs in
        (*
        print_endline ("Typeclass fun has " ^ si tc_ptv ^ " private type variables");
        *)

        let inst_ptv = length inst_funbvs - length inst_vs in
        (*
        print_endline ("Instance fun has " ^ si inst_ptv ^ " private type variables");
        *)

        if inst_ptv <> tc_ptv then
        clierr sr ("Wrong number of type parameters in instance fun!\n" ^
          "Expected " ^ si tc_ptv ^ "\n" ^
          "Got " ^ si inst_ptv 
        );

        let inst_funts = inst_ts @ vs2ts (drop inst_funbvs (length inst_vs)) in
        
        assert (length tck_bvs = length inst_funts);

        let tct = reduce_type (tsubst tck_bvs inst_funts tctype) in
        (*
        print_endline ("Typeclass function (instantiated) " ^ id ^ "<" ^ si tck ^ ">" ^ 
          ":" ^ sbt syms.dfns tct
        );
        *)

        let matches =  tct = t in
        if matches then 
          (*
          print_endline "Matches!";
          *)
          ()
        else
          clierr sr "Sole instance doesn't match virtual"
        ; 
        let old = 
          try Hashtbl.find syms.typeclass_to_instance tck 
          with Not_found -> []
        in
        let entry = inst_vs , inst_ts , i in
        if mem entry old then
          clierr sr "Instance already registered??"
        else
          Hashtbl.replace syms.typeclass_to_instance tck (entry :: old);
        
        (*
        print_endline ("Register mapping " ^ si tck ^ 
        print_bvs inst_vs ^
           "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "] -> " ^ si i
        );
        *)

      | _ -> clierr sr ("Felix can't handle overloads in typeclass instances yet, " ^ id ^ " is overloaded")
    in
    iter
    (fun tck -> 
      let tckid,tckparent,tcksr,tckentry = Hashtbl.find bbdfns tck in
      match tckentry with
      | `BBDCL_fun (props,bvs,params,ret,ct,breq,prec) ->
        if ct == `Virtual then
          let ft = `BTYP_function (typeoflist params,ret) in
          check_binding tck tcksr tckid bvs ft
        (*
        clierr tcksr "Typeclass requires virtual function";
        *)

      | `BBDCL_proc (props,bvs,params,ct,breq) ->
        if ct == `Virtual then 
          let ft = `BTYP_function (typeoflist params,`BTYP_void) in
          check_binding tck tcksr tckid bvs ft
        (*
        clierr tcksr "Typeclass requires virtual procedure";
        *)
        
      | `BBDCL_function _ 
      | `BBDCL_procedure _
      | `BBDCL_insert _ -> ()
      | _ -> clierr tcksr "Typeclass entry must be virtual function or procedure"
    )
    tc_kids


  | _ -> 
    clierr2 inst_sr tc_sr ("Expected " ^ inst_id ^ "<"^si inst ^ ">" ^
    "[" ^ catmap "," (sbt syms.dfns) inst_ts ^ "]" ^
    " to be typeclass instance, but" ^ tc_id ^ "<"^si tc^">, " ^
    "is not a typeclass" 
    )
  
let typeclass_instance_check syms bbdfns child_map = 
Hashtbl.iter
(fun i (id,_,sr,entry) -> match entry with
  | `BBDCL_instance (props, vs, tc, ts) ->
     check_instance syms bbdfns child_map i id vs sr props tc ts

  | _ -> ()
)
bbdfns

(* try to find a match for i,ts .. if it doesn't work,
   remove the last type on the list and retry.
   When found, return instance plus the removed
   tail, which are arguments to the functions personal
   type variables
*)

let chk syms i ts (inst_vs, inst_ts, j)  = 
     if length inst_ts > length ts then
       failwith (
         "Not enough ts given, expected at least " ^ 
         si (length inst_ts) ^ ", got " ^ si (length ts)
       )
     ;
     (* solve for vs' *)
     let vset = fold_left (fun acc (_,i) -> IntSet.add i acc) IntSet.empty inst_vs in
     let eqns = combine (list_prefix ts (length inst_ts)) inst_ts in
     let mgu = 
       try Some (unification false syms.dfns eqns vset) 
       with Not_found -> None
     in
     begin match mgu with 
     | None -> None
     | Some mgu ->
       let tsv = 
         map 
         (fun (s,i) ->
           if not (mem_assoc i mgu) then
             failwith ("Didn't solve for instance type variable " ^ s)
           else 
           (
             (*
             print_endline ("Solved " ^ s ^ "-> " ^ sbt syms.dfns (assoc i mgu));
             *)
             assoc i mgu
           )
         )
         inst_vs
       in
       let tail = drop ts (length inst_ts) in
       let ts = tsv @ tail in
       (*
       print_endline ("Remap to " ^ si j ^ "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
       *)
       Some (j,ts)
     end

let fixup_typeclass_instance syms i ts =
  let entries = 
    try Hashtbl.find syms.typeclass_to_instance i 
    with Not_found -> []
   in
   let entries = fold_left (fun acc x -> match chk syms i ts x with
     | None -> acc
     | Some x -> x::acc
     ) [] entries
   in
   match entries with
   | [] -> i,ts
   | [j,ts] -> j,ts
   | _ -> failwith "can't handle overlapping instances yet"

