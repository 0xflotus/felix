@head(1,"C/C++ typings")
@h = tangler("src/flx_ctypes.mli")
@select(h)

type cexpr_t =
[
  | `Ce_atom of string
  | `Ce_postfix of string * cexpr_t
  | `Ce_prefix of string  * cexpr_t
  | `Ce_infix of string * cexpr_t * cexpr_t

  | `Ce_call of cexpr_t * cexpr_t list
  | `Ce_array of cexpr_t * cexpr_t
  | `Ce_new of cexpr_t list * string * cexpr_t list
  | `Ce_cast of string * cexpr_t
  | `Ce_cond of cexpr_t * cexpr_t * cexpr_t 
]


(* These are constructors for C terms representing
   actual C types. This includes incomplete types,
   functions and arrays (which have real types, 
   even though there are no corresponding first class values).

  Note there are no refernce types, and no const types.
*)

type ctype_t = 
[
  | `Ct_base of string
  | `Ct_ptr of ctype_t
  | `Ct_cptr of ctype_t
  | `Ct_vptr of ctype_t
  | `Ct_cvptr of ctype_t
  | `Ct_ptm of string * ctype_t
  | `Ct_cptm of string * ctype_t
  | `Ct_vptm of string * ctype_t
  | `Ct_cvptm of string * ctype_t
  | `Ct_array of int * ctype_t
  | `Ct_varray of ctype_t
  | `Ct_fun of ctype_t * ctype_t list
  | `Ct_vfun of ctype_t * ctype_t list 
    (* argument list must not be empty for varags *)
]

(* The decl type is the type term used in a declaration,
  it is not a type, but the combination of a type
  and an access modifier. For example:

  int const * const x;

  declares x to be const lvalue 
  of type pointer-const to int
*)

type cdecl_type_t =
[
  | `Cdt_value of ctype_t
  | `Cdt_const of ctype_t
  | `Cdt_volatile of ctype_t
  | `Cdt_const_volatile of ctype_t
  | `Cdt_ref of ctype_t
  | `Cdt_cref of ctype_t
  | `Cdt_vref of ctype_t
  | `Cdt_cvref of ctype_t
]

@h = tangler("src/flx_ctype.mli")
@select(h)
open Flx_ctypes

val string_of_ctype: ctype_t -> string
val string_of_cdecl_type: string -> cdecl_type_t -> string

@h = tangler("src/flx_ctype.ml")
@select(h)
open Flx_ctypes

(* suffixes apply first, then dereferences so
  int *t[2]
  
is an array of 2 pointers, brackets are needed
for a pointer to an array of 2 ints:

  int ( *t )[2]

Lower value in table indicates higher precedence.
*)

let prec = function
| `Ct_base _ -> 0
| `Ct_array _
| `Ct_varray _
| `Ct_fun _
| `Ct_vfun _ -> 1
| `Ct_ptr _
| `Ct_cptr _
| `Ct_vptr _
| `Ct_cvptr _
| `Ct_ptm _
| `Ct_cptm _
| `Ct_vptm _
| `Ct_cvptm _ -> 2

let rec plist ps =
  String.concat ", " 
  (
    List.map (fun t -> aux t "" ) ps
  ) 


and aux (t:ctype_t) s = 
  let br s = "(" ^ s ^ ")" in
  match t with
  | `Ct_base x -> 
    if String.length x = 0 
    then s 
    else if String.length s = 0 then x
    else x ^ " " ^ s

  | `Ct_ptr t -> aux t ("*"^s) 
  | `Ct_cptr t -> aux t (" const*"^s) 
  | `Ct_vptr t -> aux t (" volatile*"^s) 
  | `Ct_cvptr t -> aux t (" const volatile*"^s) 

  | `Ct_ptm (k,t) -> aux t (k ^ "::*" ^ s) 
  | `Ct_cptm (k,t) -> aux t ("const "^ k ^ "::*" ^ s) 
  | `Ct_vptm (k,t) -> aux t ("volatile " ^ k ^ "::*"^ s) 
  | `Ct_cvptm (k,t) -> aux t ("const volatile " ^ k ^ "::*" ^ s) 

  | `Ct_array (i,t) -> aux t (br s ^ "["^string_of_int i^"]" ) 
  | `Ct_varray t -> aux t (br s ^ "[]") 
  | `Ct_fun (t,ps) -> 
    let args =  plist ps in
    aux t (br s ^ "(" ^ args ^ ")" )
    
  | `Ct_vfun (t,ps) ->
    let args = plist ps ^ ", ..." in
    aux t (br s ^ "(" ^ args ^ ")") 

let string_of_ctype t = aux t "" 

let string_of_cdecl_type n t = 
  match t with
  | `Cdt_value t -> aux t n
  | `Cdt_const t -> aux t ("const " ^ n)
  | `Cdt_volatile t -> aux t ("volatile " ^n)
  | `Cdt_const_volatile t -> aux t ("const volatile " ^n)
  | `Cdt_ref t -> aux t ("& " ^ n)
  | `Cdt_cref t -> aux t ("const &" ^n)
  | `Cdt_vref t -> aux t ("volatile &"^n)
  | `Cdt_cvref t -> aux t ("const volatile &"^n)
 
@h = tangler("src/flx_ctparse.mly")
@select(h)
%{
open flx_ctypes
%}

{
}

@h = tangler("src/flx_cexpr.mli")
@select(h)
open Flx_ctypes
val string_of_cexpr : cexpr_t -> string

@h = tangler("src/flx_cexpr.ml")
@select(h)
let iter = List.iter
let map = List.map
let find = Hashtbl.find
let strcat = String.concat
let add = Hashtbl.add

let precedence = [
"atom";
"primary";
"postfix";
"unary";
"cast";
"pm";
"mult";
"add";
"shift";
"rel";
"eq";
"band";
"bxor";
"bor";
"and";
"xor";
"or";
"cond";
"assign";
"comma"

]

let postfix_cops = [
  "++","postfix";
  "--","postfix";
]

let prefix_cops = [
  "~","primary";
  "+","unary";
  "-","unary";
  "!","unary";
  "&","unary";
  "*","unary";
  "++","unary";
  "--","unary";
  "sizeof","unary";
]

let infix_cops = [
  "+","add";
  "-","add";
  "*","mult";
  "/","mult";
  "%","mult";
  "<<","shift";
  ">>","shift";

  "&","band";
  "|","bor";
  "^","bxor";

  "&&","and";
  "||","or";

  "+=","assign";
  "-=","assign";
  "*=","assign";
  "/=","assign";
  "%=","assign";
  "<<=","assign";
  ">>=","assign";
  "&=","assign";
  "|=","assign";
  "^=","assign";

  "<","rel";
  ">","rel";
  ">=","rel";
  "<=","rel";
  "==","eq";
  "!=","eq";

  ".","postfix";
  "->","postfix";
  ".*","pm";
  "->*","pm";
  ",","comma";
]
;;

let prec = Hashtbl.create 17
let infix = Hashtbl.create 31
let prefix = Hashtbl.create 17
let postfix = Hashtbl.create 17
let seq = ref 0
;;
iter (fun x -> add prec x !seq; incr seq; incr seq) precedence;
iter (fun (n,p) -> add infix n (find prec p)) infix_cops;
iter (fun (n,p) -> add prefix n (find prec p)) prefix_cops;
iter (fun (n,p) -> add postfix n (find prec p)) postfix_cops
;;

let pr cop =
 match cop with
  | `Ce_atom _ -> 0
  | `Ce_postfix (s,_) -> find postfix s
  | `Ce_prefix (s,_) -> find prefix s
  | `Ce_infix (s,_,_) -> find infix s

  | `Ce_call _ 
  | `Ce_array _ -> find prec "postfix"

  | `Ce_new _ -> find prec "unary"
  | `Ce_cast _ -> find prec "cast"
  | `Ce_cond _ -> find prec "cond"

let commaprec = find prec "comma"
let rec comma es = "(" ^ strcat ", " (map (cep commaprec) es) ^ ")" 
and comma_opt = function | [] -> "" | ps -> comma ps

(* we need brackets if the binding looseness if higher
than or equal to the context.

But due associativity, (x+y)+z = x+y+z, and we make that
happen by making the context of the LHS subexpression 
slightly higher.
*)
and cep cp e = 
  let ep = pr e in
  let rce e = cep ep e and lce e = cep (ep+1) e in
  let need_brackets = ep >= cp in
  (if need_brackets then "(" else "") 
  ^
  begin match e with
    | `Ce_atom s ->  s
    | `Ce_postfix (s,e) -> rce e ^ s
    | `Ce_prefix (s,e) -> s ^ rce e
    | `Ce_infix (s,e1,e2) -> lce e1 ^ s ^ rce e2

    | `Ce_call (f,es) -> rce f ^comma es
    | `Ce_array (f,e) -> rce f ^ "["^lce e^"]"
    | `Ce_new (ps,cls,args) -> 
      "new" ^ comma_opt ps ^ " " ^ comma_opt args
    | `Ce_cast (cast,e) -> cast ^ rce e
    | `Ce_cond (e,e1,e2) -> lce e ^ "?" ^ rce e1 ^ ":" ^ rce e2
  end
  ^
  (if need_brackets then ")" else "")

let string_of_cexpr e = cep 1000 e

