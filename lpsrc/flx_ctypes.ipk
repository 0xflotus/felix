@head(1,"C/C++ typings")
@h = tangler("src/compiler/flxcclib/flx_ctypes.mli")
@select(h)

type cexpr_t =
[
  | `Ce_atom of string
  | `Ce_postfix of string * cexpr_t
  | `Ce_prefix of string  * cexpr_t
  | `Ce_infix of string * cexpr_t * cexpr_t

  | `Ce_call of cexpr_t * cexpr_t list
  | `Ce_array of cexpr_t * cexpr_t
  | `Ce_new of cexpr_t list * string * cexpr_t list
  | `Ce_cast of string * cexpr_t
  | `Ce_cond of cexpr_t * cexpr_t * cexpr_t 
  | `Ce_expr of string * string 
]


(* These are constructors for C terms representing
   actual C types. This includes incomplete types,
   functions and arrays (which have real types, 
   even though there are no corresponding first class values).

  Note there are no refernce types, and no const types.
*)

type ctype_t = 
[
  | `Ct_base of string
  | `Ct_ptr of ctype_t
  | `Ct_cptr of ctype_t
  | `Ct_vptr of ctype_t
  | `Ct_cvptr of ctype_t
  | `Ct_ptm of string * ctype_t
  | `Ct_cptm of string * ctype_t
  | `Ct_vptm of string * ctype_t
  | `Ct_cvptm of string * ctype_t
  | `Ct_array of int * ctype_t
  | `Ct_varray of ctype_t
  | `Ct_fun of ctype_t * ctype_t list
  | `Ct_vfun of ctype_t * ctype_t list 
    (* argument list must not be empty for varags *)
]

(* The decl type is the type term used in a declaration,
  it is not a type, but the combination of a type
  and an access modifier. For example:

  int const * const x;

  declares x to be const lvalue 
  of type pointer-const to int
*)

type cdecl_type_t =
[
  | `Cdt_value of ctype_t
  | `Cdt_const of ctype_t
  | `Cdt_volatile of ctype_t
  | `Cdt_const_volatile of ctype_t
  | `Cdt_ref of ctype_t
  | `Cdt_cref of ctype_t
  | `Cdt_vref of ctype_t
  | `Cdt_cvref of ctype_t
]

@h = tangler("src/compiler/flxcclib/flx_ctype.mli")
@select(h)
open Flx_ctypes

val string_of_ctype: ctype_t -> string
val string_of_cdecl_type: string -> cdecl_type_t -> string

@h = tangler("src/compiler/flxcclib/flx_ctype.ml")
@select(h)
open Flx_ctypes

(* suffixes apply first, then dereferences so
  int *t[2]
  
is an array of 2 pointers, brackets are needed
for a pointer to an array of 2 ints:

  int ( *t )[2]

Lower value in table indicates higher precedence.
*)

let prec = function
| `Ct_base _ -> 0
| `Ct_array _
| `Ct_varray _
| `Ct_fun _
| `Ct_vfun _ -> 1
| `Ct_ptr _
| `Ct_cptr _
| `Ct_vptr _
| `Ct_cvptr _
| `Ct_ptm _
| `Ct_cptm _
| `Ct_vptm _
| `Ct_cvptm _ -> 2

let rec plist ps =
  String.concat ", " 
  (
    List.map (fun t -> aux t "" ) ps
  ) 


and aux (t:ctype_t) s = 
  let br s = "(" ^ s ^ ")" in
  match t with
  | `Ct_base x -> 
    if String.length x = 0 
    then s 
    else if String.length s = 0 then x
    else x ^ " " ^ s

  | `Ct_ptr t -> aux t ("*"^s) 
  | `Ct_cptr t -> aux t (" const*"^s) 
  | `Ct_vptr t -> aux t (" volatile*"^s) 
  | `Ct_cvptr t -> aux t (" const volatile*"^s) 

  | `Ct_ptm (k,t) -> aux t (k ^ "::*" ^ s) 
  | `Ct_cptm (k,t) -> aux t ("const "^ k ^ "::*" ^ s) 
  | `Ct_vptm (k,t) -> aux t ("volatile " ^ k ^ "::*"^ s) 
  | `Ct_cvptm (k,t) -> aux t ("const volatile " ^ k ^ "::*" ^ s) 

  | `Ct_array (i,t) -> aux t (br s ^ "["^string_of_int i^"]" ) 
  | `Ct_varray t -> aux t (br s ^ "[]") 
  | `Ct_fun (t,ps) -> 
    let args =  plist ps in
    aux t (br s ^ "(" ^ args ^ ")" )
    
  | `Ct_vfun (t,ps) ->
    let args = plist ps ^ ", ..." in
    aux t (br s ^ "(" ^ args ^ ")") 

let string_of_ctype t = aux t "" 

let string_of_cdecl_type n t = 
  match t with
  | `Cdt_value t -> aux t n
  | `Cdt_const t -> aux t ("const " ^ n)
  | `Cdt_volatile t -> aux t ("volatile " ^n)
  | `Cdt_const_volatile t -> aux t ("const volatile " ^n)
  | `Cdt_ref t -> aux t ("& " ^ n)
  | `Cdt_cref t -> aux t ("const &" ^n)
  | `Cdt_vref t -> aux t ("volatile &"^n)
  | `Cdt_cvref t -> aux t ("const volatile &"^n)
 
@h = tangler("src/compiler/flxlib/flx_cexpr.mli")
@select(h)
open Flx_ast
open Flx_ctypes

val string_of_cexpr : cexpr_t -> string
val sc : prec_t -> cexpr_t -> string
val ce : prec_t -> string -> cexpr_t

val ce_atom : string -> cexpr_t
val ce_postfix : string -> cexpr_t -> cexpr_t
val ce_prefix : string -> cexpr_t -> cexpr_t
val ce_infix : string -> cexpr_t -> cexpr_t -> cexpr_t
val ce_call : cexpr_t -> cexpr_t list -> cexpr_t
val ce_array : cexpr_t -> cexpr_t -> cexpr_t
val ce_new : cexpr_t list -> string -> cexpr_t list -> cexpr_t
val ce_cast : string -> cexpr_t -> cexpr_t
val ce_cond : cexpr_t -> cexpr_t -> cexpr_t -> cexpr_t
val ce_expr : prec_t -> string -> cexpr_t
val ce_top : string -> cexpr_t
val ce_dot : cexpr_t -> string -> cexpr_t
val ce_arrow : cexpr_t -> string -> cexpr_t
exception Unknown_prec of prec_t

val genprec: string -> prec_t -> string * prec_t 

@h = tangler("src/compiler/flxlib/flx_cexpr.ml")
@select(h)
open Flx_ctypes
exception Unknown_prec of string

let iter = List.iter
let map = List.map
let find = Hashtbl.find
let strcat = String.concat
let add = Hashtbl.add

let precedence = [
"atom";
"primary";
"postfix";
"unary";
"cast";
"pm";
"mult";
"add";
"shift";
"rel";
"eq";
"band";
"bxor";
"bor";
"and";
"xor";
"or";
"cond";
"assign";
"comma";
"expr"
]

let postfix_cops = [
  "++","postfix";
  "--","postfix";
]

let prefix_cops = [
  "~","primary";
  "+","unary";
  "-","unary";
  "!","unary";
  "&","unary";
  "*","unary";
  "++","unary";
  "--","unary";
  "sizeof","unary";
]

let infix_cops = [
  "+","add";
  "-","add";
  "*","mult";
  "/","mult";
  "%","mult";
  "<<","shift";
  ">>","shift";

  "&","band";
  "|","bor";
  "^","bxor";

  "&&","and";
  "||","or";

  "+=","assign";
  "-=","assign";
  "*=","assign";
  "/=","assign";
  "%=","assign";
  "<<=","assign";
  ">>=","assign";
  "&=","assign";
  "|=","assign";
  "^=","assign";

  "<","rel";
  ">","rel";
  ">=","rel";
  "<=","rel";
  "==","eq";
  "!=","eq";

  ".","postfix";
  "->","postfix";
  ".*","pm";
  "->*","pm";
  ",","comma";
]
;;

let remaps = [
  "$1++",("$1:postfix ++ ","postfix");
  "$1--",("$1:postfix -- ","postfix");

  "~$1",("~$1:unary","unary");
  "+$1",("+ $1:unary","unary");
  "-$1",("- $1:unary","unary");
  "!$1",("!$1:unary","unary");
  "&$1",("& $1:unary","unary");
  "*$1",("*$1:unary","unary");
  "++$1",("++ $1:unary","unary");
  "--$1",("-- $1:unary","unary");
  "$1+$2",("$1:add + $2:mult","add");
  "$1-$2",("$1:add - $2:mult","add");
  "$1*$2",("$1:mult * $2:pm","mult");
  "$1/$2",("$1:mult / $2:pm","mult");
  "$1%$2",("$1:mult % $2:pm","mult");

  "$1<<$2",("$1:shift << $2:band","shift");
  "$1>>$2",("$1:shift >> $2:band","shift");
  "$1&$2",("$1:band & $2:bor","band");
  "$1|$2",("$1:bor | $2:bxor","bor");
  "$1^$2",("$1:bxor ^ $2:and","bxor");
  "$1&&$2",("$1:and &&  $2:or","and");
  "$1||$2",("$1:or || $2:cond","or");

  "$1+=$2",("$1:cond += $2:assign","assign");
  "$1-=$2",("$1:cond -= $2:assign","assign");
  "$1*=$2",("$1:cond *= $2:assign","assign");
  "$1/=$2",("$1:cond /= $2:assign","assign");
  "$1%=$2",("$1:cond %= $2:assign","assign");
  "$1<<=$2",("$1:cond <<= $2:assign","assign");
  "$1>>=$2",("$1:cond >>= $2:assign","assign");
  "$1&=$2",("$1:cond &= $2:assign","assign");
  "$1|=$2",("$1:cond |= $2:assign","assign");
  "$1^=$2",("$1:cond ^= $2:assign","assign");

  "$1<$2",("$1:rel < $2:shift","rel");
  "$1>$2",("$1:rel > $2:shift","rel");
  "$1>=$2",("$1:rel >= $2:shift","rel");
  "$1<=$2",("$1:rel <= $2:shift","rel");
  "$1==$2",("$1:eq == $2:rel","eq");
  "$1!=$2",("$1:eq != $2:rel","eq");

  "$1($2)",("$1:postfix($2:assign)","postfix");
  "$1[$2]",("$1:postfix[$2:expr]","postfix");
  "$1->$2",("$1:postfix->$2:atom","postfix");
  "$1.*$2",("$1:pm.*$2:cast","pm");
  "$1->*$2",("$1:pm->*$2:cast","pm");
  "$1:comma,$2:comma",("$1,$2","comma");
]
;;

let prec = Hashtbl.create 17
let infix = Hashtbl.create 31
let prefix = Hashtbl.create 17
let postfix = Hashtbl.create 17
let prec_remap = Hashtbl.create 31
let seq = ref 0
;;
let find_prec p = 
  try Hashtbl.find prec p 
  with Not_found -> 
    raise (Unknown_prec p)
;; 

iter (fun x -> add prec x !seq; incr seq; incr seq) precedence;
iter (fun (n,p) -> add infix n (find_prec p)) infix_cops;
iter (fun (n,p) -> add prefix n (find_prec p)) prefix_cops;
iter (fun (n,p) -> add postfix n (find_prec p)) postfix_cops;
iter (fun (k,v) -> add prec_remap k v) remaps
;;

let pr cop =
 match cop with
  | `Ce_atom _ -> 0
  | `Ce_postfix (s,_) -> find postfix s
  | `Ce_prefix (s,_) -> find prefix s
  | `Ce_infix (s,_,_) -> find infix s

  | `Ce_call _ 
  | `Ce_array _ -> find_prec "postfix"

  | `Ce_new _ -> find_prec "unary"
  | `Ce_cast _ -> find_prec "cast"
  | `Ce_cond _ -> find_prec "cond"
  | `Ce_expr (p,_) -> find_prec p

let commaprec = find_prec "comma"
let rec comma es = "(" ^ strcat ", " (map (cep commaprec) es) ^ ")" 
and comma_opt = function | [] -> "" | ps -> comma ps

(* we need brackets if the binding looseness is higher
than or equal to the context.

But due associativity, (x+y)+z = x+y+z, and we make that
happen by making the context of the LHS subexpression 
slightly higher.
*)
and cep cp e = 
  let ep = pr e in
  let rce e = cep ep e and lce e = cep (ep+1) e in
  let need_brackets = ep > cp in
  (if need_brackets then "(" else "") 
  ^
  begin match e with
    | `Ce_atom s ->  s
    | `Ce_postfix (s,e) -> rce e ^ s
    | `Ce_prefix (s,e) -> s ^ rce e
    | `Ce_infix (s,e1,e2) -> lce e1 ^ s ^ rce e2

    | `Ce_call (f,es) -> rce f ^comma es
    | `Ce_array (f,e) -> rce f ^ "["^lce e^"]"
    | `Ce_new (ps,cls,args) -> 
      "new" ^ comma_opt ps ^ " " ^ cls ^ " " ^ comma_opt args
    | `Ce_cast (cast,e) -> "("^cast^")" ^ rce e
    | `Ce_cond (e,e1,e2) -> lce e ^ "?" ^ rce e1 ^ ":" ^ rce e2
    | `Ce_expr (_, s) -> s
  end
  ^
  (if need_brackets then ")" else "")

let ce_atom s = `Ce_atom s 
let ce_postfix o e = `Ce_postfix (o,e)
let ce_prefix o e = `Ce_prefix (o,e)
let ce_infix o a b = `Ce_infix (o,a,b)
let ce_call a b = `Ce_call (a,b)
let ce_array a b = `Ce_array (a,b)
let ce_new p c a = `Ce_new (p,c,a)
let ce_cast s e = `Ce_cast (s,e)
let ce_cond c a b = `Ce_cond (c,a,b)
let ce_expr p s = `Ce_expr (p,s)
let ce_top s = ce_expr "expr" s
let ce_dot e s = ce_infix "." e (ce_atom s)
let ce_arrow e s = ce_infix "->" e (ce_atom s)

let string_of_cexpr e = cep 1000 e
let sc p e = cep (find_prec p) e
let ce p s = ce_expr p s

let genprec ct prec =
  try Hashtbl.find prec_remap ct 
  with Not_found -> ct,prec

