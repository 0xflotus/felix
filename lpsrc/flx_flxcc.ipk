@head(1,'Flxcc wrapper generator')
@h= tangler("src/flxcc.ml")
@select(h)
open List
open Flx_util
open Flx_types
open Flx_version
open Flx_mtypes1
open Flx_cil_cabs
open Flx_cil_cil
;;

type stab_t = {
  stab_cfile: string;
  stab_flxfile: string;
  stab_flxinclude: string;
  stab_module: string;

  aliases: (string,string) Hashtbl.t;
  struct_aliases: (string,string) Hashtbl.t;
  abstract_types: (string,string) Hashtbl.t;
  incomplete_types: (string,string) Hashtbl.t;
  mutable xtyps: (string,string) Hashtbl.t;
  mutable udt: (string,unit) Hashtbl.t;
  mutable ict: (string,string) Hashtbl.t;
  used_types: (string,unit) Hashtbl.t;
  variables : (string,string) Hashtbl.t;
  functions: (string,string * string) Hashtbl.t;
  fields: (string,string * string) Hashtbl.t;
  procedures: (string,string * string) Hashtbl.t;
  enums: (string,string) Hashtbl.t;
  registry: (typsig, string * string) Hashtbl.t;
  mutable includes: StringSet.t;
  counter: int ref
}
;;

let isprefix p s =
  let pn = String.length p in
  String.length s >= pn &&
  String.sub s 0 pn = p
;;

exception Next
;;
type control_t = {
  mutable control_filename: string;
  mutable prein_filename: string;
  mutable preout_filename: string;
  mutable preprocessor: string;
  mutable raw_includes: StringSet.t;
  mutable raw_include_dirs : StringSet.t;
  mutable include_path: string list;
  mutable noincludes: string list;
  merge_files: (string,string) Hashtbl.t;
  rev_merge_files: (string,string list) Hashtbl.t;
  mutable outdir: string;
  stabs : (string,stab_t) Hashtbl.t;
  mutable special_subdirs : string list;
  all_types : (string,string) Hashtbl.t;
  incomplete_types_cache: (string,string * string list) Hashtbl.t;
  files: (string,string) Hashtbl.t;
  replacements : (string,string) Hashtbl.t;
  rejects: (string,unit) Hashtbl.t;
  mutable root_includes: string list;
  mutable root_rec_includes: string list;
  mutable root_excludes : string list;
}
;;

let control = {
  control_filename = Sys.argv.(1);
  prein_filename = "flxcc_prein.h";
  preout_filename = "flxcc_preout.hhh";
@tangle('  preprocessor ="'+FLXCC_CPP+'";')
  noincludes = [];
  raw_includes = StringSet.empty;
  raw_include_dirs = StringSet.empty;
  include_path = [];
  merge_files = Hashtbl.create 97;
  rev_merge_files = Hashtbl.create 97;
  outdir = "flxcc_out";
  stabs  = Hashtbl.create 97;
  special_subdirs = [];
  all_types = Hashtbl.create 97;
  incomplete_types_cache = Hashtbl.create 97;
  files = Hashtbl.create 97;
  replacements = Hashtbl.create 97;
  rejects = Hashtbl.create 97;
  root_rec_includes = [];
  root_includes = [];
  root_excludes = [];
}
;;

(* map the name of a #include file which is
  intended to be a physical part of another
  into that filename. 
  
  The mapping is used to prevent
  a Felix include file or module being
  created for definitions in this file,
  but it should *only* be used when a file
  is uniquely included by another

  When we're scanning for includes,
  we need all the physical (unmapped)
  filenames as inputs to find the transitive
  closure. Once that is done, the transitive
  closure itself must be mapped to avoid
  references to non-existent Felix modules.
*)

let map_filename f = 
  try Hashtbl.find control.merge_files f 
  with Not_found -> f
;;

let rec glob dir recurse level =
  if not (mem dir control.root_excludes) then
  let spaces = String.make level ' ' in
  try
    let f = Unix.opendir dir in
    control.raw_include_dirs <- StringSet.add dir control.raw_include_dirs;
    begin 
      try 
        while true do let m = Unix.readdir f in
          let path = Filename.concat dir m in
          let st = 
            try Unix.lstat path
            with _ -> failwith ("Can't lstat " ^ path)
          in
          match st.Unix.st_kind with
          | Unix.S_REG ->
            if not (mem path control.root_excludes) then
            control.raw_includes <- StringSet.add path control.raw_includes
            
          | Unix.S_DIR ->
            if recurse then
            if not (isprefix "." m) then
            begin
              glob path recurse (level + 1)
            end
            
          | _ -> ()
        done 
      with End_of_file -> Unix.closedir f
    end
  with Unix.Unix_error _ ->
    failwith ("Can't find directory " ^ dir)
;;

let f = open_in control.control_filename
;;
let pattern = ref "*.h" 
;;

let rec aux () =
  try 
    let line = input_line f in
    let n = String.length line in
    let i = ref 0 in
    try
        (* skip white *)
        while !i < n && line.[!i]=' ' do incr i done;
        if !i = n then raise Next;

        (* detect C++ style comment *)
        if isprefix "//" (String.sub line !i (n - !i))
        then raise Next
        ;
        let j = !i in
        while !i < n && line.[!i]<>' ' do incr i done;
        let keyword = String.sub line j (!i-j) in

        match keyword with
        | "outdir" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "outdir statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          control.outdir <- String.sub line j (!i-j);
          raise Next

        | "prein" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "prein statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          control.prein_filename <- String.sub line j (!i-j);
          raise Next

        | "preout" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "preout statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          control.preout_filename <- String.sub line j (!i-j);
          raise Next
        
        | "preprocessor" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "preprocessor statement requires arguments";
          let j = !i in
          while !i < n do incr i done;
          control.preprocessor <- String.sub line j (!i-j);
          raise Next

        | "noheader" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "noinclude statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn = String.sub line j (!i-j) in
          control.noincludes <- fn :: control.noincludes;
          raise Next

        | "incdir" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "incdir statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn = String.sub line j (!i-j) in
          control.root_includes <- fn :: control.root_includes;
          raise Next

        | "recincdir" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "incdir statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn = String.sub line j (!i-j) in
          control.root_rec_includes <- fn :: control.root_rec_includes;
          raise Next

        | "path" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "path statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn = String.sub line j (!i-j) in
          control.include_path <- fn :: control.include_path;
          raise Next

        | "exclude" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "exclude statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn = String.sub line j (!i-j) in
          control.root_excludes<- fn :: control.root_excludes;
          raise Next

        | "merge" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "merge statement requires filename";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn1 = String.sub line j (!i-j) in

          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "merge statement requires 2 filenames";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn2 = String.sub line j (!i-j) in
          Hashtbl.add control.merge_files fn1 fn2;
          let x = 
            try Hashtbl.find control.rev_merge_files fn2 
            with Not_found -> [] 
          in Hashtbl.replace control.rev_merge_files fn2 (fn1::x)
          ; 
          raise Next

        | "rename" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "rename statement requires name";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn1 = String.sub line j (!i-j) in

          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "rename statement requires 2 names";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn2 = String.sub line j (!i-j) in
          Hashtbl.add control.replacements fn1 fn2;
          raise Next

        | "ignore" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "ignore statement requires name";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn = String.sub line j (!i-j) in
          Hashtbl.add control.rejects fn ();
          raise Next

        | "subdir" ->
          while !i < n && line.[!i]=' ' do incr i done;
          if !i = n then failwith "subdir statement requires name";
          let j = !i in
          while !i < n && line.[!i]<>' ' do incr i done;
          let fn = String.sub line j (!i-j) in
          control.special_subdirs <- fn :: control.special_subdirs;
          raise Next

        | _ -> failwith ("Unknown keyword " ^keyword^ " in control file")

    with Next -> aux()
  with End_of_file -> ()
in aux()
;;

close_in f
;;

iter
(fun s -> glob s false 0)
control.root_includes
;;

iter
(fun s -> glob s true 0)
control.root_rec_includes
;;

let autocreate x =
  try open_out x 
  with | _ ->
  let rec mkpath x  =
    let d = Filename.dirname x in
    if d <> "" then begin
      try Unix.mkdir d 0o777 
      with _ -> 
        mkpath d;
        Unix.mkdir d 0o777 
    end
  in
  mkpath x;
  open_out x
;;

let f = autocreate control.prein_filename in
StringSet.iter 
(fun s ->
  output_string f ("#include \"" ^ s ^ "\"\n")
)
control.raw_includes
;
close_out f
;;

let precmd = 
  let path = ref "" in
  (*
  StringSet.iter
  (fun s -> path := !path ^ "-I" ^ s ^ " ")
  control.raw_include_dirs
  ;
  *)
  path := 
  (
    String.concat " " 
    (
      map 
      (fun s-> "-I"^s^" ")
      (rev control.include_path)
    )
  ) ^ " " ^ !path
  ;
  
  control.preprocessor ^ " " ^ 
  !path ^ " " ^
  control.prein_filename ^ 
  " >" ^control.preout_filename
;;

print_endline "PREPROCESSOR COMMAND:";
print_endline precmd
;;

Unix.system precmd
;;

let format_time tm = 
  si (tm.Unix.tm_year + 1900) ^ "/" ^
  si (tm.Unix.tm_mon + 1) ^ "/" ^
  si tm.Unix.tm_mday ^ " " ^
  si tm.Unix.tm_hour ^ ":" ^
  si tm.Unix.tm_min ^ ":" ^
  si tm.Unix.tm_sec 
;;

let compile_start = Unix.time () 
let compile_start_gm = Unix.gmtime compile_start 
let compile_start_local = Unix.localtime compile_start 
let compile_start_gm_string = format_time compile_start_gm ^ " UTC" 
let compile_start_local_string = format_time compile_start_local ^ " (local)" 
;;

Flx_cil_cil.initCIL()
;;

let lexbuf = Flx_cil_clexer.init control.preout_filename;;
let cabs = Flx_cil_cparser.file Flx_cil_clexer.initial lexbuf
;;
Flx_cil_clexer.finish()
;;

(*
Flx_cil_cprint.print_defs cabs;;
*)

let ns (s,_,_,_) = s
;;
let is_def = function | Some _ -> "complete" | None -> "incomplete"
;;
let type_of_se = function
| SpecType ts -> 
  begin match ts with
  | Tnamed s -> print_endline ("type " ^ s)
  | Tstruct (s,fglo,_) -> 
    print_endline ("struct " ^ s ^ " " ^ is_def fglo)
  | Tunion (s,fglo,_) -> 
    print_endline ("union " ^ s ^ " " ^ is_def fglo)
  | Tenum (s,fglo,_) -> 
    print_endline ("enum " ^ s ^ " " ^ is_def fglo)
  | _ -> ()
  end
| _ -> ()

let types_in sp = List.iter type_of_se sp
;;

let rec find_type d = match d with
 | FUNDEF ((spec,s),b,_,_) -> 
   print_endline ("fun " ^ns s);
   types_in spec

 | DECDEF ((spec,ss),_) -> 
   List.iter 
   (fun (s,_)-> print_endline ("Decl " ^ ns s)) 
   ss
   ;
   types_in spec

 | TYPEDEF ((sp,ss),_)-> 
   List.iter 
   (fun s -> 
     print_endline ("typedef " ^ ns s);
   ) 
   ss
   ;
   types_in sp
   
 | LINKAGE (s,_,cabs') ->
   if s = "C"
   then List.iter find_type cabs'
   else print_endline ("Unknown linkage " ^s)

 | ONLYTYPEDEF (spec,_) -> types_in spec
 | GLOBASM _  
 | PRAGMA _ 
 | TRANSFORMER _
 | EXPRTRANSFORMER _ -> ()
;;
(*
List.iter find_type cabs ;;
*)

let cil = Flx_cil_cabs2cil.convFile (control.preout_filename, cabs)
;;


(*
dumpFile defaultCilPrinter stdout cil ;;
*)

let {fileName=f; globals=gs} = cil
;;

(* files not corresponding to a module *)
let excludes : string list ref = ref
[
]
;;

let exclude_prefixes = ref [] (*"/usr/include/bits/"; "/usr/include/asm/"] *)
;;
let exclude_file f =
  let rec aux ts = match ts with
  | [] -> false
  | h :: t -> if isprefix h f then true else aux t
  in 
    aux !exclude_prefixes ||
    mem f !excludes
;;

let rplname s = 
  try Hashtbl.find control.replacements s 
  with Not_found -> s
;;

let soi = function
| IBool -> "bool"
| IChar -> "char"
| ISChar -> "tiny"
| IUChar -> "utiny"
| IInt -> "int"
| IUInt -> "uint"
| IShort -> "short"
| IUShort -> "ushort"
| ILong -> "long"
| IULong -> "ulong"
| ILongLong -> "vlong"
| IULongLong -> "uvlong"

let sof = function
| FFloat -> "float"
| FDouble -> "double"
| FLongDouble -> "ldouble"

| IFloat -> "imaginary"
| IDouble -> "dimaginary"
| ILongDouble -> "limaginary"

| CFloat -> "complex"
| CDouble -> "dcomplex"
| CLongDouble -> "lcomplex"

let cvqual a = 
  let const = ref false
  and volatile = ref false
  in
  List.iter
  (fun (Attr (s,_)) -> 
    if s = "const" then const := true
    else if s = "volatile" then volatile := true
  )
  a
  ;
  if !const && !volatile then "cv"
  else if !const then "c"
  else if !volatile then "v"
  else ""

let attrof = function
| TVoid a
| TInt (_,a) 
| TFloat (_,a)
| TPtr (_,a)
| TArray (_,_,a)
| TFun (_,_,_,a) 
| TNamed (_,a)
| TComp (_,a) 
| TEnum (_,a) 
| TBuiltin_va_list a 
-> a

let strexp n = "0" (* cheat *)
;;

let remove_pnames t = match t with
| TPtr (TFun (t,Some ps,b,a),a') ->
  let ps = map (fun (_,t,a)->"",t,a) ps in
  TPtr (TFun (t,Some ps,b,a),a')
| _ -> t

let rec sot ((registry,counter,modulename,used_types) as reg) t = 
match t with
| TVoid a -> "void_t"
| TInt (ik,a) -> soi ik
| TFloat (fk,a) -> sof fk
| TPtr (TVoid a',a) -> (cvqual a')^"address"
| TPtr (TFun _,a) ->
  let t' = typeSig t in
  begin try 
    fst (Hashtbl.find registry t')
  with
    Not_found ->
    let name = modulename ^"_cft_" ^ si !counter in
    incr counter;
    let sr = locUnknown in
    let t = remove_pnames t in
    let si = {tname=name;ttype=t;treferenced=true } in
    let gt =  GType (si,sr) in
    let d = defaultCilPrinter#pGlobal () gt in
    let s = Flx_cil_pretty.sprint 65 d in
    Hashtbl.add registry t' (name,s);
    name
  end
   
| TPtr (t',a) -> cvqual (attrof t') ^ "ptr[" ^ sot reg t'^ "]"
| TArray (t',Some n,a)-> 
  cvqual (attrof t') ^ "ptr[" ^ sot reg t'^ "]"

| TArray (t',None,a)-> 
  cvqual (attrof t') ^ "ptr[" ^ sot reg t' ^ "]"

| TFun (t',Some ps,false,a) ->
  let ret = sot reg t'
  and args = 
    if length ps = 0 then "1" 
    else String.concat " * " (List.map (soa reg) ps) 
  in args ^ " -> " ^ ret
    
| TFun (t',None,false,a) -> 
  let ret = sot reg t'
  and args = "1"
  in args ^ " -> " ^ ret

| TFun (t',_,_,a) -> "CANT HANDLE THIS FUN"

| TNamed (ti,a) -> 
  let name = ptname ti in 
  Hashtbl.add used_types name ();
  rplname name
  
| TComp (ci,a) ->  
  let name = pci ci in 
  Hashtbl.add used_types name ();
  rplname name

| TEnum (ei,a) -> "int"
| TBuiltin_va_list a -> "__builtin_va_list"

and ptname {tname=tname} = tname
and ciname {cname=cname} = cname
and einame {ename=ename} = ename
and viname {vname=vname} = vname

and pci ci = match ci with
{cname=cname; cstruct=cstruct} -> 
(if cstruct then "_struct_" else "_union_") ^ cname

and pcci ci = match ci with
{cname=cname; cstruct=cstruct} -> 
(if cstruct then "struct " else " union ") ^ cname

and pei ei = match ei with
{ename=ename} -> "_enum_" ^ ename

and pcei ei = match ei with
{ename=ename} -> "enum " ^ ename

and ptdef registry ti:string = match ti with
{ttype=tt} -> sot registry tt

and pcomp pi = match pi with
{cname=name} -> name

and soa registry (name,t,a) = sot registry t

and sov registry vi = match vi with
{vname=vname; vtype=vtype} ->
"const " ^ vname ^ ": " ^ sot registry vtype

let pe x = print_endline x
;;

let achk x = 
  let a = "__anon" in
  let n = String.length a in
  String.length x > n &&
  a = String.sub x 0 n 
  
let isanon = function
  | GType ({tname=tname},_) -> achk tname
  | GCompTag ({cname=cname},_) -> achk cname
  | GCompTagDecl ({cname=cname},_) -> achk cname
  | GEnumTag ({ename=ename},_) -> achk ename
  | GEnumTagDecl ({ename=ename},_) -> achk ename
  | GVarDecl ({vname=vname},_) -> false
  | GVar ({vname=vname},_,_) -> false
  | GFun (fd,sr) -> false
  | GAsm _ -> true
  | GPragma _ -> true
  | GText _ -> true


let flx_name' = function
  | GType ({tname=tname},_) -> Some tname
  | GCompTag (ci,sr) -> Some (pci ci)
  | GCompTagDecl (ci,_) -> Some (pci ci)
  | GEnumTag ({ename=ename},_) -> Some ename
  | GEnumTagDecl ({ename=ename},_) -> Some ename
  | GVarDecl ({vname=vname},_) -> Some vname
  | GVar ({vname=vname},_,_) -> Some vname
  | GFun ({svar={vname=vname}},sr) -> Some vname
  | GAsm _ -> None
  | GPragma _ -> None
  | GText _ -> None
;;

let flx_name x = match flx_name' x with 
| Some x -> Some (rplname x)
| None -> None
;;

let c_name = function
  | GType ({tname=tname},_) -> Some tname
  | GCompTag (ci,sr) -> Some (pcci ci)
  | GCompTagDecl (ci,_) -> Some (pcci ci)
  | GEnumTag (ei,_) -> Some "int"
  | GEnumTagDecl (ei,_) -> Some "int"
  | GVarDecl ({vname=vname},_) -> Some vname
  | GVar ({vname=vname},_,_) -> Some vname
  | GFun ({svar={vname=vname}},sr) -> Some vname
  | GAsm _ -> None
  | GPragma _ -> None
  | GText _ -> None
;;

let rec isanont t =  match t with
| TVoid _
| TInt _
| TFloat _ -> false
| TPtr (t,_) -> isanont t
| TArray (t,_,_) -> isanont t
| TFun (t,Some ps,_,_) -> 
  fold_left (fun b (_,t,_)-> b || isanont t ) (isanont t) ps

| TFun (t,None,_,_) -> isanont t
| TNamed ({tname=tname},_) -> achk tname
| TComp ({cname=cname},_) -> achk cname
| TEnum _ -> false
| TBuiltin_va_list _ -> false



let mk_stab cfile flxfile flxinclude flxmodule = {
  stab_cfile = cfile;
  stab_flxfile = flxfile;
  stab_flxinclude = flxinclude;
  stab_module = flxmodule;

  aliases= Hashtbl.create 97;
  struct_aliases= Hashtbl.create 97;
  abstract_types= Hashtbl.create 97;
  incomplete_types= Hashtbl.create 97;
  used_types= Hashtbl.create 97;
  variables= Hashtbl.create 97;
  functions= Hashtbl.create 97;
  fields= Hashtbl.create 97;
  procedures= Hashtbl.create 97;
  enums= Hashtbl.create 97;
  registry= Hashtbl.create 97;
  includes = StringSet.empty;
  xtyps = Hashtbl.create 97;
  ict = Hashtbl.create 97;
  udt = Hashtbl.create 97;
  counter = ref 1
}
;;

let chop_extension f =
  let b = Filename.basename f in
  let d = Filename.dirname f in
  let b = try Filename.chop_extension b with _ -> b in
  Filename.concat d b
;;

let flxinclude_of_cfile cfilename =
  let x = chop_extension cfilename ^ "_lib" in
  String.sub x 1 (String.length x - 1)
;;

let flxfile_of_cfile cfilename =
  let base = flxinclude_of_cfile cfilename in
  Filename.concat (control.outdir)  (base ^ ".flx")
;;

let module_of_filename fname =
  let srepl s c1 c2 =
    for i = 0 to String.length s - 1 do
      if s.[i]=c1 then s.[i] <- c2
    done
  in
  let basename = Filename.basename fname in
  let dirname = Filename.dirname fname in
  let subdirname = Filename.basename dirname in
  let prefix = 
    if mem subdirname control.special_subdirs then subdirname ^ "_"
    else ""
  in
  try 
    let x = prefix ^ (chop_extension basename) in
    srepl x '.' '_';
    srepl x ' ' '_';
    srepl x '/' '_';
    srepl x '-' '_';
    x ^ "_h"
  with Invalid_argument _ ->
    print_endline ("Weird (C++??) filename " ^ fname ^ " without extension");
    basename ^ "_hxx"
;;

let getstab s = 
  let s = map_filename s in
  try Hashtbl.find control.stabs s 
  with Not_found ->
    let x = mk_stab s 
      (flxfile_of_cfile s) 
      (flxinclude_of_cfile s) 
      (module_of_filename s) 
    in
    Hashtbl.add control.stabs s x;
    x
;;

let getreg {file=s} = 
  let stab = getstab s in 
  stab.registry,stab.counter,stab.stab_module,stab.used_types
;;


let rpl {file=s} which = 
  let stab = (getstab s) in
  match which with
  | `aliases (k,v) -> 
    Hashtbl.replace stab.aliases k v;
    Hashtbl.replace control.all_types k s
  
  | `struct_aliases(k,v)  -> 
    Hashtbl.replace stab.struct_aliases k v;
    Hashtbl.replace control.all_types k s

  | `abstract_types (k,v)  -> 
    Hashtbl.replace stab.abstract_types k v;
    Hashtbl.replace control.all_types k s

  | `incomplete_types (k,v)  -> Hashtbl.replace stab.incomplete_types k v
  | `variables(k,v)  ->  Hashtbl.replace stab.variables k v
  | `functions(k,v)  -> Hashtbl.replace stab.functions k v
  | `fields(k,v)  -> Hashtbl.replace stab.fields k v
  | `procedures(k,v)  -> Hashtbl.replace stab.procedures k v
  | `enums(k,v)  -> Hashtbl.replace stab.enums k v
;;

let ispublic s = 
 String.length s < 2 || String.sub s 0 2 <> "__" 
;;


let add_file fname =
  if not (exclude_file fname) then
  let m = module_of_filename fname in
  if not (Hashtbl.mem control.files m) then
    Hashtbl.add control.files m fname
  else 
    let existing_fname = Hashtbl.find control.files m in
    if not (fname = existing_fname) then 
    begin
      print_endline
      (
        "Duplicate module name " ^ m ^
        " for files \n" ^
        "Existing file: " ^ existing_fname ^ "\n" ^
        "Excluding new file: " ^ fname ^ "\n"
      );
      excludes := fname :: !excludes
    end
;;

let add_loc {file=fname} = 
  add_file fname
;;

let filename_of_module m =
  Hashtbl.find control.files m
;;

List.iter
(fun g-> let loc = get_globalLoc g in 
  add_loc loc;
  match isanon g,flx_name g,flx_name' g with
  | _,None,_ 
  | true,_,_ -> ()
  | _,Some _,None -> assert false
  | false,Some key,Some key' ->
  if not (Hashtbl.mem control.rejects key) then
  match g with
  | GType (ti,loc) -> 
    let registry = getreg loc in
    begin
      match ti with {ttype=ttype} ->
      match  ttype with 
      | TComp (ci,_) -> 
        let anon= achk (ciname ci) in
        begin match ci with { cfields=cfields } ->
        iter
        (fun {fname=fname; ftype=ftype} -> 
          if not (isanont ftype) && ispublic fname then
          let t = key ^ " -> " ^ sot registry ftype in
          rpl loc (`fields (("get_"^fname), (t,"$1."^fname)))
        )
        cfields
        end
        ;
        if anon then
          rpl loc (`abstract_types (key, key'))
        else
          let v = ptdef registry ti in
          rpl loc (`struct_aliases (key, v))


      | TEnum (ei,_) -> 
        begin match ei with { eitems=eitems } ->
        iter
        (fun (s,_,_) -> if ispublic s then rpl loc (`enums (rplname s,s)))
        eitems
        end
        ;
        if achk (einame ei) then
          rpl loc (`abstract_types (key, key'))
        else
          rpl loc (`aliases (key, (ptdef registry ti)))

      | TFun (_,_,true,_) -> 
        (* HACK: varargs function typedef *)
        rpl loc (`abstract_types (key, key'))

      | t ->
        if isanont t then
          rpl loc (`abstract_types (key, key'))
        else
          let v = ptdef registry ti in
          rpl loc (`aliases (key, v))
    end

  | GCompTag (ci,loc) -> 
    rpl loc (`abstract_types (key, (pcci ci)));
    begin match ci with { cfields=cfields } ->
    iter
    (fun {fname=fname; ftype=ftype} -> 
      if not (isanont ftype) && ispublic fname then
      let t = key ^ " -> " ^ sot (getreg loc) ftype in
      rpl loc (`fields (("get_"^fname), (t,"$1."^fname)))
    )
    cfields
    end

    
  | GCompTagDecl (ci,loc) -> 
    rpl loc (`incomplete_types (key, (pcci ci)))
    
  | GEnumTag (ei,loc) -> 
    rpl loc (`aliases (key, "int"));
    begin match ei with { eitems=eitems } ->
    iter
    (fun (s,_,_) -> if ispublic s then rpl loc (`enums (rplname s,s)))
    eitems
    end

  | GEnumTagDecl (ci,loc) -> rpl loc (`aliases (key, "int"))
  
  | GVar (vi,_,loc) 
  | GFun ({svar=vi},loc)
  | GVarDecl (vi,loc) ->
    let registry = getreg loc in
    let vname, vtype=
      match vi with {vname=vname; vtype=vtype}->vname,vtype 
    in
    if ispublic vname then
    begin match vtype with
    | TFun (TVoid _,Some ps,false,a) ->
      let args = 
        if length ps = 0 then "1" 
        else String.concat " * " (List.map (soa registry) ps) 
      in
      rpl loc (`procedures (key, (args,key'^"($a);")))

    | TFun (TVoid _,Some _,true,a) ->
      rpl loc (`procedures ((key^"[t]"), ("t",key'^"($a);")))

    | TFun (ret,Some ps,false,a) ->
      let ftb,ptb =
        let ret = sot (getreg loc) ret
        and args = List.map (soa registry) ps
        in 
        (
          (
            if length ps = 0 
            then "1" 
            else String.concat " * " args
          ) 
          ^ 
          " -> " ^ ret,key'^"($a)"
        ),
        (String.concat " * " (ret :: args),
          let a2 = 
            String.concat "," 
            (tl (tl 
              (
                map 
                (fun i->"$"^si i) 
                (nlist ((length ps)+2))
              )
            ))
          in
          "$1="^key'^"("^a2^");"
        )
      in 
        rpl loc (`functions (key, ftb))
        (*
        ;
        rpl loc (`procedures (key, ptb))
        *)

    | TFun (ret,Some _,true,a) ->
      let ftb =
        let ret = sot (getreg loc) ret in 
        "t -> " ^ ret,key'^"($a)"
      in 
        rpl loc (`functions ((key^"[t]"), ftb));
        
    | _ ->
      rpl loc (`variables (key, (sot (getreg loc) vtype)))
    end

  | GAsm _ -> print_endline "GASM"
  | GPragma _ -> print_endline "PRAGMA"
  | GText _ -> print_endline "TEXT"
)
gs
;;

(*
iter 
(fun s ->
  let s = Filename.concat control.outdir s in
  try Unix.mkdir s 0o777 
  with _ -> ()
)
control.special_subdirs
;;
*)
let is_nonempty h = 
  try 
    Hashtbl.iter (fun _ -> raise Not_found) h; 
    false
   with Not_found -> true
;;

(* This routine calculates the transitive closure
of includes of 'known' C header files, where
a file is 'known' if the table 'files' contains
a map from the file's deduced modulename.

This process in bugged in that a file's modulename
might map to a different file. We always know when
this happens when adding files during the processing
of preprocessed C headers because the preprocessor
has expanded them to absolute pathnames.

Currently, a warning is printed, rather than terminating
the process: to prevent the subsequent possibly hard to 
detect faults we should probably turn this warning into
an error.

Note that the set of known files excludes specifically
excluded files (as well as any file sharing the modulename
of an already registered file .. which one is included
is implementation dependent and thus fragile)

Note that the result found is NOT the intersection
of the known files with the transitive closure of
includes, because including a file outside the known
set, which subsequently includes on inside the known
set, will not introduce the latter into the closure,
even though it is actually known.
*)

let rec find_includes' includes fname =
  if not (StringSet.mem fname !includes) then
  let f = open_in fname in
  includes := StringSet.add fname !includes;
  try 
    let rec aux () =
      let line = input_line f in
      let n = String.length line in
      let i = ref 0 in

      try
        (* skip white *)
        while !i < n && line.[!i]=' ' do incr i done;
        if !i = n then raise Next;

        (* check # *)
        if line.[!i]<>'#' then raise Next;
        incr i;

        (* skip white *)
        while !i < n && line.[!i]=' ' do incr i done;
        if !i = n then raise Next;

        (* check include *)
        if !i+String.length "include" > n then raise Next;
        let li = String.length "include" in
        if (String.sub line !i li)  <> "include" then raise Next;
        i := !i + li;

        (* skip white *)
        while !i < n && line.[!i]=' ' do incr i done;

        (* check < or '"' *)
        if line.[!i]<>'"' && line.[!i]<>'<' then raise Next;
        incr i;

        (* skip to > or '"' *)
        let j = !i in
        while !i < n && line.[!i]<>'>' && line.[!i]<>'"' do incr i done;

        (* extract filename *)
        let filename = String.sub line j (!i-j) in


        (* lookup full path name *)
        let filename = 
          if not (Filename.is_relative filename) then filename else
          try filename_of_module (module_of_filename filename)
          (*
          with Not_found -> 
          try
            (* try a relative lookup *)
            if Filename.is_implicit filename then
              let d = Filename.dirname fname in
              let f = Filename.concat d filename in
              if Sys.file_exists f then f
              else raise Not_found
            else raise Not_found
          *)
          with Not_found -> 
            (*
            print_endline 
            (
              "[include_file'] Can't resolve " ^ filename ^
              " included from " ^ fname
            );
            *)
            raise Next
        in
        add_file filename;

        (* if not already known, put transitive closure in set *)
        if StringSet.mem filename !includes then raise Next;
        includes := StringSet.add filename !includes;
        find_includes' includes filename;

        (* next line *)
        raise Next
      with Next -> aux ()
    in 
      aux()
  with End_of_file -> close_in f

(* This routine computes the union of transitive
closures with respect to known inclusion, 
of a file, and all the files registered to be merged
into that file. Note that these roots are always
counted in the transitive closure even if they
themselves are excluded or not known.

The resultant set is then filtered using the
filename merge mapping, to remove filenames
registered to be merged into others, and replace
them by their merge targets.
*)

let find_includes fname =
  let includes = ref StringSet.empty in
  find_includes' includes fname;
  let extras = 
    try Hashtbl.find control.rev_merge_files fname 
    with Not_found -> [] 
  in
  iter (find_includes' includes) extras
  ;
  stringset_map map_filename !includes
;;

Hashtbl.iter
begin 
  fun fname stab ->
  let includes = ref (find_includes fname) in
  let ict = Hashtbl.create 97 in
  let xtyps = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v ->
    if not (Hashtbl.mem stab.abstract_types k) then 
    try 
      let file = Hashtbl.find control.all_types k in
      includes := StringSet.add file !includes;
      Hashtbl.add xtyps k file;

    with Not_found ->
      Hashtbl.add ict k v;
      let v',ms = 
        try Hashtbl.find control.incomplete_types_cache k 
        with Not_found -> v,[]
      in
      if v'<>v then 
      failwith ("Inconsistent type " ^k^"->"^ v ^ " <> " ^ v')
      ;
      Hashtbl.replace control.incomplete_types_cache k (v,stab.stab_module::ms)
    else
      ()
  )
  stab.incomplete_types
  ;

  let udt = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v ->
    let k = rplname k in
    if not (Hashtbl.mem control.rejects k) then
    try 
      let file = Hashtbl.find control.all_types k in
      includes := StringSet.add file !includes;
    with Not_found ->
      if not (Hashtbl.mem control.incomplete_types_cache k) then
      Hashtbl.add udt k v
  )
  stab.used_types
  ;
  stab.includes <- !includes;
  stab.udt <- udt;
  stab.ict <- ict;
  stab.xtyps <- xtyps
end
control.stabs
;;

Hashtbl.iter
begin 
  fun fname stab ->
  let outname = flxfile_of_cfile fname in
  let outf = autocreate outname in

  let print_endline s = output_string outf (s ^ "\n") in

  print_endline ("// " ^ fname);
  print_endline ("//Raw Input file: " ^ control.preout_filename);
  print_endline ("//Generated by Felix Version " ^ !version_data.version_string);
  print_endline ("//Timestamp: " ^ compile_start_gm_string);
  print_endline ("//Timestamp: " ^ compile_start_local_string);
  print_endline ("include 'std';");
  print_endline "";
 
  if not (mem fname control.noincludes) then
    print_endline ("header '#include \"" ^ fname^"\"';")
  else
    print_endline ("//NOT INCLUDED: \"" ^ fname^"\"")
  ;

  (* This process calculates all the modules
  on which the current module depends in two stages.
  
  First it finds the transitive closure using
  the find_includes function.

  Then it augments the set, by looking up every
  incomplete type registered for that module,
  and adds to the set the module containing
  the complete definition.

  We have to do this, because Felix does not
  permit two abstract types definitions to
  be unified, even if one or both specify
  the type is incomplete: abstract type
  bindings are generative, every specification
  denotes a distinct type. 
  
  This isn't so in C, so we have to try to fix this up.
  Note that in C some types can remain incomplete.
  So if we cannot find a complete definition,
  we have to generate an incomplete abstract type.

  If the type is defined in two places, two distinct
  types will be generated, which is wrong.

  If the type is, in fact defined completely,
  but outside the set of files known to flxcc,
  then again any subsequent separate wrapping
  will generate a distinct type, which is wrong.

  However, even a human programmer will be hard
  pressed to tell the difference between such
  an error, and an accidental use of the same
  structure tag in two unrelated headers, 
  which might in fact introduce two incompatible
  definitions.

  At least with Felix, in the case the wrappings
  are independent, these incompatible definitions
  will not clash because they're wrapped in distinct
  modules .. however complete types will clash
  if both are actually used in a program because
  two conflicting C headers will be dragged in.

  This is basically a C problem, it cannot be 
  circumvented even by manual wrapping, so the
  failure of flxcc to cope is inevitable and not
  a design flaw.
  *)
       
  begin 
    try
      Hashtbl.iter
      (fun k v-> 
        match Hashtbl.find control.incomplete_types_cache k with
        | (_,[_]) -> ()
        | _ -> 
          print_endline ("include \"_incomplete_types_cache\";");
          raise Not_found
      )
      stab.ict 
    with Not_found -> ()
  end
  ;


  let include_depends = 
    let x = stringset_map map_filename stab.includes in
    let x = stringset_map flxinclude_of_cfile x in
    StringSet.remove stab.stab_flxinclude x
  in
  let module_depends = 
    let x = stringset_map map_filename stab.includes in
    let x = stringset_map module_of_filename x in
    StringSet.remove stab.stab_module x
  in

  if StringSet.cardinal include_depends > 0 then
  begin
    print_endline "";
    print_endline "//INCLUDES";
    StringSet.iter
    (fun incname -> 
      print_endline ("include \"" ^ incname^ "\";")
    )
    include_depends
  end
  ;

  print_endline "";
  print_endline ("module " ^ stab.stab_module ^ "\n{");
  begin
    let print_endline s = output_string outf ("  " ^ s ^ "\n") in
    print_endline "open C_hack;";
    if StringSet.cardinal module_depends > 0 then
    begin
      StringSet.iter
      (fun modulename' -> 
        print_endline ("open " ^ modulename' ^";")
      )
      module_depends
    end
    ;

    if is_nonempty stab.abstract_types then
    begin
      print_endline "";
      print_endline "//ABSTRACT TYPES";
      Hashtbl.iter
      (fun k v-> 
        print_endline ("type " ^ k ^ " = '" ^ v ^ "';")
      )
      stab.abstract_types
    end
    ;

    if is_nonempty stab.registry then
    begin
      print_endline "";
      print_endline "//C FUNCTION POINTER TYPES";
      Hashtbl.iter
      (fun _ (name,tdef)-> 
        print_endline ("header '''" ^ tdef ^ "''';");
        print_endline ("type " ^ name ^ " = '" ^ name ^ "';")
      )
      stab.registry
    end
    ;

    if is_nonempty stab.xtyps then
    begin
      print_endline "";
      print_endline "//EXTERNALLY COMPLETED TYPES";
      Hashtbl.iter
      (fun k v-> 
        let m = module_of_filename v in
        print_endline ("//type " ^ k ^ " defined in "^m^"='" ^ v ^ "';")
      )
      stab.xtyps 
    end
    ;

    if is_nonempty stab.ict then
    begin
      print_endline "";
      print_endline "//PURE INCOMPLETE TYPES";
      Hashtbl.iter
      (fun k v-> 
        match Hashtbl.find control.incomplete_types_cache k with
        | (_,[_]) ->
          print_endline ("type " ^ k ^ " = '" ^ v ^ "'; //local")
        | (_,ls) -> 
          print_endline ("typedef " ^ k ^ " = _incomplete_types::" ^ k ^ ";//shared");
          iter (fun s->print_endline ("//shared by: " ^ s)) ls
      )
      stab.ict 
    end
    ;

    if is_nonempty stab.udt then
    begin
      print_endline "";
      print_endline "//TYPES WE CAN'T FIND";
      Hashtbl.iter
      (fun k _ -> 
        print_endline ("//type " ^ k ^ " ??")
      )
      stab.udt 
    end
    ;

    if is_nonempty stab.struct_aliases then
    begin
      print_endline "";
      print_endline "//STRUCT or UNION ALIASES";
      Hashtbl.iter
      (fun k v-> 
        (* va_list is already defined in the standard library *)
        if k <> "va_list" then
        print_endline ("typedef " ^ k ^ " = " ^ v ^ ";")
      )
      stab.struct_aliases
    end
    ;

    if is_nonempty stab.aliases then
    begin
      print_endline "";
      print_endline "//TYPE ALIASES";
      Hashtbl.iter
      (fun k v-> 
        (* va_list is already defined in the standard library *)
        if k <> "va_list" then
        print_endline ("typedef " ^ k ^ " = " ^ v ^ ";")
      )
      stab.aliases
    end
    ;

    if is_nonempty stab.variables then
    begin
      print_endline "";
      print_endline "//VARIABLES";
      Hashtbl.iter
      (fun k v-> 
        print_endline ("const " ^ k ^ ": " ^v^ " = '" ^ k ^ "';")
      )
      stab.variables
    end
    ;

    if is_nonempty stab.enums then
    begin
      print_endline "";
      print_endline "//ENUMERATION CONSTANTS";
      Hashtbl.iter
      (fun k v -> 
        print_endline ("const " ^ k ^ ": int = '" ^ v ^ "';")
      )
      stab.enums
    end
    ;

    if is_nonempty stab.procedures then
    begin
      print_endline "";
      print_endline "//PROCEDURES";
      Hashtbl.iter
      (fun k (v,b)-> 
        print_endline ("proc " ^ k ^ ": " ^v^ " = '"^b^"';")
      )
      stab.procedures
    end
    ;

    if is_nonempty stab.functions then
    begin
      print_endline "";
      print_endline "//FUNCTIONS";
      Hashtbl.iter
      (fun k (v,b)-> 
        print_endline ("fun " ^ k ^ ": " ^v^ " = '" ^ b ^ "';")
      )
      stab.functions
    end
    ;

    if is_nonempty stab.fields then
    begin
      print_endline "";
      print_endline "//STRUCT and UNION FIELDS";
      Hashtbl.iter
      (fun k (v,b)-> 
        print_endline ("fun " ^ k ^ ": " ^v^ " = '" ^ b ^ "';")
      )
      stab.fields
    end
  end
  ;
  print_endline "}";
  close_out outf
end
control.stabs
;;

if is_nonempty control.incomplete_types_cache then
  let outname = 
    Filename.concat (control.outdir)  
    ("_incomplete_types_cache.flx") 
  in
  let outf = autocreate outname in
  let print_endline s = output_string outf (s ^ "\n") in
  print_endline "//incomplete type cache";
  print_endline "module _incomplete_types {";
  Hashtbl.iter
  (fun k (v,m) ->
    match m with
    | [_] -> ()
    | _ ->
      print_endline ("incomplete type " ^ k ^ " = '" ^v^ "';");
      List.iter
      (fun s -> print_endline ("  // used by " ^ s)
      )
      m
  )
  control.incomplete_types_cache
  ;
  print_endline "}";
  close_out outf
;;

let flx f = 
  let cmd = "flxg -Ilib -I"^control.outdir^" -c " ^ f in
  print_endline cmd;
  Unix.system(cmd)
;;
  
let rec dflx dir =
  try
    let f = Unix.opendir dir in
    begin 
      try 
        while true do let m = Unix.readdir f in
          let path = Filename.concat dir m in
          let st = 
            try Unix.lstat path
            with _ -> failwith ("Can't lstat " ^ path)
          in
          match st.Unix.st_kind with
          | Unix.S_REG ->
            if Filename.check_suffix path ".flx" then
            let fn = Filename.chop_suffix path ".flx" in
            let result = flx fn in
            begin match result with
            | Unix.WEXITED 0 -> ()
            | Unix.WEXITED i -> print_endline ("***** Failed, error " ^ string_of_int i)
            | Unix.WSIGNALED i 
            | Unix.WSTOPPED i -> failwith ("SIGNAL " ^ string_of_int i)
            end
          | Unix.S_DIR -> 
            if not (isprefix "." m) then dflx path 
          | _ -> ()
        done 
      with End_of_file -> Unix.closedir f
    end
  with Unix.Unix_error _ ->
    failwith ("Can't find directory " ^ dir)
;;

dflx control.outdir
;;

@h=tangler("config/usr_include.flxcc.default","data")
@select(h)
outdir flxcc_out
prein usr_include.h
preout usr_include.hhh
preprocessor gcc -E 

//-pthread -D_REENTRANT -DNEED_GNOMESUPPORT_H -DGTKHTML_HAVE_GCONF -DORBIT2=1 

path /usr/include/atk-1.0 
path /usr/include/bonobo-activation-2.0 
path /usr/include/eel-2 
path /usr/include/gail-1.0 
path /usr/include/gal-1.0 
path /usr/include/gconf/2 
path /usr/include/gtk-2.0 
path /usr/lib/gtk-2.0/include 
path /usr/X11R6/include 
path /usr/include/glib-2.0 
path /usr/lib/glib-2.0/include 
path /usr/lib/glib/include 
path /usr/include/gnome-vfs-2.0 
path /usr/lib/gnome-vfs-2.0/include 
path /usr/include/gnome-vfs-module-2.0 
path /usr/include/gtkhtml-1.1 
path /usr/include/gdk-pixbuf-1.0 
path /usr/include/gnome-1.0 
path /usr/include/freetype2 
path /usr/lib/gnome-libs/include 
path /usr/include/gnome-xml 
path /usr/include/libglade-1.0 
path /usr/include/libart-2.0 
path /usr/include/libbonobo-2.0 
path /usr/include/libbonoboui-2.0 
path /usr/include/libglade-2.0 
path /usr/include/libgnome-2.0 
path /usr/include/libgnomecanvas-2.0 
path /usr/include/libgnomeui-2.0 
path /usr/include/libgsf-1 
path /usr/include/libIDL-2.0 
path /usr/include/metacity-1 
path /usr/include/panel-2.0 
path /usr/include/libpng12 
path /usr/include/librsvg-2 
path /usr/include/libxml2 
path /usr/include/linc-1.0 
path /usr/kerberos/include 
path /usr/include/orbit-2.0 
path /usr/include/orbit-2.0/orbit-idl 
path /usr/include/pango-1.0 
path /usr/include  

subdir bits
subdir sys
subdir asm
subdir rpc
subdir linux
subdir python2.3

incdir /usr/include
recincdir /usr/local/include/python2.3
exclude /usr/include/af_vfs.h
exclude /usr/include/disptmpl.h
exclude /usr/include/bits
exclude /usr/include/asm
exclude /usr/include/linux
exclude /usr/include/glib-1.2
exclude /usr/include/orbit-1.0
exclude /usr/include/c++
exclude /usr/include/g++-3
exclude /usr/include/libglade-1.0
exclude /usr/include/libIDL-1.0
exclude /usr/include/gtk-1.2
exclude /usr/include/glib-2.0/gobject
exclude /usr/include/FlexLexer.h
exclude /usr/include/swig.h
exclude /usr/include/Imlib.h
exclude /usr/include/Imlib_private.h
exclude /usr/include/Imlib_types.h
exclude /usr/include/jpeglib.h
exclude /usr/include/rle.h
exclude /usr/include/rle_config.h
exclude /usr/include/md5.h
exclude /usr/include/pcap-namedb.h
exclude /usr/include/regexp.h
exclude /usr/include/hmac-md5.h
exclude /usr/include/jmorecfg.h
exclude /usr/include/jconfig.h
exclude /usr/include/resolv.h
exclude /usr/local/include/python2.3/pymactoolbox.h
exclude /usr/include/libmng.h
exclude /usr/include/mp.h
exclude /usr/include/pammap.h

noheader /usr/include/bits/byteswap.h
noheader /usr/include/bits/cmathcalls.h
noheader /usr/include/bits/confname.h
noheader /usr/include/bits/dirent.h
noheader /usr/include/bits/dlfcn.h
noheader /usr/include/bits/elfclass.h
noheader /usr/include/bits/endian.h
noheader /usr/include/bits/environments.h
noheader /usr/include/bits/fcntl.h
noheader /usr/include/bits/fenv.h
noheader /usr/include/bits/huge_val.h
noheader /usr/include/bits/in.h
noheader /usr/include/bits/ioctls.h
noheader /usr/include/bits/ioctl-types.h
noheader /usr/include/bits/ipc.h
noheader /usr/include/bits/ipctypes.h
noheader /usr/include/bits/locale.h
noheader /usr/include/bits/mathcalls.h
noheader /usr/include/bits/mathdef.h
noheader /usr/include/bits/mathinline.h
noheader /usr/include/bits/mman.h
noheader /usr/include/bits/msq.h
noheader /usr/include/bits/nan.h
noheader /usr/include/bits/netdb.h
noheader /usr/include/bits/poll.h
noheader /usr/include/bits/posix1_lim.h
noheader /usr/include/bits/posix2_lim.h
noheader /usr/include/bits/pthreadtypes.h
noheader /usr/include/bits/resource.h
noheader /usr/include/bits/sched.h
noheader /usr/include/bits/select.h
noheader /usr/include/bits/sem.h
noheader /usr/include/bits/setjmp.h
noheader /usr/include/bits/shm.h
//noheader /usr/include/bits/sigset.h
//noheader /usr/include/bits/sigaction.h
//noheader /usr/include/bits/sigcontext.h
//noheader /usr/include/bits/siginfo.h
//noheader /usr/include/bits/sigstack.h
//noheader /usr/include/bits/sigthread.h
noheader /usr/include/bits/sockaddr.h
noheader /usr/include/bits/socket.h
noheader /usr/include/bits/statfs.h
noheader /usr/include/bits/stat.h
noheader /usr/include/bits/statvfs.h
noheader /usr/include/bits/stdio.h
noheader /usr/include/bits/stdio_lim.h
noheader /usr/include/bits/string2.h
noheader /usr/include/bits/string.h
noheader /usr/include/bits/stropts.h
noheader /usr/include/bits/syscall.h
noheader /usr/include/bits/sys_errlist.h
noheader /usr/include/bits/termios.h
noheader /usr/include/bits/time.h
noheader /usr/include/bits/types.h
noheader /usr/include/bits/typesizes.h
noheader /usr/include/bits/uio.h
noheader /usr/include/bits/ustat.h
noheader /usr/include/bits/utmp.h
noheader /usr/include/bits/utmpx.h
noheader /usr/include/bits/utsname.h
noheader /usr/include/bits/waitflags.h
noheader /usr/include/bits/waitstatus.h
noheader /usr/include/bits/xopen_lim.h
noheader /usr/include/bits/xtitypes.h

merge /usr/include/bits/sigset.h /usr/include/signal.h
merge /usr/include/bits/sigaction.h /usr/include/signal.h
merge /usr/include/bits/sigcontext.h /usr/include/signal.h
merge /usr/include/bits/siginfo.h /usr/include/signal.h
merge /usr/include/bits/sigstack.h /usr/include/signal.h
merge /usr/include/bits/sigthread.h /usr/include/pthread.h
merge /usr/include/bits/sched.h /usr/include/sched.h
merge /usr/include/bits/pthreadtypes.h /usr/include/sys/types.h
merge /usr/include/bits/confname.h /usr/include/unistd.h
merge /usr/include/bits/time.h /usr/include/time.h

merge /usr/include/bits/byteswap.h /usr/include/byteswap.h
merge /usr/include/bits/cmathcalls.h /usr/include/complex.h
merge /usr/include/bits/dirent.h /usr/include/dirent.h
merge /usr/include/bits/dlfcn.h /usr/include/dlfcn.h
merge /usr/include/bits/elfclass.h /usr/include/link.h
merge /usr/include/bits/endian.h /usr/include/endian.h
merge /usr/include/bits/environments.h /usr/include/unistd.h
merge /usr/include/bits/fcntl.h /usr/include/fcntl.h
merge /usr/include/bits/fenv.h /usr/include/fenv.h
merge /usr/include/bits/huge_val.h /usr/include/math.h
merge /usr/include/bits/in.h /usr/include/netinet/in.h
merge /usr/include/bits/ioctls.h /usr/include/sys/ioctl.h
merge /usr/include/bits/ioctl-types.h /usr/include/sys/ioctl.h
merge /usr/include/bits/ipc.h /usr/include/sys/ipc.h
merge /usr/include/bits/ipctypes.h /usr/include/sys/ipc.h
merge /usr/include/bits/locale.h /usr/include/locale.h
merge /usr/include/bits/mathcalls.h /usr/include/math.h
merge /usr/include/bits/mathdef.h /usr/include/math.h
merge /usr/include/bits/mathinline.h /usr/include/math.h
merge /usr/include/bits/mman.h /usr/include/sys/mman.h
merge /usr/include/bits/msq.h /usr/include/sys/msg.h
merge /usr/include/bits/nan.h /usr/include/math.h
merge /usr/include/bits/netdb.h /usr/include/netdb.h
merge /usr/include/bits/poll.h /usr/include/sys/poll.h
merge /usr/include/bits/posix1_lim.h /usr/include/limits.h
merge /usr/include/bits/posix2_lim.h /usr/include/limits.h
merge /usr/include/bits/resource.h /usr/include/sys/resource.h
merge /usr/include/bits/select.h /usr/include/sys/select.h
merge /usr/include/bits/sem.h /usr/include/sys/sem.h
merge /usr/include/bits/setjmp.h /usr/include/setjmp.h
merge /usr/include/bits/shm.h /usr/include/sys/shm.h
merge /usr/include/bits/sockaddr.h /usr/include/sys/socket.h
merge /usr/include/bits/socket.h /usr/include/sys/socket.h
merge /usr/include/bits/statfs.h /usr/include/sys/statfs.h
merge /usr/include/bits/stat.h /usr/include/sys/stat.h
merge /usr/include/bits/statvfs.h /usr/include/sys/statvfs.h
merge /usr/include/bits/stdio.h /usr/include/stdio.h
merge /usr/include/bits/stdio_lim.h /usr/include/stdio.h
merge /usr/include/bits/string2.h /usr/include/string.h
merge /usr/include/bits/string.h /usr/include/string.h
merge /usr/include/bits/stropts.h /usr/include/stropts.h
merge /usr/include/bits/syscall.h /usr/include/sys/syscall.h
merge /usr/include/bits/sys_errlist.h /usr/include/stdio.h
merge /usr/include/bits/termios.h /usr/include/termios.h
merge /usr/include/bits/types.h /usr/include/sys/types.h
merge /usr/include/bits/typesizes.h /usr/include/sys/types.h
merge /usr/include/bits/uio.h /usr/include/sys/uio.h
merge /usr/include/bits/ustat.h /usr/include/sys/ustat.h
merge /usr/include/bits/utmp.h /usr/include/utmp.h
merge /usr/include/bits/utmpx.h /usr/include/utmpx.h
merge /usr/include/bits/utsname.h /usr/include/sys/utsname.h
merge /usr/include/bits/waitflags.h /usr/include/sys/wait.h
merge /usr/include/bits/waitstatus.h /usr/include/sys/wait.h
merge /usr/include/bits/xopen_lim.h /usr/include/limits.h
merge /usr/include/bits/xtitypes.h /usr/include/stropts.h
@for k,j in flx_keywords+[('String','')]:
  tangle('rename '+k+' '+k+'_')
rename size_t size
rename wchar_t wchar
@for k in tmap.keys()+['wchar']:
  tangle('ignore '+k)

@h=tangler("config/usr_include.h.default","data")
@select(h)

/* we have to have this .. */
#include <stddef.h>

/* shut up some error diagnostics */
#include <features.h>

/* due to GNU WEIRDNESS sigset_t gets defined in either
/usr/include/signal.h or in /usr/include/sys/select.h,
whichever comes first .. this works for C, but alphabetical
order would #include select.h first, and it include
sys/select.h, so sigset_t ends up in the wrong place for us:
we want it in signal.h please! A few similar problems exist
for some other types ..
*/
#include "/usr/include/signal.h"
#include "/usr/include/sys/types.h"

/* #include "/usr/include/af_vfs.h" */
#include "/usr/include/aio.h"
#include "/usr/include/aliases.h"
#include "/usr/include/alloca.h"
#include "/usr/include/ansidecl.h"
#include "/usr/include/a.out.h"
#include "/usr/include/apm.h"
#include "/usr/include/argp.h"
#include "/usr/include/argz.h"
#include "/usr/include/ar.h"
#include "/usr/include/assert.h"
#include "/usr/include/audiofile.h"
#include "/usr/include/aupvlist.h"
#include "/usr/include/baudboy.h"
#include "/usr/include/bfd.h"
#include "/usr/include/bfdlink.h"
#include "/usr/include/byteswap.h"
#include "/usr/include/complex.h"
#include "/usr/include/cpio.h"
#include "/usr/include/crack.h"
#include "/usr/include/crypt.h"
#include "/usr/include/ctype.h"
#include "/usr/include/curses.h"
/* #include "/usr/include/cxx_common.h" */
/* #include "/usr/include/cxx_except.h" */
#include "/usr/include/db_185.h"
#include "/usr/include/db.h"
#include "/usr/include/dejagnu.h"
#include "/usr/include/dirent.h"
#include "/usr/include/dis-asm.h"
/* #include "/usr/include/disptmpl.h" */
#include "/usr/include/dlfcn.h"
#include "/usr/include/efs_error.h"
#include "/usr/include/efs.h"
/* #include "/usr/include/elf.h" */ /* obsolete .. */
#include "/usr/include/endian.h"
#include "/usr/include/envz.h"
#include "/usr/include/err.h"
#include "/usr/include/errno.h"
#include "/usr/include/error.h"
#include "/usr/include/esd.h"
#include "/usr/include/eti.h"
#include "/usr/include/execinfo.h"
#include "/usr/include/expat.h"
#include "/usr/include/fam.h"
#include "/usr/include/fcntl.h"
#include "/usr/include/features.h"
#include "/usr/include/fenv.h"
#include "/usr/include/fmtmsg.h"
#include "/usr/include/fnmatch.h"
#include "/usr/include/form.h"
#include "/usr/include/fpu_control.h"
#include "/usr/include/fstab.h"
#include "/usr/include/ft2build.h"
#include "/usr/include/fts.h"
#include "/usr/include/ftw.h"
#include "/usr/include/_G_config.h"
#include "/usr/include/gconv.h"
#include "/usr/include/gdbm.h"
#include "/usr/include/gdcache.h"
#include "/usr/include/gdfontg.h"
#include "/usr/include/gdfontl.h"
#include "/usr/include/gdfontmb.h"
#include "/usr/include/gdfonts.h"
#include "/usr/include/gdfontt.h"
#include "/usr/include/gd.h"
#include "/usr/include/gd_io.h"
#include "/usr/include/gdk_imlib.h"
#include "/usr/include/gdk_imlib_private.h"
#include "/usr/include/gdk_imlib_types.h"
#include "/usr/include/getopt.h"
#include "/usr/include/gif_lib.h"
#include "/usr/include/glibtop.h"
#include "/usr/include/glibtop_machine.h"
#include "/usr/include/glibtop_server.h"
#include "/usr/include/glob.h"
#include "/usr/include/gmp.h"
#include "/usr/include/gmp-mparam.h"
#include "/usr/include/gnu-versions.h"
#include "/usr/include/gpm.h"
#include "/usr/include/grp.h"
#include "/usr/include/hesiod.h"
/* #include "/usr/include/hmac-md5.h" */
#include "/usr/include/iconv.h"
#include "/usr/include/ieee754.h"
#include "/usr/include/ifaddrs.h"
#include "/usr/include/Imlib.h"
#include "/usr/include/Imlib_private.h"
#include "/usr/include/Imlib_types.h"
#include "/usr/include/inttypes.h"
#include "/usr/include/iwlib.h"
#include "/usr/include/jconfig.h"
#include "/usr/include/jerror.h"
#include "/usr/include/jmorecfg.h"
#include "/usr/include/jpeglib.h"
#include "/usr/include/langinfo.h"
#include "/usr/include/lastlog.h"
#include "/usr/include/lber.h"
#include "/usr/include/lber_types.h"
#include "/usr/include/ldap_cdefs.h"
#include "/usr/include/ldap_features.h"
#include "/usr/include/ldap.h"
#include "/usr/include/ldap_schema.h"
#include "/usr/include/liba2ps.h"
#include "/usr/include/libgen.h"
#include "/usr/include/libiberty.h"
#include "/usr/include/libintl.h"
#include "/usr/include/libio.h"
#include "/usr/include/libmng_conf.h"
#include "/usr/include/libmng.h"
#include "/usr/include/libmng_types.h"
#include "/usr/include/libsmbclient.h"
#include "/usr/include/limits.h"
#include "/usr/include/link.h"
#include "/usr/include/locale.h"
#include "/usr/include/lockdev.h"
#include "/usr/include/ltdl.h"
#include "/usr/include/malloc.h"
#include "/usr/include/math.h"
#include "/usr/include/mcheck.h"
#include "/usr/include/md5global.h"
#include "/usr/include/md5.h"
#include "/usr/include/memory.h"
#include "/usr/include/menu.h"
#include "/usr/include/mikmod.h"
#include "/usr/include/mntent.h"
#include "/usr/include/monetary.h"
/* #include "/usr/include/mp.h" */
#include "/usr/include/ncurses.h"
#include "/usr/include/netdb.h"
#include "/usr/include/newt.h"
#include "/usr/include/nl_types.h"
#include "/usr/include/nss.h"
#include "/usr/include/obstack.h"
#include "/usr/include/pam.h"
/* #include "/usr/include/pammap.h" */
#include "/usr/include/panel.h"
#include "/usr/include/paths.h"
#include "/usr/include/pbm.h"
#include "/usr/include/pbmshhopt.h"
#include "/usr/include/pcap.h"
#include "/usr/include/pcap-namedb.h"
#include "/usr/include/pgm.h"
#include "/usr/include/pm_config.h"
#include "/usr/include/pm.h"
/* #include "/usr/include/pngconf.h" */
/* #include "/usr/include/png.h" */
#include "/usr/include/pnm.h"
#include "/usr/include/poll.h"
#include "/usr/include/popt.h"
#include "/usr/include/ppmcmap.h"
#include "/usr/include/ppmfloyd.h"
#include "/usr/include/ppm.h"
#include "/usr/include/printf.h"
#include "/usr/include/pthread.h"
#include "/usr/include/pty.h"
#include "/usr/include/pwd.h"
#include "/usr/include/re_comp.h"
#include "/usr/include/regex.h"
/* #include "/usr/include/regexp.h" */
/* hack .. */
#undef BSD
#include "/usr/include/resolv.h"
#include "/usr/include/sasl.h"
#include "/usr/include/saslplug.h"
#include "/usr/include/saslutil.h"
#include "/usr/include/sched.h"
#include "/usr/include/search.h"
#include "/usr/include/semaphore.h"
#include "/usr/include/setjmp.h"
#include "/usr/include/sgtty.h"
#include "/usr/include/shadow.h"
#include "/usr/include/spawn.h"
#include "/usr/include/srchpref.h"
#include "/usr/include/stab.h"
#include "/usr/include/stdint.h"
#include "/usr/include/stdio_ext.h"
#include "/usr/include/stdio.h"
#include "/usr/include/stdlib.h"
#include "/usr/include/string.h"
#include "/usr/include/strings.h"
#include "/usr/include/stropts.h"
/* #include "/usr/include/swig.h" */
#include "/usr/include/symcat.h"
#include "/usr/include/syscall.h"
#include "/usr/include/sysexits.h"
#include "/usr/include/syslog.h"
#include "/usr/include/tar.h"
/* #include "/usr/include/tclDecls.h" */
#include "/usr/include/tcl.h"
#include "/usr/include/tclPlatDecls.h"
#include "/usr/include/tcpd.h"
#include "/usr/include/termcap.h"
/* #include "/usr/include/term.h" */
#include "/usr/include/termio.h"
#include "/usr/include/termios.h"
#include "/usr/include/tgmath.h"
#include "/usr/include/thread_db.h"
#include "/usr/include/tiffconf.h"
#include "/usr/include/tiff.h"
#include "/usr/include/tiffio.h"
#include "/usr/include/tiffvers.h"
#include "/usr/include/time.h"
/* #include "/usr/include/tkDecls.h" */
#include "/usr/include/tk.h"
#include "/usr/include/tkPlatDecls.h"
#include "/usr/include/ttyent.h"
#include "/usr/include/ttylock.h"
#include "/usr/include/ucontext.h"
#include "/usr/include/ulimit.h"
#include "/usr/include/unctrl.h"
#include "/usr/include/unicode.h"
#include "/usr/include/unistd.h"
#include "/usr/include/usb.h"
#include "/usr/include/ustat.h"
#include "/usr/include/utempter.h"
#include "/usr/include/utime.h"
#include "/usr/include/utmp.h"
#include "/usr/include/utmpx.h"
#include "/usr/include/values.h"
#include "/usr/include/wait.h"
#include "/usr/include/wchar.h"
#include "/usr/include/wctype.h"
#include "/usr/include/wordexp.h"
#include "/usr/include/xlocale.h"
#include "/usr/include/zconf.h"
#include "/usr/include/zlib.h"
/* #include "/usr/include/zutil.h" */

#include "/usr/include/sys/acct.h"
#include "/usr/include/sys/acl.h"
#include "/usr/include/sys/bitypes.h"
#include "/usr/include/sys/capability.h"
#include "/usr/include/sys/cdefs.h"
#include "/usr/include/sys/debugreg.h"
#include "/usr/include/sys/dir.h"
/* #include "/usr/include/sys/elf.h" */ /* obsolete */
#include "/usr/include/sys/epoll.h"
#include "/usr/include/sys/errno.h"
#include "/usr/include/sys/fcntl.h"
#include "/usr/include/sys/file.h"
#include "/usr/include/sys/fsuid.h"
#include "/usr/include/sys/gmon.h"
#include "/usr/include/sys/gmon_out.h"
#include "/usr/include/sys/ioctl.h"
#include "/usr/include/sys/io.h"
#include "/usr/include/sys/ipc.h"
#include "/usr/include/sys/kdaemon.h"
#include "/usr/include/sys/kd.h"
#include "/usr/include/sys/klog.h"
#include "/usr/include/sys/mman.h"
#include "/usr/include/sys/mount.h"
#include "/usr/include/sys/msg.h"
#include "/usr/include/sys/mtio.h"
#include "/usr/include/sys/param.h"
#include "/usr/include/sys/pci.h"
#include "/usr/include/sys/perm.h"
#include "/usr/include/sys/personality.h"
#include "/usr/include/sys/poll.h"
#include "/usr/include/sys/prctl.h"
#include "/usr/include/sys/procfs.h"
#include "/usr/include/sys/profil.h"
#include "/usr/include/sys/ptrace.h"
#include "/usr/include/sys/queue.h"
#include "/usr/include/sys/quota.h"
#include "/usr/include/sys/raw.h"
#include "/usr/include/sys/reboot.h"
#include "/usr/include/sys/reg.h"
#include "/usr/include/sys/resource.h"
#include "/usr/include/sys/select.h"
#include "/usr/include/sys/sem.h"
#include "/usr/include/sys/sendfile.h"
#include "/usr/include/sys/shm.h"
#include "/usr/include/sys/signal.h"
#include "/usr/include/sys/socket.h"
#include "/usr/include/sys/socketvar.h"
#include "/usr/include/sys/soundcard.h"
#include "/usr/include/sys/statfs.h"
#include "/usr/include/sys/stat.h"
#include "/usr/include/sys/statvfs.h"
#include "/usr/include/sys/stropts.h"
#include "/usr/include/sys/swap.h"
#include "/usr/include/sys/syscall.h"
#include "/usr/include/sys/sysctl.h"
#include "/usr/include/sys/sysinfo.h"
#include "/usr/include/sys/syslog.h"
#include "/usr/include/sys/sysmacros.h"
#include "/usr/include/sys/termios.h"
#include "/usr/include/sys/timeb.h"
#include "/usr/include/sys/time.h"
#include "/usr/include/sys/times.h"
#include "/usr/include/sys/timex.h"
#include "/usr/include/sys/ttychars.h"
#include "/usr/include/sys/ttydefaults.h"
#include "/usr/include/sys/ucontext.h"
#include "/usr/include/sys/uio.h"
#include "/usr/include/sys/ultrasound.h"
#include "/usr/include/sys/un.h"
#include "/usr/include/sys/unistd.h"
#include "/usr/include/sys/user.h"
#include "/usr/include/sys/ustat.h"
#include "/usr/include/sys/utsname.h"
#include "/usr/include/sys/vfs.h"
#include "/usr/include/sys/vlimit.h"
#include "/usr/include/sys/vm86.h"
#include "/usr/include/sys/vt.h"
#include "/usr/include/sys/vtimes.h"
#include "/usr/include/sys/wait.h"
#include "/usr/include/sys/xattr.h"

#include "/usr/local/include/python2.3/Python.h"

