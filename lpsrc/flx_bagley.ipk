@def setup():
  tangle("//")
  tangle("// Contributed by John Skaller")
  tangle("//")
  tangle('include "std";')
  tangle("n := atoi(System::argv 1);")

@head(1,'Bagley Language Shootout')
Temporary script to check the tests work, and also
to get some times.
@select(tangler('bagley/run.sh','data'))
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/ackermann 8
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/fibo 8
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/nestedloop 8
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/regexmatch 8 
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/random 1000
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/hello 1
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/matrix 8
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/reversefile 1 < bagley/data/phone_numbers.data
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/sumcol < bagley/data/sumcol.data
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/sieve 8
/usr/bin/time -f "User Time: %U" bin/flx --test --echo --optimise bagley/felix/lists 8

@head(2,'Hello World')
@select(tangler('bagley/felix/hello.flx','data'))
@setup()
print "hello world"; endl;

@head(2,'Ackermans Function')
Two of the three calls are tail recursive.
@select(tangler('bagley/felix/ackermann.flx','data'))
@setup()
fun ack(x:int,y:int):int =>
  if x == 0 then  y + 1
  elif y == 0 then  ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;

v := ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;


@head(2,'Fibonacci Function')
@select(tangler('bagley/felix/fibo.flx','data'))
@setup()

fun fib(n:int):int => 
  if n < 2 then 1 else fib (n - 2) + fib (n - 1) endif
;

v := fib(n);
print "Fib("; print n; print "): "; print v; endl;

@head(2,"Nested Loops")
@select(tangler('bagley/felix/nestedloop.flx','data'))
@setup()

var a:int;
var b:int;
var c:int;
var d:int;
var e:int;
var f:int;
var x = 0;

for {a=0;} {a<n} {a++;} {
  for {b=0;} {b<n} {b++;} {
    for {c=0;} {c<n} {c++;} {
      for {d=0;} {d<n} {d++;} {
        for {e=0;} {e<n} {e++;} {
          for {f=0;} {f<n} {f++;} {
            x++;
          };
        };
      };
    };
  };
};

print x; endl;

@head(2,"Regexp matching")
This GREATLY decreases the performance for this
test -- which would otherwise blow PCRE out of the water

Note: the actual result data given on the Alioth
site is WRONG and so are the regexp encodings
given by every language that passes this test.
The following entry:

@begin_displayed_code()
foo (213 222-2222 bar
@end_displayed_code()

actually meets the specified conditions but is listed
as a mismatch. You can see how the other languages
cheated -- for example the gcc encoding goes ..

@begin_displayed_code()
"(?:^|[^\\d\\(])"		/* must be preceeded by non-digit */
             ^ since when is ( a digit?
@end_displayed_code()


@select(tangler('bagley/felix/regexmatch.flx','data'))
@setup()

open Lexer;

regexp digit = ["0123456789"];
regexp digits3 = digit digit digit;
regexp digits4 =  digits3 digit;

regexp area_code = digits3 | "(" digits3 ")";
regexp exchange = digits3;

regexp phone = area_code " " exchange (" " | "-") digits4;

// Felix, like Python, provides no literals of char type
zero := ord("0".[0]);
nine := ord("9".[0]);

// Felix regular matching currently only supports
// actual regular sets of strings -- it does not support
// lookback or lookahead because they're not regular
// 
// So we have to hand code the context check.
//
fun check_context(start: iterator, finish: iterator): string =
{
  prior :=  ord(deref(start-1));
  next := ord(deref(finish));
  return 
    if zero <= prior &<= nine 
    or zero <= next &<= nine 
    then ""
    else string_between(start, finish)
    endif
  ;
}

// this is the actual lexer function
fun lexit (start:iterator, finish:iterator): iterator * string =>
  reglex start to finish with
  | phone => check_context (lexeme_start, lexeme_end)
  | _ => ""
  endmatch
;

// hack so context_check won't crash (pre- and append space)
val data = " " + Text_file::load("bagley/data/phone_numbers.data")+" ";
first := Lexer::start_iterator data;
finish := Lexer::end_iterator data;


var i=n;
while {i>1} {
  var current = first;
  while {current != finish} {
    def current, val s = lexit(current, finish);
  };
  --i;
};

proc print_phone(x:string, j:int) {
  n := len x;
  var s = "";
  var i = 0;
  while {i<n} {
    if zero <= ord(x.[i]) &<= nine 
    then { s = s + ord(x.[i]); }
    else {}
    endif;
    ++i;
  };
  print j; print ": ";
  print ("("+s.[0 to 3]+") "+s.[3 to 6]+" "+s.[6 to 10]); endl;
}

var current = first;
var j = 0;
while {current != finish} {
 def current, val s = lexit(current, finish);
 if s != "" then { ++j; print_phone (s,j); } else {} endif;
};

@select(tangler('bagley/data/phone_numbers.data','data'))
datafile for regex matching of phone numbers test

the following numbers should match:

(111) 111 1111
111 222-2222
(111) 333-3333
111 444 4444

foo (111) 555 5555
foo 111 666-6666
foo (111) 777-7777
foo 111 888 8888

foo (111) 999 9999 bar
foo 111 000-0000 bar
foo (111) 232-1111 bar
foo 111 242 1111 bar

The following should fail to match:

2(212) 222 2222
2232 222-2222
(242) 222-22222
2252 222 2222

foo (262) 2222222
foo 272 2222222
foo (282) 222-22227
foo 292 222 22222

foo (202).222 2222 bar
foo 211@22222222 bar
foo (213 222-2222 bar
foo 214) 222 2222 bar

@#@select(tangler('bagley/data/moments.flx'))
@#// to be done

@select(tangler('bagley/data/moments.data','data'))
@for i in range(1,501):
  tangle(str(i))
@doc()

@head(2,'Random Numbers')
Copied from the Ocaml code.
@select(tangler('bagley/felix/random.flx','data'))
@setup()

im := 139968;
ia := 3877;
ic := 29573;
first_last := 42;


fun gen_random (max:double, last:int, i:int):double =>
  let ?new_last = (last * ia + ic) % im in
  if i > 1 then gen_random (max, new_last, (i - 1))
  else max * double_of new_last / double_of im
  endif
;

print (gen_random (100.0, first_last, n)); endl;

@head(2,'Reverse a File')
@select(tangler('bagley/felix/reversefile.flx','data'))
@setup()

open List;
open Text_file;

var x = Empty[string];
var s = readln stdin;
while { s != "" } 
{ 
  x = Cons (s,x);
  s = readln stdin; 
};

proc plist(x:list[string]){
  match x with
  | Cons (?s,?t) => { print s; plist t; }
  |  _ => {}
  endmatch;
};

plist x; endl;

@head(2,'Matrix multiplication')
@select(tangler('bagley/felix/matrix.flx','data'))
@setup()
//Adapted from C++ solution.

body """
int **mkmatrix(int rows, int cols) {
  int i, j, count = 1;
  int **m = (int **) malloc(rows * sizeof(int *));
  for (i=0; i<rows; i++) {
    m[i] = (int *) malloc(cols * sizeof(int));
    for (j=0; j<cols; j++) m[i][j] = count++;
  }
  return(m);
}

void zeromatrix(int rows, int cols, int **m) {
  int i, j;
  for (i=0; i<rows; i++)
  for (j=0; j<cols; j++)
	  m[i][j] = 0;
}

void freematrix(int rows, int **m) {
  while (--rows > -1) free(m[rows]);
  free(m);
}

void mmult(int rows, int cols, int **m1, int **m2, int **m3) {
  int i, j, k, val;
  for (i=0; i<rows; i++)
	for (j=0; j<cols; j++) {
	  val = 0;
	  for (k=0; k<cols; k++) val += m1[i][k] * m2[k][j];
    m3[i][j] = val;
  }
}

int get(int **mm, int x, int y) { return mm[x][y];}
""";

type matrix = "int**";
fun mkmatrix: int * int -> matrix;
fun get: matrix * int * int -> int;
proc zeromatrix: matrix;
proc mmult: int * int * matrix * matrix * matrix;
proc freematrix: int * matrix;

SIZE := 30;
m1 := mkmatrix(SIZE,SIZE);
m2 := mkmatrix(SIZE,SIZE);
mm := mkmatrix(SIZE,SIZE);

var i : int;
for {i=0;} {i<n} {i++;} {
	mmult(SIZE, SIZE, m1, m2, mm);
};

print (get(mm,0,0)); print " "; 
print (get(mm,2,3)); print " "; 
print (get(mm,3,2)); print " "; 
print (get(mm,4,4)); endl;

freematrix(SIZE, m1);
freematrix(SIZE, m2);
freematrix(SIZE, mm);

@head(2,'Sum column of integers')
@select(tangler('bagley/felix/sumcol.flx','data'))
@setup()

open Text_file;
var sum = 0;
var line = readln stdin;

while {line != "" } {
  word := line.[to -1];
  sum += atoi(word);
  line = readln stdin;
};

print sum; endl;


@select(tangler('bagley/data/sumcol.data','data'))
@for i in range(1,1001): tangle(str(i))


@select(tangler('bagley/felix/sieve.flx','data'))
@setup()
type barry = "char*";
fun mk_barry : unit -> barry = "(char*)calloc(8193,1)";
proc free : barry = "free($1);";
fun subscript: barry * int -> bool = "$1[$2]";

var prime = mk_barry();
var i:int;
var k: int;
var count = 0;
var m = n;

while {m>0} {
  m--;
  count = 0;
  for {i=2;} { i <= 8192 } { i++; } { prime.[i] = true; };
  for {i=2;} {i <= 8192} {i++;} {
    if prime.[i] then {
      for {k=i+i;} {k <= 8192} { k+=i; } { prime.[k] = false; };
      count++;
    }
    else {}
    endif;
  };
};

free prime;

print "Count: "; print count; endl;

@select(tangler('bagley/felix/lists.flx','data'))
@setup()
// Adapted from C solution

header """
// a simple Double Linked List
// the head node is special, it's val is length of list
struct DLL {
    int val;
    struct DLL *next;        /* points to next or head (if at tail) */
    struct DLL *prev;        /* points to prev or tail (if at head) */
};
""";

body """
inline int len(DLL *head) { return(head->val); }
inline int empty(DLL *head) { return(len(head) == 0); }
inline DLL *first(DLL *head) { return(head->next); }
inline DLL *last(DLL *head) { return(head->prev); }

void push_tail(DLL *head, DLL *item) {
    DLL *tail = head->prev;
    tail->next = item;
    item->next = head;
    head->prev = item;
    item->prev = tail;
    head->val++;
}

DLL *pop_tail(DLL *head) {
    DLL *prev, *tail;
    if (empty(head)) return(NULL);
    tail = head->prev;
    prev = tail->prev;
    prev->next = head;
    head->prev = prev;
    head->val--;
    return(tail);
}

void push_head(DLL *head, DLL *item) {
    DLL *next = head->next;
    head->next = item;
    next->prev = item;
    item->next = next;
    item->prev = head;
    head->val++;
}

DLL *pop_head(DLL *head) {
    DLL *next;
    if (empty(head)) return(NULL);
    next = head->next;
    head->next = next->next;
    next->next->prev = head;
    head->val--;
    return(next);
}

int list_equal(DLL *x, DLL *y) {
    DLL *xp, *yp;
    // first val's checked will be list lengths
    for (xp=x, yp=y; xp->next != x; xp=xp->next, yp=yp->next) {
        if (xp->val != yp->val) return(0);
    }
    if (xp->val != yp->val) return(0);
    return(yp->next == y);
}

DLL *list_new() {
    DLL *l = (DLL *)malloc(sizeof(DLL));
    l->next = l;
    l->prev = l;
    l->val = 0;
    return(l);
}

/* inclusive sequence 'from' <-> 'to' */
DLL *list_sequence(int from, int to) {
    int size, tmp, i, j;
    DLL *l;
    if (from > to) {
        tmp = from; from = to; to = tmp;
    }
    size = to - from + 1;
    l = (DLL *)malloc((size+1) * sizeof(DLL));
    from--;
    for (i=0, j=1; i<size; ++i, ++j) {
        l[i].next = &l[i+1];
        l[j].prev = &l[j-1];
        l[i].val = from++;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].prev = &l[size-1];
    l[size].val = from;
    l[0].val = size;
    return(l);
}

DLL *copy(DLL *x) {
    int i, j, size = len(x);
    DLL *xp, *l = (DLL *)malloc((size+1) * sizeof(DLL));
    for (i=0, j=1, xp=x; i<size; i++, j++, xp=xp->next) {
        l[i].next = &l[j];
        l[j].prev = &l[i];
        l[i].val = xp->val;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].val = last(x)->val;
    return(l);
}

void rev (DLL *head) {
    DLL *tmp, *p = head;
    do {
        tmp = p->next;
        p->next = p->prev;
        p->prev = tmp;
        p = tmp;
    } while (p != head);
}
""";

type DLL_head = "DLL*";
type DLL_item = "DLL*";

fun get: DLL_item -> int = "$1->val";

fun len: DLL_head -> int;
fun empty: DLL_head -> bool;

fun non_empty(x:DLL_head)=> not (empty x);

fun first: DLL_head -> DLL_item;
fun last: DLL_head -> DLL_item;

proc push_tail: DLL_head * DLL_item;
fun pop_tail: DLL_head -> DLL_item;
proc push_head: DLL_head * DLL_item;

fun pop_head: DLL_head -> DLL_item;
fun eq: DLL_head * DLL_head -> bool = "list_equal($1,$2)";
fun ne (x:DLL_head,y:DLL_head) => not (x == y);

fun list_new: unit -> DLL_head;

/* inclusive sequence 'from' <-> 'to' */
fun list_sequence: int * int -> DLL_head;
fun copy: DLL_head -> DLL_head;

proc rev: DLL_head;
proc free: DLL_head = "std::free($1);";

proc check(cond:bool) (msg:string) {
  open System;
  open Text_file;
  if cond goto endoff;
  writeln (stderr,msg);
  exit 1;
endoff:>
}

SIZE:=10000;


var result: int;
proc test_lists() {
    var li1 = list_sequence(1, SIZE);
    var li2 = copy(li1);
    check (li2 == li1) "li2 and li1 are not equal";

    // remove each individual item from left side of li2 and
    // append to right side of li3 (preserving order)
    var li3 = list_new();
    while { non_empty li2 } {
        val x = pop_head li2;
        push_tail(li3, x);
    };

    check (empty li2) "li2 should be empty now";

    // remove each individual item from right side of li3 and
    // append to right side of li2 (reversing list)
    while { non_empty li3 } {
        val x = pop_tail li3;
        push_tail(li2, x);
    };

    check (empty li3) "li3 should be empty now";

    // reverse li1 in place
    rev li1;

    check (get (first li1) == SIZE) "li1 first value wrong";
    check (get (last li1) == 1) "last value wrong";

    check (get (first li2) == SIZE) "li2 first value wrong";
    check (get (last li2) == 1) "li2 last value wrong";
    check (len li1 == SIZE) "li1 size wrong";

    // compare li1 and li2 for equality
    check (li1 == li2) "li1 and li2 are not equal";

    result = len li1;
    free li1;
    free li2;
    free li3;
}

var i:int;
for {i=0;} {i<n} {++i;} { test_lists(); };
print result; endl;


