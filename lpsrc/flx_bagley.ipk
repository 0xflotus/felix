@def setup():
  tangle("//")
  tangle("// Contributed by John Skaller")
  tangle("//")
  tangle('include "std";')
  tangle("n := atoi(System::argv 1);")

@head(1,'Bagley Language Shootout')
Temporary script to check the tests work, and also
to get some times.

@sbags = [
  ('array',' 1000'),
  ('ackermann',' 8'),
  ('except',' 8'),
  ('fibo',' 8'),
  ('heapsort',' 1000'),
  ('hello',' 1'),
  ('hash',' 20000'),
  ('hash2',' 10'),
  ('lists',' 8'),
  ('matrix',' 8'),
  ('methcall',' 8'),
  ('nestedloop',' 8'),
  ('objinst',' 8'),
  ('random',' 1000'),
  ('regexmatch',' 8'),
  ('reversefile',' 1 < bagley/data/phone_numbers.data'),
  ('sieve',' 8'),
  ('strcat',' 8'),
  ('sumcol',' < bagley/data/sumcol.data'),
  ('wc',' < bagley/data/phone_numbers.data'), 
 ]

@dbags = [
  ('plugin',' 20'),
 ]

@if SUPPORT_DYNAMIC_LOADING:
  bags = sbags + dbags
 else:
  bags = sbags

@def mk(i,j):
  k = (i+' .................  ')[:20]+' '
  tangle('/usr/bin/time -f "'+k+' %U" bin/flx --test --optimise bagley/felix/'+i+' '+j+' >bagley/felix/'+i+'.output')
@def mkc(i,j):
  mk(i,j)
  tangle('diff -a -b bagley/felix/'+i+'.output bagley/felix/'+i+'.expect')

@select(tangler('bagley/run.sh','data'))
PLUGIN_DIR=bagley/felix/
export PLUGIN_DIR
@if SUPPORT_DYNAMIC_LOADING:
  tangle('bin/flx --test --optimise -c bagley/felix/plugin_1')
  tangle('bin/flx --test --optimise -c bagley/felix/plugin_2')
  tangle('bin/flx --test --optimise -c bagley/felix/plugin_3')
@for i,j in bags: mk (i,j)

@select(tangler('bagley/check.sh','data'))
PLUGIN_DIR=bagley/felix/
export PLUGIN_DIR
@for i,j in bags: mkc (i,j)

@head(2,'Hello World')
@select(tangler('bagley/felix/hello.flx','data'))
@setup()
print "hello world"; endl;

@head(2,'Ackermans Function')
Two of the three calls are tail recursive.
@select(tangler('bagley/felix/ackermann.flx','data'))
@setup()
fun ack(x:int,y:int):int =>
  if x == 0 then y + 1
  elif y == 0 then ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;

v := ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;


@head(2,'Fibonacci Function')
@select(tangler('bagley/felix/fibo.flx','data'))
@setup()

fun fib(n:int):int => 
  if n < 2 then 1 else fib (n - 2) + fib (n - 1) endif
;

v := fib(n);
print "Fib("; print n; print "): "; print v; endl;

@head(2,'Array access')
Inspired by the C code.
@select(tangler('bagley/felix/array.flx','data'))
@setup()
//adapted from C solution
open Carray;

x := array_calloc[int] n;
y := array_calloc[int] n;

var i = 0;
whilst i < n do x.[i] = i + 1; ++i; done;

var k = 0;
whilst k<1000 do
  i = n - 1;
  whilst i >= 0 do
    y.[i] = y.[i] + x.[i];
    --i;
  done;
  ++k;
done;

print y.[0]; print " "; print y.[n-1]; endl;
free x;
free y;

@head(2,"Nested Loops")
@select(tangler('bagley/felix/nestedloop.flx','data'))
@setup()
var x = 0;

var a=0; 
whilst a<n do
  var b=0; 
  whilst b<n do
    var c=0; 
    whilst c<n do
      var d=0; 
      whilst d<n do
        var e=0; 
        whilst e<n do
          var f=0; 
          whilst f<n do
            x++;
            ++f;
          done;
          ++e;
        done;
        ++d; 
      done;
      ++c;
    done;
    ++b;
  done;
  ++a;
done;

print x; endl;

@head(2,"Regexp matching")
This GREATLY decreases the performance for this
test -- which would otherwise blow PCRE out of the water

Note: the actual result data given on the Alioth
site is WRONG and so are the regexp encodings
given by every language that passes this test.
The following entry:

@begin_displayed_code()
foo (213 222-2222 bar
@end_displayed_code()

actually meets the specified conditions but is listed
as a mismatch. You can see how the other languages
cheated -- for example the gcc encoding goes ..

@begin_displayed_code()
"(?:^|[^\\d\\(])"  	/* must be preceeded by non-digit */
             ^ since when is ( a digit?
@end_displayed_code()


@select(tangler('bagley/felix/regexmatch.flx','data'))
@setup()

open Lexer;

regexp digit = ["0123456789"];
regexp digits3 = digit digit digit;
regexp digits4 =  digits3 digit;

regexp area_code = digits3 | "(" digits3 ")";
regexp exchange = digits3;

regexp phone = area_code " " exchange (" " | "-") digits4;

// Felix, like Python, provides no literals of char type
zero := ord("0".[0]);
nine := ord("9".[0]);

// Felix regular matching currently only supports
// actual regular sets of strings -- it does not support
// lookback or lookahead because they're not regular
// 
// So we have to hand code the context check.
//
fun check_context(start: iterator, finish: iterator): string =
{
  prior :=  ord(deref(start-1));
  next := ord(deref(finish));
  return 
    if zero <= prior &<= nine 
    or zero <= next &<= nine 
    then ""
    else string_between(start, finish)
    endif
  ;
}

// this is the actual lexer function
fun lexit (start:iterator, finish:iterator): iterator * string =>
  reglex start to finish with
  | phone => check_context (lexeme_start, lexeme_end)
  | _ => ""
  endmatch
;

// hack so context_check won't crash (pre- and append space)
val data = " " + Text_file::load("bagley/data/phone_numbers.data")+" ";
first := Lexer::start_iterator data;
finish := Lexer::end_iterator data;


var i=n;
var current: iterator;
var s: string;
whilst i>1 do 
  current = first;
  until current == finish do
    current, s = lexit(current, finish);
  done;
  --i;
done;

proc print_phone(x:string, j:int) {
  n := len x;
  var s = "";
  var i = 0;
  whilst i<n do
    if zero <= ord(x.[i]) &<= nine do 
      s = s + ord(x.[i]); 
    done;
    ++i;
  done;
  print j; print ": ";
  print ("("+s.[0 to 3]+") "+s.[3 to 6]+" "+s.[6 to 10]); endl;
}

current = first;
var j = 0;
until current == finish do
 current, s = lexit(current, finish);
 if s != "" do  ++j; print_phone (s,j); done;
done;

@select(tangler('bagley/data/phone_numbers.data','data'))
datafile for regex matching of phone numbers test

the following numbers should match:

(111) 111 1111
111 222-2222
(111) 333-3333
111 444 4444

foo (111) 555 5555
foo 111 666-6666
foo (111) 777-7777
foo 111 888 8888

foo (111) 999 9999 bar
foo 111 000-0000 bar
foo (111) 232-1111 bar
foo 111 242 1111 bar

The following should fail to match:

2(212) 222 2222
2232 222-2222
(242) 222-22222
2252 222 2222

foo (262) 2222222
foo 272 2222222
foo (282) 222-22227
foo 292 222 22222

foo (202).222 2222 bar
foo 211@22222222 bar
foo (213 222-2222 bar
foo 214) 222 2222 bar

@#@select(tangler('bagley/data/moments.flx'))
@#// to be done

@select(tangler('bagley/data/moments.data','data'))
@for i in range(1,501):
  tangle(str(i))
@doc()

@head(2,'Random Numbers')
Copied from the Ocaml code.
@select(tangler('bagley/felix/random.flx','data'))
@setup()
//adapted from Ocaml solution
im := 139968;
ia := 3877;
ic := 29573;
first_last := 42;


fun gen_random (max:double, last:int, i:int):double =>
  let ?new_last = (last * ia + ic) % im in
  if i > 1 then gen_random (max, new_last, (i - 1))
  else max * double_of new_last / double_of im
  endif
;

print (gen_random (100.0, first_last, n)); endl;

@head(2,'Reverse a File')
@select(tangler('bagley/felix/reversefile.flx','data'))
@setup()

open List;
open Text_file;

var x = Empty[string];
var s = readln stdin;
until s == "" do
  x = Cons (s,x);
  s = readln stdin; 
done;

proc plist(x:list[string]){
  match x with
  | Cons (?s,?t) => { print s; plist t; }
  |  _ => {}
  endmatch;
};

plist x; 

@head(2,'Matrix multiplication')
@select(tangler('bagley/felix/matrix.flx','data'))
@setup()
//Adapted from C++ solution.

body """
int **mkmatrix(int rows, int cols) {
  int i, j, count = 1;
  int **m = (int **) malloc(rows * sizeof(int *));
  for (i=0; i<rows; i++) {
    m[i] = (int *) malloc(cols * sizeof(int));
    for (j=0; j<cols; j++) m[i][j] = count++;
  }
  return(m);
}

void zeromatrix(int rows, int cols, int **m) {
  int i, j;
  for (i=0; i<rows; i++)
  for (j=0; j<cols; j++)
    m[i][j] = 0;
}

void freematrix(int rows, int **m) {
  while (--rows > -1) free(m[rows]);
  free(m);
}

void mmult(int rows, int cols, int **m1, int **m2, int **m3) {
  int i, j, k, val;
  for (i=0; i<rows; i++)
  for (j=0; j<cols; j++) {
    val = 0;
    for (k=0; k<cols; k++) val += m1[i][k] * m2[k][j];
    m3[i][j] = val;
  }
}

int get(int **mm, int x, int y) { return mm[x][y];}
""";

type matrix = "int**";
fun mkmatrix: int * int -> matrix;
fun get: matrix * int * int -> int;
proc zeromatrix: matrix;
proc mmult: int * int * matrix * matrix * matrix;
proc freematrix: int * matrix;

SIZE := 30;
m1 := mkmatrix(SIZE,SIZE);
m2 := mkmatrix(SIZE,SIZE);
mm := mkmatrix(SIZE,SIZE);

var i = n;
until i == 0 do
  mmult(SIZE, SIZE, m1, m2, mm);
  --i;
done;

print (get(mm,0,0)); print " "; 
print (get(mm,2,3)); print " "; 
print (get(mm,3,2)); print " "; 
print (get(mm,4,4)); endl;

freematrix(SIZE, m1);
freematrix(SIZE, m2);
freematrix(SIZE, mm);

@head(2,'Sum column of integers')
@select(tangler('bagley/felix/sumcol.flx','data'))
@setup()

open Text_file;
var sum = 0;
var line = readln stdin;

until line == "" do
  sum += atoi(line);
  line = readln stdin;
done;

print sum; endl;


@select(tangler('bagley/data/sumcol.data','data'))
@for i in range(1,1001): tangle(str(i))


@select(tangler('bagley/felix/sieve.flx','data'))
@setup()
type barry = "char*";
fun mk_barry : unit -> barry = "(char*)calloc(8193,1)";
proc free : barry = "free($1);";
fun subscript: barry * int -> bool = "$1[$2]";

var prime = mk_barry();
var i:int;
var k: int;
var count = 0;
var m = n;

until m == 0 do
  m--;
  count = 0;
  for {i=2;} { i <= 8192 } { i++; } { prime.[i] = true; };
  i=2;
  whilst i <= 8192 do
    if prime.[i] do
      k=i+i;
      whilst k <= 8192 do 
        prime.[k] = false; 
        k+=i; 
      done;
      count++;
    done;
    i++;
  done;
done;

free prime;

print "Count: "; print count; endl;

@select(tangler('bagley/felix/lists.flx','data'))
@setup()
// Adapted from C solution

header """
// a simple Double Linked List
// the head node is special, it's val is length of list
struct DLL {
    int val;
    struct DLL *next;        /* points to next or head (if at tail) */
    struct DLL *prev;        /* points to prev or tail (if at head) */
};
""";

body """
inline int len(DLL *head) { return(head->val); }
inline int empty(DLL *head) { return(len(head) == 0); }
inline DLL *first(DLL *head) { return(head->next); }
inline DLL *last(DLL *head) { return(head->prev); }

void push_tail(DLL *head, DLL *item) {
    DLL *tail = head->prev;
    tail->next = item;
    item->next = head;
    head->prev = item;
    item->prev = tail;
    head->val++;
}

DLL *pop_tail(DLL *head) {
    DLL *prev, *tail;
    if (empty(head)) return(NULL);
    tail = head->prev;
    prev = tail->prev;
    prev->next = head;
    head->prev = prev;
    head->val--;
    return(tail);
}

void push_head(DLL *head, DLL *item) {
    DLL *next = head->next;
    head->next = item;
    next->prev = item;
    item->next = next;
    item->prev = head;
    head->val++;
}

DLL *pop_head(DLL *head) {
    DLL *next;
    if (empty(head)) return(NULL);
    next = head->next;
    head->next = next->next;
    next->next->prev = head;
    head->val--;
    return(next);
}

int list_equal(DLL *x, DLL *y) {
    DLL *xp, *yp;
    // first val's checked will be list lengths
    for (xp=x, yp=y; xp->next != x; xp=xp->next, yp=yp->next) {
        if (xp->val != yp->val) return(0);
    }
    if (xp->val != yp->val) return(0);
    return(yp->next == y);
}

DLL *list_new() {
    DLL *l = (DLL *)malloc(sizeof(DLL));
    l->next = l;
    l->prev = l;
    l->val = 0;
    return(l);
}

/* inclusive sequence 'from' <-> 'to' */
DLL *list_sequence(int from, int to) {
    int size, tmp, i, j;
    DLL *l;
    if (from > to) {
        tmp = from; from = to; to = tmp;
    }
    size = to - from + 1;
    l = (DLL *)malloc((size+1) * sizeof(DLL));
    from--;
    for (i=0, j=1; i<size; ++i, ++j) {
        l[i].next = &l[i+1];
        l[j].prev = &l[j-1];
        l[i].val = from++;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].prev = &l[size-1];
    l[size].val = from;
    l[0].val = size;
    return(l);
}

DLL *copy(DLL *x) {
    int i, j, size = len(x);
    DLL *xp, *l = (DLL *)malloc((size+1) * sizeof(DLL));
    for (i=0, j=1, xp=x; i<size; i++, j++, xp=xp->next) {
        l[i].next = &l[j];
        l[j].prev = &l[i];
        l[i].val = xp->val;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].val = last(x)->val;
    return(l);
}

void rev (DLL *head) {
    DLL *tmp, *p = head;
    do {
        tmp = p->next;
        p->next = p->prev;
        p->prev = tmp;
        p = tmp;
    } while (p != head);
}
""";

type DLL_head = "DLL*";
type DLL_item = "DLL*";

fun get: DLL_item -> int = "$1->val";

fun len: DLL_head -> int;
fun empty: DLL_head -> bool;

fun non_empty(x:DLL_head)=> not (empty x);

fun first: DLL_head -> DLL_item;
fun last: DLL_head -> DLL_item;

proc push_tail: DLL_head * DLL_item;
fun pop_tail: DLL_head -> DLL_item;
proc push_head: DLL_head * DLL_item;

fun pop_head: DLL_head -> DLL_item;
fun eq: DLL_head * DLL_head -> bool = "list_equal($1,$2)";
fun ne (x:DLL_head,y:DLL_head) => not (x == y);

fun list_new: unit -> DLL_head;

/* inclusive sequence 'from' <-> 'to' */
fun list_sequence: int * int -> DLL_head;
fun copy: DLL_head -> DLL_head;

proc rev: DLL_head;
proc free: DLL_head = "std::free($1);";

proc check(cond:bool) (msg:string) {
  open System;
  open Text_file;
  if cond goto endoff;
  writeln (stderr,msg);
  exit 1;
endoff:>
}

SIZE:=10000;


var result: int;
proc test_lists() {
    var li1 = list_sequence(1, SIZE);
    var li2 = copy(li1);
    var x : DLL_item;
    check (li2 == li1) "li2 and li1 are not equal";

    // remove each individual item from left side of li2 and
    // append to right side of li3 (preserving order)
    var li3 = list_new();
    whilst non_empty li2 do
        x = pop_head li2;
        push_tail(li3, x);
    done;

    check (empty li2) "li2 should be empty now";

    // remove each individual item from right side of li3 and
    // append to right side of li2 (reversing list)
    whilst non_empty li3 do
        x = pop_tail li3;
        push_tail(li2, x);
    done; 

    check (empty li3) "li3 should be empty now";

    // reverse li1 in place
    rev li1;

    check (get (first li1) == SIZE) "li1 first value wrong";
    check (get (last li1) == 1) "last value wrong";

    check (get (first li2) == SIZE) "li2 first value wrong";
    check (get (last li2) == 1) "li2 last value wrong";
    check (len li1 == SIZE) "li1 size wrong";

    // compare li1 and li2 for equality
    check (li1 == li2) "li1 and li2 are not equal";

    result = len li1;
    free li1;
    free li2;
    free li3;
}

var i = n;
until i == 0 do test_lists; --i; done;
print result; endl;

@select(tangler('bagley/felix/objinst.flx','data'))
@setup()
// Adapted from C++ solution

body """
class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() { return(state); }
    virtual Toggle* activate() {
        state = !state;
        return this;
    }
protected:
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
        Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle *activate() {
        if (++this->counter >= this->count_max) {
            state = !state;
            counter = 0;
        }
        return this;
    }
private:
    int count_max;
    int counter;
};
""";

pod type toggle =  "class Toggle*";

fun new_toggle: bool -> toggle = "new Toggle($1)";
fun new_ntoggle: bool * int -> toggle = "new NthToggle($1,$2)";
proc del: toggle = "delete $1;";
fun value: toggle -> bool = "$1->value()";
proc activate: toggle = "$1->activate();";
proc print (t: toggle) { print (value t); }

proc check(t: toggle, k:int) {
  var tt = t;
  var i=k;
  until i == 0 do
    activate tt; 
    print tt; endl; 
    --i;
  done;
  del t;
}

check(new_toggle true,5);

{
  var i = n;
  until i == 0 do
    del (new_toggle true); 
    --i;
  done;
  endl;
};

check (new_ntoggle(true, 3), 8);

{
  var i = n;
  until i == 0 do
    del (new_ntoggle (true, 3)); 
    --i;
  done;
};

@select(tangler('bagley/felix/methcall.flx','data'))
@setup()
// Adapted from C++ solution

body """
class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() { return(state); }
    virtual Toggle* activate() {
        state = !state;
        return this;
    }
protected:
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
        Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle *activate() {
        if (++this->counter >= this->count_max) {
            state = !state;
            counter = 0;
        }
        return this;
    }
private:
    int count_max;
    int counter;
};
""";

pod type toggle =  "class Toggle*";
fun new_toggle: bool -> toggle = "new Toggle($1)";
fun new_ntoggle: bool * int -> toggle = "new NthToggle($1,$2)";
proc del: toggle = "delete $1;";
fun value: toggle -> bool = "$1->value()";
proc activate: toggle = "$1->activate();";

proc check (t:toggle) {
  var tt = t;
  var v = true;
  var i = n;
  until i == 0 do 
    activate tt; 
    v = value tt; 
    --i; 
  done;
  print v; endl;
  del t;
}

check (new_toggle true);
check (new_ntoggle (true, 3));


@select(tangler('bagley/felix/strcat.flx','data'))
@setup()
// Adapted from C++ solution

var str = "";
var capacity = 31;
reserve(str,capacity); // as per C-string
var newLength = 6;
var i = n;
until i == 0 do
  if newLength > capacity do
    capacity *= 2;
    reserve(str,capacity);
  done;
  str += c"hello\n";
  newLength += 6;
  --i;
done;

print (len str); endl;

@select(tangler('bagley/felix/except.flx','data'))
@setup()
// Felix uses explicitly passed closures to handle errors
// and therefore guarrantees exceptions get caught statically

typedef err = int -> void;

var hi = 0;
var lo = 0;

proc blowup (n:int, hie:err, loe:err) {
  if n % 2 == 0 do loe n; else hie n; done;
}

proc lo_fun (n:int, hie:err) {
  blowup (n,hie,loe of (int));
  proc loe(n:int) { ++lo; goto fin; }
fin:>
}

proc hi_fun (n:int) {
  lo_fun (n,hie of (int));
  proc hie(n:int) { ++hi; goto fin; }
fin:>
}

proc some_fun (n:int) { hi_fun n; }

var i = n - 1;
until i < 0 do some_fun i; --i; done;
print "Exceptions: HI="; print hi; print " / LO="; print lo; endl;


@select(tangler('bagley/felix/wc.flx','data'))
@setup()
open Ulong;

body '''
#include <limits.h>
#include <unistd.h>
#define BSIZE 4096
unsigned long wds[UCHAR_MAX + 1];
unsigned long nwds[UCHAR_MAX + 1];
char sp=' ';
char tab = '\\t';
char lf='\\n';
unsigned char buff[BSIZE];
''';

const UCHAR_MAX:int;
const BSIZE:int;
const sp:int;
const lf:int;
const tab:int;

proc setws: int * ulong = "wds[$1]=$2;";
proc setnws: int * ulong = "nwds[$1]=$2;";
fun getws: ulong -> ulong = "wds[$1]";
fun getnws: ulong -> ulong = "nwds[$1]";

fun readbuf: unit -> int = "read(0,buff,BSIZE)";

var prev_nws = 0x1_0000uL;
var w_cnt = 0uL;
var l_cnt = 0uL;
var b_cnt = 0uL;

type iterator = "unsigned char *";
fun eq: iterator * iterator -> bool = "$1 == $2";
fun deref: iterator -> ulong = "*$1";
fun add: iterator * ulong -> iterator = "$1 + $2";
proc post_incr: iterator = "$1++;";

fun band: ulong * ulong -> ulong = "$1 & $2";
fun hi: ulong -> ulong = "$1 >> 16";
fun lo: ulong -> ulong = "$1 & 0xFFFFuL";
fun parity : ulong -> ulong = "$1 & 1uL";
fun neg: ulong -> ulong = "-$1";

const buff: iterator = "buff";

fun iswhite(ch:int) => 
  ch == sp or ch == tab or ch == lf;

fun islf(ch:int)=> ch == lf;

fun ul(x:bool)=> C_hack::cast[ulong]x;
 
/* Fill tables */
{
  var ch = UCHAR_MAX; until ch < 0 do
    setws(ch, ul (iswhite ch) + band (0x10000uL,  -(ul (islf ch))));
    setnws(ch, ul (not (iswhite ch)) +  0x10000uL);
    --ch;
  done;
};

/* Main loop */
{
  var cnt: ulong;
  proc uread() {
    var n = readbuf();
    if n < 0 do System::exit 1; done;
    cnt = C_hack::cast[ulong]n;
  }

  uread;
  whilst cnt > 0uL do
    var vect_count = 0uL;
    var pp:iterator;
    pe := buff + cnt;

    b_cnt += cnt;
    pp = buff;

    until pp == pe do
      vect_count += band (getws(deref pp), prev_nws);
      prev_nws    = getnws(deref pp);
      pp++;
    done;
    w_cnt += lo vect_count;
    l_cnt += hi vect_count;
    uread;
  done;

  w_cnt += parity prev_nws;
};

print l_cnt; print " "; print w_cnt; print " "; print b_cnt; endl;

@head(2,'Heapsort')
@select(tangler('bagley/felix/heapsort.flx','data'))
@setup()
// stolen from C implementation

fun gen_random: double -> double 
  requires body """
    #define IM 139968
    #define IA   3877
    #define IC  29573
    static long last;
    double
    gen_random(double max) {
        static long last = 42;
        return( max * (last = (last * IA + IC) % IM) / IM );
    }
""";
typedef darray = C_hack::ptr[double];

fun subscript: darray * int -> double = "$1[$2]";

val cows_jump_over_moon = false;

proc heapsort(n:int, ra: darray) {
    var i:int;
    var j:int;
    var ir = n;
    var l = (n / 2) + 1;
    var rra:double;

    until cows_jump_over_moon do
        if l > 1 do 
            --l;
            rra = ra.[l];
        else
            rra = ra.[ir];
            ra.[ir] = ra.[1];
            --ir;
            if ir == 1 do
                ra.[1] = rra;
                return;
            done;
        done;
        i = l;
        j = l * 2;
        whilst j <= ir do
            if j < ir and ra.[j] < ra.[j+1] do ++j; done;
            if rra < ra.[j] do 
                ra.[i] = ra.[j];
                i = j;
                j *= 2;
            else
                j = ir + 1;
            done;
        done;
        ra.[i] = rra;
    done;
}

var ary = Carray::array_alloc[double] (n+1);
var i = n; until i == 0 do
    ary.[i] = gen_random(1.0);
    --i;
done;

heapsort(n, ary);

proc print_10f: double = 'printf("%.10f\\n", $1);';
print_10f ary.[n];

Carray::free ary;

@select(tangler('bagley/felix/plugin.flx','data'))
@setup()
open List;

var prefix = Env::getenv "PLUGIN_DIR";
if prefix == "" do prefix = "./"; done;

// list of the plugin filenames
var plugins = List::Empty[string];
plugins = plugins + (prefix + 'plugin_1.so');
plugins = plugins + (prefix + 'plugin_2.so');
plugins = plugins + (prefix + 'plugin_3.so');

// data structure for communication with plugin
struct plugin_com_t
{
  input_line: string;
  string_pos:int;
  decoded_num:int;
  success:bool;
};

var plugin_com : plugin_com_t;
var ptr_plugin_com = C_hack::address_of plugin_com;
plugin_com.input_line = "I 1 i 2 3";

val m = len plugin_com.input_line;
var sum = 0;

// do it n times
var repeat_count = n; 
until repeat_count == 0 do

  // starting at start of string
  plugin_com.string_pos = 0;
  until plugin_com.string_pos == m do

    // trying each plugin
    var remaining_plugins = plugins; 
    plugin_com.success = false;
    until plugin_com.success do
    
      match remaining_plugins with
      | Empty => 
        {
          print "Can't find a suitable plugin"; endl;
          print "Position "; print plugin_com.string_pos; endl;
          System::exit 1;
        }

      | Cons (?plugin, ?tail) =>
        {
          var plug_lib = Dynlink::init_lib(plugin);
          Dynlink::run_proc(plug_lib,"plugin",ptr_plugin_com);
          if plugin_com.success do
            sum += plugin_com.decoded_num;
          else 
            remaining_plugins = tail;
          done;
          Dynlink::destroy_lib plug_lib;
        }
      endmatch;
    done;
  done;
  --repeat_count; 
done;

print sum; endl;

@select(tangler('bagley/felix/plugin_1.flx','data'))
@setup()
// data structure for communication with plugin
struct plugin_com_t
{
  input_line: string;
  string_pos:int;
  decoded_num:int;
  success:bool;
};

val zero = '0'.[0];
val nine = '9'.[0];
val space = ' '.[0];

proc plugin (p:address) {
  var q = C_hack::cast[C_hack::ptr[plugin_com_t]] p;
  val r = C_hack::deref q;
  var k = r.string_pos;
  var acc = 0;
  whilst r.input_line.[k] == space do ++k; done;
  if ord zero <= ord r.input_line.[k] &<= ord nine do
    whilst ord zero <= ord r.input_line.[k] &<= ord nine do
      acc += acc * 10 + (ord r.input_line.[k] - ord zero);
      ++k;
    done;
    r.success = true;
    r.decoded_num = acc;
    r.string_pos = k;
  else 
    r.success = false;
  done;
  C_hack::deref q = r;
}

export fun plugin of (address) as "plugin";

@select(tangler('bagley/felix/plugin_2.flx','data'))
@setup()
// data structure for communication with plugin
struct plugin_com_t
{
  input_line: string;
  string_pos:int;
  decoded_num:int;
  success:bool;
};

val zero = '0'.[0];
val nine = '9'.[0];
val space = ' '.[0];
val leadin = 'i'.[0];

proc plugin (p:address) {
  var q = C_hack::cast[C_hack::ptr[plugin_com_t]] p;
  val r = C_hack::deref q;
  var k = r.string_pos;
  var acc = 0;
  whilst r.input_line.[k] == space do ++k; done;
  if r.input_line.[k] == leadin do
    ++k;
    whilst r.input_line.[k] == space do ++k; done;
    if ord zero <= ord r.input_line.[k] &<= ord nine do
      whilst ord zero <= ord r.input_line.[k] &<= ord nine do
        acc += acc * 10 + (ord r.input_line.[k] - ord zero);
        ++k;
      done;
      r.success = true;
      r.decoded_num = acc;
      r.string_pos = k;
    else 
      r.success = false;
    done;
  else
    r.success = false;
  done;
  C_hack::deref q = r;
}

export fun plugin of (address) as "plugin";


@select(tangler('bagley/felix/plugin_3.flx','data'))
@setup()
// data structure for communication with plugin
struct plugin_com_t
{
  input_line: string;
  string_pos:int;
  decoded_num:int;
  success:bool;
};

val zero = '0'.[0];
val nine = '9'.[0];
val space = ' '.[0];
val leadin = 'I'.[0];

proc plugin (p:address) {
  var q = C_hack::cast[C_hack::ptr[plugin_com_t]] p;
  val r = C_hack::deref q;
  var k = r.string_pos;
  var acc = 0;
  whilst r.input_line.[k] == space do ++k; done;
  if r.input_line.[k] == leadin do
    ++k;
    whilst r.input_line.[k] == space do ++k; done;
    if ord zero <= ord r.input_line.[k] &<= ord nine do
      whilst ord zero <= ord r.input_line.[k] &<= ord nine do
        acc += acc * 10 + (ord r.input_line.[k] - ord zero);
        ++k;
      done;
      r.success = true;
      r.decoded_num = acc;
      r.string_pos = k;
    else 
      r.success = false;
    done;
  else
    r.success = false;
  done;
  C_hack::deref q = r;
}

export fun plugin of (address) as "plugin";


@select(tangler('bagley/felix/hash.flx','data'))
@setup()
include "stl";
open Stl;
open Stl::HashMap;

requires ext_string_hash;

body hexer """ 
string hex(int x) { char buf[20]; sprintf(buf,"%x",x); return buf; }
""";

fun hex: int -> string requires hexer;

var hm = HashMap::create[string,int]();

var i = n; until i == 0 do 
  insert(hm,hex i,i); 
  --i; 
done;

var c = 0;
i = n; until i == 0 do 
  if mem (hm,str i) do c++; done;
  --i;
done;

print c; endl;

 
@select(tangler('bagley/felix/hash2.flx','data'))
@setup()
include "stl";
open Stl;
open Stl::HashMap;

requires ext_string_hash;

var h1 = HashMap::create[string,int]();
   
var i = 1; until i == 10000 do
  s := "foo_" + str i;
  insert (h1, s, i);
  ++i;
done;

var h2 = HashMap::create[string,int]();

i=n; until i == 0 do
  var j = begin h1; until j == end h1 do
    k, v := deref j;
    h2.[k] = h2.[k] + v; 
    ++j;
  done;
  --i;
done;

print h1.["foo_1"]; print " "; print h1.["foo_9999"]; print " " ; 
print h2.["foo_1"]; print " "; print h2.["foo_9999"]; endl;




