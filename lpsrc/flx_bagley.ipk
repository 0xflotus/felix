@head(1,'Bagley Language Shootout')
Temporary script to check the tests work, and also
to get some times.
@select(tangler('bagley/run.sh'))
time bin/flx --test --optimise bagley/felix/ack 8
time bin/flx --test --optimise bagley/felix/fib 8
time bin/flx --test --optimise bagley/felix/nested_loops 8
time bin/flx --test --optimise bagley/felix/phone_numbers 8 
time bin/flx --test --optimise bagley/felix/random 1000
time bin/flx --test --optimise bagley/felix/hello_world 1
time bin/flx --test --optimise bagley/felix/matrix 8
time bin/flx --test --optimise bagley/felix/revfile 1 < bagley/data/phone_numbers.data
time bin/flx --test --optimise bagley/felix/sumcol < bagley/data/sumcol.data

@head(2,'Hello World')
@select(tangler('bagley/felix/hello_world.flx'))
include "std";
print "hello world"; endl;

@head(2,'Ackermans Function')
Two of the three calls are tail recursive.
@select(tangler('bagley/felix/ack.flx'))
include "std";

val n = atoi(System::argv 1);
print "ack "; print n; endl;

fun ack(x:int,y:int):int =>
  if x == 0 then  y + 1
  elif y == 0 then  ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;

val v = ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;


@head(2,'Fibonacci Function')
@select(tangler('bagley/felix/fib.flx'))
include "std";
val n = atoi(System::argv 1);
print "fib "; print n; endl;

fun fib(n:int):int => 
  if n < 2 then 1 else fib (n - 2) + fib (n - 1) endif
;

val v = fib(n);
print "Fib("; print n; print "): "; print v; endl;

@head(2,"Nested Loops")
@select(tangler('bagley/felix/nested_loops.flx'))
include "std";

val n = atoi(System::argv 1);
print "nested_loops "; print n; endl;

var a:int;
var b:int;
var c:int;
var d:int;
var e:int;
var f:int;
var x = 0;

for {a=0;} {a<n} {a++;} {
  for {b=0;} {b<n} {b++;} {
    for {c=0;} {c<n} {c++;} {
      for {d=0;} {d<n} {d++;} {
        for {e=0;} {e<n} {e++;} {
          for {f=0;} {f<n} {f++;} {
            x++;
          };
        };
      };
    };
  };
};

print x; endl;

@head(2,"Phone Numbers")
This GREATLY decreases the performance for this
test -- which would otherwise blow PCRE out of the water

Note: the actual result data given on the Alioth
site is WRONG and so are the regexp encodings
given by every language that passes this test.
The following entry:

@begin_displayed_code()
foo (213 222-2222 bar
@end_displayed_code()

actually meets the specified conditions but is listed
as a mismatch. You can see how the other languages
cheated -- for example the gcc encoding goes ..

@begin_displayed_code()
"(?:^|[^\\d\\(])"		/* must be preceeded by non-digit */
             ^ since when is ( a digit?
@end_displayed_code()


@select(tangler('bagley/felix/phone_numbers.flx'))
include "std";
var n = atoi(System::argv 1);
print "phone_numbers "; print n; endl;

open Lexer;

regexp digit = ["0123456789"];
regexp digits3 = digit digit digit;
regexp digits4 =  digits3 digit;

regexp area_code = digits3 | "(" digits3 ")";
regexp exchange = digits3;

regexp phone = area_code " " exchange (" " | "-") digits4;

// Felix, like Python, provides no literals of char type
zero := ord("0".[0]);
nine := ord("9".[0]);

// Felix regular matching currently only supports
// actual regular sets of strings -- it does not support
// lookback or lookahead because they're not regular
// 
// So we have to hand code the context check.
//
fun check_context(start: iterator, finish: iterator): string =
{
  prior :=  ord(deref(start-1));
  next := ord(deref(finish));
  return 
    if zero <= prior &<= nine 
    or zero <= next &<= nine 
    then ""
    else string_between(start, finish)
    endif
  ;
}

// this is the actual lexer function
fun lexit (start:iterator, finish:iterator): iterator * string =>
  reglex start to finish with
  | phone => check_context (lexeme_start, lexeme_end)
  | _ => ""
  endmatch
;

// hack so context_check won't crash (pre- and append space)
val data = " " + Text_file::load("bagley/data/phone_numbers.data")+" ";
first := Lexer::start_iterator data;
finish := Lexer::end_iterator data;


while {n>1} {
  var current = first;
  while {current != finish} {
    def current, val s = lexit(current, finish);
  };
  --n;
};

proc print_phone(x:string, j:int) {
  n := len x;
  var s = "";
  var i = 0;
  while {i<n} {
    if zero <= ord(x.[i]) &<= nine 
    then { s = s + ord(x.[i]); }
    else {}
    endif;
    ++i;
  };
  print j; print ": ";
  print ("("+s.[0 to 3]+") "+s.[3 to 6]+" "+s.[6 to 10]); endl;
}

var current = first;
var j = 0;
while {current != finish} {
 def current, val s = lexit(current, finish);
 if s != "" then { ++j; print_phone (s,j); } else {} endif;
};

@select(tangler('bagley/data/phone_numbers.data'))
datafile for regex matching of phone numbers test

the following numbers should match:

(111) 111 1111
111 222-2222
(111) 333-3333
111 444 4444

foo (111) 555 5555
foo 111 666-6666
foo (111) 777-7777
foo 111 888 8888

foo (111) 999 9999 bar
foo 111 000-0000 bar
foo (111) 232-1111 bar
foo 111 242 1111 bar

The following should fail to match:

2(212) 222 2222
2232 222-2222
(242) 222-22222
2252 222 2222

foo (262) 2222222
foo 272 2222222
foo (282) 222-22227
foo 292 222 22222

foo (202).222 2222 bar
foo 211@22222222 bar
foo (213 222-2222 bar
foo 214) 222 2222 bar

@#@select(tangler('bagley/data/moments.flx'))
@#// to be done

@select(tangler('bagley/data/moments.data'))
@for i in range(1,501):
  tangle(str(i))
@doc()

@head(2,'Random Numbers')
Copied from the Ocaml code.
@select(tangler('bagley/felix/random.flx'))
include "std";
val n = atoi(System::argv 1);
print "random "; print n; endl;

im := 139968;
ia := 3877;
ic := 29573;
first_last := 42;


fun gen_random (max:double, last:int, i:int):double =>
  let ?new_last = (last * ia + ic) % im in
  if i > 1 then gen_random (max, new_last, (i - 1))
  else max * double_of new_last / double_of im
  endif
;

print (gen_random (100.0, first_last, n)); endl;

@head(2,'Reverse a File')
@select(tangler('bagley/felix/revfile.flx'))
include "std";
val n = atoi(System::argv 1);
print "revfile "; print n; endl;

open List;
open Text_file;

var x = Empty[string];
var s = readln stdin;
while { s != "" } 
{ 
  x = Cons (s,x);
  s = readln stdin; 
};

proc plist(x:list[string]){
  match x with
  | Cons (?s,?t) => { print s; plist t; }
  |  _ => {}
  endmatch;
};

plist x; endl;

@head(2,'Matrix multiplication')
@select(tangler('bagley/felix/matrix.flx'))
//Adapted from C++ solution.

include "std";
val n = atoi(System::argv 1);
print "matrix "; print n; endl;

body """
int **mkmatrix(int rows, int cols) {
  int i, j, count = 1;
  int **m = (int **) malloc(rows * sizeof(int *));
  for (i=0; i<rows; i++) {
    m[i] = (int *) malloc(cols * sizeof(int));
    for (j=0; j<cols; j++) m[i][j] = count++;
  }
  return(m);
}

void zeromatrix(int rows, int cols, int **m) {
  int i, j;
  for (i=0; i<rows; i++)
  for (j=0; j<cols; j++)
	  m[i][j] = 0;
}

void freematrix(int rows, int **m) {
  while (--rows > -1) free(m[rows]);
  free(m);
}

void mmult(int rows, int cols, int **m1, int **m2, int **m3) {
  int i, j, k, val;
  for (i=0; i<rows; i++)
	for (j=0; j<cols; j++) {
	  val = 0;
	  for (k=0; k<cols; k++) val += m1[i][k] * m2[k][j];
    m3[i][j] = val;
  }
}

int get(int **mm, int x, int y) { return mm[x][y];}
""";

type matrix = "int**";
fun mkmatrix: int * int -> matrix;
fun get: matrix * int * int -> int;
proc zeromatrix: matrix;
proc mmult: int * int * matrix * matrix * matrix;
proc freematrix: int * matrix;

SIZE := 30;
m1 := mkmatrix(SIZE,SIZE);
m2 := mkmatrix(SIZE,SIZE);
mm := mkmatrix(SIZE,SIZE);

var i : int;
for {i=0;} {i<n} {i++;} {
	mmult(SIZE, SIZE, m1, m2, mm);
};

print (get(mm,0,0)); print " "; 
print (get(mm,2,3)); print " "; 
print (get(mm,3,2)); print " "; 
print (get(mm,4,4)); endl;

freematrix(SIZE, m1);
freematrix(SIZE, m2);
freematrix(SIZE, mm);

@head(2,'Sum column of integers')
@select(tangler('bagley/felix/sumcol.flx'))
include "std";
val n = atoi(System::argv 1);
print "sumcol"; print n; endl;

open Text_file;
var sum = 0;
var line = readln stdin;

while {line != "" } {
  word := line.[to -1];
  sum += atoi(word);
  line = readln stdin;
};

print sum; endl;


@select(tangler('bagley/data/sumcol.data'))
@for i in range(1,1001): tangle(str(i))
@doc()

