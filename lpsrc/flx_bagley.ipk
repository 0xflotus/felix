@head(1,'Bagley Language Shootout')
Temporary script to check the tests work, and also
to get some times.
@select(tangler('bagley/run.sh'))
time for i in 1 2 3 4 5 6 7 8; do bin/flx --test --optimise bagley/felix/ack $i; done
time for i in 1 2 3 4 5 6 7 8; do bin/flx --test --optimise bagley/felix/fib $i; done
time for i in 1 2 3 4; do bin/flx --test --optimise bagley/felix/nested_loops $i; done
time for i in 1 2 3 4; do bin/flx --test --optimise bagley/felix/phone_numbers $i; done
time bin/flx --test --optimise bagley/felix/random 1000
time bin/flx --test --optimise bagley/felix/hello_world $i
time bin/flx --test --optimise bagley/felix/revfile $i < bagley/data/phone_numbers.data

@head(2,'Hello World')
@select(tangler('bagley/felix/hello_world.flx'))
include "std";
print "hello world"; endl;

@head(2,'Ackermans Function')
Two of the three calls are tail recursive.
@select(tangler('bagley/felix/ack.flx'))
include "std";

val n = String::atoi(System::argv 1);
print "ack "; print n; endl;

fun ack(x:int,y:int):int =>
  if x == 0 then  y + 1
  elif y == 0 then  ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;

val v = ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;


@head(2,'Fibonacci Function')
@select(tangler('bagley/felix/fib.flx'))
include "std";
val n = String::atoi(System::argv 1);
print "fib "; print n; endl;

fun fib(n:int):int => 
  if n < 2 then 1 else fib (n - 2) + fib (n - 1) endif
;

val v = fib(n);
print "Fib("; print n; print "): "; print v; endl;

@head(2,"Nested Loops")
@select(tangler('bagley/felix/nested_loops.flx'))
include "std";

val n = String::atoi(System::argv 1);
print "nested_loops "; print n;

var a:int;
var b:int;
var c:int;
var d:int;
var e:int;
var f:int;
var x = 0;

for {a=0;} {a<n} {a++;} {
  for {b=0;} {b<n} {b++;} {
    for {c=0;} {c<n} {c++;} {
      for {d=0;} {d<n} {d++;} {
        for {e=0;} {e<n} {e++;} {
          for {f=0;} {f<n} {f++;} {
            x++;
          };
        };
      };
    };
  };
};

print x; endl;

@head(2,"Phone Numbers")
@select(tangler('bagley/felix/phone_numbers.flx'))
// Felix regular matching currently only supports
// actual regular sets of strings -- it does not support
// lookback or lookahead because they're not regular
// 
// So we have to hand code the context check.
//
// This GREATLY decreases the performance for this
// test -- which would otherwise blow PCRE out of the water
//
// Note: the actual result data given on the Alioth
// site is WRONG and so are the regexp encodings
// given by every language that passes this test.
// The following entry:
//
//foo (213 222-2222 bar
//
// actually meets the specified conditions but is listed
// as a mismatch. You can see how the other languages
// cheated -- for example the gcc encoding goes ..
//
//"(?:^|[^\\d\\(])"		/* must be preceeded by non-digit */
//             ^ since when is ( a digit?


include "std";
var n = String::atoi(System::argv 1);
print "phone_numbers "; print n; endl;

open Lexer;

regexp digit = ["0123456789"];
regexp digits3 = digit digit digit;
regexp digits4 =  digits3 digit;

regexp area_code = digits3 | "(" digits3 ")";
regexp exchange = digits3;

regexp phone = area_code " " exchange (" " | "-") digits4;

// Felix, like Python, provides no literals of char type
zero := ord("0".[0]);
nine := ord("9".[0]);

fun check_context(start: iterator, finish: iterator): string =
{
  prior :=  ord(deref(start-1));
  next := ord(deref(finish));
  return 
    if prior >= zero and prior <= nine 
    or next >= zero and next <= nine 
    then ""
    else string_between(start, finish)
    endif
  ;
}

fun lexit (start:iterator, finish:iterator): iterator * string =>
  reglex start to finish with
  | phone => check_context (lexeme_start, lexeme_end)
  | _ => ""
  endmatch
;

// hack so context_check won't crash
val data = " " + Text_file::load("bagley/data/phone_numbers.data")+" ";
first := Lexer::start_iterator data;
finish := Lexer::end_iterator data;


while {n>1} {
  var current = first;
  while {current != finish} {
    def current, val s = lexit(current, finish);
  };
  --n;
};

proc print_phone(x:string, j:int) {
  n := len x;
  s := "";
  var i = 0;
  while {i<n} {
    if ord(x.[i]) >= zero and ord(x.[i]) <= nine 
    then { s = s + ord(x.[i]); }
    else {}
    endif;
    ++i;
  };
  print j; print ": ";
  print ("("+s.[0 to 3]+") "+s.[3 to 6]+" "+s.[6 to 10]); endl;
}

var current = first;
var j = 0;
while {current != finish} {
 def current, val s = lexit(current, finish);
 if s != "" then { ++j; print_phone (s,j); } else {} endif;
};

@select(tangler('bagley/data/phone_numbers.data'))
datafile for regex matching of phone numbers test

the following numbers should match:

(111) 111 1111
111 222-2222
(111) 333-3333
111 444 4444

foo (111) 555 5555
foo 111 666-6666
foo (111) 777-7777
foo 111 888 8888

foo (111) 999 9999 bar
foo 111 000-0000 bar
foo (111) 232-1111 bar
foo 111 242 1111 bar

The following should fail to match:

2(212) 222 2222
2232 222-2222
(242) 222-22222
2252 222 2222

foo (262) 2222222
foo 272 2222222
foo (282) 222-22227
foo 292 222 22222

foo (202).222 2222 bar
foo 211@22222222 bar
foo (213 222-2222 bar
foo 214) 222 2222 bar

@#@select(tangler('bagley/data/moments.flx'))
@#// to be done

@select(tangler('bagley/data/moments.data'))
@for i in range(1,501):
  tangle(str(i))
@doc()

@select(tangler('bagley/felix/random.flx'))
include "std";
val n = String::atoi(System::argv 1);
print "random "; print n; endl;

im := 139968;
ia := 3877;
ic := 29573;
first_last := 42;


fun gen_random (max:double, last:int, i:int):double =>
  let ?new_last = (last * ia + ic) % im in
  if i > 1 then gen_random (max, new_last, (i - 1))
  else max * double_of new_last / double_of im
  endif
;

print (gen_random (100.0, first_last, n)); endl;

@select(tangler('bagley/felix/revfile.flx'))
include "std";
val n = String::atoi(System::argv 1);
print "revfile "; print n; endl;

open List;
open Text_file;

var x = Empty[string];
var s = readln stdin;
while { s != "" } 
{ 
  x = Cons (s,x);
  s = readln stdin; 
};

proc plist(x:list[string]){
  match x with
  | Cons (?s,?t) => { print s; plist t; }
  |  _ => {}
  endmatch;
};

plist x; endl;
