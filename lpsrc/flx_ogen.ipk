@head(1,'GC shape object generator')
@h = tangler('src/flx_ogen.mli')
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2

val gen_offset_tables:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  string

val find_thread_vars_with_type:
  fully_bound_symbol_table_t ->
  (bid_t * btypecode_t) list

val find_references:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  bid_t ->
  btypecode_t list ->
  (bid_t * btypecode_t) list

@h = tangler('src/flx_ogen.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_name
open Flx_unify
open Flx_typing
open Flx_tgen
open List
open Flx_print
open Flx_exceptions
open Flx_maps

let find_thread_vars_with_type bbdfns =
  let vars = ref [] in
  Hashtbl.iter
  (fun k (id,parent,sr,entry) ->
    match parent,entry with
    | None,`BBDCL_var (_,t)
    | None,`BBDCL_val (_,t)
      -> vars := (k,t) :: !vars
    | _ -> ()
  )
  bbdfns
  ;
  !vars


let find_references syms (child_map,bbdfns) index ts = 
  let children = 
    try 
      Hashtbl.find child_map index 
    with Not_found -> []
  in
  let references = ref [] in
  iter
  (fun idx -> 
    try
      let id,_,_,bbdfn = 
        Hashtbl.find bbdfns idx
      in
      match bbdfn with
      | `BBDCL_var (vs,t)
      | `BBDCL_val (vs,t)
        -> 
        if length ts <> length vs then 
        failwith 
        (
          "[find_references} wrong number of args, expected vs = " ^ 
          si (length vs) ^ 
          ", got ts=" ^ 
          si (length ts)
        );
        let t = reduce_type (tsubst vs ts (lower t)) in
        references := (idx,t) :: !references
      | _ -> ()
    with Not_found -> ()
  ) 
  children 
  ;
  rev (!references)

let comma_sub s = 
  let rec aux l r =
    try   (* note: breaks tail recursion optimisation *)
      let i = String.index r ',' in
      let n = String.length r in
      aux (l ^ String.sub r 0 i ^ " comma ") (String.sub r (i+1) (n-i-1))
    with Not_found -> l ^ r
  in
  aux "" s
 
(* this code handles pointers in types *)
let rec get_offsets' syms bbdfns typ : string list =
  let typ = reduce_type (lstrip syms.dfns typ) in
  let tname = cpp_typename syms typ in
  let t' = unfold syms.dfns typ in
  match t' with
    
  | `BTYP_pointer t -> 
    ["offsetof("^tname^",frame)"]

  | `BTYP_sum args when not (all_units args) -> 
    ["offsetof("^tname^",data)"]

  | `BTYP_inst (i,ts) ->
    let id,parent,sr,entry = Hashtbl.find bbdfns i in 
    begin match entry with
    | `BBDCL_union (vs,idts) ->
      let varmap = mk_varmap vs ts in
      let cpts = map (fun (_,t) -> varmap_subst varmap t) idts in
      if all_voids cpts then []
      else ["offsetof("^tname^",data)"]

    | `BBDCL_struct (vs,idts) ->
      let varmap = mk_varmap vs ts in
      let n = ref 0 in
      let cpts = map (fun (s,t) -> s,varmap_subst varmap t) idts in
      let lst = ref [] in
      iter 
      (fun (s,t) ->
        let prefix = 
          "offsetof("^tname^","^s^")+" 
        in
        iter
        (fun s -> lst := !lst @ [prefix ^ s])
        (get_offsets' syms bbdfns t)
      )
      cpts 
      ;
      !lst
 
    (* this is a HACK to fix the continuation type *)
    | `BBDCL_abs (vs,_,`Str "flx::rtl::con_t*",_) 
    | `BBDCL_abs (vs,_,`StrTemplate "flx::rtl::con_t*",_) 
       when id = "cont" -> ["0"]
    
    | _ -> []
    end

  | `BTYP_array (t,`BTYP_unitsum k) -> 
    let toffsets = get_offsets' syms bbdfns t in
    if toffsets = [] then [] else 
    if k> 100 then 
      failwith ("[get_offsets] Too many elements in array for shape, type " ^ sbt syms.dfns t')
    else begin
      let eltype = cpp_typename syms t in
      fold_left 
      (fun result i -> 
        let ss = "+" ^ si i ^ "*sizeof("^eltype^")" in
        fold_left
        (fun result s -> (s ^ ss) :: result)
        result
        toffsets
      )
      []
      (nlist k)
    end

  | `BTYP_tuple args -> 
    let n = ref 0 in
    let lst = ref [] in
    iter 
    (fun t ->
      let prefix = 
        "offsetof("^tname^",mem_"^si !n^")+" 
      in
      iter
      (fun s -> lst := !lst @ [prefix ^ s])
      (get_offsets' syms bbdfns t)
      ;
      incr n
    )
    args
    ;
    !lst

  | `BTYP_function _ -> ["0"]

  | `BTYP_unitsum _ -> []

  | `BTYP_intersect _
    -> failwith "[ogen] Type intersection has no representation"

  (* this is a lie .. it does, namely a plain C union *)
  | `BTYP_typeset _ 
    -> failwith "[ogen] Type set has no representation"

  | `BTYP_sum _
  | `BTYP_array _ 
  | `BTYP_lvalue _ 
  | `BTYP_fix _
  | `BTYP_void 
  | `BTYP_var _ 

  | `BTYP_apply _
  | `BTYP_type 
  | `BTYP_typefun _
  | `BTYP_type_tuple _
  | `BTYP_type_match _ -> assert false

let get_offsets syms bbdfns typ =
  map (fun s -> s^",") (get_offsets' syms bbdfns typ)

let gen_offset_data s n name offsets isfun props =
  let noffsets = 
    if isfun && mem `Requires_ptf props then si (n-1)^"+FLX_PASS_PTF"
    else si n
  in
  if n <> 0 then
  begin
    bcat s ("static std::size_t " ^ name ^ 
      "_offsets["^noffsets^ "]={\n");
    bcat s ("  " ^ cat "\n  " offsets);
    bcat s ("\n" ^  "};\n");
  end;
  bcat s ("FLX_FINALISER("^name^")\n");
  bcat s (  "static gc_shape_t "^ name ^"_ptr_map (\n");
  bcat s ("  \"" ^ name ^ "\",\n");
  bcat s ( "  1,sizeof("^name^"),\n  "^name^"_finaliser,\n  "^noffsets^",\n  "^
  (if n<>0 then name^"_offsets\n" else "0\n"));
  bcat s ( ");\n")

let is_instantiated syms i ts = Hashtbl.mem syms.instances (i,ts)

let gen_fun_offsets s syms (child_map,bbdfns) index vs ps ret ts instance props : unit = 
  let vars =  (find_references syms (child_map,bbdfns) index ts) in
  let vars = filter (fun (i, _) -> is_instantiated syms i ts) vars in
  let name = cpp_instance_name syms bbdfns index ts in
  let display = Flx_display.get_display_list bbdfns index in
  let offsets = 
    (if mem `Requires_ptf props then
    ["FLX_EAT_PTF(offsetof(" ^ name ^ ",ptf)comma)"]
    else []
    )
    @
    (match ret with 
      | `BTYP_void -> [ ("offsetof(" ^ name ^ ",_caller),")  ] 
      | _ -> []
    ) 
    @
    map
    (fun (didx, vslen) ->
    let dptr = "ptr" ^ cpp_instance_name syms bbdfns didx (list_prefix ts vslen) in
    "offsetof("^name^","^dptr^"),"
    )
    display
    @
    concat
    (
      map 
      (fun (idx,typ)->
        let mem = cpp_instance_name syms bbdfns idx ts in
        let offsets = get_offsets syms bbdfns typ in
        map 
        (fun offset ->
          "offsetof("^name^","^mem^")+" ^ offset
        )
        offsets 
      )
      vars
    )
  in
  let n = length offsets in
  bcat s 
  (
    "\n//OFFSETS for "^
    (match ret with |`BTYP_void -> "procedure " | _ -> "function ") ^ 
    name ^ "\n"
  );
  gen_offset_data s n name offsets true props

let gen_thread_frame_offsets s syms bbdfns =
  let vars = find_thread_vars_with_type bbdfns in
  let ts = [] in
  let name = "thread_frame_t" in
  let offsets = 
    concat
    (
      map 
      (fun (idx,typ)->
        let mem = cpp_instance_name syms bbdfns idx ts in
        let offsets = get_offsets syms bbdfns typ in
        map 
        (fun offset ->
          "offsetof("^name^","^mem^")+" ^ offset
        )
        offsets 
      )
      vars
    )
  in
  let n = length offsets in
  bcat s 
  (
    "\n//OFFSETS for "^ name ^ "\n"
  );
  gen_offset_data s n name offsets false []

let gen_offset_tables syms (child_map,bbdfns) =
  let primitive_shapes = Hashtbl.create 97 in
  let s = Buffer.create 20000 in

  (* print_endline "Function and procedure offsets"; *)
  Hashtbl.iter
  (fun (index,ts) instance ->
    let id,parent,sr,entry = Hashtbl.find bbdfns index in 
    (*
    print_endline ("Offsets for " ^ id ^ "<"^ si index ^">["^catmap "," (sbt syms.dfns) ts ^"]");
    *)
    match entry with
    | `BBDCL_function (props,vs,ps, ret,_) -> 
      if mem `Heap_closure props then
        gen_fun_offsets s syms (child_map,bbdfns) index vs ps ret ts instance props
      (*
      else 
        print_endline ("Warning: no closure of " ^ id ^ "<"^si index ^"> is used")
      *)

    | `BBDCL_regmatch (props,vs,ps,ret,_) 
    | `BBDCL_reglex (props,vs,ps,_,ret,_)  ->
      if mem `Heap_closure props then
        gen_fun_offsets s syms (child_map,bbdfns) index vs ps ret ts instance props
      (*
      else 
        print_endline ("Warning: no closure of " ^ id ^ "<"^si index ^"> is used")
      *)
        
    | `BBDCL_procedure (props,vs,ps,_) -> 
      if mem `Heap_closure props then
        gen_fun_offsets s syms (child_map,bbdfns) index vs ps `BTYP_void ts instance props
      (*
      else
        print_endline ("Warning: no closure of " ^ id ^"<" ^ si index ^ "> is used")
      *)
    | _ -> ()
  )
  syms.instances
  ;
  gen_thread_frame_offsets s syms bbdfns
  ;

  (* We're not finished: we need offsets dynamically allocated types too *)

  (* currently the ONLY non-function types that can be allocated
    are the arguments of non-constant variant constructors:
    this WILL change when a 'new' operator is introduced.
  *)
  let allocable_types = Hashtbl.create 97 in
  Hashtbl.iter
  (fun btyp index -> 
    match unfold syms.dfns btyp with
    | `BTYP_sum args -> 
      iter 
      (fun t -> let t = reduce_type t in
        match t with
        | `BTYP_tuple [] 
        | `BTYP_void -> ()
        | _ -> 
          try
          let index = Hashtbl.find syms.registry t in
          Hashtbl.replace allocable_types t index
          with Not_found -> 
            failwith ("Can't find the type " ^ sbt syms.dfns t ^ " in registry")
      )
      args

    | `BTYP_inst (i,ts) ->
      (*
      print_endline ("Thinking about instance type --> " ^ string_of_btypecode syms.dfns btyp);
      *)
      let id,parent,sr,entry = Hashtbl.find bbdfns i in 
      begin match entry with
      | `BBDCL_union (vs,args) ->
        let varmap = mk_varmap vs ts in
        let args = map snd args in
        let args = map (varmap_subst varmap) args in
        iter 
        (fun t -> let t = reduce_type t in
          match t with
          | `BTYP_tuple [] 
          | `BTYP_void -> ()
          | _ -> 
            (*
              print_endline ("Thinking about argument type --> " ^ string_of_btypecode syms.dfns t);
            *)
            try
            let index = Hashtbl.find syms.registry t in
            Hashtbl.replace allocable_types t index
            with Not_found -> 
              failwith ("Can't find the type " ^ sbt syms.dfns t ^ " in registry")
        )
        args
      | _ -> ()
      end
    | _ -> ()
  )
  syms.registry
  ;
  Hashtbl.iter
  (fun btyp index -> 
    (*
    print_endline ("allocable type --> " ^ string_of_btypecode syms.dfns btyp);
    *)
    match unfold syms.dfns btyp with
    | `BTYP_tuple args ->
      let name = cpp_type_classname syms btyp in
      let offsets = get_offsets syms bbdfns btyp in
      let n = length offsets in 
      let classname = cpp_type_classname syms btyp in
      bcat s ("\n//OFFSETS for tuple type " ^ si index ^ "\n");
      gen_offset_data s n name offsets false []

    (* for an array, we only have offsets for the first element *)
    | `BTYP_array (t,i) ->
      let k = 
        try int_of_unitsum i
        with Not_found -> failwith "Array index must be unitsum"
      in
      let name = cpp_typename syms btyp in
      let tname = cpp_typename syms t in
      let offsets = get_offsets syms bbdfns t in
      let n = length offsets in 
      bcat s ("\n//OFFSETS for array type " ^ si index ^ "\n");
      if n <> 0 then begin
        bcat s ("static std::size_t " ^ name ^ "_offsets["^si n^"]={\n  ");
        bcat s ("  " ^ cat ",\n  " offsets);
        bcat s "};\n"
      end
      ;

      bcat s ("//WARNING: ONLY WORKS WITH CORRECT STATIC SIZE\n");
      bcat s ("static void " ^ name ^ "_finaliser(collector_t *, void *p){\n");
      bcat s ("  for(std::size_t count = "^ si k ^"; count; --count)\n");
      bcat s ("  {\n");
      bcat s ("    (("^ tname ^ "*)p)->~" ^ tname ^ "();\n");
      bcat s ("    p = (void*)((char*)p + sizeof("^tname^"));\n");
      bcat s ("  }\n");
      bcat s ("}\n");
      bcat s ("static gc_shape_t "^ name ^"_ptr_map(\n");
      bcat s ("  \"" ^ name ^ "\",\n");
      bcat s ("  " ^ si k ^ ",\n");
      bcat s ("  sizeof("^name^"),\n  "^name^"_finaliser,\n  "^si n^
      (
        if n = 0 then ",0\n" 
        else ",\n  " ^name^"_offsets\n"
      )
      );
      bcat s ");\n"

    | `BTYP_inst (i,ts) ->
      let name = cpp_typename syms btyp in
      let id,parent,sr,entry = Hashtbl.find bbdfns i in 
      begin match entry with
      | `BBDCL_abs (_,quals,_,_) ->
        let complete = not (mem `Incomplete quals) in
        let pod = mem `Pod quals in
        if complete then
          if not (Hashtbl.mem primitive_shapes name) then 
          begin
            Hashtbl.add primitive_shapes name true; 
            bcat s ("\n//OFFSETS for complete abstract "^(if pod then "pod " else "finalisable ")^
              "type " ^ name ^ " instance\n"
            );
            if not pod then bcat s ("FLX_FINALISER("^name^")\n");
            bcat s ( "static gc_shape_t " ^ name ^ "_ptr_map(\n") ;
            bcat s ("  \"" ^ name ^ "\",\n");
            if pod then
              bcat s ("  1,sizeof("^name^"),0,0,0\n")
            else
              bcat s ("  1,sizeof("^name^"),"^name^"_finaliser,0,0\n")
            ;
            bcat s ");\n"
          end else begin
            bcat s ("\n//OFFSETS for abstract type " ^ name ^ " instance\n");
            bcat s ("//Use "^name^"_ptr_map\n");
          end
        else 
          clierr sr 
          ("[ogen] attempt to allocate an incomplete type: '" ^ id ^"'")
        
      | `BBDCL_union _ -> () (* handled by universal _uctor_ *)
      | `BBDCL_cstruct (vs,cps)
      | `BBDCL_struct (vs,cps) ->
        failwith 
        (
          "[ogen]: can't handle struct offsets yet: type " ^ 
          sbt syms.dfns btyp
        )
        (*
        bcat s ("\n//OFFSETS for struct type " ^ name ^ " instance\n");
        bcat s ("//CANT HANDLE YET!\n");
        *)
      | _ -> 
        failwith 
        (
          "[ogen]: can't handle instances of this kind yet: type " ^ 
          sbt syms.dfns btyp
        )
    end

   | _ -> 
     failwith 
     (
       "[ogen]: Unknown kind of allocable type " ^ 
       sbt syms.dfns btyp
     )
  )
  allocable_types
  ;
  Buffer.contents s


