@head(1,"Name Lookup")
There are some tricky issues with the name binding
rules. First, name binding is complicated by the fact
we support overloading. This defeats a simple linear
binding scheme: instead, we need to bind the type
of the argument of the application of a named function.
@p()
In addition, felix provides simple first order
generics by allowing declared name to be parameterised
by types.
@p()
There are two names then: simple and indexed.
Indexed names must of course refer to declarations
with the right number of parameters.
@p()
However, a non-indexed name may refer to a non-generic
entity, or, refer to a local generic entity, in which
case the arguments are just the list of parameter names.
@p()
Actually we can further generalise because of nesting.
Name binding consists of uniquely identifying
every name, and replacing the concrete name with
its canonical representation. Each declared name 
is number in order of writing, and takes type
parameters in a single list which is the concatenation
of the visible parameters in order of writing, in
other words starting with the outermost construction:
we can assume all names are parameterised by a list
of types, modeling non-generic names as if they had
0 type parameters.
@p()
We need to note now how our code is driven.
We start with certain non-genertc root functions,
and recurse through the call structure. In the root
of course, the type arguments used for a name must
selves be monomorphic (free of type variables),
so the binding itself is monomorphic.
@p()
What this all means is that routines like
bind_type and bind_expression are always accepting
and returning monomorphic data. What all this
means is that the indexing scheme never needs any
bound type variables: a name denoting a type parameter
is always being replaced by a monotype directly,
without any need to first go to variables and then
instantiate them.
@p()
Hmm .. messy .. consider:
@begin_displayed_code()
val x0 = 1;
module p1[t1] {
  val x1 = x0;
  module p2[t2] {
    va1 x2a = x1 + x2; // x1[t1] + x2[t1,t2]
    va1 x2b = x1 + p2[int]::x2; // x1[t1] + x2[t1,int]

  .. fine .. but the equivalent function structure:

val x0 = 1;
proc p1[t1]() {
  val x1 = x0;
  proc p2[t2]() {
    va1 x2a = x1 + x2; // x1[t1] + x2[t1,t2]
    // explicit indexing here is not allowed
    // for *variables* since
    // we have to refer to a a stack from on
    // the display which has fixed type
    // parameters .. but it IS allowed for
    // enclosed types (since type are static ..)
@end_displayed_code()
SUMMARY .. the total number of variables needed to
instaniate a name is the length of the list
of the concatenation of the type vaiable lists
of the entities ancestors including itself.
If any indexes are given explicitly, they're
always most local, and replace the last so many
bindings from context. Note the number of *implicit*
variables needed may be less than those given
if the name is defined in a parent: in this case
we just take first part of the argument list.
@p()
With this mechanism a simply list of bound
type indices suffices provided when a lookup
is done we calculate how many values are needed.
@p()
Hmm: this may cause a LOT of pain, if we're looking
up generic functions .. since we assumed the lookup
could select on the number of arguments .. well,
it can, by adjusting as the search deepens .. nice!
@p()
Technology: given an index i, find its vs list including
that of its parents (string -> int) form.

@h = tangler("src/flx_lookup.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2

val lookup_name_in_htab:
  name_map_t ->
  string -> 
  entry_set_t option

val build_env:
  sym_state_t ->
  int option -> (* parent *)
  env_t

val lookup_name_in_env :
  sym_state_t ->
  env_t ->
  range_srcref ->
  id_t -> 
  entry_set_t

val lookup_qn_in_env :
  sym_state_t ->
  env_t ->
  qualified_name_t -> 
  entry_kind_t * typecode_t list

val lookup_qn_in_env2:
  sym_state_t ->
  env_t ->
  qualified_name_t -> 
  entry_set_t * typecode_t list

val lookup_sn_in_env :
  sym_state_t ->
  env_t ->
  suffixed_name_t -> 
  int * btypecode_t list

val lookup_code_in_env:
  sym_state_t ->
  env_t ->
  range_srcref ->
  qualified_name_t -> 
  entry_kind_t list * typecode_t list

(** This routine takes an unbound type term 
and binds it. The term may contain explicit
type variables. If the term denotes a generative
type (abstract, union, or struct) then an instance
is made with type variables for the indices.

Note that the result of binding a term with type
variables is not a type function.
*)

val bind_type:
  sym_state_t ->
  env_t ->
  range_srcref ->
  typecode_t ->
  btypecode_t

val eval_module_expr:
  sym_state_t ->
  env_t ->
  expr_t ->
  module_rep_t

val resolve_overload:
  sym_state_t -> 
  range_srcref ->
  entry_kind_t list ->  
  id_t -> 
  btypecode_t list ->
  btypecode_t list ->      (* explicit param/arg bindings *)
  (entry_kind_t * btypecode_t * (int * btypecode_t) list * btypecode_t list) option

val bind_expression :
  sym_state_t ->
  env_t ->
  expr_t ->
  tbexpr_t

val typeofindex :
  sym_state_t ->
  int ->
  btypecode_t

val typeofindex_with_ts:
  sym_state_t ->
  range_srcref ->
  int ->
  btypecode_t list ->
  btypecode_t

val typeof_literal:
  sym_state_t ->
  env_t ->
  range_srcref ->
  literal_t ->
  btypecode_t

val lookup_qn_with_sig:
  sym_state_t ->
  range_srcref ->
  range_srcref ->
  env_t ->
  qualified_name_t ->
  btypecode_t list ->
  tbexpr_t

val bind_regdef:
  sym_state_t ->
  env_t ->
  int list -> (* regexp exclusion list *)
  regexp_t ->
  regexp_t

@h = tangler("src/flx_lookup.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_exceptions
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_typing2
open List
open Flx_srcref
open Flx_unify
open Flx_beta
open Flx_generic
open Flx_name
open Flx_overload
open Flx_tpat

let unit_t = `BTYP_tuple []

let lvalify t = match t with 
  | `BTYP_lvalue _ -> t
  | t -> `BTYP_lvalue t

exception Found of int
exception Tfound of btypecode_t

type kind_t = Parameter | Other

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_lookup.get_data] No definition of <" ^ string_of_int index ^ ">")

let lookup_name_in_htab htab name : entry_set_t option =
  (* print_endline ("Lookup name in htab: " ^ name); *)
  try Some (Hashtbl.find htab name)
  with Not_found -> None
  
let merge_functions 
  (opens:entry_set_t list) 
  name 
: entry_kind_t list = 
  fold_left
    (fun init x -> match x with
    | FunctionEntry ls -> 
      fold_left
      (fun init x -> 
        if mem x init then init else x :: init
      )
      init ls
    | _ -> failwith ("[merge_functions] Expected " ^ name ^ " to be function overload set in all open modules")
    )
  []
  opens

let lookup_name_in_table_dirs table dirs sr name : entry_set_t option =
  (* 
  print_endline ("Lookup name " ^ name ^ " in table dirs");
  flush stdout;
  *)
  match lookup_name_in_htab table name with
  | Some x as y -> 
    (*
    print_endline ("Lookup_name_in_htab found " ^ name);
    *)
    y
  | None ->
  let opens = 
    concat
    (
      map
      (fun table -> 
        match lookup_name_in_htab table name with
        | Some x -> [x]
        | None -> [] 
      )
      dirs
    )
  in 
  match opens with
  | [x] -> Some x
  | FunctionEntry ls :: rest ->
    Some (FunctionEntry (merge_functions opens name))

  | (NonFunctionEntry (i)) as some ::_ -> 
    if 
      fold_left 
        (function t -> function
          | NonFunctionEntry (j) when i = j -> t
          | _ -> false
        )
        true
        opens
    then 
      Some some
    else
      clierr sr ("Conflicting values for "^name ^" found in open modules")
  
  | [] -> None


type recstop = {
  idx_fixlist: int list;
  type_alias_fixlist: (int * int) list;
  as_fixlist: (string * int) list;
  expr_fixlist: (expr_t * int) list;
  depth:int;
  open_excludes : qualified_name_t list
}

let rsground= { 
  idx_fixlist = [];
  type_alias_fixlist = [];
  as_fixlist = [];
  expr_fixlist = [];
  depth = 0;
  open_excludes = []
}

(* this ugly thing merges a list of function entries
some of which might be inherits, into a list of
actual functions
*)

let rec trclose syms rs sr fs =
  let inset = ref IntSet.empty in
  let outset = ref IntSet.empty in
  let exclude = ref IntSet.empty in
  let append fs = iter (fun i -> inset := IntSet.add i !inset) fs in

  let rec trclosem () =
    if IntSet.is_empty !inset then ()
    else
      (* grab an element *)
      let x = IntSet.choose !inset in
      inset := IntSet.remove x !inset;
      
      (* loop if already handled *)
      if IntSet.mem x !exclude then trclosem ()
      else begin
        (* say we're handling this one *)
        exclude := IntSet.add x !exclude;

        match Hashtbl.find syms.dfns x with
        | {parent=parent; sr=sr2; symdef=`SYMDEF_inherit_fun qn} ->
          let env = build_env syms parent in
          begin match fst (lookup_qn_in_env2' syms env rs qn) with
          | NonFunctionEntry _ -> clierr2 sr sr2 "Inherit fun doesn't denote function set"
          | FunctionEntry fs' -> append fs'; trclosem ()
          end

        | _ -> outset := IntSet.add x !outset; trclosem ()
      end
  in
  append fs;
  trclosem (); 
  let output = ref [] in 
  IntSet.iter (fun i -> output := i :: !output) !outset;
  !output

and resolve_inherits syms rs sr x =
  match x with
  | NonFunctionEntry z -> 
    begin match Hashtbl.find syms.dfns z with
    | {parent=parent; symdef=`SYMDEF_inherit qn} ->
      (*
      print_endline ("Found an inherit symbol qn=" ^ string_of_qualified_name qn);
      *)
      let env = inner_build_env syms rs parent in
      (*
      print_endline "Environment built for lookup ..";
      *)
      fst (lookup_qn_in_env2' syms env rs qn)
    | {sr=sr2; symdef=`SYMDEF_inherit_fun qn} ->
      clierr2 sr sr2
      "NonFunction inherit denotes function"
    | _ -> x
    end
  | FunctionEntry fs -> FunctionEntry (trclose syms rs sr fs)

and lookup_name_in_env syms (env:env_t) sr name : entry_set_t =
 inner_lookup_name_in_env syms (env:env_t) rsground sr name

and inner_lookup_name_in_env syms (env:env_t) rs sr name : entry_set_t =
  (*
  print_endline ("[lookup_name_in_env] " ^ name);
  *)
  let rec aux env = 
    match env with 
    | [] -> None
    | (_,_,table,dirs) :: tail ->
      match lookup_name_in_table_dirs table dirs sr name with
      | Some x as y -> y
      | None -> aux tail
  in 
    match aux env with
    | Some x -> 
      (*
      print_endline "[lookup_name_in_env] Got result, resolve inherits";
      *)
      resolve_inherits syms rs sr x
    | None ->
      clierr sr 
      (
        "[lookup_name_in_env]: Name '" ^ 
        name ^ 
        "' not found in environment (depth "^
        string_of_int (length env)^ ")" 
      )

(* This routine looks up a qualified name in the
   environment and returns an entry_set_t:
   can be either non-function or function set
*)
and lookup_qn_in_env2'
  syms
  (env:env_t) 
  (rs:recstop)
  (qn: qualified_name_t)
  : entry_set_t * typecode_t list
=
  (*
  print_endline ("[lookup_qn_in_env2] qn=" ^ string_of_qualified_name qn);
  *)
  match qn with
  | `AST_callback (sr,qn) -> clierr sr "[lookup_qn_in_env2] qualified name is callback [not implemented yet]"
  | `AST_void sr -> clierr sr "[lookup_qn_in_env2] qualified name is void"
  | `AST_case_tag (sr,_) -> clierr sr "[lookup_qn_in_env2] Can't lookup a case tag"
  | `AST_typed_case (sr,_,_) -> clierr sr "[lookup_qn_in_env2] Can't lookup a typed case tag"
  | `AST_index (sr,name,_) -> 
    print_endline ("[lookup_qn_in_env2] synthetic name " ^ name);
    clierr sr "[lookup_qn_in_env2] Can't lookup a synthetic name"

  | `AST_name (sr,name,ts) -> 
    (*
    print_endline ("Found simple name " ^ name);
    *)
    inner_lookup_name_in_env syms env rs sr name, ts

  | `AST_the (sr,qn) -> 
    let es,ts = lookup_qn_in_env2' syms env rs qn in
    begin match es with
    | NonFunctionEntry  _
    | FunctionEntry [_] -> es,ts
    | _ -> clierr sr
      "'the' expression denotes non-singleton function set"
    end

  | `AST_lookup (sr,(me,name,ts)) ->
    (*
    print_endline ("Searching for name " ^ name);
    *)
    match eval_module_expr syms env me with 
    | Simple_module (impl,ts', htab,dirs) ->
      let env' = mk_bare_env syms impl in
      let tables = get_pub_tables syms env' rs dirs in
      let result = lookup_name_in_table_dirs htab tables sr name in
      match result with
      | Some entry ->
        resolve_inherits syms rs sr entry,
        ts' @ ts
      | None ->
        clierr sr
        (
          "[lookup_qn_in_env2] Can't find " ^ name
        )

      (*
      begin 
      try 
        let entry = Hashtbl.find htab name in
        resolve_inherits syms rs sr entry,
        ts' @ ts
      with Not_found -> 
        clierr sr
        (
          "[lookup_qn_in_env2] Can't find " ^ name
        )
      end
      *)

and lookup_qn_in_env2
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_set_t * typecode_t list
=
  lookup_qn_in_env2' syms env rsground qn


(* this one isn't recursive i hope .. *)
and lookup_code_in_env syms env sr qn =
  let result = 
    try Some (lookup_qn_in_env2' syms env rsground qn)
    with _ -> None
  in match result with
  | Some (NonFunctionEntry x,ts) -> 
    clierr sr 
    (
      "[lookup_qn_in_env] Not expecting " ^ 
      string_of_qualified_name qn ^
      " to be non-function (code insertions use function entries) "
    )

  | Some (FunctionEntry x,ts) -> 
    iter 
    (fun i -> 
      match Hashtbl.find syms.dfns i with
      | {symdef=`SYMDEF_insert _} -> ()
      | {id=id; vs=vs; symdef=y} -> clierr sr 
        (
          "Expected requirement '"^
          string_of_qualified_name qn ^
          "' to bind to a header or body insertion, instead got:\n" ^
          string_of_symdef y id vs
        )
    )
    x
    ;
    x,ts

  | None -> [0],[]

and lookup_qn_in_env 
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  lookup_qn_in_env' syms env rsground qn

and lookup_qn_in_env'
  syms
  (env:env_t) rs
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  match lookup_qn_in_env2' syms env rs qn with
    | NonFunctionEntry x,ts -> x,ts
    | FunctionEntry _,_ ->
      let sr = src_of_expr (qn:>expr_t) in
      clierr sr
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be function set"
      )

and lookup_uniq_in_env 
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  match lookup_qn_in_env2' syms env rsground qn with
    | NonFunctionEntry x,ts -> x,ts
    | FunctionEntry [x],ts -> x,ts
    | _ ->
      let sr = src_of_expr (qn:>expr_t) in
      clierr sr
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be non-singleton function set"
      )

and lookup_function_in_env 
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  match lookup_qn_in_env2' syms env rsground qn with
    | FunctionEntry [x],ts -> x,ts
    | _ ->
      let sr = src_of_expr (qn:>expr_t) in
      clierr sr
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be non-function or non-singleton function set"
      )

and lookup_sn_in_env 
  syms 
  (env:env_t) 
  (sn: suffixed_name_t)
  : int * btypecode_t list
= 
  let sr = src_of_expr (sn:>expr_t) in
  let bt t = bind_type syms env sr t in
  match sn with
  | #qualified_name_t as x ->
    begin match
      lookup_qn_in_env syms env x
    with
    | index,ts -> index,map bt ts
    end

  | `AST_suffix (sr,(qn,suf)) ->
    let bsuf = bind_type syms env sr suf in
    (* OUCH HACKERY *)
    let (be,t) = 
      lookup_qn_with_sig' 
      syms 
      sr sr 
      env rsground
      qn [bsuf]
    in match be with
    | `BEXPR_name (index,ts) -> 
      index,ts
    | `BEXPR_closure (index,ts) -> index,ts

    | _ -> failwith "Expected expression to be index"

(* This routine binds a type expression to a bound type expression.
   Note in particular that a type alias is replaced by what
   it as an alias for, recursively so that the result 
   globally unique

   if params is present it is a list mapping strings to types
   possibly bound type variable

   THIS IS WEIRD .. expr_fixlist is propagated, but 'depth'
   isn't. But the depth is essential to insert the correct
   fixpoint term .. ????

   i think this arises from:

   val x = e1 + y;
   val y = e2 + x;
 
   here, the implied typeof() operator is used
   twice: the first bind expression invoking a second
   bind expression which would invoke the first again ..
   here we have to propagate the bind_expression
   back to the original call on the first term,
   but we don't want to accumulate depths? Hmmm...
   I should test that ..
   
*)
and bind_type syms env sr t : btypecode_t =
  (*
  print_endline ("[bind_type] " ^ string_of_typecode t);
  *)
  let bt:btypecode_t = 
    try
      bind_type' syms env rsground sr t []

    with 
      | Free_fixpoint b ->
        clierr sr
        ("Unresolvable recursive type " ^ sbt syms.dfns b)
  in
  (*
  print_endline ("Bound type= " ^ sbt syms.dfns t);
  *)
  let bt = beta_reduce syms [] bt 
  in
    (*
    print_endline ("Beta reduced type= " ^ sbt syms.dfns bt);
    *)
    bt 

and bind_expression syms env e  =
  let e',t' = 
    try
      bind_expression' syms env rsground e []
    with 
     | Free_fixpoint b ->
       let sr = src_of_expr e in
       clierr sr 
       ("Circular dependency typing expression " ^ string_of_expr e)
  in
  let t' = beta_reduce syms [] t' in
  e',t'


(* =========================================== *)
(* INTERNAL BINDING ROUTINES *)
(* =========================================== *)

(* RECURSION DETECTORS

There are FOUR type recursion detectors:

idx_fixlist is a list of indexes, used by
bind_index to detect a recursion determining
the type of a function or variable:
the depth is calculated from the list length:
this arises from bind_expression, which uses
bind type : bind_expression is called to deduce
a function return type from returned expressions

TEST CASE:
  val x = (x,x) // type is ('a * 'a) as 'a

RECURSION CYCLE: 
  typeofindex' -> bind_type'

type_alias_fixlist is a list of indexes, used by
bind_type_index to detect a recursive type alias,
[list contains depth]

TEST CASE:
  typedef a = a * a // type is ('a * 'a) as 'a


RECURSION CYCLE:
  bind_type' -> type_of_type_index
  
as_fixlist is a list of (name,depth) pairs, used by
bind_type' to detect explicit fixpoint variables
from the TYP_as terms (x as fv)
[list contains depth]

TEST CASE:
  typedef a = b * b as b // type is ('a * 'a) as 'a

RECURSION CYCLE:
  typeofindex' -> bind_type'

expr_fixlist is a list of (expression,depth)
used by bind_type' to detect recursion from
typeof(e) type terms
[list contains depth]

TEST CASE:
  val x: typeof(x) = (x,x) // type is ('a * 'a) as 'a

RECURSION CYCLE:
  bind_type' -> bind_expression'

TRAP NOTES: 
  idx_fixlist and expr_fixlist are related :(

  The expr_fixlist handles an explicit typeof(expr)
  term, for an arbitrary expr term.

  idx_fixlist is initiated by typeofindex, and only
  occurs typing a variable or function from its
  declaration when the declaration is omitted
  OR when cal_ret_type is verifying it

BUG: cal_ret_type is used to verify or compute function
return types. However the equivalent for variables
exists, even uninitialised ones. The two cases
should be handled similarly, if not by the same
routine.

Note it is NOT a error for a cycle to occur, even
in the (useless) examples:

   val x = x;
   var x = x;

In the first case, the val simply might not be used.
In the second case, there may be an assignment.
For a function, a recursive call is NOT an error
for the same reason: a function may
contain other calls, or be unused:
  fun f(x:int)= { return if x = 0 then 0 else f (x-1); }
Note two branches, the first determines the return type
as 'int' quite happily.

DEPTH:
  Depth is used to determine the argument of the
  fixpoint term.

  Depth is incremented when we decode a type
  or expression into subterms.

PROPAGATION.
It appears as_fixlist can only occur 
binding a type expression, and doesn't propagate
into bind_expression when a typeof() term is
part of the type expression: it's pure a syntactic
feature of a localised type expression.

  typedef t = a * typeof(x) as a;
  var x : t;

This is NOT the case, for example:

  typedef t = a * typeof (f of (a)) as a;

shows the as_fixlist label has propagated into
the expression: expressions can contain type
terms. However, the 'as' label IS always
localised to a single term.

Clearly, the same thing can happen with a type alias:

  typedef a = a * typeof (f of (a));

However, type aliases are more general because they
can span statement boundaries:

  typedef a = a * typeof (f of (b));
  typedef b = a;

Of course, it comes to the same thing after
substitution .. but lookup and binding is responsible
for that. The key distinction is that an as label
is just a string, whereas a type alias name has
an index in the symtab, and a fully qualified name
can be used to look it up: it's identifid by
its index, not a string label: OTOH non-top level
as labels don't map to any index.

NASTY CASE: It's possible to have this kind of thing:

  typedef a = typeof ( { typedef b = a; return x; } )

so that a type_alias CAN indeed be defined inside a type
expression. That alias can't escape however. In fact,
desugaring restructures this with a lambda (or should):

  typedef a = typeof (f of ());
  fun f() { typedef b = a; return x; }

This should work BUT if an as_label is propagated
we get a failure:

  typedef a = typeof ( { typedef c = b; return x; } ) as b;

This can be made to work by lifting the as label too,
which means creating a typedef. Hmmm. All as labels 
could be replaced by typedefs ..


MORE NOTES:
Each of these traps is used to inject a fixpoint
term into the expression, ensuring analysis terminates
and recursions are represented in typing.

It is sometimes a bit tricky to know when to pass, and when
to reset these detectors: in bind_type' and inner
bind_type of a subterm should usually pass the detectors
with a pushed value in appropriate cases, however and
independent typing, say of an instance index value,
should start with reset traps.

*)

(*
  we match type patterns by cheating a bit:
  we convert the pattern to a type, replacing
  the _ with a dummy type variable. We then
  record the 'as' terms of the pattern as a list
  of equations with the as variable index
  on the left, and the type term on the right:
  the RHS cannot contain any as variables.

  The generated type can contain both,
  but we can factor the as variables out
  and leave the type a function of the non-as
  pattern variables
*)

(* params is list of string * bound type *)

and bind_type' 
  syms env (rs:recstop)
  sr t (params: (string * btypecode_t) list)
: btypecode_t =
  let btp t params = bind_type' syms env 
    {rs with depth = rs.depth+1}
    sr t params 
  in
  let bt t = btp t params in
  let bi i ts = bind_type_index syms rs sr i ts  in
  let bisub i ts = bind_type_index syms {rs with depth= rs.depth+1} sr i ts in
  (*
  print_endline ("[bind_type'] " ^ string_of_typecode t);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  if length params <> 0 then
  begin
    print_endline ("  [" ^
    catmap ", " 
    (fun (s,t) -> s ^ " -> " ^ sbt syms.dfns t)
    params
    ^ "]"
    )
  end else print_endline  ""
  ;
  *)
  let t = 
  match t with
  | `TYP_intersect ts -> `BTYP_intersect (map bt ts)
  | `TYP_record ts -> `BTYP_record (map (fun (s,t) -> s,bt t) ts)

  (* We first attempt to perform the match
    at binding time as an optimisation, if that
    fails, we generate a delayed matching construction.
    The latter will be needed when the argument is a type
    variable.
  *)
  | `TYP_type_match (t,ps) ->
    let t = bt t in
    (*
    print_endline ("Typematch " ^ sbt syms.dfns t);
    *)
    let pts = ref [] in
    let finished = ref false in
    iter
    (fun (p',t') ->
      let p',explicit_vars,any_vars, as_vars, eqns = type_of_tpattern syms p' in
      let p' = bt p' in
      let eqns = map (fun (j,t) -> j, bt t) eqns in
      let varset = 
        let x =
          fold_left (fun s (i,_) -> IntSet.add i s) 
          IntSet.empty explicit_vars 
        in 
          fold_left (fun s i -> IntSet.add i s) 
          x any_vars 
      in
      (* HACK! GACK! we have to assume a variable in a pattern is 
        is a TYPE variable .. type patterns don't include coercion
        terms at the moment, so there isn't any way to even
        specify the metatype

        In some contexts the kinding can be infered, for example:

        int * ?x

        clearly x has to be a type .. but a lone type variable
        would require the argument typing to be known ... no
        notation for that yet either
      *)
      let args = map (fun (i,s) -> 
      (*
      print_endline ("Mapping " ^ s ^ "<"^si i^"> to TYPE"); 
      *)
      s,`BTYP_var (i,`BTYP_type)) (explicit_vars @ as_vars) 
      in
      let t' = btp t' args in
      let t' = list_subst eqns t' in
      (*
        print_endline ("Bound matching is " ^ sbt syms.dfns p' ^ " => " ^ sbt syms.dfns t');
      *)
      pts := ({pattern=p'; pattern_vars=varset; assignments=eqns},t') :: !pts;
      let u = maybe_unification syms.dfns [p', t] in
      match u with
      | None ->  ()
        (* CRAP! The below argument is correct BUT ..
        our unification algorithm isn't strong enough ...
        so just let this thru and hope it is reduced
        later on instantiation
        *)
        (* If the initially bound, context free pattern can never
        unify with the argument, we have a choice: chuck an error,
        or just eliminate the match case -- I'm going to chuck
        an error for now, because I don't see why one would
        ever code such a case, except as a mistake.
        *)
        (*
        clierr sr 
          ("[bind_type'] type match argument\n" ^ 
          sbt syms.dfns t ^
          "\nwill never unify with pattern\n" ^
          sbt syms.dfns p'
          )
        *)
      | Some mgu ->
        if !finished then
          print_endline "[bind_type] Warning: useless match case ignored"
        else
          let mguvars = fold_left (fun s (i,_) -> IntSet.add i s) IntSet.empty mgu in
          if varset = mguvars then finished := true
    )
    ps
    ;
    let pts = rev !pts in
    
    let tm = `BTYP_type_match (t,pts) in
    (*
    print_endline ("Bound typematch is " ^ sbt syms.dfns tm);
    *)
    tm


  | `TYP_dual t ->
    let t = bt t in
    dual t

  | `TYP_proj (i,t) -> 
    let t = bt t in
    ignore (try unfold syms.dfns t with _ -> failwith "TYP_proj unfold screwd");
    begin match unfold syms.dfns t with 
    | `BTYP_tuple ls ->
      if i < 1 or i>length ls
      then 
       clierr sr 
        (
          "product type projection index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (length ls)
        )
      else nth ls (i-1)

    | _ -> 
      clierr sr 
      (
        "\ntype projection requires product type"
      )
    end

  | `TYP_dom t -> 
    let t = bt t in 
    begin match unfold syms.dfns t with
    | `BTYP_function (a,b) -> a
    | `BTYP_cfunction (a,b) -> a
    | _ ->
      clierr sr
      (
        short_string_of_src sr ^
        "\ntype domain requires function" 
      )
    end
  | `TYP_cod t -> 
    let t = bt t in 
    begin match unfold syms.dfns t with
    | `BTYP_function (a,b) -> b
    | `BTYP_cfunction (a,b) -> b
    | _ ->
      clierr sr
      (
        short_string_of_src sr ^
        "\ntype codomain requires function" 
      )
    end

  | `TYP_case_arg (i,t) ->
    let t = bt t in
    ignore (try unfold syms.dfns t with _ -> failwith "TYP_case_arg unfold screwd");
    begin match unfold syms.dfns t with
    | `BTYP_unitsum k ->
      if i < 1 or i>k
      then 
        clierr sr
        (
          "sum type extraction index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^ si k
        )
      else unit_t

    | `BTYP_sum ls ->
      if i < 1 or i>length ls
      then 
        clierr sr
        (
          "sum type extraction index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (length ls)
        )
      else nth ls (i-1)

    | _ -> 
      clierr sr
      (
        "sum type extraction requires sum type"
      )
    end

 
  | `TYP_ellipsis ->  
    failwith "Unexpected `TYP_ellipsis (...) in bind type"
  | `TYP_none ->  
    failwith "Unexpected `TYP_none in bind type"

  | `TYP_setunion ts -> `BTYP_typesetunion (map bt ts)
  | `TYP_setintersection ts -> `BTYP_typesetintersection (map bt ts)
  | `TYP_typeset ts -> `BTYP_typeset (map bt ts)


  | `TYP_isin (elt,tset) ->  
    let elt = bt elt in
    let tset = bt tset in
    begin match tset with
    (* x isin { a,b,c } is the same as 
      typematch x with
      | a => 1
      | b => 1
      | c => 1
      | _ => 0
      endmatch

      ** THIS CODE ONLY WORKS FOR BASIC TYPES **
      
      This is because we don't know what to do with any
      type variables in the terms of the set. The problem
      is that 'bind type' just replaces them with bound
      variables. We have to assume they're not pattern
      variables at the moment, therefore they're variables
      from the environment.

      We should really allow for patterns, however bound
      patterns aren't just types, but types with binders
      indicating 'as' assignments and pattern variables.

      Crudely -- typesets are a hack that we should get 
      rid of in the future, since a typematch is just
      more general .. however we have no way to generalise
      type match cases so they can be named at the moment.

      This is why we have typesets.. so I need to fix them,
      so the list of things in a typeset is actually
      a sequence of type patterns, not types.
      
    *)
    | `BTYP_typeset ls ->
    let e = IntSet.empty in
    let un = `BTYP_tuple [] in
    let lss = rev_map (fun t -> {pattern=t; pattern_vars=e; assignments=[]},un) ls in
    let fresh = !(syms.counter) in incr (syms.counter);
    let dflt = 
      {
        pattern=`BTYP_var (fresh,`BTYP_type); 
        pattern_vars = IntSet.singleton fresh;
        assignments=[]
      },
      `BTYP_void 
    in
    let lss = rev (dflt :: lss) in
    `BTYP_type_match (elt, lss)
    
    | x -> 
      clierr sr  
        ("expected explicit typeset, got " ^ sbt syms.dfns x)
    end

  (* HACK .. assume variable is type TYPE *)
  | `TYP_var i ->  `BTYP_var (i,`BTYP_type)
  | `TYP_as (t,s) -> 
    bind_type' syms env 
    { rs with as_fixlist = (s,rs.depth)::rs.as_fixlist }
    sr t params

  | `TYP_typeof e ->
    (*
    print_endline ("Evaluating typeof(" ^ string_of_expr e ^ ")");
    *)
    let t =
      if mem_assq e rs.expr_fixlist
      then begin
        (*
        print_endline "Typeof is recursive";
        *)
        let outer_depth = assq e rs.expr_fixlist in
        let fixdepth = outer_depth -rs.depth in
        (*
        print_endline ("OUTER DEPTH IS " ^ string_of_int outer_depth);
        print_endline ("CURRENT DEPTH " ^ string_of_int rs.depth);
        print_endline ("FIXPOINT IS " ^ string_of_int fixdepth);
        *)
        `BTYP_fix fixdepth
      end
      else begin
        snd(bind_expression' syms env rs e [])
      end
    in 
      (*
      print_endline ("typeof --> " ^ sbt syms.dfns t);
      *)
      t

  | `TYP_array (t1,t2)-> 
    let index = match bt t2 with
    | `BTYP_tuple [] -> `BTYP_unitsum 1
    | x -> x
    in
    `BTYP_array (bt t1, index)

  | `TYP_tuple ts -> 
    let ts' =map bt ts  in
    `BTYP_tuple ts'

  | `TYP_unitsum k -> 
    (match k with
    | 0 -> `BTYP_void
    | 1 -> `BTYP_tuple[]
    | _ -> `BTYP_unitsum k
    )

  | `TYP_sum ts -> 
    let ts' = map bt ts  in
    if all_units ts' then
      `BTYP_unitsum (length ts)
    else
      `BTYP_sum ts'

  | `TYP_function (d,c) -> 
    let 
      d' = bt d  and 
      c' = bt c 
    in 
      `BTYP_function (bt d, bt c)

  | `TYP_cfunction (d,c) -> 
    let 
      d' = bt d  and 
      c' = bt c 
    in 
      `BTYP_cfunction (bt d, bt c)

  | `TYP_pointer t -> 
     let t' = bt t in 
     `BTYP_pointer t'

  | `TYP_lvalue t -> lvalify (bt t)

  | `AST_void _ -> 
    `BTYP_void

  | `TYP_typefun (ps,r,body) -> 
    (*
    print_endline ("BINDING TYPE FUNCTION " ^ string_of_typecode t);
    *)
    let data = 
      rev_map 
      (fun (name,mt) -> 
        name, 
        bt mt, 
        let n = !(syms.counter) in 
        incr (syms.counter); 
        n
      ) 
      ps 
    in
    let pnames =  (* reverse order .. *)
      map (fun (n, t, i) -> 
        (*
        print_endline ("Binding param " ^ n ^ "<" ^ si i ^ "> metatype " ^ sbt syms.dfns t);
        *)
        (n,`BTYP_var (i,t))) data 
    in
    let bbody = 
      (*
      print_endline (" ... binding body .. " ^ string_of_typecode body);
      print_endline ("Context " ^ catmap "" (fun (n,t) -> "\n"^ n ^ " -> " ^ sbt syms.dfns t) (pnames @ params));
      *)
      bind_type' syms env { rs with depth=rs.depth+1 }
      sr 
      body (pnames@params)
    in
      let bparams = (* order as written *)
        rev_map (fun (n,t,i) -> (i,t)) data 
      in
      (*
      print_endline "BINDING DONE\n";
      *)
      `BTYP_typefun (bparams, bt r, bbody)

  | `TYP_apply(#qualified_name_t as qn, t2) ->
     let t2 = bt t2 in
     (*
     print_endline ("meta typing argument " ^ sbt syms.dfns t2);
     *)
     let sign = metatype syms [] t2 in
     (*
     print_endline ("Arg type " ^ sbt syms.dfns t2 ^ " meta type " ^ sbt syms.dfns sign);
     *)
     let t = 
       try match qn with
       | `AST_name (sr,name,[]) ->
         let t1 = assoc name params in
         `BTYP_apply(t1,t2)
       | _ -> raise Not_found
       with Not_found ->
       
       (* Note: parameters etc cannot be found with a qualified name,
       unless it is a simple name .. which is already handled by
       the previous case .. so we can drop them .. ?
       *)

       let result = lookup_qn_with_sig' syms sr sr env
         {rs with depth=rs.depth+1 } qn [sign]
       in
       (* this is a hack, since result will be a closure expression,
          we just want a bound name .. but type name lookup, which returns
          the derired type, doesn't do overloading: so we use lookup_qn_with_sig,
          and then decode the result to get the index, then just use a numbered name
       *)
       (* HUMM .. what if the result is a parameter? then its a
       variable, already a 'closure' -- meaning analogous to
       the usual situation!! We have to know if we've found
       a parameter or a type function.
       *)
       (*
       print_endline ("Result of lookup is " ^ sbe syms.dfns result); 
       *)
       let j,ts = 
         match result with
         | `BEXPR_closure(j,ts),mt -> j,ts
         | _ -> assert false
       in
       (*
       print_endline ("Rebinding index " ^ si j);
       *)
       let t1 = bisub j ts in
       (*
       print_endline ("Result of binding is term " ^ sbt syms.dfns t1);
       *)
       `BTYP_apply (t1,t2) 
     in
     (*
     print_endline ("type Application is " ^ sbt syms.dfns t);
     *)
     let t = beta_reduce syms [] t in
     (*
     print_endline ("after beta reduction is " ^ sbt syms.dfns t);
     *)
     t

  | `TYP_apply (t1,t2) ->
    let t1 = bt t1 in
    let t2 = bt t2 in
    let t = `BTYP_apply (t1,t2) in
    (*
    let t = beta_reduce syms [] t in
    *)
    t

  | `TYP_type_tuple ts ->
    `BTYP_type_tuple (map bt ts)

  | `TYP_type -> `BTYP_type

  | `AST_name (sr,s,[]) when mem_assoc s rs.as_fixlist ->
    `BTYP_fix ((assoc s rs.as_fixlist)-rs.depth)

  | `AST_name (sr,s,[]) when mem_assoc s params ->
    (*
    print_endline "Found in assoc list .. ";
    *)
    assoc s params

  | `TYP_glr_attr_type qn ->
    (*
    print_string ("[bind_type] Calculating type of glr symbol " ^ string_of_qualified_name qn);
    *)
    (* WARNING: we're skipping the recursion stoppers here !! *)
    let t = 
      match lookup_qn_in_env2' syms env rs qn with
      | FunctionEntry ii,[] -> 
        cal_glr_attr_type syms sr ii

      | NonFunctionEntry i,[] ->
        begin match Hashtbl.find syms.dfns i with
        | {sr=sr; symdef=`SYMDEF_const_ctor (_,ut,_)} -> `BTYP_void (* hack *)
        | {sr=sr; symdef=`SYMDEF_nonconst_ctor (_,_,_,argt)} -> 
          cal_glr_attr_type'' syms sr i argt
        | _ -> clierr sr "Token must be union constructor"
        end
      | _,ts -> clierr sr "GLR symbol can't have type subscripts"
    in 
      (*
      print_endline (" .. Calculated: " ^sbt syms.dfns t);
      *)
      t
      

  | `AST_index (sr,name,index) as x -> 
    (*
    print_endline ("[bind type] AST_index " ^ string_of_qualified_name x);
    *)
    let { vs=vs; symdef=entry } =
      try Hashtbl.find syms.dfns index 
      with Not_found -> 
        syserr sr ("Synthetic name "^name ^ " not in symbol table!")
    in
    begin match entry with
    | `SYMDEF_struct _ 
    | `SYMDEF_cstruct _ 
    | `SYMDEF_union _ 
    | `SYMDEF_class  
    | `SYMDEF_cclass _ 
    | `SYMDEF_abs _ 
      ->
      (* I STILL DO NOT UNDERSTAND THIS .. BUT LOTS OF EXAMPLES USE IT
         AND IT WORKS .. so the diagnostic is comment out
      *)
      (*
      if length vs <> 0 then begin
        print_endline ("Synthetic name "^name ^ " is a nominal type!");
        print_endline ("Using ts = [] .. probably wrong since type is polymorphic!");
      end
      ;
      *)
      `BTYP_inst (index,[])

    | `SYMDEF_typevar _ ->
      print_endline ("Synthetic name "^name ^ " is a typevar!");
      syserr sr ("Synthetic name "^name ^ " is a typevar!")

    | _ 
      ->
        print_endline ("Synthetic name "^name ^ " is not a nominal type!");
        syserr sr ("Synthetic name "^name ^ " is not a nominal type!")
    end

  (* QUALIFIED OR UNQUALIFIED NAME *)
  | #qualified_name_t as x ->
    (*
    print_endline ("Matched qualified name " ^ string_of_qualified_name x);
    *)
    begin match lookup_qn_in_env syms env x with
    | i,ts ->
      let ts = map bt ts in
      (*
      print_endline ("Qualified name lookup finds index " ^ si i ^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
      *)
      bi i ts
    end

  | `AST_suffix (sr,(qn,t)) ->
    let sign = bt t in
    let result = 
      lookup_qn_with_sig' syms  sr sr env rs qn [sign]
    in 
    begin match result with
    | `BEXPR_closure (i,ts),_ -> 
      bi i ts
    | _  -> clierr sr 
      (
        "[typecode_of_expr] Type expected, got: " ^
        sbe syms.dfns result
      )
    end
  in
    (*
    print_endline ("Bound type is " ^ sbt syms.dfns t);
    *)
    t

and cal_glr_attr_type'' syms sr i t =
  try Hashtbl.find syms.glr_cache i
  with Not_found ->
  try Hashtbl.find syms.varmap i
  with Not_found ->
  match t with 
  | `TYP_none -> `BTYP_var (i,`BTYP_type)
  | _ ->
    let env = build_env syms (Some i) in
    let t = bind_type syms env sr t in
    Hashtbl.add syms.glr_cache i t;
    Hashtbl.add syms.varmap i t;
    t
 
and cal_glr_attr_type' syms sr i =
  match Hashtbl.find syms.dfns i with
  | {symdef=`SYMDEF_glr (t,_)} -> 
    `Nonterm,cal_glr_attr_type'' syms sr i t 
    
  | {symdef=`SYMDEF_nonconst_ctor (_,_,_,t)} -> 
    `Term, cal_glr_attr_type'' syms sr i t 

  (* shouldn't happen .. *)
  | {symdef=`SYMDEF_const_ctor (_,_,_)} -> 
    `Term, `BTYP_void 

  | {id=id;symdef=symdef} -> 
    clierr sr (
      "[cal_glr_attr_type'] Expected glr nonterminal or token "^
      "(union constructor with argument), got\n" ^
      string_of_symdef symdef id []
    )

and cal_glr_attr_type syms sr ii =
  let idof i = match Hashtbl.find syms.dfns i with {id=id} -> id in
  match ii with
  | [] -> syserr sr "Unexpected empty FunctonEntry"
  | h :: tts -> 
    let kind,t = cal_glr_attr_type' syms sr h in
    iter 
    (fun i ->
      let kind',t' = cal_glr_attr_type' syms sr i in
      match kind,kind' with
      | `Nonterm,`Nonterm 
      | `Term,`Term  ->
        if not (type_eq syms.dfns t t') then
        clierr sr 
        ("Expected same type for glr symbols,\n" ^ 
          idof h ^ " has type " ^ sbt syms.dfns t ^ "\n" ^
          idof i ^ " has type " ^ sbt syms.dfns t'
        )

      | `Nonterm,`Term -> clierr sr "Expected glr nonterminal argument"
      | `Term,`Nonterm -> clierr sr "Token: Expected union constructor with argument"
    )
    tts
    ;
    t

and bind_type_index syms (rs:recstop)
  sr index ts 
= 
  (*
  print_endline 
  (
    "BINDING INDEX " ^ string_of_int index ^ 
    " with ["^
    catmap ", " 
    (sbt syms.dfns)
    ts^
    "]"
  );
  print_endline ("type alias fixlist is " ^ catmap "," 
    (fun (i,j) -> si i ^ "(depth "^si j^")") type_alias_fixlist
  );
  *)
  if mem_assoc index rs.type_alias_fixlist 
  then begin
    (*
    print_endline (
      "Making fixpoint for Recursive type alias " ^
      (
        match get_data syms.dfns index with {id=id;sr=sr}-> 
          id ^ " defined at " ^
          short_string_of_src sr
      )
    );
    *)
    `BTYP_fix ((assoc index rs.type_alias_fixlist)-rs.depth)
  end  
  else begin 
  (*
  print_endline "bind_type_index";
  *)
  let ts = adjust_ts syms sr index ts in
  let bt t =
      let params = make_params syms sr index ts in
      let env:env_t = build_env syms (Some index) in
      let t = 
        bind_type' syms env
        { rs with type_alias_fixlist = (index,rs.depth):: rs.type_alias_fixlist }
        sr t params 
      in
        (*
        print_endline ("Unravelled and bound is " ^ sbt syms.dfns t);
        *)
        let t = beta_reduce syms [] t in
        (*
        print_endline ("Beta reduced: " ^ sbt syms.dfns t);
        *)
        t
  in
  match get_data syms.dfns index with
  | {id=id;sr=sr;parent=parent;vs=vs;pubmap=tabl;dirs=dirs;symdef=entry} ->
    (*
    if length vs <> length ts 
    then 
      clierr sr 
      (
        "[bind_type_index] Wrong number of type arguments for " ^ id ^
        ", expected " ^ 
        si (length vs) ^ " got " ^ si (length ts)
      );
    *)
    match entry with
    | `SYMDEF_typevar mt -> 
      (* HACK! We will assume metatype are entirely algebraic,
        that is, they cannot be named and referenced, we also
        assume they cannot be subscripted .. the bt routine
        that works for type aliases doesn't seem to work for
        metatypes .. we get vs != ts .. ts don't make sense
        for type variables, only for named things ..
      *)
      let mt = bind_type syms [] sr mt in
      `BTYP_var (index,mt)

    (* type alias RECURSE *)
    | `SYMDEF_type_alias t -> 
      (*
      print_endline ("Unravelling type alias " ^ id);
      *)
      bt t

    | `SYMDEF_abs _ -> 
      `BTYP_inst (index,ts)

    | `SYMDEF_union _
    | `SYMDEF_struct _ 
    | `SYMDEF_cstruct _ 
    | `SYMDEF_class
    | `SYMDEF_cclass _ 
      ->
      `BTYP_inst (index,ts)


    | _ -> 
      clierr sr
      (
        "[bind_type_index] Type " ^ id ^ 
        " must be a type [alias, abstract, union, struct], got:\n" ^
        string_of_symdef entry id vs
      )
  end 


and base_typename_of_literal v = match v with
  | `AST_int (t,_) -> t
  | `AST_float (t,_) -> t
  | `AST_string _ -> "string"
  | `AST_cstring _ -> "charp"
  | `AST_wstring _ -> "wstring"
  | `AST_ustring _ -> "string"

and  typeof_literal syms env sr v : btypecode_t = 
  let _,_,root,_ = hd (rev env) in
  let name = base_typename_of_literal v in
  let t = `AST_name (sr,name,[]) in
  let bt = bind_type syms env sr t in
  bt
  
and typeofindex_with_ts
  syms sr
  (index:int)
  ts
=
  let t = typeofindex syms index in
  let varmap = make_varmap syms sr index ts in
  let t = varmap_subst varmap t in
  beta_reduce syms [] t

(* This routine should ONLY 'fail' if the return type
  is indeterminate. This cannot usually happen.

  Otherwise, the result may be recursive, possibly
  Fix 0 -- which is determinate 'indeterminate' value :-)
  
  For example: fun f(x:int) { return f x; }

  should yield fix 0, and NOT fail.
*)


(* cal_ret_type uses the private name map *)
(* args is string,btype list *)
and cal_ret_type syms (rs:recstop) index args =
  (*
  print_endline ("[cal_ret_type] index " ^ si index);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    rs.expr_fixlist
  );
  *)
  let env = build_env syms (Some index) in
  (*
  print_env_short env;
  *)
  match (get_data syms.dfns index) with
  | {id=id;sr=sr;parent=parent;vs=vs;privmap=name_map;dirs=dirs;
     symdef=`SYMDEF_function ((ps,_),rt,props,exes)
    } ->
    (*
    print_endline ("Calculate return type of " ^ id);
    *)
    let rt = bind_type' syms env rs sr rt args in
    let rt = beta_reduce syms [] rt in
    let ret_type = ref rt in
    (*
    begin match rt with
    | `BTYP_var (i,_) when i = index -> 
      print_endline "No return type given"
    | _ -> 
      print_endline (" .. given type is " ^ sbt syms.dfns rt)
    end
    ;
    *)
    let return_counter = ref 0 in
    iter
    (fun exe -> match exe with
    | (sr,`EXE_fun_return e) ->
      incr return_counter;
      (*
      print_endline ("  .. Handling return of " ^ string_of_expr e);
      *)
      begin try
        let t = 
          (* this is bad code .. we lose detection
          of errors other than recursive dependencies ..
          which shouldn't be errors anyhow ..
          *)
            snd 
            (
              bind_expression' syms env
              { rs with idx_fixlist = index::rs.idx_fixlist }
              e []
            ) 
        in
        if do_unify syms !ret_type t (* the argument order is crucial *)
        then 
          ret_type := varmap_subst syms.varmap !ret_type
        else begin
          (*
          print_endline 
          (
            "[cal_ret_type2] Inconsistent return type of " ^ id ^ "<"^string_of_int index^">" ^
            "\nGot: " ^ sbt syms.dfns !ret_type ^
            "\nAnd: " ^ sbt syms.dfns t
          )
          ;
          *)
          clierr sr
          (
            "[cal_ret_type2] Inconsistent return type of " ^ id ^ "<"^string_of_int index^">" ^
            "\nGot: " ^ sbt syms.dfns !ret_type ^
            "\nAnd: " ^ sbt syms.dfns t
          )
        end
      with 
        | Stack_overflow -> failwith "[cal_ret_type] Stack overflow"
        | Expr_recursion e -> () 
        | Free_fixpoint t -> () 
        | Unresolved_return (sr,s) -> () 
        | ClientError (sr,s) as e -> raise (ClientError (sr,"Whilst calculating return type:\n"^s))
        | x -> 
        (*
        print_endline ("  .. Unable to compute type of " ^ string_of_expr e);
        print_endline ("Reason: " ^ Printexc.to_string x);
        *)
        ()
      end
    | _ -> ()
    )
    exes
    ;
    if !return_counter = 0 then (* it's a procedure .. *)
    begin 
      let mgu = do_unify syms !ret_type `BTYP_void in
      ret_type := varmap_subst syms.varmap !ret_type
    end
    ;
    (* not sure if this is needed or not .. 
      if a type variable is computed during evaluation,
      but the evaluation fails .. substitute now
    ret_type := varmap_subst syms.varmap !ret_type
    ;
    *)
    (*
    let ss = ref "" in 
    Hashtbl.iter 
    (fun i t -> ss:=!ss ^si i^ " --> " ^sbt syms.dfns t^ "\n") 
    syms.varmap;
    print_endline ("syms.varmap=" ^ !ss);
    print_endline ("  .. ret type index " ^ si index ^ " = " ^ sbt syms.dfns !ret_type);
    *)
    !ret_type

  | _ -> assert false

  
and inner_typeofindex_with_ts
  syms sr (rs:recstop)
  (index:int)
  (ts: btypecode_t list)
: btypecode_t = 
 (*
 print_endline "Inner type of index with ts ..";
 *)
 let t = inner_typeofindex syms rs index in
 let varmap = make_varmap syms sr index ts in
 let t = varmap_subst varmap t in
 beta_reduce syms [] t 
 

(* this routine is called to find the type of a function
or variable .. so there's no type_alias_fixlist .. 
*)

and typeofindex 
  syms 
  (index:int)
: btypecode_t = 
    (*
    let () = print_endline ("Top level type of index " ^ si index) in
    *)
    if Hashtbl.mem syms.ticache index
    then begin
      let t = Hashtbl.find syms.ticache index in
      (*
      let () = print_endline ("Cached .." ^ sbt syms.dfns t) in
      *)
      t
    end
    else 
      let t = inner_typeofindex syms rsground index in
      let _ = try unfold syms.dfns t with _ ->
        print_endline "typeofindex produced free fixpoint";
        failwith "[typeofindex] free fixpoint constructed"
      in
      let t = beta_reduce syms [] t in
      (*
      print_endline ("Type of index "^ si index ^ " is " ^ sbt syms.dfns t);
      *)
      (match t with (* HACK .. *)
      | `BTYP_fix _ -> ()
      | _ -> Hashtbl.add syms.ticache index t
      );
      t

and inner_typeofindex
  syms (rs:recstop)
  (index:int)
: btypecode_t = 
  (*
  print_endline ("[inner_type_of_index] " ^ si index);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    rs.expr_fixlist
  );
  *)
  (* check the cache *)
  try Hashtbl.find syms.ticache index
  with Not_found ->   

  (* check index recursion *)
  if mem index rs.idx_fixlist
  then `BTYP_fix (-rs.depth)
  else begin
  match get_data syms.dfns index with
  | {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs;symdef=entry} 
  ->
  let env:env_t = build_env syms (Some index) in 
  (*
  print_endline ("Setting up env for " ^ si index);
  print_env_short env;
  *)
  let bt t:btypecode_t = 
    let t' = 
      bind_type' syms env rs sr t [] in
    let t' = beta_reduce syms [] t' in
    t'
  in
  match entry with
  | `SYMDEF_callback _ -> print_endline "Inner type of index finds callback"; assert false
  | `SYMDEF_inherit qn -> failwith ("Woops inner_typeofindex found inherit " ^ si index)
  | `SYMDEF_inherit_fun qn -> failwith ("Woops inner_typeofindex found inherit fun!! " ^ si index)
  | `SYMDEF_type_alias t ->
    begin
      let t = bt t in
      let mt = metatype syms [] t in
      (*
      print_endline ("Type of type alias is meta_type: " ^ sbt syms.dfns mt);
      *)
      mt
    end

  | `SYMDEF_function ((ps,_), rt,_,_) -> 
    let pts = map snd ps in
    let rt' = 
      try Hashtbl.find syms.varmap index with Not_found ->
      cal_ret_type syms { rs with idx_fixlist = index::rs.idx_fixlist}
      index [] 
    in 
      (* this really isn't right .. need a better way to 
        handle indeterminate result .. hmm .. 
      *)
      if var_i_occurs index rt' then 
        raise (Unresolved_return (sr,
        (
          "[typeofindex'] " ^ 
          "function "^id^"<"^string_of_int index^
          ">: Can't resolve return type, got : " ^ 
          sbt syms.dfns rt' ^ 
          "\nPossibly each returned expression depends on the return type" ^
          "\nTry adding an explicit return type annotation"
        )))
      else
        let t = `BTYP_function (bt (typeof_list pts), rt') in
        t

  | `SYMDEF_const (t,_,_)
  | `SYMDEF_parameter (t)
  | `SYMDEF_val (t)
  | `SYMDEF_var (t)
  | `SYMDEF_const_ctor (_,t,_)
    -> 
    (*
    print_endline ("Calculating type of variable " ^ id);
    *)
    bt t

  | `SYMDEF_regmatch (ps,cls)
  | `SYMDEF_reglex (ps,_,cls) ->
    let be e = 
      bind_expression' syms env 
      { rs with idx_fixlist = index::rs.idx_fixlist }
      e []
    in
    let t = snd (be (snd (hd cls))) in
    let lexit_t = bt (`AST_lookup (sr,(`AST_name (sr,"Lexer",[]),"iterator",[]))) in
    `BTYP_function (`BTYP_array (lexit_t,`BTYP_unitsum 2),t)

  | `SYMDEF_nonconst_ctor (_,ut,_,argt) ->
    bt (`TYP_function (argt,ut))

  | `SYMDEF_match_check _ ->
    `BTYP_function (`BTYP_tuple [], flx_bbool)

  | `SYMDEF_fun (_,pts,rt,_,_,_) -> 
    let t = `TYP_function (typeof_list pts,rt) in
    bt t
    
  | `SYMDEF_union _ ->
    clierr sr ("Union "^id^" doesn't have a type")

  (* struct as function *)
  | `SYMDEF_cstruct (ls)
  | `SYMDEF_struct (ls) -> 
    (* ARGGG WHAT A MESS *)
    let ts = map (fun (s,i,_) -> `AST_name (sr,s,[])) vs in
    let ts = map bt ts in
  (*
  print_endline "inner_typeofindex: struct";
  *)
    let ts = adjust_ts syms sr index ts in
    let t = `BTYP_function(bt (paramtype ls),`BTYP_inst (index,ts)) in
    (*
    print_endline ("Struct as function type is " ^ sbt syms.dfns t);
    *)
    t

  | `SYMDEF_class ->
    let ts = map (fun (s,i,_) -> `AST_name (sr,s,[])) vs in
    let ts = map bt ts in
    let ts = adjust_ts syms sr index ts in
    `BTYP_inst (index,ts)

  | _ ->
    clierr sr
    (
      "[typeofindex] Expected declaration of typed entity for index "^
      string_of_int index^", got " ^ id 
    )
  end

and cal_apply syms sr ((be1,t1) as tbe1) ((be2,t2) as tbe2) : tbexpr_t =
  let rest =
    match unfold syms.dfns t1 with
    | `BTYP_lvalue (`BTYP_function (argt,rest))
    | `BTYP_function (argt,rest)
    | `BTYP_lvalue (`BTYP_cfunction (argt,rest))
    | `BTYP_cfunction (argt,rest) ->
      if type_match syms.dfns argt t2
      then rest 
      else
        clierr sr
        (
          "[cal_apply] Function " ^
          sbe syms.dfns tbe1 ^
          "\nof type " ^
          sbt syms.dfns t1 ^
          "\napplied to argument " ^
          sbe syms.dfns tbe2 ^
          "\n of type " ^
          sbt syms.dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          sbt syms.dfns argt 
        )

    (* HACKERY TO SUPPORT STRUCT CONSTRUCTORS *)
    | `BTYP_inst (index,ts) ->
      begin match get_data syms.dfns index with
      { id=id;vs=vs;symdef=entry} ->
        begin match entry with
        | `SYMDEF_cstruct (cs)
        | `SYMDEF_struct (cs) -> t1
        | _ -> 
          clierr sr
          (
            "[cal_apply] Attempt to apply non-struct " ^ id ^ ", type " ^
            sbt syms.dfns t1 ^
            " as constructor"
          )
        end
      end
    | _ -> 
      clierr sr
      (
        "Attempt to apply non-function\n" ^
        sbe syms.dfns tbe1 ^ 
        "\nof type\n" ^
        sbt syms.dfns t1 ^
        "\nto argument of type\n" ^
        sbe syms.dfns tbe2
      )
  in
  (*
  print_endline 
  (
    "---------------------------------------" ^
    "\nApply type " ^ sbt syms.dfns t1 ^
    "\nto argument of type " ^ sbt syms.dfns t2 ^ 
    "\nresult type is " ^ sbt syms.dfns rest ^
    "\n-------------------------------------"
  );
  *)

  let rest = varmap_subst syms.varmap rest in
  if rest = `BTYP_void then 
    clierr sr
    (
      "[cal_apply] Function " ^
      sbe syms.dfns tbe1 ^
      "\nof type " ^
      sbt syms.dfns t1 ^
      "\napplied to argument " ^
      sbe syms.dfns tbe2 ^
      "\n of type " ^
      sbt syms.dfns t2 ^
      "\nreturns void"
    )
  else
  
  (* We have to allow type variables now .. the result
  should ALWAYS be determined, and independent of function
  return type unknowns, even if that means it is a recursive
  type, perhaps like 'Fix 0' ..: we should really test
  for the *function* return type variable not being
  eliminated ..
  *)
  (* 
  if var_occurs rest 
  then 
    clierr sr
    (
      "[cal_apply] Type variable in return type applying\n" ^
        sbe syms.dfns tbe1 ^ 
        "\nof type\n" ^
        sbt syms.dfns t1 ^
        "\nto argument of type\n" ^
        sbe syms.dfns tbe2
    )
  ;
  *)
  match be1 with
  | `BEXPR_closure (i,ts) ->
    begin match Hashtbl.find syms.dfns i with
    | {symdef=`SYMDEF_fun _} 
    | {symdef=`SYMDEF_callback _} ->
      `BEXPR_apply_prim (i,ts, (be2,lower t2)),rest
    | {symdef=`SYMDEF_function _} ->
      `BEXPR_apply_direct (i,ts, (be2,lower t2)),rest
    | _ -> (* needed temporarily for constructors .. *)
      `BEXPR_apply_direct (i,ts, (be2,lower t2)),rest

    end
  | _ ->
    `BEXPR_apply ((be1,lower t1), (be2,lower t2)),rest

and koenig_lookup syms rs sra id' name_map fn t2 ts =
  (*
  print_endline ("Applying Koenig lookup for " ^ fn);
  *)
  let entries =  
    try Hashtbl.find name_map fn 
    with Not_found -> 
      clierr sra
      (
        "Koenig lookup: can't find name "^
        fn^ " in " ^ 
        (match id' with 
        | "" -> "top level module"
        | _ -> "module '" ^ id' ^ "'"
        )
      )
  in 
  match entries with
  | FunctionEntry fs ->
    (*
    print_endline ("Got candidates: " ^ string_of_entry_set entries);
    *)
    begin match resolve_overload' syms rs sra fs fn [t2] ts with
    | Some (index'',t,mgu,ts) ->
      (* print_endline "Overload resolution OK"; *)
      `BEXPR_closure (index'',ts),
       typeofindex_with_ts syms sra index'' ts


    | None ->
        (*
        let n = ref 0 
        in Hashtbl.iter (fun _ _ -> incr n) name_map; 
        print_endline ("module defines " ^ string_of_int !n^ " entries");
        *)
        clierr sra
        (
          "[flx_ebind] Koenig lookup: Can't find match for " ^ fn ^
          "\ncandidates are: " ^ full_string_of_entry_set syms.dfns entries
        )
    end
  | NonFunctionEntry _ -> clierr sra "Koenig lookup expected function"

(* this routine has to return a function or procedure .. *)
and lookup_qn_with_sig
  syms  
  sra srn 
  env 
  (qn:qualified_name_t)
  (signs:btypecode_t list)
=
try
  lookup_qn_with_sig'
    syms 
    sra srn 
    env rsground
    qn
    signs
with 
  | Free_fixpoint b ->
    clierr sra 
    ("Recursive dependency resolving name " ^ string_of_qualified_name qn)
    
and lookup_qn_with_sig'
  syms 
  sra srn 
  env (rs:recstop)
  (qn:qualified_name_t)
  (signs:btypecode_t list)
: tbexpr_t =    
  (*
  print_endline ("[lookup_qn_with_sig] " ^ string_of_qualified_name qn);
  print_endline ("sigs = " ^ catmap "," (sbt syms.dfns) signs);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    rs.expr_fixlist
  );
  *)
  let bt sr t = 
    (*
    print_endline "NON PROPAGATING BIND TYPE";
    *)
    bind_type syms env sr t 
  in
  let handle_nonfunction_index index ts =
    begin match get_data syms.dfns index with 
    {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs;symdef=entry} 
    ->
      begin match entry with
      | `SYMDEF_inherit_fun qn ->
          clierr sr "Chasing functional inherit in lookup_qn_with_sig'";

      | `SYMDEF_inherit qn ->
          clierr sr "Chasing inherit in lookup_qn_with_sig'";

      | `SYMDEF_regmatch _
      | `SYMDEF_reglex _
      | `SYMDEF_cstruct _ 
      | `SYMDEF_struct _ ->
        (*
        print_endline ("Struct constructor found, type= " ^ sbt syms.dfns t);
        *)
(*
print_endline (id ^ ": lookup_qn_with_sig: struct/regmatch/lex");
*)
        (*
        let ts = adjust_ts syms sr index ts in
        *)
        let sign = try hd signs with _ -> assert false in
        let t = typeofindex_with_ts syms sr index ts in
        begin match t with
        | `BTYP_function (a,_) ->
          if not (type_match syms.dfns a sign) then
            clierr sr
            (
              "[lookup_qn_with_sig] Struct constructor for "^id^" has wrong signature, got:\n" ^
              sbt syms.dfns t ^
              "\nexpected:\n" ^
              sbt syms.dfns sign
            )
        | _ -> assert false
        end
        ;
        `BEXPR_closure (index,ts),
        t

      | `SYMDEF_const (t,_,_) 
      | `SYMDEF_val t 
      | `SYMDEF_var t 
      | `SYMDEF_parameter t
        ->
print_endline (id ^ ": lookup_qn_with_sig: val/var");
        (*
        let ts = adjust_ts syms sr index ts in
        *)
        let t = bt sr t in
        let bvs = map (fun (s,i,tp) -> s,i) vs in
        let t = try tsubst bvs ts t with _ -> failwith "[lookup_qn_with_sig] WOOPS" in
        begin match t with
        | `BTYP_function (a,b) ->
          let sign = try hd signs with _ -> assert false in
          if not (type_match syms.dfns a sign) then
          clierr srn
          (
            "[lookup_qn_with_sig] Expected variable "^id ^
            "<" ^ si index ^ "> to have function type with signature " ^
            sbt syms.dfns sign ^
            ", got function type:\n" ^
            sbt syms.dfns t
          )
          else
            `BEXPR_name (index, ts),
            t

        | _ ->
          clierr srn
          (
            "[lookup_qn_with_sig] expected variable " ^ 
            id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
            sbt syms.dfns t
            
          )
        end
      | _ ->
        clierr sr
        (
          "[lookup_qn_with_sig] Named Non function entry "^id^
          " must be function type: requires struct," ^
          "or value or variable of function type"
        )
      end
    end
  in
  match qn with
  | `AST_callback (sr,qn) ->  
    failwith "[lookup_qn_with_sig] Callbacks not implemented yet"

  | `AST_the (sr,qn) -> 
    lookup_qn_with_sig' syms sra srn
    env rs
    qn signs

  | `AST_void _ -> clierr sra "qualified-name is void"

  | `AST_case_tag _ -> clierr sra "Can't lookup case tag here"

  (* WEIRD .. this is a qualified name syntactically ..
    but semantically it belongs in bind_expression
    where this code is duplicated ..

    AH NO it isn't. Here, we always return a function
    type, even for constant constructors (because we 
    have a signature ..)
  *)
  | `AST_typed_case (sr,v,t) ->
    let t = bt sr t in
    begin match unfold syms.dfns t with
    | `BTYP_unitsum k ->
      if v<1 or v> k
      then clierr sra "Case index out of range of sum"
      else 
        let ct = `BTYP_function (unit_t,t) in
        `BEXPR_case (v,t),ct 

    | `BTYP_sum ls ->
      if v<1 or v> length ls
      then clierr sra "Case index out of range of sum"
      else let vt = nth ls (v-1) in
      let ct = `BTYP_function (vt,t) in
      `BEXPR_case (v,t), ct

    | _ -> 
      clierr sr 
      (
        "[lookup_qn_with_sig] Type of case must be sum, got " ^
        sbt syms.dfns t
      )
    end

  | `AST_name (sr,name,ts) ->
    (*
    print_endline "Looking up name with sig ..";
    *)
    let ts = map (bt sr) ts in
    lookup_name_with_sig 
      syms 
      sra srn
      env rs name ts signs

  | `AST_index (sr,name,index) ->
    begin match get_data syms.dfns index with 
    | {id=id; sr=sra; symdef=entry} ->
    match entry with 
    | `SYMDEF_fun _
    | `SYMDEF_function _ 
    | `SYMDEF_match_check _ 
      ->
      (* THIS IS A HACK! THERE IS NOTHING TO RESOLVE, WE KNOW
      WHICH FUNCTION IS CHOSEN ALREADY .. WE SEEM TO BE DOING
      THIS OVERLOAD JUST TO FIND THE TS VALUES
      *)
      begin match
        resolve_overload'
        syms rs sra [index] name signs []
      with
      | Some (index,t,mgu,ts) ->
        `BEXPR_closure (index,ts),
        inner_typeofindex_with_ts syms sr rs index ts

      | None -> 
        clierr sra
        (
          "[lookup_qn_with_sig] Unable to resolve overload of synthetic function " ^ 
          name 
        )
      end

    | _ ->
      handle_nonfunction_index index []
    end

  | `AST_lookup (sr,(qn',name,ts)) -> 
    let m =  eval_module_expr syms env qn' in
    match m with (Simple_module (impl, ts',htab,dirs)) ->
    (* let n = length ts in *)
    let ts = map (bt sr)( ts' @ ts) in
    (*
    print_endline ("Module " ^ si impl ^ "[" ^ catmap "," (sbt syms.dfns) ts' ^"]");
    *)
    let env' = mk_bare_env syms impl in
    let tables = get_pub_tables syms env' rs dirs in
    let result = lookup_name_in_table_dirs htab tables sr name in
    begin match result with
    | None -> 
      clierr sr
      (
        "[lookup_qn_with_sig] AST_lookup: Simple_module: Can't find name " ^ name
      )
    | Some entries -> match entries with 
    | NonFunctionEntry (index) ->
      handle_nonfunction_index index ts

    | FunctionEntry fs ->
      match
        resolve_overload'
        syms rs sra fs name signs ts
      with
      | Some (index,t,mgu,ts) ->
        (*
        print_endline ("Resolved overload for " ^ name);
        print_endline ("ts = [" ^ catmap ", " (sbt syms.dfns) ts ^ "]");
        *)
        (*
        let ts = adjust_ts syms sr index ts in
        *)
        `BEXPR_closure (index,ts),
         typeofindex_with_ts syms sr index ts

      | None -> 
        clierr sra
        (
          "[lookup_qn_with_sig] (Simple module) Unable to resolve overload of " ^ 
          string_of_qualified_name qn ^
          " of (" ^ catmap "," (sbt syms.dfns) signs ^")\n" ^
          "candidates are: " ^ full_string_of_entry_set syms.dfns entries
        )
    end

and lookup_name_with_sig 
  syms 
  sra srn 
  env
  (rs:recstop)
  (name : string)
  (ts : btypecode_t list)
  (t2:btypecode_t list) 
: tbexpr_t =
  (*
  print_endline ("[lookup_name_with_sig] " ^ name ^ 
    " of " ^ catmap "," (sbt syms.dfns) t2)
  ;
  *)
  match env with
  | [] -> 
    clierr srn
    (
      "[lookup_name_with_sig] Can't find " ^ name ^ 
      " of " ^ catmap "," (sbt syms.dfns) t2
    )
  | (_,_,table,dirs)::tail ->
    match 
      lookup_name_in_table_dirs_with_sig 
      (table, dirs) 
      syms env rs
      sra srn name ts t2 
    with
    | Some result -> (result:>tbexpr_t)
    | None -> 
      let tbx= 
        lookup_name_with_sig 
          syms 
          sra srn 
          tail rs name ts t2
       in (tbx:>tbexpr_t)
        
and handle_function 
  syms 
  env (rs:recstop)
  sra srn 
  name 
  ts
  index 
: tbexpr_t 
=
  match get_data syms.dfns index with 
  {
    id=id;sr=sr;vs=vs;parent=parent;
    privmap=tabl;dirs=dirs;
    symdef=entry
  }
  -> 
  match entry with
  | `SYMDEF_match_check _
  | `SYMDEF_function _
  | `SYMDEF_fun _
  | `SYMDEF_struct _
  | `SYMDEF_cstruct _
  | `SYMDEF_nonconst_ctor _
  | `SYMDEF_regmatch _
  | `SYMDEF_reglex _
  | `SYMDEF_callback _
    ->
    let t = inner_typeofindex_with_ts syms sr rs index ts 
    in
    `BEXPR_closure (index,ts),
    (
      match t with
      | `BTYP_cfunction (s,d) as t -> t
      | `BTYP_function (s,d) as t -> t
      | t -> 
        ignore begin
          match t with 
          | `BTYP_fix _ -> raise (Free_fixpoint t)
          | _ -> try unfold syms.dfns t with
          | _ -> raise (Free_fixpoint t)
        end
        ;
        clierr sra
        (
          "[handle_function]: closure operator expected '"^name^"' to have function type, got '"^
          sbt syms.dfns t ^ "'"
        )
    )
  | `SYMDEF_type_alias (`TYP_typefun _) ->
    (* THIS IS A HACK .. WE KNOW THE TYPE IS NOT NEEDED BY THE CALLER .. *)
    (* let t = inner_typeofindex_with_ts syms sr rs index ts in *)
    let t = `BTYP_function (`BTYP_type,`BTYP_type) in
    `BEXPR_closure (index,ts),
    (
      match t with
      | `BTYP_function (s,d) as t -> t
      | t -> 
        ignore begin
          match t with 
          | `BTYP_fix _ -> raise (Free_fixpoint t)
          | _ -> try unfold syms.dfns t with
          | _ -> raise (Free_fixpoint t)
        end
        ;
        clierr sra
        (
          "[handle_function]: closure operator expected '"^name^"' to have function type, got '"^
          sbt syms.dfns t ^ "'"
        )
    )

  | _ -> 
    clierr sra
    (
      "[handle_function] Expected "^name^" to be function, got: " ^
      string_of_symdef entry name vs
    )

and handle_variable syms
  env (rs:recstop)
  index id sr ts t t2 
= 
  (* HACKED the params argument to [] .. this is WRONG!! *)
  let bt sr t = 
    bind_type' syms env rs sr t []
  in

    (* we have to check the variable is the right type *) 
    let t = bt sr t in
    let ts = adjust_ts syms sr index ts in
    let vs = find_vs syms index in
    let bvs = map (fun (s,i,tp) -> s,i) vs in
    let t = tsubst bvs ts t in
    let t = match t with | `BTYP_lvalue t -> t | t -> t in
    begin match t with
    | `BTYP_function (d,c) ->
      if not (type_match syms.dfns d t2) then
      clierr sr
      (
        "[handle_variable(1)] Expected variable "^id ^
        "<" ^ si index ^ "> to have function type with signature " ^
        sbt syms.dfns t2 ^
        ", got function type:\n" ^
        sbt syms.dfns t
      )
      else
        (*
        let ts = adjust_ts syms sr index ts in
        *)
        Some
        (
          `BEXPR_name (index, ts),t
          (* should equal t ..
          typeofindex_with_ts syms sr index ts
          *)
        )

    (* anything other than function type, dont check the sig,
       just return it.. 
    *)
    | _ ->  Some (`BEXPR_name (index,ts),t)
    end

and lookup_name_in_table_dirs_with_sig (table, dirs) 
  syms 
  env (rs:recstop)
  sra srn name (ts:btypecode_t list) (t2: btypecode_t list)
: tbexpr_t option
=
  (*
  print_endline 
  (
    "LOOKUP NAME "^name ^"["^
    catmap "," (sbt syms.dfns) ts ^
    "] IN TABLE DIRS WITH SIG " ^ catmap "," (sbt syms.dfns) t2
  ); 
  *)
  let result:entry_set_t =
    match lookup_name_in_htab table name  with
    | Some x -> x
    | None -> FunctionEntry []
  in
  match result with
  | NonFunctionEntry (index) ->
    begin match get_data syms.dfns index with
    {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubmap;symdef=entry}->
    begin match entry with
    | `SYMDEF_inherit _ -> 
      clierr sra "Woops found inherit in lookup_name_in_table_dirs_with_sig"
    | `SYMDEF_inherit_fun _ -> 
      clierr sra "Woops found inherit function in lookup_name_in_table_dirs_with_sig"

    | `SYMDEF_regmatch _
    | `SYMDEF_reglex _
    | `SYMDEF_cstruct _
    | `SYMDEF_struct _
    | `SYMDEF_nonconst_ctor _
      ->
        (*
        print_endline "lookup_name_in_table_dirs_with_sig finds struct constructor";
        *)
        let ro = 
          resolve_overload'
          syms rs sra [index] name t2 ts
        in
          begin match ro with 
          | Some (index,t,mgu,ts) ->
            let tb : tbexpr_t =
              handle_function 
              syms 
              env rs
              sra srn name ts index
            in 
              Some tb 
          | None -> None
          end

    | `SYMDEF_class ->
      (*
      print_endline ("Found a class "^name^", look for constructor with hacked name _ctor_"^name);
      *)
      let entries = lookup_name_in_htab pubmap ("_ctor_" ^ name) in
      begin match entries with
      | None -> clierr sr "Unable to find any constructors for this class"
      | Some (NonFunctionEntry _) -> syserr sr 
        "[lookup_name_in_table_dirs_with_sig] Expected constructor to be a procedure"

      | Some (FunctionEntry fs) ->
        (*
        print_endline ("Ok, found "^si (length fs) ^"constructors for " ^ name);
        *)
        let ro = 
          resolve_overload'
          syms rs sra fs ("_ctor_" ^ name) t2 ts
        in
        match ro with 
          | Some (index,t,mgu,ts) ->
            let ((_,tt) as tb) =
              handle_function 
              syms 
              env rs
              sra srn name ts index
            in 
              print_endline ("SUCCESS: overload chooses " ^ full_string_of_entry_kind syms.dfns index);
              print_endline ("Value of ts is " ^ catmap "," (sbt syms.dfns) ts);
              print_endline ("Instantiated closure value is " ^ sbe syms.dfns tb);
              print_endline ("type is " ^ sbt syms.dfns tt);
              Some tb 
          | None ->
            clierr sr "Unable to find matching constructor"
      end
      (*
      lookup_name_in_table_dirs_with_sig (table, dirs) 
      syms env rs sra srn ("_ctor_" ^ name) ts t2 
      *)
 
    | `SYMDEF_cclass _ -> 
      (* recursively lookup using "_ctor_" ^ name :
         WARNING: we might find a constructor with the
         right name for a different cclass than this one,
         it isn't clear this is wrong though.
      *)
      lookup_name_in_table_dirs_with_sig (table, dirs) 
      syms env rs sra srn ("_ctor_" ^ name) ts t2 
    
    | `SYMDEF_const_ctor (_,t,_)
    | `SYMDEF_const (t,_,_)
    | `SYMDEF_var t
    | `SYMDEF_val t 
    | `SYMDEF_parameter t
      ->
      let sign = try hd t2 with _ -> assert false in
      handle_variable syms env rs index id srn ts t sign
    | _ 
      -> 
        clierr sra 
        (
          "Expected " ^id^
          " to be struct or variable of function type, got " ^ 
          string_of_symdef entry id vs
        )
    end
    end

  | FunctionEntry fs ->
    let ro = 
      resolve_overload'
      syms rs sra fs name t2 ts
    in
    match ro with 
      | Some (index,t,mgu,ts) ->
        let ((_,tt) as tb) =
          handle_function 
          syms 
          env rs
          sra srn name ts index
        in 
          (*
          print_endline ("SUCCESS: overload chooses " ^ full_string_of_entry_kind syms.dfns index);
          print_endline ("Value of ts is " ^ catmap "," (sbt syms.dfns) ts);
          print_endline ("Instantiated closure value is " ^ sbe syms.dfns tb);
          print_endline ("type is " ^ sbt syms.dfns tt);
          *)
          Some tb 

      | None ->
        let opens : entry_set_t list = 
          concat
          (
            map
            (fun table -> 
              match lookup_name_in_htab table name with
              | Some x -> [x]
              | None -> []
            )
            dirs
          )
        in
          (*
          print_endline (si (length opens) ^ " OPENS BUILT for " ^ name);
          *)
          let fs:entry_kind_t list = 
            match opens with 
            | [NonFunctionEntry i] -> [i]
            | [FunctionEntry ii] -> ii
            | _ -> merge_functions opens name 
          in
          let ro = 
            resolve_overload'
            syms rs sra fs name t2 ts
          in
          (*
          print_endline "OVERLOAD RESOLVED .. ";
          *)
          match ro with
          | Some (result,t,mgu,ts) ->
            let tb : tbexpr_t = 
              handle_function 
              syms 
              env rs
              sra srn name ts result
            in 
              Some tb
          | None -> 
            (*
            print_endline "FAILURE"; flush stdout; 
            *)
            None

and bind_regdef syms env regexp_exclude e =
  let bd e = bind_regdef syms env regexp_exclude e in
  match e with
  | REGEXP_group (n,e) -> REGEXP_group (n, bd e)
  | REGEXP_seq (e1,e2) -> REGEXP_seq (bd e1, bd e2)
  | REGEXP_alt (e1,e2) -> REGEXP_alt (bd e1, bd e2)
  | REGEXP_aster e -> REGEXP_aster (bd e)
  | REGEXP_name qn ->
    begin match lookup_qn_in_env syms env qn with
    | i,_ ->
      if mem i regexp_exclude
      then 
        let sr = src_of_expr (qn:>expr_t) in
        clierr sr
        (
          "[bind_regdef] Regdef " ^ string_of_qualified_name qn ^
          " depends on itself"
        )
      else
        begin
          match get_data syms.dfns i with
          {symdef=entry} ->
          match entry with
          | `SYMDEF_regdef e ->
            bind_regdef syms env (i::regexp_exclude) e
          | _ -> 
            let sr = src_of_expr (qn:>expr_t) in
            clierr sr
            (
              "[bind_regdef] Expected " ^ string_of_qualified_name qn ^
              " to be regdef"
            ) 
        end
    end 

  | x -> x

and handle_map sr (f,ft) (a,at) =
    let t =
      match ft with
      | `BTYP_function (d,c) ->
        begin match at with
        | `BTYP_inst (i,[t]) ->
          if t <> d 
          then clierr sr 
            ("map type of data structure index " ^ 
            "must agree with function domain")
          else
            `BTYP_inst (i,[c])
        | _ -> clierr sr "map requires instance"
        end
      | _ -> clierr sr "map non-function"
    in
      (* actually this part is easy, it's just
      applies ((map[i] f) a) where map[i] denotes
      the map function generated for data structure i
      *)
      failwith "MAP NOT IMPLEMENTED"
 
and bind_expression' syms env (rs:recstop) e args
: tbexpr_t = 
  (*
  print_endline ("[bind_expression'] " ^ string_of_expr e);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    rs.expr_fixlist
  );
  *)
  if mem_assq e rs.expr_fixlist
  then raise (Expr_recursion e)
  ;
  let be e' = bind_expression' syms env 
    { rs with expr_fixlist=(e,rs.depth)::rs.expr_fixlist; depth=rs.depth+1} e' [] in
  let bt sr t = 
    (* we're really wanting to call bind type and propagate depth ? *)
    let t = bind_type' syms env 
      { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist; depth=rs.depth +1 }
      sr t [] 
    in
    let t = beta_reduce syms [] t in
    t
  in
  let ti sr i ts = 
    inner_typeofindex_with_ts syms sr
    { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist; depth = rs.depth + 1}
                               (* CHANGED THIS ------------------*******)
    i ts
  in

  (* model infix operator as function call *)
  let apl2 (sri:range_srcref) (fn : string) (tup:expr_t list) = 
    let sr = rslist tup in
    `AST_apply 
    (
      sr, 
      (
        `AST_name (sri,fn,[]), 
        `AST_tuple (sr,tup)
      )
    )
  in
  (*
  print_endline ("Binding expression " ^ string_of_expr e ^ " depth=" ^ string_of_int depth);
  print_endline ("environment is:");
  print_env env;
  print_endline "==";
  *)
  let sr = src_of_expr e in
  match e with
  | `AST_type_match _ 
  | `AST_noexpand _
  | `AST_letin _ 
  | `AST_cond _ 
  | `AST_typeof _
  | `AST_as _
  | `AST_void _
  | `AST_arrow _ 
  | `AST_longarrow _ 
  | `AST_superscript _ 
  | `AST_ellipsis _ 
  | `AST_parse _ 
  | `AST_setunion _
  | `AST_setintersection _
  | `AST_macro_ctor _
  | `AST_macro_statements  _
    -> 
      clierr sr 
     ("[bind_expression] Expected expression, got " ^ string_of_expr e) 

  | `AST_callback (sr,qn) ->
    let es,ts = lookup_qn_in_env2' syms env rs qn in
    begin match es with
    | FunctionEntry [index] ->
       print_endline "Callback closure ..";
       let ts = map (bt sr) ts in
       `BEXPR_closure (index, ts),
       ti sr index ts
    | NonFunctionEntry  _
    | _ -> clierr sr
      "'callback' expression denotes non-singleton function set"
    end

  | `AST_sparse (sr,e,nt,nts) ->
    let e = be e in
    (*
    print_endline ("Calculating AST_parse, symbol " ^ nt);
    *)
    let t = cal_glr_attr_type syms sr nts in
    (*
    print_endline (".. DONE: Calculating AST_parse, type=" ^ sbt syms.dfns t);
    *)
    `BEXPR_parse (e,nts),`BTYP_sum [unit_t;t]
   
  | `AST_expr (sr,s,t) -> 
    let t = bt sr t in 
    `BEXPR_expr (s,t),t

  | `AST_andlist (sri,ls) -> 
    begin let mksum a b = apl2 sri "land" [a;b] in
    match ls with 
    | h::t -> be (fold_left mksum h t)
    | [] -> clierr sri "Not expecting empty and list"
    end

  | `AST_orlist (sri,ls) -> 
    begin let mksum a b = apl2 sri "lor" [a;b] in
    match ls with 
    | h::t -> be (fold_left mksum h t)
    | [] -> clierr sri "Not expecting empty or list"
    end
 
  | `AST_sum (sri,ls) -> 
    begin let mksum a b = apl2 sri "add" [a;b] in
    match ls with 
    | h::t -> be (fold_left mksum h t)
    | [] -> clierr sri "Not expecting empty product (unit)"
    end
    
  | `AST_product (sri,ls) ->
    begin let mkprod a b = apl2 sri "mul" [a;b] in
    match ls with 
    | h::t -> be (fold_left mkprod h t)
    | [] -> clierr sri "Not expecting empty sum (void)"
    end

  | `AST_coercion (sr,(x,t)) -> 
    let (e',t') as x' = be x in
    let t'' = bt sr t in
    if type_eq syms.dfns t' t'' then x'
    else clierr sr 
    (
      "Wrong type in coercion:\n" ^
      sbe syms.dfns x' ^ " has type " ^ sbt syms.dfns t' ^
      "\nwhereas annotation requires " ^ sbt syms.dfns t''
    )
    
  | `AST_get_n (sr,(n,e')) -> 
    let expr,typ = be e' in
    let ctyp = match unfold syms.dfns typ with 
    | `BTYP_array (t,`BTYP_unitsum len)  ->
      if n<0 or n>len-1
      then clierr sr
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1)
        )
      else t

    | `BTYP_lvalue (`BTYP_array (t,`BTYP_unitsum len)) ->
      if n<0 or n>len-1
      then clierr sr
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1)
        )
      else lvalify t


    | `BTYP_tuple ts 
    | `BTYP_lvalue (`BTYP_tuple ts) 
      -> 
      let len = length ts in
      if n<0 or n>len-1
      then clierr sr
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1)
        )
      else nth ts n
    | _ -> 
      clierr sr 
      (
        "[bind_expression] Expected tuple " ^ 
        string_of_expr e' ^ 
        " to have tuple type, got " ^ 
        sbt syms.dfns typ
      )
    in 
      `BEXPR_get_n (n, (expr,typ)), ctyp

  | `AST_get_named_variable (sr,(name,e')) ->
    let e'',t'' = be e' in
    begin match t'' with
    | `BTYP_inst (i,ts) 
    | `BTYP_lvalue (`BTYP_inst (i,ts)) ->
      begin match Hashtbl.find syms.dfns i with
      | {pubmap=pubtab; symdef = `SYMDEF_class } ->
        (*
        print_endline "AST_get_named finds a class .. ";
        print_endline ("Looking for component named " ^ name);
        *)
        let entryset = 
          try Hashtbl.find pubtab name 
          with Not_found -> clierr sr ("Cannot find component " ^ name ^ " in class")
        in
        begin match entryset with
        | NonFunctionEntry idx ->
          let vtype = 
            inner_typeofindex_with_ts syms sr
            { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist; depth = rs.depth+1 }
            idx ts
           in
           (*
           print_endline ("Class member variable has type " ^ sbt syms.dfns vtype);
           *)
           `BEXPR_get_named (idx,(e'',t'')),vtype
        | _ -> clierr sr ("Expected component "^name^" to be a variable")
        end
      | _ -> clierr sr ("[bind_expression] Projection requires class")
      end
    | _ -> clierr sr ("[bind_expression] Projection requires class instance")
    end

  | `AST_get_named_method (sr,(meth_name,meth_idx,meth_ts,obj)) ->
    (*
    print_endline ("Get named method " ^ meth_name);
    *)
    let meth_ts = map (bt sr) meth_ts in
    let oe,ot = be obj in
    begin match ot with
    | `BTYP_inst (oi,ots) 
    | `BTYP_lvalue (`BTYP_inst (oi,ots)) ->

      (*
      (* bind the method signature in the context of the object *)
      let sign =
        let entry = Hashtbl.find syms.dfns oi in
        match entry with | {vs = vs } ->
        let bvs = map (fun (n,i,_) -> n,`BTYP_var (i,`BTYP_type)) vs in
        print_endline ("Binding sign = " ^ string_of_typecode sign);
        let env' = build_env syms (Some oi) in
        bind_type' syms env' rsground sr sign bvs
      in
      print_endline ("Got sign bound = " ^ sbt syms.dfns sign);
      *)
      begin match Hashtbl.find syms.dfns oi with
      | {id=classname; pubmap=pubtab; vs=obj_vs; symdef = `SYMDEF_class } ->
        (*
        print_endline ("AST_get_named finds a class .. " ^ classname);
        print_endline ("Looking for component named " ^ name);
        *)
        let entryset = 
          try Hashtbl.find pubtab meth_name 
          with Not_found -> clierr sr ("Cannot find component " ^ meth_name ^ " in class " ^ classname)
        in
        begin match entryset with
        | FunctionEntry fs ->
          if not (mem meth_idx fs) then syserr sr "Woops, method index isn't a member function!";
          begin match Hashtbl.find syms.dfns meth_idx with
          | {id=method_name; vs=meth_vs; symdef = `SYMDEF_function _} ->
            assert (meth_name = method_name);
            (*
            print_endline ("Found " ^ si (length fs) ^ " candidates");
            print_endline ("Object ts=" ^ catmap "," (sbt syms.dfns) ots);
            print_endline ("Object vs = " ^ print_ivs_with_index obj_vs);
            print_endline ("Method ts=" ^ catmap "," (sbt syms.dfns) meth_ts);
            print_endline ("Method vs = " ^ print_ivs_with_index meth_vs);
            *)
            (*
            begin match resolve_overload' syms rs sr fs meth_name [sign] meth_ts with
            | Some (meth_idx,meth_rt,mgu,meth_ts) ->
              (*
              print_endline "Overload resolution OK";
              *)
              (* Now we need to fixate the class type variables in the method *)
              *)
              (*
              print_endline ("ots = " ^ catmap "," (sbt syms.dfns) ots);
              *)
              let omap =
                let vars = map2 (fun (_,i,_) t -> i,t) obj_vs ots in
                hashtable_of_list vars 
              in
              let meth_ts = map (varmap_subst omap) meth_ts in
              (*
              print_endline ("meth_ts = " ^ catmap "," (sbt syms.dfns) meth_ts);
              *)
              let ts = ots @ meth_ts in
              let typ = typeofindex_with_ts syms sr meth_idx ts in
              `BEXPR_method_closure ((oe,ot),meth_idx,ts),typ


            (*
            | _ -> clierr sr 
              ("[get_named_method] Cannot find method " ^ meth_name ^ 
                " with signature "^sbt syms.dfns sign^" in class, candidates are:\n" ^
                catmap "," (fun i -> meth_name ^ "<" ^si i^ ">") fs
              )
          end
          *)
          | _ -> clierr sr ("[get_named_method] Can't find method "^meth_name)
          end
        | _ -> clierr sr ("Expected component "^meth_name^" to be a function")
        end
      | _ -> clierr sr ("[bind_expression] Projection requires class")
      end
    | _ -> clierr sr ("[bind_expression] Projection requires class instance")
    end

  | `AST_case_index (sr,e) -> 
    let (e',t) as e  = be e in
    begin match lstrip syms.dfns t with
    | `BTYP_unitsum _ -> ()
    | `BTYP_sum _ -> ()
    | `BTYP_inst (i,_) ->
      begin match Hashtbl.find syms.dfns i with
      | {symdef=`SYMDEF_union _} -> ()
      | {id=id} -> clierr sr ("Argument of caseno must be sum or union type, got type " ^ id)
      end
    | _ -> clierr sr ("Argument of caseno must be sum or union type, got " ^ sbt syms.dfns t)
    end
    ;
    let int_t = bt sr (`AST_name (sr,"int",[])) in
    begin match e' with 
    | `BEXPR_case (i,_) -> 
      `BEXPR_literal (`AST_int ("",Big_int.big_int_of_int i))
    | _ -> `BEXPR_case_index e
    end
    ,
    int_t
    
  | `AST_case_tag (sr,v) ->
     clierr sr "plain case tag not allowed in expression (only in pattern)"

  | `AST_typed_case (sr,v,t) ->
    let t = bt sr t in
    ignore (try unfold syms.dfns t with _ -> failwith "AST_typed_case unfold screwd");
    begin match unfold syms.dfns t with
    | `BTYP_unitsum k ->
      if v<1 or v> k
      then clierr sr "Case index out of range of sum"
      else 
        `BEXPR_case (v,t),t  (* const ctor *)

    | `BTYP_sum ls ->
      if v<1 or v> length ls
      then clierr sr "Case index out of range of sum"
      else let vt = nth ls (v-1) in
      let ct = 
        match vt with
        | `BTYP_tuple [] -> t        (* const ctor *)
        | _ -> `BTYP_function (vt,t) (* non-const ctor *)
      in
      `BEXPR_case (v,t), ct
    | _ ->
      clierr sr 
      (
        "[bind_expression] Type of case must be sum, got " ^
        sbt syms.dfns t
      )
    end

  | `AST_name (sr,name,ts) ->
    (*
    print_endline ("BINDING NAME " ^ name);
    *)
    let ts = map (bt sr) ts in
    begin match inner_lookup_name_in_env syms env rs sr name with
    | NonFunctionEntry (index) -> 
      let ts = adjust_ts syms sr index ts in
      `BEXPR_name (index,ts),
      let t = ti sr index ts in
      t

    | FunctionEntry fs ->
      assert (length fs > 0);
      begin match args with
      | [] ->
        clierr sr
        (
          "[bind_expression] Simple name " ^ name ^ 
          " binds to function set in\n" ^
          short_string_of_src sr
        )
      | args -> 
        let sufs = map snd args in
        let rs = { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist } in
        let ro = resolve_overload' syms rs sr fs name sufs ts in
        begin match ro with
         | Some (index, ret,mgu,ts) ->
           (*
           print_endline "OK, overload resolved!!";
           *)
           `BEXPR_closure (index,ts),
            ti sr index ts
            (*
            typeofindex_with_ts syms sr index ts
            *)

         | None -> clierr sr "Cannot resolve overload .."
        end 
      end
    end

  | `AST_index (_,name,index) ->
    let ts = adjust_ts syms sr index [] in
    let t = ti sr index ts in
    begin match Hashtbl.find syms.dfns index with
    | {symdef=`SYMDEF_fun _ } 
    | {symdef=`SYMDEF_function _ } 
    -> 
    (*
    print_endline ("Indexed name: Binding " ^ name ^ "<"^si index^">"^ " to closure");
    *)
      `BEXPR_closure (index,ts),t
    | _ -> 
    (*
    print_endline ("Indexed name: Binding " ^ name ^ "<"^si index^">"^ " to variable");
    *)
      `BEXPR_name (index,ts),t
    end

  | `AST_the(_,`AST_name (sr,name,ts)) ->
    (*
    print_endline ("AST_name " ^ name ^ "[" ^ catmap "," string_of_typecode ts^ "]");
    *)
    let ts = map (bt sr) ts in
    begin match inner_lookup_name_in_env syms env rs sr name with
    | NonFunctionEntry (index) -> 
      let ts = adjust_ts syms sr index ts in
      `BEXPR_name (index,ts),
      let t = ti sr index ts in
      t

    | FunctionEntry [index] -> 
      let ts = adjust_ts syms sr index ts in
      `BEXPR_closure (index,ts),
      let t = ti sr index ts in
      t

    | FunctionEntry _ -> 
      clierr sr
      (
        "[bind_expression] Simple 'the' name " ^ name ^ 
        " binds to non-singleton function set"
      )
    end
  | `AST_the (sr,q) -> clierr sr "invalid use of 'the' "

  | (`AST_lookup (sr,(e,name,ts))) as qn ->
    (*
    print_endline ("Handling qn " ^ string_of_qualified_name qn);
    *)
    let ts = map (bt sr) ts in
    let entry = 
      match 
          eval_module_expr 
          syms 
          env 
          e 
      with 
      | (Simple_module (impl, ts, htab,dirs)) ->
        let env' = mk_bare_env syms impl in
        let tables = get_pub_tables syms env' rs dirs in
        let result = lookup_name_in_table_dirs htab tables sr name in
        result

    in 
      begin match entry with
      | Some entry -> 
        begin match entry with
        | NonFunctionEntry (i) ->  
          begin match Hashtbl.find syms.dfns i with
          | {sr=srn; symdef=`SYMDEF_inherit qn} -> be (qn :> expr_t)
          | _ ->
            let ts = adjust_ts syms sr i ts in
            `BEXPR_name (i,ts), 
            ti sr i ts
          end

        | FunctionEntry fs ->
          begin match args with
          | [] ->
            clierr sr 
            (
              "[bind_expression] Qualified name " ^ 
              string_of_qualified_name qn ^ 
              " binds to function set"
            )
          
          | args -> 
            let sufs = map snd args in
            let rs  = { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist } in
            let ro = resolve_overload' syms rs sr fs name sufs ts in
            begin match ro with
             | Some (index, ret,mgu,ts) ->
               (*
               print_endline "OK, overload resolved!!";
               *)
               `BEXPR_closure (index,ts),
               (*
               typeofindex_with_ts syms sr index ts
               *)
               ti sr index ts

            | None -> 
              clierr sr "Overload resolution failed .. "
            end
          end
        end

      | None ->
        clierr sr
        (
          "Can't find " ^ name
        )
      end

  | `AST_suffix (sr,(f,suf)) ->
    let sign = bt sr suf in
    begin match (f:>expr_t) with
    | #qualified_name_t as name -> 
      let srn = src_of_expr name in
      lookup_qn_with_sig'
        syms 
        sr srn env 
        { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist }
        name [sign]

    | e -> be e
    end

    (*
    lookup sr (f:>expr_t) [sign]
    *)

  | `AST_ref (_,(`AST_deref (sr,e))) -> be e

  | `AST_lvalue (srr,e) ->
    failwith "WOOPS, lvalue in expression??";
 
  | `AST_ref (sr,(`AST_dot (_,(e,id,[])))) ->
    let ref_name = "ref_" ^ id in
    be 
    (
      `AST_apply 
      (
        sr,
        (
          `AST_name (sr, ref_name,[]),
          `AST_ref (sr,e)
        )
      )
    )

  | `AST_ref (srr,e) -> 
    let e',t' = be e in 
    begin match e' with
    | `BEXPR_name (index,ts) ->
      begin match get_data syms.dfns index with
      {id=id; sr=sr; symdef=entry} ->
      begin match entry with
      | `SYMDEF_inherit _ -> clierr srr "Woops, bindexpr yielded inherit"
      | `SYMDEF_inherit_fun _ -> clierr srr "Woops, bindexpr yielded inherit fun"
      | `SYMDEF_var _ ->
        let vtype = 
          inner_typeofindex_with_ts syms sr
          { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist; depth = rs.depth+1 }
         index ts
        in
          `BEXPR_ref (index,ts), `BTYP_pointer vtype

      | `SYMDEF_parameter _ -> 
         clierr2 srr sr
        (
          "[bind_expression] " ^
          "Address value parameter " ^ id 
        )
      | `SYMDEF_const _
      | `SYMDEF_val _ ->
        clierr2 srr sr
        (
          "[bind_expression] " ^
          "Can't address a value or const " ^ id
        )
      | _ -> 
         clierr2 srr sr
        (
          "[bind_expression] " ^
          "Address non variable " ^ id 
        )
      end
      end
    | _ ->
       clierr srr 
        (
          "[bind_expression] " ^
          "Address non variable"
        )
    end

  | `AST_deref (_,`AST_ref (sr,e)) -> 
    let e,t = be e in
    let t = lvalify t in e,t

  | `AST_deref (sr,e) -> 
    let e,t = be e in
    begin match unfold syms.dfns t with 
    | `BTYP_lvalue (`BTYP_pointer t')
    | `BTYP_pointer t' 
      -> `BEXPR_deref (e,t),`BTYP_lvalue t'
    | _ -> clierr sr "[bind_expression'] Dereference non pointer"
    end

  | `AST_literal (sr,v) -> 
    let t = typeof_literal syms env sr v in
    `BEXPR_literal v, t

  | `AST_method_apply (sra,(fn,e2,meth_ts)) -> 
    (*
    print_endline ("METHOD APPLY: " ^ string_of_expr e);
    *)
    (* .. PRAPS .. *)
    let meth_ts = map (bt sra) meth_ts in
    let (be2,t2) as x2 = be e2 in
    begin match t2 with
    | `BTYP_lvalue(`BTYP_record es)
    | `BTYP_record es ->
      let rcmp (s1,_) (s2,_) = compare s1 s2 in
      let es = sort rcmp es in
      let field_name = String.sub fn 4 (String.length fn -4) in
      begin match list_index (map fst es) field_name with
      | Some n -> `BEXPR_get_n (n,x2),assoc field_name es
      | None -> clierr sr 
         (
           "Field " ^ field_name ^ 
           " is not a member of anonymous structure " ^ 
           sbt syms.dfns t2
          )
      end
    | _ ->
    let tbe1 = 
      match t2 with
      | `BTYP_lvalue(`BTYP_inst (index,ts)) 
      | `BTYP_inst (index,ts) ->
        begin match get_data syms.dfns index with
        {id=id; parent=parent;sr=sr;symdef=entry} ->
        match parent with
        | None -> clierr sra "Koenig lookup: No parent for method apply (can't handle global yet)"
        | Some index' ->
          match get_data syms.dfns index' with
          {id=id';sr=sr';parent=parent';vs=vs';pubmap=name_map;dirs=dirs;symdef=entry'}
          ->
          match entry' with
          | `SYMDEF_module 
          | `SYMDEF_function _
            ->
            koenig_lookup syms rs sra id' name_map fn t2 (ts @ meth_ts)

          | _ -> clierr sra ("Koenig lookup: parent for method apply not module")
        end
 
      | _ -> clierr sra ("apply method "^fn^" to nongenerative type")
    in
      cal_apply syms sra tbe1 (be2, t2)
    end

  | `AST_map (sr,f,a) ->
    handle_map sr (be f) (be a)
  
  | `AST_apply (sr,(f',a')) ->
    (*
    print_endline ("Apply " ^ string_of_expr f' ^ " to " ^  string_of_expr a');
    *)
    let (ea,ta) as a = be a' in
    (*
    print_endline ("Recursive descent into application " ^ string_of_expr e);
    *)
    let (bf,tf) as f  =
      match f' with
      | #qualified_name_t as name -> 
        let sigs = map snd args in
        let srn = src_of_expr name in
        lookup_qn_with_sig' syms sr srn env 
          { rs with expr_fixlist = (e,rs.depth)::rs.expr_fixlist }
          name (ta::sigs)
      | _ -> bind_expression' syms env rs f' (a :: args) 
    in
    begin match tf with 
    | `BTYP_cfunction _ -> cal_apply syms sr f a
    | `BTYP_function _ -> cal_apply syms sr f a
    | _ ->
      let apl name =
        be 
        (
          `AST_apply 
          (
            sr,
            (
              `AST_name (sr,name,[]),
              `AST_tuple (sr,[f';a'])
            )
          )
        )
      in
      apl "apply"
    end

  
  | `AST_arrayof (sr,es) ->
    let bets = map be es in
    let _, bts = split bets in
    let n = length bets in
    if n > 1 then begin
      let t = hd bts in
      iter
      (fun t' -> if t <> t' then 
         clierr sr 
         (
           "Elements of this array must all be of type:\n" ^
           sbt syms.dfns t ^ "\ngot:\n"^ sbt syms.dfns t'
         )
      )
      (tl bts)
      ;
      let t = `BTYP_array (t,`BTYP_unitsum n) in
      `BEXPR_tuple bets,t
    end else if n = 1 then hd bets
    else syserr sr "Empty array?"

  | `AST_record_type _ -> assert false

  | `AST_record (sr,ls) ->
    begin match ls with
    | [] -> `BEXPR_tuple [],`BTYP_tuple []
    | _ ->
    let ss,es = split ls in
    let es = map be es in
    let ts = map snd es in
    let t = `BTYP_record (combine ss ts) in
    `BEXPR_record (combine ss es),t
    end

  | `AST_tuple (_,es) -> 
    let bets = map be es in
    let _, bts = split bets in
    let n = length bets in
    if n > 1 then
      try 
        let t = hd bts in
        iter
        (fun t' -> if t <> t' then raise Not_found)
        (tl bts)
        ;
        let t = `BTYP_array (t,`BTYP_unitsum n) in
        `BEXPR_tuple bets,t
      with Not_found ->
        `BEXPR_tuple bets, `BTYP_tuple bts
    else if n = 1 then 
      hd bets 
    else
    `BEXPR_tuple [],`BTYP_tuple []


  | `AST_dot (sr,(e,id,ts)) ->
    let get_name = "get_" ^ id in
    be (`AST_method_apply (sr,(get_name,e,ts)))

  | `AST_match_case (sr,(v,e)) ->
     `BEXPR_match_case (v,be e),flx_bbool

  | `AST_match_ctor (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name,ts) -> 
      let fname = `AST_name (sr,"_match_ctor_" ^ name,ts) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(context,name,ts)) ->
      let fname = `AST_lookup (sr,(context,"_match_ctor_" ^ name,ts)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
       be (`AST_match_case (sr,(v,e)))

    | _ -> clierr sr "Expected variant constructor name in union decoder"
    end
    
  | `AST_case_arg (sr,(v,e)) ->
     let (_,t) as e' = be e in
    ignore (try unfold syms.dfns t with _ -> failwith "AST_case_arg unfold screwd");
     begin match lstrip syms.dfns (unfold syms.dfns t) with
     | `BTYP_unitsum n ->
       if v<1 or v>n 
       then clierr sr "Invalid sum index"
       else
         `BEXPR_case_arg (v, e'),unit_t

     | `BTYP_sum ls ->
       let n = length ls in
       if v<1 or v>n 
       then clierr sr "Invalid sum index"
       else let t = nth ls (v-1) in
       `BEXPR_case_arg (v, e'),t

     | _ -> clierr sr ("Expected sum type, got " ^ sbt syms.dfns t)
     end 

  | `AST_ctor_arg (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name,ts) -> 
      let fname = `AST_name (sr,"_ctor_arg_" ^ name,ts) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(e,name,ts)) ->
      let fname = `AST_lookup (sr,(e,"_ctor_arg_" ^ name,ts)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
      be (`AST_case_arg (sr,(v,e)))

    | _ -> clierr sr "Expected variant constructor name in union dtor"
    end

  | `AST_string_regmatch (sr,_) 
  | `AST_regmatch (sr,_) ->
    syserr sr
    (
      "[bind_expression] "  ^
      "Unexpected regmatch when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_reglex (sr,(p1,p2,cls)) ->
    syserr sr
    (
      "[bind_expression] " ^
      "Unexpected reglex when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_lambda (sr,_) -> 
    syserr sr
    (
      "[bind_expression] " ^
      "Unexpected lambda when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_match (sr,_) -> 
    clierr sr
    (
      "[bind_expression] " ^
      "Unexpected match when binding expression (should have been lifted out)"
    )

and resolve_overload
  syms
  sr
  (fs : entry_kind_t list)
  (name: string)
  (sufs : btypecode_t list)
  (ts:btypecode_t list)
=
  resolve_overload' syms rsground sr fs name sufs ts

and resolve_overload'
  syms (rs:recstop)
  sr
  (fs : entry_kind_t list)
  (name: string)
  (sufs : btypecode_t list)
  (ts:btypecode_t list)
: (entry_kind_t * btypecode_t * (int * btypecode_t) list * btypecode_t list) option =

  if length fs = 0 then None else
  let bt sr i t =
    let env = inner_build_env syms rs (Some i) in
    bind_type syms env sr t
  in
    let fs = trclose syms rs sr fs in
    overload syms bt sr fs name sufs ts

(* an environment is a list of hastables, mapping
   names to definition indicies. Each entity defining
   a scope contains one hashtable, and a pointer to
   its parent, if any. The name 'root' is special,
   it is the name of the single top level module
   created by the desugaring phase. We have to be
   able to find this name, so if when we run out
   of parents, which is when we hit the top module,
   we create a parent name map with a single entry
   'top'->NonFunctionEntry 0. 
*)

and split_dirs open_excludes dirs :
    qualified_name_t list *
    qualified_name_t list *
    (string * qualified_name_t) list
=
  let opens = 
     concat
     (
       map
       (fun x -> match x with 
         | DIR_open qn -> if mem qn open_excludes then [] else [qn]
         | DIR_inject_module qn -> []
         | DIR_use (n,qn) -> []
       )
       dirs
     )
  and includes = 
     concat
     (
       map
       (fun x -> match x with 
         | DIR_open qn -> []
         | DIR_inject_module qn -> [qn]
         | DIR_use (n,qn) -> []
       )
       dirs
     )
  and uses = 
     concat
     (
       map
       (fun x -> match x with 
         | DIR_open qn -> []
         | DIR_inject_module qn -> []
         | DIR_use (n,qn) -> [n,qn]
       )
       dirs
     )
  in opens, includes, uses

and get_includes' syms includes index =
  if not (mem index !includes) then
  begin
    includes := index :: !includes;
    let env = mk_bare_env syms index in
    match Hashtbl.find syms.dfns index with
    {id=id;sr=sr;parent=parent;vs=vs;pubmap=table;dirs=dirs} ->
    iter
    (fun x -> match x with 
      | DIR_open _
      | DIR_use _ -> ()
      | DIR_inject_module qn -> 
        let i,ts =
          try lookup_qn_in_env syms env qn 
          with Not_found -> failwith "QN NOT FOUND"
        in 
          get_includes' syms includes i
    )
    dirs
  end

and bind_dir 
  syms 
  (env:env_t) rs
  qn 
: int =
  let sr = ("dummy",0,0,0,0) in
  (*
  print_endline ("Try to bind dir " ^ string_of_qualified_name qn);
  *)
  let result = 
    try 
      lookup_qn_in_env' syms env 
      {rs with open_excludes = qn::rs.open_excludes } 
      qn 
    with Not_found -> failwith "QN NOT FOUND"
  in
  match result with
  | i,ts -> i

and pub_table_dir 
  syms 
  i 
: name_map_t =
  match get_data syms.dfns i with
  | {sr=sr; pubmap=table;symdef=`SYMDEF_module} -> table
  | {sr=sr} -> clierr sr "[map_dir] Expected module"


and get_pub_tables syms env rs dirs =
  let _,includes,_ = split_dirs rs.open_excludes dirs in
  let opens = uniq_list (map (bind_dir syms env rs) includes) in
  let includes = ref [] in
  iter (get_includes' syms includes) opens;
  let includes = uniq_list !includes in
  let tables = map (pub_table_dir syms) includes in
  tables

and mk_bare_env syms index = 
  match Hashtbl.find syms.dfns index with
  {id=id;parent=parent;privmap=table} -> (index,id,table,[]) :: 
  match parent with 
  | None -> [] 
  | Some index -> mk_bare_env syms index

and merge_opens syms env rs (opens,includes,uses) =
  (*
  print_endline ("MERGE OPENS ");
  *)
  let use_map = Hashtbl.create 97 in
  iter
  (fun (n,qn) ->
    let entry,_ = lookup_qn_in_env2' syms env rs qn in
    match entry with
    
    | NonFunctionEntry _ ->
      if Hashtbl.mem use_map n
      then failwith "Duplicate non function used"
      else Hashtbl.add use_map n entry

    | FunctionEntry ls ->
      let entry2 = 
        try Hashtbl.find use_map  n 
        with Not_found -> FunctionEntry []
      in
      match entry2 with
      | NonFunctionEntry _ ->
        failwith "Use function and non-function kinds"
      | FunctionEntry ls2 ->
        Hashtbl.replace use_map n (FunctionEntry (ls @ ls2))
  )
  uses 
  ;
  (*
  print_endline "Binding opens ..";
  *)
  let opens = uniq_list (map (bind_dir syms env rs) opens) in
  (*
  print_endline "Binding complete";
  *)
  let opens = uniq_cat opens (map (bind_dir syms env rs) includes) in

  let includes = ref [] in
  iter (get_includes' syms includes) opens;
  let includes = uniq_list !includes in
  let tables = map (pub_table_dir syms) includes in
  use_map::tables 

and build_env'' syms rs index : env_t =
  match Hashtbl.find syms.dfns index with
  {id=id; parent=parent;privmap=table;dirs=dirs} ->
  let opens,includes,uses = split_dirs rs.open_excludes dirs in
  let env = inner_build_env syms rs parent in
  let env' = (index,id,table,[])::env in
  let second = merge_opens syms env' rs (opens,includes,uses) in
  (index,id,table,second)::env
  
and inner_build_env syms rs parent : env_t =
  match parent with
  | None -> []
  | Some i ->
    try 
      Hashtbl.find syms.env_cache i
    with 
      Not_found ->
       let env = build_env'' syms rs i in
       Hashtbl.add syms.env_cache i env;
       env

and build_env syms parent : env_t =
  inner_build_env syms rsground parent
 

(*===========================================================*)
(* MODULE STUFF *)
(*===========================================================*)

(* This routine takes a bound type, and produces a unique form
   of the bound type, by again factoring out type aliases.
   The type aliases can get reintroduced by map_type,
   if an abstract type is mapped to a typedef, so we have
   to factor them out again .. YUK!!
*)
   
and rebind_btype syms env sr ts t: btypecode_t =
  let rbt t = rebind_btype syms env sr ts t in
  match t with
  | `BTYP_inst (i,_) ->
    begin match get_data syms.dfns i with
    | {symdef=`SYMDEF_type_alias t'} ->
      bind_type syms env sr t'
    | _ -> t
    end

  | `BTYP_typesetunion ts -> `BTYP_typesetunion (map rbt ts)
  | `BTYP_typesetintersection ts -> `BTYP_typesetintersection (map rbt ts)

  | `BTYP_tuple ts -> `BTYP_tuple (map rbt ts)
  | `BTYP_record ts -> 
      let ss,ts = split ts in 
      `BTYP_record (combine ss (map rbt ts))

  | `BTYP_typeset ts ->  `BTYP_typeset (map rbt ts)
  | `BTYP_intersect ts ->  `BTYP_intersect (map rbt ts)

  | `BTYP_sum ts -> 
    let ts = map rbt ts in 
    if all_units ts then
      `BTYP_unitsum (length ts)
    else
      `BTYP_sum ts
    
  | `BTYP_function (a,r) -> `BTYP_function (rbt a, rbt r) 
  | `BTYP_cfunction (a,r) -> `BTYP_cfunction (rbt a, rbt r) 
  | `BTYP_pointer t -> `BTYP_pointer (rbt t)
  | `BTYP_lvalue t -> lvalify (rbt t)
  | `BTYP_array (t1,t2) -> `BTYP_array (rbt t1, rbt t2)

  | `BTYP_unitsum _ 
  | `BTYP_void 
  | `BTYP_fix _ -> t

  | `BTYP_var (i,mt) -> clierr sr ("[rebind_type] Unexpected type variable " ^ sbt syms.dfns t)
  | `BTYP_apply _
  | `BTYP_typefun _
  | `BTYP_type
  | `BTYP_type_tuple _
  | `BTYP_type_match _
    -> clierr sr ("[rebind_type] Unexpected metatype " ^ sbt syms.dfns t)


and check_module syms name sr entries ts =
    begin match entries with
    | NonFunctionEntry (index) ->
      begin match get_data syms.dfns index with
      | {dirs=dirs;pubmap=table;symdef=`SYMDEF_module} -> 
        Simple_module (index,ts,table,dirs)
      | {id=id;sr=sr'} -> 
        clierr sr
        (
          "Expected '" ^ id ^ "' to be module in: " ^
          short_string_of_src sr ^ ", found: " ^
          short_string_of_src sr'
        )
      end
    | _ -> 
      failwith
      (
        "Expected non function entry for " ^ name
      )
    end

(* the top level table only has a single entry,
  the root module, which is the whole file

  returns the root name, table index, and environment
*)

and eval_module_expr syms env e : module_rep_t = 
  (*
  print_endline ("Eval module expr " ^ string_of_expr e);
  *)
  match e with
  | `AST_name (sr,name,ts) ->
    let entries = inner_lookup_name_in_env syms env rsground sr name in
    check_module syms name sr entries ts

  | `AST_lookup (sr,(e,name,ts)) ->
    let result = eval_module_expr syms env e in
    begin match result with
      | Simple_module (index,ts',htab,dirs) ->
      let env' = mk_bare_env syms index in
      let tables = get_pub_tables syms env' rsground dirs in
      let result = lookup_name_in_table_dirs htab tables sr name in
        begin match result with
        | Some x -> 
          check_module syms name sr x (ts' @ ts)

        | None -> clierr sr 
          (
            "Can't find " ^ name ^ " in module"
          )
        end

    end 

  | _ ->
    let sr = src_of_expr e in
    clierr sr
    (
      "Invalid module expression " ^ 
      string_of_expr e
    )


