@head(1,"Name Lookup")
There are some tricky issues with the name binding
rules. First, name binding is complicated by the fact
we support overloading. This defeats a simple linear
binding scheme: instead, we need to bind the type
of the argument of the application of a named function.
@p()
In addition, felix provides simple first order
generics by allowing declared name to be parameterised
by types.
@p()
There are two names then: simple and indexed.
Indexed names must of course refer to declarations
with the right number of parameters.
@p()
However, a non-indexed name may refer to a non-generic
entity, or, refer to a local generic entity, in which
case the arguments are just the list of parameter names.
@p()
Actually we can further generalise because of nesting.
Name binding consists of uniquely identifying
every name, and replacing the concrete name with
its canonical representation. Each declared name 
is number in order of writing, and takes type
parameters in a single list which is the concatenation
of the visible parameters in order of writing, in
other words starting with the outermost construction:
we can assume all names are parameterised by a list
of types, modeling non-generic names as if they had
0 type parameters.
@p()
We need to note now how our code is driven.
We start with certain non-genertc root functions,
and recurse through the call structure. In the root
of course, the type arguments used for a name must
selves be monomorphic (free of type variables),
so the binding itself is monomorphic.
@p()
What this all means is that routines like
bind_type and bind_expression are always accepting
and returning monomorphic data. What all this
means is that the indexing scheme never needs any
bound type variables: a name denoting a type parameter
is always being replaced by a monotype directly,
without any need to first go to variables and then
instantiate them.
@p()
Hmm .. messy .. consider:
@begin_displayed_code()
val x0 = 1;
module p1[t1] {
  val x1 = x0;
  module p2[t2] {
    va1 x2a = x1 + x2; // x1[t1] + x2[t1,t2]
    va1 x2b = x1 + p2[int]::x2; // x1[t1] + x2[t1,int]

  .. fine .. but the equivalent function structure:

val x0 = 1;
proc p1[t1]() {
  val x1 = x0;
  proc p2[t2]() {
    va1 x2a = x1 + x2; // x1[t1] + x2[t1,t2]
    // explicit indexing here is not allowed
    // for *variables* since
    // we have to refer to a a stack from on
    // the display which has fixed type
    // parameters .. but it IS allowed for
    // enclosed types (since type are static ..)
@end_displayed_code()
SUMMARY .. the total number of variables needed to
instaniate a name is the length of the list
of the concatenation of the type vaiable lists
of the entities ancestors including itself.
If any indexes are given explicitly, they're
always most local, and replace the last so many
bindings from context. Note the number of *implicit*
variables needed may be less than those given
if the name is defined in a parent: in this case
we just take first part of the argument list.
@p()
With this mechanism a simply list of bound
type indices suffices provided when a lookup
is done we calculate how many values are needed.
@p()
Hmm: this may cause a LOT of pain, if we're looking
up generic functions .. since we assumed the lookup
could select on the number of arguments .. well,
it can, by adjusting as the search deepens .. nice!
@p()
Technology: given an index i, find its vs list including
that of its parents (string -> int) form.

@h = tangler("src/flx_lookup.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2

val build_env:
  sym_state_t ->
  int option -> (* parent *)
  env_t

val lookup_name_in_env :
  sym_state_t ->
  env_t ->
  range_srcref ->
  id_t -> 
  entry_set_t

val lookup_qn_in_env :
  sym_state_t ->
  env_t ->
  qualified_name_t -> 
  entry_kind_t * typecode_t list

val lookup_sn_in_env :
  sym_state_t ->
  env_t ->
  suffixed_name_t -> 
  int * btypecode_t list

val lookup_code_in_env:
  sym_state_t ->
  env_t ->
  range_srcref ->
  qualified_name_t -> 
  entry_kind_t list * typecode_t list

(** This routine takes an unbound type term 
and binds it. The term may contain explicit
type variables. If the term denotes a generative
type (abstract, union, or struct) then an instance
is made with type variables for the indices.

Note that the result of binding a term with type
variables is not a type function.
*)

val bind_type:
  sym_state_t ->
  env_t ->
  range_srcref ->
  typecode_t ->
  btypecode_t

val eval_module_expr:
  sym_state_t ->
  env_t ->
  expr_t ->
  module_rep_t

val resolve_overload:
  sym_state_t ->
  range_srcref ->
  entry_kind_t list ->  
  id_t -> 
  btypecode_t ->
  btypecode_t list ->      (* explicit param/arg bindings *)
  (entry_kind_t * btypecode_t * (int * btypecode_t) list * btypecode_t list) option

val bind_expression :
  sym_state_t ->
  env_t ->
  expr_t ->
  tbexpr_t

val typeofindex :
  sym_state_t ->
  int ->
  btypecode_t

val typeofindex_with_ts:
  sym_state_t ->
  int ->
  btypecode_t list ->
  btypecode_t

val typeof_literal:
  sym_state_t ->
  env_t ->
  range_srcref ->
  literal_t ->
  btypecode_t

val lookup_qn_with_sig:
  sym_state_t ->
  range_srcref ->
  range_srcref ->
  env_t ->
  int list ->
  qualified_name_t ->
  btypecode_t ->
  tbexpr_t

val print_env: (* debugging *)
  env_t -> unit

val bind_regdef:
  sym_state_t ->
  env_t ->
  int list ->
  int list ->
  regexp_t ->
  regexp_t

@h = tangler("src/flx_lookup.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_exceptions
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_typing2
open List
open Flx_srcref
open Flx_unify
open Flx_beta
open Flx_generic
open Flx_name
open Flx_overload

exception Found of int
exception Tfound of btypecode_t

type kind_t = Parameter | Other

let print_env e = 
  let print_entry k v = 
    print_endline 
    (
      "  " ^ k ^ " " ^
      (
        match v with 
        | (NonFunctionEntry (i)) -> string_of_int i
        | _ -> ""
      )
    )
  in 
  let print_table htab = 
    print_endline "--"; Hashtbl.iter print_entry htab

  in 
  let print_level (index,id,htab,htabs) = 
    print_string (id^"<"^si index^">");
    print_table htab;
    print_endline "OPENS:";
    List.iter print_table htabs;
    print_endline "ENDOFOPENS"
  in 

  List.iter print_level e

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_lookup.get_data] No definition of <" ^ string_of_int index ^ ">")

let lookup_name_in_htab htab name : entry_set_t option =
  (* print_endline ("Lookup name in htab: " ^ name); *)
  try Some (Hashtbl.find htab name)
  with Not_found -> None
  
let merge_functions 
  (opens:entry_set_t list) 
  name 
: entry_kind_t list = 
  fold_left
    (fun init x -> match x with
    | FunctionEntry ls -> 
      fold_left
      (fun init x -> 
        if mem x init then init else x :: init
      )
      init ls
    | _ -> failwith ("Expected " ^ name ^ " to be function overload set in all open modules")
    )
  []
  opens

let lookup_name_in_table_dirs table dirs sr name : entry_set_t option =
  (* 
  print_endline ("Lookup name " ^ name ^ " in table dirs");
  flush stdout;
  *)
  match lookup_name_in_htab table name with
  | Some x as y -> 
    y
  | None ->
  let opens = 
    List.concat
    (
      List.map
      (fun table -> 
        match lookup_name_in_htab table name with
        | Some x -> [x]
        | None -> [] 
      )
      dirs
    )
  in match opens with
  | [x] -> Some x
  | FunctionEntry ls :: rest ->
    Some (FunctionEntry (merge_functions opens name))

  | (NonFunctionEntry (i)) as some ::_ -> 
    if 
      fold_left 
        (function t -> function
          | NonFunctionEntry (j) when i = j -> t
          | _ -> false
        )
        true
        opens
    then 
      Some some
    else
      clierr sr ("Conflicting values for "^name ^" found in open modules")
  
  | [] -> None

(* this ugly thing merges a list of function entries
some of which might be inherits, into a list of
actual functions
*)

let rec trclose syms sr fs =
  let inset = ref IntSet.empty in
  let outset = ref IntSet.empty in
  let exclude = ref IntSet.empty in
  let append fs = iter (fun i -> inset := IntSet.add i !inset) fs in

  let rec trclosem () =
    if IntSet.is_empty !inset then ()
    else
      (* grab an element *)
      let x = IntSet.choose !inset in
      inset := IntSet.remove x !inset;
      
      (* loop if already handled *)
      if IntSet.mem x !exclude then trclosem ()
      else begin
        (* say we're handling this one *)
        exclude := IntSet.add x !exclude;

        match Hashtbl.find syms.dfns x with
        | {parent=parent; sr=sr2; symdef=`SYMDEF_inherit_fun qn} ->
          let env = build_env syms parent in
          begin match fst (lookup_qn_in_env2 syms env qn) with
          | NonFunctionEntry _ -> clierr2 sr sr2 "Inherit fun doesn't denote function set"
          | FunctionEntry fs' -> append fs'; trclosem ()
          end

        | _ -> outset := IntSet.add x !outset; trclosem ()
      end
  in
  append fs;
  trclosem (); 
  let output = ref [] in 
  IntSet.iter (fun i -> output := i :: !output) !outset;
  !output

and resolve_inherits syms sr x =
  match x with
  | NonFunctionEntry z -> 
    begin match Hashtbl.find syms.dfns z with
    | {parent=parent; symdef=`SYMDEF_inherit qn} ->
      let env = build_env syms parent in
      fst (lookup_qn_in_env2 syms env qn)
    | {sr=sr2; symdef=`SYMDEF_inherit_fun qn} ->
      clierr2 sr sr2
      "NonFunction inherit denotes function"
    | _ -> x
    end
  | FunctionEntry fs -> FunctionEntry (trclose syms sr fs)

and lookup_name_in_env syms (env:env_t) sr name : entry_set_t =
  let rec aux env = 
    match env with 
    | [] -> None
    | (_,_,table,dirs) :: tail ->
      match lookup_name_in_table_dirs table dirs sr name with
      | Some x as y -> y
      | None -> aux tail
  in 
    match aux env with
    | Some x -> resolve_inherits syms sr x
    | None ->
      clierr sr 
      (
        "[lookup_name_in_env]: Name '" ^ 
        name ^ 
        "' not found in environment (depth "^
        string_of_int (List.length env)^ ")" 
      )

(* This routine looks up a qualified name in the
   environment and returns an entry_set_t:
   can be either non-function or function set
*)

and lookup_qn_in_env2
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_set_t * typecode_t list
=
  match qn with
  | `AST_void sr -> clierr sr "[lookup_qn_in_env2] qualified name is void"
  | `AST_case_tag (sr,_) -> clierr sr "[lookup_qn_in_env2] Can't lookup a case tag"
  | `AST_typed_case (sr,_,_) -> clierr sr "[lookup_qn_in_env2] Can't lookup a typed case tag"

  | `AST_name (sr,name,ts) -> 
    lookup_name_in_env syms env sr name, ts

  | `AST_the (sr,qn) -> 
    let es,ts = lookup_qn_in_env2 syms env qn in
    begin match es with
    | NonFunctionEntry  _
    | FunctionEntry [_] -> es,ts
    | _ -> clierr sr
      "'the' expression denotes non-singleton function set"
    end

  | `AST_lookup (sr,(me,name,ts)) ->
    match eval_module_expr syms env me with 
    | Simple_module (impl,ts', htab,dirs) ->
      let env' = mk_bare_env syms impl in
      let tables = get_pub_tables syms env' dirs in
      let result = lookup_name_in_table_dirs htab tables sr name in
      match result with
      | Some entry ->
        resolve_inherits syms sr entry,
        ts' @ ts
      | None ->
        clierr sr
        (
          "[lookup_qn_in_env2] Can't find " ^ name
        )

      (*
      begin 
      try 
        let entry = Hashtbl.find htab name in
        resolve_inherits syms sr entry,
        ts' @ ts
      with Not_found -> 
        clierr sr
        (
          "[lookup_qn_in_env2] Can't find " ^ name
        )
      end
      *)

and lookup_code_in_env syms env sr qn =
  match lookup_qn_in_env2 syms env qn with
    | NonFunctionEntry x,ts -> 
      clierr sr 
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be non-function (code insertions use function entries) "
      )
    | FunctionEntry x,ts -> x,ts


and lookup_qn_in_env 
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  match lookup_qn_in_env2 syms env qn with
    | NonFunctionEntry x,ts -> x,ts
    | FunctionEntry _,_ ->
      let sr = src_of_expr (qn:>expr_t) in
      clierr sr
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be function set"
      )

and lookup_uniq_in_env 
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  match lookup_qn_in_env2 syms env qn with
    | NonFunctionEntry x,ts -> x,ts
    | FunctionEntry [x],ts -> x,ts
    | _ ->
      let sr = src_of_expr (qn:>expr_t) in
      clierr sr
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be non-singleton function set"
      )

and lookup_function_in_env 
  syms
  (env:env_t) 
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  match lookup_qn_in_env2 syms env qn with
    | FunctionEntry [x],ts -> x,ts
    | _ ->
      let sr = src_of_expr (qn:>expr_t) in
      clierr sr
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be non-function or non-singleton function set"
      )

and lookup_sn_in_env 
  syms
  (env:env_t) 
  (sn: suffixed_name_t)
  : int * btypecode_t list
= 
  let sr = src_of_expr (sn:>expr_t) in
  let bt t = bind_type syms env sr t in
  match sn with
  | #qualified_name_t as x ->
    begin match
      lookup_qn_in_env syms env x
    with
    | index,ts -> index,map bt ts
    end

  | `AST_suffix (sr,(qn,suf)) ->
    let bsuf = bind_type syms env sr suf in
    (* OUCH HACKERY *)
    let (be,t) = 
      lookup_qn_with_sig'
      syms 
      sr sr 
      env [] [] 0 
      qn bsuf
    in match be with
    | `BEXPR_name (index,ts) -> 
      index,ts
    | `BEXPR_closure (index,ts) -> index,ts

    | _ -> failwith "Expected expression to be index"

(* This routine binds a type expression to a bound type expression.
   Note in particular that a type alias is replaced by what
   it as an alias for, recursively so that the result 
   globally unique

   if params is present it is a list mapping strings to types
   possibly bound type variable

   THIS IS WEIRD .. expr_fixlist is propagated, but 'depth'
   isn't. But the depth is essential to insert the correct
   fixpoint term .. ????

   i think this arises from:

   val x = e1 + y;
   val y = e2 + x;
 
   here, the implied typeof() operator is used
   twice: the first bind expression invoking a second
   bind expression which would invoke the first again ..
   here we have to propagate the bind_expression
   back to the original call on the first term,
   but we don't want to accumulate depths? Hmmm...
   I should test that ..
   
*)
and bind_type syms env sr t : btypecode_t =
  (*
  print_endline ("[bind_type] " ^ string_of_typecode t);
  *)
  let bt:btypecode_t = 
    bind_type' syms env [] [] [] [] 0 sr t []
  in
  (*
  print_endline ("Bound type= " ^ sbt syms.dfns t);
  *)
  let bt = beta_reduce syms [] bt 
  in
    (*
    print_endline ("Beta reduced type= " ^ sbt syms.dfns bt);
    *)
    bt 

and bind_expression syms env e  =
  let be = bind_expression' syms env [] [] 0 e in
  be


(* =========================================== *)
(* INTERNAL BINDING ROUTINES *)
(* =========================================== *)

(* RECURSION DETECTORS

There are FOUR type recursion detectors:

idx_fixlist is a list of indexes, used by
bind_index to detect a recursion determining
the type of a function or variable:
the depth is calculated from the list length:
this arises from bind_expression, which uses
bind type : bind_expression is called to deduce
a function return type from returned expressions

TEST CASE:
  val x = (x,x) // type is ('a * 'a) as 'a

RECURSION CYCLE: 
  typeofindex' -> bind_type'

type_alias_fixlist is a list of indexes, used by
bind_type_index to detect a recursive type alias,
[list contains depth]

TEST CASE:
  typedef a = a * a // type is ('a * 'a) as 'a


RECURSION CYCLE:
  bind_type' -> type_of_type_index
  
as_fixlist is a list of (name,depth) pairs, used by
bind_type' to detect explicit fixpoint variables
from the TYP_as terms (x as fv)
[list contains depth]

TEST CASE:
  typedef a = b * b as b // type is ('a * 'a) as 'a

RECURSION CYCLE:
  typeofindex' -> bind_type'

expr_fixlist is a list of (expression,depth)
used by bind_type' to detect recursion from
typeof(e) type terms
[list contains depth]

TEST CASE:
  val x: typeof(x) = (x,x) // type is ('a * 'a) as 'a

RECURSION CYCLE:
  bind_type' -> bind_expression'

TRAP NOTES: 
  idx_fixlist and expr_fixlist are related :(

  The expr_fixlist handles an explicit typeof(expr)
  term, for an arbitrary expr term.

  idx_fixlist is initiated by typeofindex, and only
  occurs typing a variable or function from its
  declaration when the declaration is omitted
  OR when cal_ret_type is verifying it

BUG: cal_ret_type is used to verify or compute function
return types. However the equivalent for variables
exists, even uninitialised ones. The two cases
should be handled similarly, if not by the same
routine.

Note it is NOT a error for a cycle to occur, even
in the (useless) examples:

   val x = x;
   var x = x;

In the first case, the val simply might not be used.
In the second case, there may be an assignment.
For a function, a recursive call is NOT an error
for the same reason: a function may
contain other calls, or be unused:
  fun f(x:int)= { return if x = 0 then 0 else f (x-1); }
Note two branches, the first determines the return type
as 'int' quite happily.

DEPTH:
  Depth is used to determine the argument of the
  fixpoint term.

  Depth is incremented when we decode a type
  or expression into subterms.

PROPAGATION.
It appears as_fixlist can only occur 
binding a type expression, and doesn't propagate
into bind_expression when a typeof() term is
part of the type expression: it's pure a syntactic
feature of a localised type expression.

  typedef t = a * typeof(x) as a;
  var x : t;

This is NOT the case, for example:

  typedef t = a * typeof (f of (a)) as a;

shows the as_fixlist label has propagated into
the expression: expressions can contain type
terms. However, the 'as' label IS always
localised to a single term.

Clearly, the same thing can happen with a type alias:

  typedef a = a * typeof (f of (a));

However, type aliases are more general because they
can span statement boundaries:

  typedef a = a * typeof (f of (b));
  typedef b = a;

Of course, it comes to the same thing after
substitution .. but lookup and binding is responsible
for that. The key distinction is that an as label
is just a string, whereas a type alias name has
an index in the symtab, and a fully qualified name
can be used to look it up: it's identifid by
its index, not a string label: OTOH non-top level
as labels don't map to any index.

NASTY CASE: It's possible to have this kind of thing:

  typedef a = typeof ( { typedef b = a; return x; } )

so that a type_alias CAN indeed be defined inside a type
expression. That alias can't escape however. In fact,
desugaring restructures this with a lambda (or should):

  typedef a = typeof (f of ());
  fun f() { typedef b = a; return x; }

This should work BUT if an as_label is propagated
we get a failure:

  typedef a = typeof ( { typedef c = b; return x; } ) as b;

This can be made to work by lifting the as label too,
which means creating a typedef. Hmmm. All as labels 
could be replaced by typedefs ..


MORE NOTES:
Each of these traps is used to inject a fixpoint
term into the expression, ensuring analysis terminates
and recursions are represented in typing.

It is sometimes a bit tricky to know when to pass, and when
to reset these detectors: in bind_type' and inner
bind_type of a subterm should usually pass the detectors
with a pushed value in appropriate cases, however and
independent typing, say of an instance index value,
should start with reset traps.

*)

(*
  we match type patterns by cheating a bit:
  we convert the pattern to a type, replacing
  the _ with a dummy type variable. We then
  record the 'as' terms of the pattern as a list
  of equations with the as variable index
  on the left, and the type term on the right:
  the RHS cannot contain any as variables.

  The generated type can contain both,
  but we can factor the as variables out
  and leave the type a function of the non-as
  pattern variables
*)

and type_of_tpattern syms p : 
  typecode_t * 
  (int * string) list *     (* variables found *)
  (int * typecode_t) list   (* as terms *)
= 
  let sr = "unk",0,0,0,0 in
  let vars = ref [] in
  let eqns = ref [] in
  let rec tp p = 
    match p with
    | `TPAT_function (a,b) -> `TYP_function (tp a, tp b)
    | `TPAT_tuple ps -> `TYP_tuple (map tp ps)
    | `TPAT_sum ps -> `TYP_sum (map tp ps)
    | `TPAT_pointer p -> `TYP_pointer (tp p)
    | `TPAT_name (n,ps) -> `AST_name (sr,n,map tp ps)
    | `TPAT_void -> `AST_void sr

    | `TPAT_var n -> 
      let j = !(syms.counter) in 
      incr (syms.counter); 
      vars := (j,n) :: !vars;
      `TYP_var j 

    | `TPAT_any -> 
      let j = !(syms.counter) in 
      incr (syms.counter); 
      `TYP_var j

    | `TPAT_as (t,n) ->
      let t = tp t in
      let j = !(syms.counter) in 
      incr (syms.counter); 
      vars := (j,n) :: !vars;
      eqns := (j,t) :: !eqns;
      t
  in 
    let t = tp p in
    t,!vars, !eqns

(* params is list of string * bound type *)

and bind_type' 
  syms env 
  idx_fixlist type_alias_fixlist as_fixlist expr_fixlist depth 
  sr t params
: btypecode_t =
  let btp t params = bind_type' syms env 
    idx_fixlist type_alias_fixlist as_fixlist expr_fixlist (depth+1) 
    sr t params 
  in
  let bt t = btp t params in
  let bi i ts = bind_type_index syms 
    idx_fixlist type_alias_fixlist as_fixlist expr_fixlist depth 
    sr i ts 
  in
  (*
  print_endline ("[bind_type'] " ^ string_of_typecode t);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  (*
  if length params <> 0 then
  begin
    print_endline ("  [" ^
    catmap ", " 
    (fun (s,t) -> s ^ " -> " ^ sbt syms.dfns t)
    params
    ^ "]"
    )
  end else print_endline  ""
  ;
  *)
  let t = 
  match t with

  (* We first attempt to perform the match
    at binding time as an optimisation, if that
    fails, we generate a delayed matching construction.
    The latter will be needed when the argument is a type
    variable.
  *)
  | `TYP_type_match (t,ps) ->
    let t = bt t in
    (*
    print_endline ("Typematch " ^ sbt syms.dfns t);
    *)
    let pts = ref [] in
    begin try 
      iter
      (fun (p',t') ->
        let p',vars,eqns = type_of_tpattern syms p' in
        (*
        print_endline ("Type of pattern is " ^ string_of_typecode p');
        *)
        let p' = bt p' in
        (*
        print_endline ("Bound Type of pattern is " ^ string_of_btypecode syms.dfns p');
        *)
        let eqns = map (fun (j,t) -> j, bt t) eqns in
        let u = maybe_unification syms.dfns [p', t] in
        match u with
        | Some mgu 
          when not (var_list_occurs (map fst mgu) t) ->
          (*
          print_endline "UNIFIED";
          *)
          (* bind the subterms of 'as' patterns,
            substituting in any variables found
          *)
          let eqns = 
            map 
            (fun (j,t) -> j, list_subst mgu t) 
            eqns 
          in

          (* join up the lists of variable assignments *)
          let args = mgu @ eqns in

          (* replace the variable index with its string name *)
          let args' = ref [] in
          iter
          (fun (j,t) -> 
            try args' := (assoc j vars,t) :: !args'
            with Not_found -> ()
          ) 
          args 
          ;
          let args = !args' in

          (* bind the result type, substituting the variables out *)
          let t' = btp t' args in
          raise (Tfound t')

        | Some _
        | None -> 
          (*
          print_endline "Not unified";
          *)
          let args = map (fun (i,s) -> s,`BTYP_var i) vars in
          let t' = btp t' args in
          let t' = list_subst eqns t' in
          pts := (p',t') :: !pts
      )
      ps
      ;
      `BTYP_type_match (t,rev !pts)
      (* clierr sr "[bind_type] typematch failure" *)

    with 
    | Tfound t -> t
    end

  | `TYP_lvalue t -> bt t
  | `TYP_dual t ->
    let t = bt t in
    dual t

  | `TYP_proj (i,t) -> 
    let t = bt t in
    ignore (try unfold t with _ -> failwith "TYP_proj unfold screwd");
    begin match unfold t with 
    | `BTYP_tuple ls ->
      if i < 1 or i>List.length ls
      then 
       clierr sr 
        (
          "product type projection index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (List.length ls)
        )
      else List.nth ls (i-1)

    | _ -> 
      clierr sr 
      (
        "\ntype projection requires product type"
      )
    end

  | `TYP_dom t -> 
    let t = bt t in 
    begin match unfold t with
    | `BTYP_function (a,b) -> a
    | _ ->
      clierr sr
      (
        short_string_of_src sr ^
        "\ntype domain requires function" 
      )
    end
  | `TYP_cod t -> 
    let t = bt t in 
    begin match unfold t with
    | `BTYP_function (a,b) -> b
    | _ ->
      clierr sr
      (
        short_string_of_src sr ^
        "\ntype codomain requires function" 
      )
    end

  | `TYP_case_arg (i,t) ->
    let t = bt t in
    ignore (try unfold t with _ -> failwith "TYP_case_arg unfold screwd");
    begin match unfold t with
    | `BTYP_sum ls ->
      if i < 1 or i>List.length ls
      then 
        clierr sr
        (
          "sum type extraction index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (List.length ls)
        )
      else List.nth ls (i-1)

    | _ -> 
      clierr sr
      (
        "sum type extraction requires sum type"
      )
    end

 
  | `TYP_ellipsis ->  
    failwith "Unexpected `TYP_ellipsis (...) in bind type"
  | `TYP_none ->  
    failwith "Unexpected `TYP_none in bind type"

  | `TYP_var i ->  `BTYP_var i
  | `TYP_as (t,s) -> 
    bind_type' syms env 
    idx_fixlist type_alias_fixlist 
    ((s,depth)::as_fixlist) expr_fixlist depth 
    sr t params

  | `TYP_typeof e ->
    (*
    print_endline ("Evaluating typeof(" ^ string_of_expr e ^ ")");
    *)
    let t =
      if List.mem_assq e expr_fixlist
      then begin
        let outer_depth = List.assq e expr_fixlist in
        let fixdepth = outer_depth -depth in
        (*
        print_endline ("OUTER DEPTH IS " ^ string_of_int outer_depth);
        print_endline ("CURRENT DEPTH " ^ string_of_int depth);
        print_endline ("FIXPOINT IS " ^ string_of_int fixdepth);
        *)
        `BTYP_fix fixdepth
      end
      else 
        snd(bind_expression' syms env [] expr_fixlist depth e)
    in 
      (*
      print_endline ("typeof --> " ^ sbt syms.dfns t);
      *)
      t

  | `TYP_array (t1,t2)-> 
    `BTYP_array (bt t1, bt t2)

  | `TYP_tuple ts -> 
    let ts' =List.map bt ts  in
    `BTYP_tuple ts'

  | `TYP_sum ts -> 
    let ts' =List.map bt ts  in
    `BTYP_sum ts'

  | `TYP_function (d,c) -> 
    let 
      d' = bt d  and 
      c' = bt c 
    in 
      `BTYP_function (bt d, bt c)

  | `TYP_pointer t -> 
     let t' = bt t in 
     `BTYP_pointer t'

  | `AST_void _ -> 
    `BTYP_void

  | `TYP_typefun (ps,r,body) -> 
    let data = 
      List.rev_map 
      (fun x -> 
        fst x, 
        bt (snd x), 
        let n = !(syms.counter) in 
        incr (syms.counter); 
        n
      ) 
      ps 
    in
    let pnames =  (* reverse order .. *)
      List.map (fun (n, t, i) -> (n,`BTYP_var i)) data 
    in
    let bbody = 
      bind_type' syms env idx_fixlist type_alias_fixlist 
      as_fixlist expr_fixlist (depth+1) 
      sr 
      body (pnames@params)
    in
      let bparams = (* order as written *)
        List.rev_map (fun (n,t,i) -> (i,t)) data 
      in
      `BTYP_typefun (bparams, bt r, bbody)

  | `TYP_apply (t1,t2) ->
    let t1 = bt t1 in
    let t2 = bt t2 in
    let t = `BTYP_apply (t1,t2) in
    (*
    let t = beta_reduce syms [] t in
    *)
    t

  | `TYP_type_tuple ts ->
    `BTYP_type_tuple (List.map bt ts)

  | `TYP_type -> `BTYP_type

  | `AST_name (sr,s,[]) when List.mem_assoc s as_fixlist ->
    `BTYP_fix ((List.assoc s as_fixlist)-depth)

  | `AST_name (sr,s,[]) when List.mem_assoc s params ->
    (*
    print_endline "Found in assoc list .. ";
    *)
    List.assoc s params

  (* QUALIFIED OR UNQUALIFIED NAME *)
  | #qualified_name_t as x ->
    (*
    print_endline ("Matched qualified name " ^ string_of_qualified_name x);
    *)
    match lookup_qn_in_env syms env x with
    | i,ts ->
      let ts = map bt ts in
      (*
      print_endline ("Qualified name lookup finds index " ^ si i ^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
      *)
      bi i ts
  in
    (*
    print_endline ("Bound type is " ^ sbt syms.dfns t);
    *)
    t

and bind_type_index syms 
  idx_fixlist type_alias_fixlist as_fixlist expr_fixlist depth 
  sr index ts 
= 
  (*
  print_endline 
  (
    "BINDING INDEX " ^ string_of_int index ^ 
    " with ["^
    catmap ", " 
    (sbt syms.dfns)
    ts^
    "]"
  );
  *)
  if List.mem_assoc index type_alias_fixlist 
  then begin
    (*
    print_endline (
      "Making fixpoint for Recursive type alias " ^
      (
        match get_data syms.dfns index with {id=id;sr=sr}-> 
          id ^ " defined at " ^
          short_string_of_src sr
      )
    );
    *)
    `BTYP_fix ((List.assoc index type_alias_fixlist)-depth)
  end  
  else begin let ts = adjust_ts syms index ts in
  match get_data syms.dfns index with
  | {id=id;sr=sr;parent=parent;vs=vs;pubmap=tabl;dirs=dirs;symdef=entry} ->
    (*
    if length vs <> length ts 
    then 
      clierr sr 
      (
        "[bind_type_index] Wrong number of type arguments for " ^ id ^
        ", expected " ^ 
        si (length vs) ^ " got " ^ si (length ts)
      );
    *)
    match entry with
    | `SYMDEF_typevar _ -> (* not sure if kind is not TYPE .. *)
      `BTYP_var index

    (* type alias RECURSE *)
    | `SYMDEF_type_alias t -> 
      (*
      print_endline ("Unravelling type alias " ^ id);
      *)
      let params = make_params syms index ts in
      let env:env_t = build_env syms (Some index) in
      let t = 
        bind_type' syms env idx_fixlist ((index,depth) :: type_alias_fixlist) as_fixlist 
        expr_fixlist depth sr t params 
      in
        (*
        print_endline ("Unravelled and bound is " ^ sbt syms.dfns t);
        *)
        let t = beta_reduce syms [] t in
        (*
        print_endline ("Beta reduced: " ^ sbt syms.dfns t);
        *)
        t


    | `SYMDEF_abs _ -> 
      `BTYP_inst (index,ts)

    | `SYMDEF_union _
    | `SYMDEF_struct _ 
    | `SYMDEF_cstruct _ 
      ->
      `BTYP_inst (index,ts)


    | _ -> 
      clierr sr
      (
        "[bind_type_index] Type " ^ id ^ 
        " must be a type [alias, abstract, union, struct], got:\n" ^
        string_of_symdef entry id vs
      )
  end 


and base_typename_of_literal v = match v with
  | `AST_int (t,_) -> t
  | `AST_float (t,_) -> t
  | `AST_string _ -> "string"
  | `AST_cstring _ -> "charp"
  | `AST_wstring _ -> "wstring"
  | `AST_ustring _ -> "string"

and  typeof_literal syms env sr v : btypecode_t = 
  let _,_,root,_ = List.hd (List.rev env) in
  let name = base_typename_of_literal v in
  match lookup_name_in_env syms env dummy_sr name with
  | NonFunctionEntry (index) -> 
    `BTYP_inst (index,[])
  | _ -> 
    clierr sr
    (
      "Unable to find simple definition of type " ^ 
      name ^ " of literal " ^
      string_of_literal v
    )
  
and typeofindex_with_ts
  syms 
  (index:int)
  ts
=
  let t = typeofindex syms index in
  let varmap = make_varmap syms index ts in
  let t = varmap_subst varmap t in
  t

(* This routine should ONLY 'fail' if the return type
  is indeterminate. This cannot usually happen.

  Otherwise, the result may be recursive, possibly
  Fix 0 -- which is determinate 'indeterminate' value :-)
  
  For example: fun f(x:int) { return f x; }

  should yield fix 0, and NOT fail.
*)


(* cal_ret_type uses the private name map *)
(* args is string,btype list *)
and cal_ret_type syms idx_fixlist expr_fixlist depth index args =
  (*
  print_endline ("[cal_ret_type] index " ^ si index);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  let env = build_env syms (Some index) in
  match (get_data syms.dfns index) with
  | {id=id;sr=sr;parent=parent;vs=vs;privmap=name_map;dirs=dirs;
     symdef=`SYMDEF_function (ps,rt,props,exes)
    } ->
    let rt = bind_type' syms env idx_fixlist [] [] expr_fixlist depth sr rt args in
    let rt = beta_reduce syms [] rt in
    let ret_type = ref rt in
    (*
    begin match rt with
    | `BTYP_var i when i = index -> 
      print_endline "No return type given"
    | _ -> 
      print_endline (" .. given type is " ^ sbt syms.dfns rt)
    end
    ;
    *)
    begin match exes with
    (* a bit hacky: in principle this is a multi-branch return statement,
      so it could be used wherever a return statement is used, however
      really regmatch is a function, but we use a normal function wrapper
      and a special instruction because the processing is lighter
    *)
    | [sr,`EXE_reglex (_,_,cls)] 
    | [sr,`EXE_regmatch (_,cls)] ->
      (*
      print_endline 
      (
       "Calc ret type of regmatch, initially " ^
       sbt syms.dfns !ret_type
      );
      *)

      List.iter
      (
       fun (re,e) ->
         let t = snd 
         (
           bind_expression' syms env 
           (index::idx_fixlist) expr_fixlist depth 
           e
          ) 
         in
         (*
         print_endline 
         (
           "regmatch instance " ^ string_of_expr e ^ ", type " ^ 
           sbt syms.dfns t
         );
         *)
         if do_unify syms !ret_type t
         then 
           ret_type := varmap_subst syms.varmap !ret_type
         else 
           clierr sr
           (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
           )
      )
      cls
      (*
      ;
      print_endline ("type is " ^ sbt syms.dfns !ret_type)
      *)
        
    | _ ->
      let return_counter = ref 0 in
      List.iter
      (fun exe -> match exe with
      | (sr,`EXE_fun_return e) ->
        incr return_counter;
        (*
        print_endline ("  .. Handling return of " ^ string_of_expr e);
        *)
        begin try
          let t = 
            (* this is bad code .. we lose detection
            of errors other than recursive dependencies ..
            which shouldn't be errors anyhow ..
            *)
              snd 
              (
                bind_expression' syms env 
                (index::idx_fixlist) expr_fixlist depth 
                e
              ) 
          in
          if do_unify syms !ret_type t (* the argument order is crucial *)
          then 
            ret_type := varmap_subst syms.varmap !ret_type
          else begin
            print_endline 
            (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
            )
            ;
            clierr sr
            (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
            )
          end
        with 
          | Stack_overflow -> failwith "[cal_ret_type] Stack overflow"
          | Expr_recursion e -> () 
          | Free_fixpoint t -> () 
          | Unresolved_return (sr,s) -> () 
          | ClientError (sr,s) as e -> raise (ClientError (sr,"Whilst calculating return type:\n"^s))
          | x -> 
          print_endline ("  .. Unable to compute type of " ^ string_of_expr e);
          print_endline ("Reason: " ^ Printexc.to_string x);
          ()
        end
      | _ -> ()
      )
      exes
      ;
      if !return_counter = 0 then (* it's a procedure .. *)
      begin 
        let mgu = do_unify syms !ret_type `BTYP_void in
        ret_type := varmap_subst syms.varmap !ret_type
      end
    end
    ;
    (* not sure if this is needed or not .. 
      if a type variable is computed during evaluation,
      but the evaluation fails .. substitute now
    ret_type := varmap_subst syms.varmap !ret_type
    ;
    *)
    (*
    let ss = ref "" in 
    Hashtbl.iter 
    (fun i t -> ss:=!ss ^si i^ " --> " ^sbt syms.dfns t^ "\n") 
    syms.varmap;
    print_endline ("syms.varmap=" ^ !ss);
    print_endline ("  .. ret type index " ^ si index ^ " = " ^ sbt syms.dfns !ret_type);
    *)
    !ret_type

  | _ -> assert false

  
and inner_typeofindex_with_ts
  syms 
  (idx_fixlist:int list) expr_fixlist depth
  (index:int)
  (ts: btypecode_t list)
: btypecode_t = 
 (*
 print_endline "Inner type of index with ts ..";
 *)
 let t = inner_typeofindex syms idx_fixlist expr_fixlist depth index in
 let varmap = make_varmap syms index ts in
 varmap_subst varmap t
 

(* this routine is called to find the type of a function
or variable .. so there's no type_alias_fixlist .. 
*)

and typeofindex 
  syms 
  (index:int)
: btypecode_t = 
    (*
    let () = print_endline ("Top level type of index " ^ si index) in
    *)
    if Hashtbl.mem syms.ticache index
    then begin
      let t = Hashtbl.find syms.ticache index in
      (*
      let () = print_endline ("Cached .." ^ sbt syms.dfns t) in
      *)
      t
    end
    else 
      let t = inner_typeofindex syms [] [] 0 index in
      let _ = try unfold t with _ ->
        print_endline "typeofindex produced free fixpoint";
        failwith "[typeofindex] free fixpoint constructed"
      in
      (*
      print_endline ("Type of index "^ si index ^ " is " ^ sbt syms.dfns t);
      *)
      (match t with (* HACK .. *)
      | `BTYP_fix _ -> ()
      | _ -> Hashtbl.add syms.ticache index t
      );
      t

and inner_typeofindex
  syms 
  (idx_fixlist:int list) expr_fixlist depth
  (index:int)
: btypecode_t = 
  (*
  print_endline ("[inner_type_of_index] " ^ si index);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  (* check the cache *)
  try Hashtbl.find syms.ticache index
  with Not_found ->   


  (* check index recursion *)
  if List.mem index idx_fixlist
  then `BTYP_fix (-depth)
  else

  match get_data syms.dfns index with
  | {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs;symdef=entry} 
  ->

  let env:env_t = build_env syms (Some index) in 

  let bt t:btypecode_t = 
    let t' = bind_type' syms env idx_fixlist [] [] expr_fixlist depth sr t [] in
    let t' = beta_reduce syms [] t' in
    t'
  in
  match entry with
  | `SYMDEF_inherit qn -> failwith ("Woops inner_typeofindex found inherit " ^ si index)
  | `SYMDEF_inherit_fun qn -> failwith ("Woops inner_typeofindex found inherit fun!! " ^ si index)
  | `SYMDEF_function (ps, rt,_,_) -> 
    let pts = List.map snd ps in
    let rt' = 
      try Hashtbl.find syms.varmap index with Not_found ->
      cal_ret_type syms (index::idx_fixlist) expr_fixlist depth index [] 
    in 
      (* this really isn't right .. need a better way to 
        handle indeterminate result .. hmm .. 
      *)
      if var_i_occurs index rt' then 
        raise (Unresolved_return (sr,
        (
          "[typeofindex'] " ^ 
          "function "^id^"<"^string_of_int index^
          ">: Can't resolve return type, got : " ^ 
          sbt syms.dfns rt' ^ 
          "\nPossibly each returned expression depends on the return type" ^
          "\nTry adding an explicit return type annotation"
        )))
      else
        let t = `BTYP_function (bt (typeof_list pts), rt') in
        t

  | `SYMDEF_const (t,_,_)
  | `SYMDEF_parameter (t)
  | `SYMDEF_val (t)
  | `SYMDEF_var (t)
    -> bt t

  | `SYMDEF_match_check _ ->
    `BTYP_function (`BTYP_tuple [], flx_bbool)

  | `SYMDEF_fun (pts,rt,_,_) -> 
    let t = `TYP_function (typeof_list pts,rt) in
    bt t
    
  | `SYMDEF_union _ ->
    clierr sr ("Union "^id^" doesn't have a type")

  (* struct as function *)
  | `SYMDEF_cstruct (ls)
  | `SYMDEF_struct (ls) -> 
    (* ARGGG WHAT A MESS *)
    let ts = map (fun (s,i) -> `AST_name (sr,s,[])) vs in
    let ts = map bt ts in
    let ts = adjust_ts syms index ts in
    let t = `BTYP_function(bt (paramtype ls),`BTYP_inst (index,ts)) in
    (*
    print_endline ("Struct as function type is " ^ sbt syms.dfns t);
    *)
    t

  | _ ->
    clierr sr
    (
      "[typeofindex] Expected declaration of typed entity for index "^
      string_of_int index^", got " ^ id 
    )

and cal_apply syms sr ((be1,t1) as tbe1) ((be2,t2) as tbe2) : tbexpr_t =
  let rest =
    match unfold t1 with
    | `BTYP_function (argt,rest) ->
      if argt = t2
      then rest 
      else
        clierr sr
        (
          "[cal_apply] Function " ^
          sbe syms.dfns tbe1 ^
          "\nof type " ^
          sbt syms.dfns t1 ^
          "\napplied to argument " ^
          sbe syms.dfns tbe2 ^
          "\n of type " ^
          sbt syms.dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          sbt syms.dfns argt 
        )

    (* HACKERY TO SUPPORT STRUCT CONSTRUCTORS *)
    | `BTYP_inst (index,ts) ->
      begin match get_data syms.dfns index with
      { id=id;vs=vs;symdef=entry} ->
        begin match entry with
        | `SYMDEF_cstruct (cs)
        | `SYMDEF_struct (cs) -> t1
        | _ -> 
          clierr sr
          (
            "[cal_apply] Attempt to apply non-struct " ^ id ^ ", type " ^
            sbt syms.dfns t1 ^
            " as constructor"
          )
        end
      end
    | _ -> 
      clierr sr
      (
        "Attempt to apply non-function\n" ^
        sbe syms.dfns tbe1 ^ 
        "\nof type\n" ^
        sbt syms.dfns t1 ^
        "\nto argument of type\n" ^
        sbe syms.dfns tbe2
      )
  in
  (*
  print_endline 
  (
    "---------------------------------------" ^
    "\nApply type " ^ sbt syms.dfns t1 ^
    "\nto argument of type " ^ sbt syms.dfns t2 ^ 
    "\nresult type is " ^ sbt syms.dfns rest ^
    "\n-------------------------------------"
  );
  *)

  let rest = varmap_subst syms.varmap rest in
  (* We have to allow type variables now .. the result
  should ALWAYS be determined, and independent of function
  return type unknowns, even if that means it is a recursive
  type, perhaps like 'Fix 0' ..: we should really test
  for the *function* return type variable not being
  eliminated ..
  *)
  (* 
  if var_occurs rest 
  then 
    clierr sr
    (
      "[cal_apply] Type variable in return type applying\n" ^
        sbe syms.dfns tbe1 ^ 
        "\nof type\n" ^
        sbt syms.dfns t1 ^
        "\nto argument of type\n" ^
        sbe syms.dfns tbe2
    )
  ;
  *)
  match be1 with
  | `BEXPR_closure (i,ts) ->
    begin match Hashtbl.find syms.dfns i with
    | {symdef=`SYMDEF_fun _} ->
      `BEXPR_apply_prim (i,ts, (be2,lower t2)),rest
    | {symdef=`SYMDEF_function _} ->
      `BEXPR_apply_direct (i,ts, (be2,lower t2)),rest
    | _ -> (* needed temporarily for constructors .. *)
      `BEXPR_apply_direct (i,ts, (be2,lower t2)),rest

    end
  | _ ->
    `BEXPR_apply ((be1,lower t1), (be2,lower t2)),rest

and koenig_lookup syms sra id' name_map fn t2 ts =
  (*
  print_endline ("Applying Koenig lookup for " ^ fn);
  *)
  let entries =  
    try Hashtbl.find name_map fn 
    with Not_found -> 
      clierr sra
      (
        "Koenig lookup: can't find name "^
        fn^ " in " ^ 
        (match id' with 
        | "" -> "top level module"
        | _ -> "module '" ^ id' ^ "'"
        )
      )
  in 
  match entries with
  | FunctionEntry fs ->
    (*
    print_endline ("Got candidates: " ^ string_of_entry_set entries);
    *)
    begin match resolve_overload syms sra fs fn t2 ts with
    | Some (index'',t,mgu,ts) ->
      (* print_endline "Overload resolution OK"; *)
      `BEXPR_closure (index'',ts),
       typeofindex_with_ts syms index'' ts


    | None ->
        (*
        let n = ref 0 
        in Hashtbl.iter (fun _ _ -> incr n) name_map; 
        print_endline ("module defines " ^ string_of_int !n^ " entries");
        *)
        clierr sra
        (
          "[flx_ebind] Koenig lookup: Can't find match for " ^ fn ^
          "\ncandidates are: " ^ full_string_of_entry_set syms.dfns entries
        )
    end
  | NonFunctionEntry _ -> clierr sra "Koenig lookup expected function"

(* this routine has to return a function or procedure .. *)
and lookup_qn_with_sig
  syms 
  sra srn 
  env idx_fixlist 
  (qn:qualified_name_t)
  (sign:btypecode_t)
=
lookup_qn_with_sig'
  syms 
  sra srn 
  env idx_fixlist [] 0 
  qn
  sign

and lookup_qn_with_sig'
  syms 
  sra srn 
  env idx_fixlist expr_fixlist depth 
  (qn:qualified_name_t)
  (sign:btypecode_t)
: tbexpr_t =    
  (*
  print_endline ("[lookup_qn_with_sig] " ^ string_of_qualified_name qn);
  print_endline ("sig = " ^ sbt syms.dfns sign);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  let bt sr t = 
    (*
    print_endline "NON PROPAGATING BIND TYPE";
    *)
    bind_type syms env sr t in
  match qn with
  | `AST_the (sr,qn) -> 
    lookup_qn_with_sig' syms sra srn
    env idx_fixlist expr_fixlist depth 
    qn sign

  | `AST_void _ -> clierr sra "qualified-name is void"

  | `AST_case_tag _ -> clierr sra "Can't lookup case tag here"

  (* WEIRD .. this is a qualified name syntactically ..
    but semantically it belongs in bind_expression
    where this code is duplicated ..
  *)
  | `AST_typed_case (sr,v,t) ->
    let t = bt sr t in
    begin match unfold t with
    | `BTYP_sum ls ->
      if v<1 or v> List.length ls
      then clierr sra "Case index out of range of sum"
      else let vt = List.nth ls (v-1) in
      let ct = `BTYP_function (vt,t) in
      `BEXPR_case (v,t), ct

    | _ -> 
      clierr sr 
      (
        "[lookup_qn_with_sig] Type of case must be sum, got " ^
        sbt syms.dfns t
      )
    end

  | `AST_name (sr,name,ts) ->
    let ts = map (bt sr) ts in
    lookup_name_with_sig 
      syms 
      sra srn idx_fixlist expr_fixlist depth 
      env name ts sign

  | `AST_lookup (sr,(qn',name,ts)) -> 
    let n = length ts in
    let ts = map (bt sr) ts in
    let m =  eval_module_expr syms env qn' in
    match m with
      | (Simple_module (impl, ts',htab,dirs)) ->
        let ts' = map (bt sr) ts' in
        (*
        print_endline ("Module " ^ si impl ^ "[" ^ catmap "," (sbt syms.dfns) ts' ^"]");
        *)
        let env' = mk_bare_env syms impl in
        let tables = get_pub_tables syms env' dirs in
        let result = lookup_name_in_table_dirs htab tables sr name in
        begin match result with
        | None -> 
          clierr sr
          (
            "[lookup_qn_with_sig] AST_lookup: Simple_module: Can't find name " ^ name
          )
        | Some entries -> match entries with 
        | NonFunctionEntry (index) ->
          begin match get_data syms.dfns index with 
          {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs;symdef=entry} 
          ->
            begin match entry with
            | `SYMDEF_inherit_fun qn ->
                clierr sr "Chasing functional inherit in lookup_qn_with_sig'";

            | `SYMDEF_inherit qn ->
                clierr sr "Chasing inherit in lookup_qn_with_sig'";

            | `SYMDEF_cstruct _ 
            | `SYMDEF_struct _ ->
              (*
              print_endline ("Struct constructor found, type= " ^ sbt syms.dfns t);
              *)
              let ts = adjust_ts syms index ts in
              let t = typeofindex_with_ts syms index ts in
              begin match t with
              | `BTYP_function (a,_) ->
                if a <> sign then
                  clierr sr
                  (
                    "[lookup_qn_with_sig] Struct constructor for "^id^" has wrong signature, got:\n" ^
                    sbt syms.dfns t ^
                    "\nexpected:\n" ^
                    sbt syms.dfns sign
                  )
              | _ -> assert false
              end
              ;
              let ts'' = ts' @ ts in
              let ts'' = adjust_ts syms index ts'' in
              `BEXPR_closure (index,ts''),
              t

            | `SYMDEF_const (t,_,_) 
            | `SYMDEF_val t 
            | `SYMDEF_var t 
            | `SYMDEF_parameter t
              ->
              let ts = adjust_ts syms index ts in
              let t = bt sr t in
              let t = tsubst vs ts t in
              begin match t with
              | `BTYP_function (a,b) ->
                if a <> sign then 
                clierr srn
                (
                  "[lookup_qn_with_sig] Expected variable "^id ^
                  "<" ^ si index ^ "> to have function type with signature " ^
                  sbt syms.dfns sign ^
                  ", got function type:\n" ^
                  sbt syms.dfns t
                )
                else
                  `BEXPR_name (index, ts),
                  t

              | `BTYP_inst (i,[]) ->
                begin match get_data syms.dfns i with
                { id=id'}->
                begin match sign with
                | `BTYP_inst (j,[]) ->
                  begin match get_data syms.dfns j with 
                  { id=id''} ->
                  begin match id',id'' with
                  | "string","string" 
                  | "ustring","ustring" 
                  | "string","int"
                  | "ustring","int" -> 
                    `BEXPR_name (index, ts),
                     t

                  | _ ->
                    clierr srn
                    (
                      "[lookup_qn_with_sig] expected variable " ^ 
                      id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
                      sbt syms.dfns t
                    )
                  end
                  end
                | _ ->
                  clierr srn
                  (
                    "[lookup_qn_with_sig] expected variable " ^ 
                    id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
                    sbt syms.dfns t
                  )
                end
                end
              | _ ->
                clierr srn
                (
                  "[lookup_qn_with_sig] expected variable " ^ 
                  id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
                  sbt syms.dfns t
                  
                )
              end
            | _ ->
              clierr sr
              (
                "[lookup_qn_with_sig] Named Non function entry "^id^
                "must befunction type requires struct," ^
                "or value or variable of function type"
              )
            end
          end

        | FunctionEntry fs ->
          match
            resolve_overload
            syms sra fs name sign ts
          with
          | Some (index,t,mgu,ts) ->
            (*
            print_endline ("Resolved overload for " ^ name);
            print_endline ("ts = [" ^ catmap ", " (sbt syms.dfns) ts ^ "]");
            *)
            let ts = adjust_ts syms index (ts' @ ts) in
            `BEXPR_closure (index,ts),
             typeofindex_with_ts syms index ts

          | None -> 
            clierr sra
            (
              "[lookup_qn_with_sig] (Simple module) Unable to resolve overload of " ^ 
              string_of_qualified_name qn ^
              " of (" ^ sbt syms.dfns sign ^")\n" ^
              "candidates are: " ^ full_string_of_entry_set syms.dfns entries
            )
        end

and lookup_name_with_sig 
  syms 
  sra srn 
  idx_fixlist expr_fixlist depth env 
  (name : string)
  (ts : btypecode_t list)
  (t2:btypecode_t) 
: tbexpr_t =
  (*
  print_endline ("[lookup_name_with_sig] " ^ name ^ " of " ^ sbt syms.dfns t2);
  *)
  match env with
  | [] -> 
    clierr srn
    (
      "[lookup_name_with_sig] Can't find " ^ name ^ 
      " of " ^ sbt syms.dfns t2
    )
  | (_,_,table,dirs)::tail ->
    match 
      lookup_name_in_table_dirs_with_sig 
      (table, dirs) 
      syms env 
      idx_fixlist expr_fixlist depth 
      sra srn name ts t2 
    with
    | Some result -> (result:>tbexpr_t)
    | None -> 
      let tbx= 
        lookup_name_with_sig 
          syms 
          sra srn 
          idx_fixlist expr_fixlist depth 
          tail name ts t2
       in (tbx:>tbexpr_t)
        
and handle_function 
  syms 
  env idx_fixlist expr_fixlist depth 
  sra srn 
  name 
  ts
  index 
: tbexpr_t 
=
  match get_data syms.dfns index with 
  {
    id=id;sr=sr;vs=vs;parent=parent;
    privmap=tabl;dirs=dirs;
    symdef=entry
  }
  -> match entry with
  | `SYMDEF_match_check _
  | `SYMDEF_function _
  | `SYMDEF_fun _
  | `SYMDEF_struct _
  | `SYMDEF_cstruct _
    ->
    let ts = adjust_ts syms index ts in
    `BEXPR_closure (index,ts),
    (
      match inner_typeofindex_with_ts syms 
        idx_fixlist expr_fixlist depth 
        index ts 
      with
      | `BTYP_function (s,d) as t -> t
      | t -> 
        ignore begin
          match t with 
          | `BTYP_fix _ -> raise (Free_fixpoint t)
          | _ -> try unfold t with
          | _ -> raise (Free_fixpoint t)
        end
        ;
        clierr sra
        (
          "[handle_function]: closure operator expected '"^name^"' to be function definition, got '"^
          sbt syms.dfns t
        )
    )
  | _ -> 
    clierr sra
    (
      "[handle_function] Expected function"
    )

and handle_variable syms env index id sr vs ts t t2 = 
  let bt sr t = 
    bind_type syms env sr t 
  in

    (* we have to check the variable is the right type *) 
    let t = bt sr t in
    let t = tsubst vs ts t in
    begin match t with
    | `BTYP_function (d,c) ->
      if d <> t2 then
      clierr sr
      (
        "[lookup_name_in_table_dirs_with_sig] Expected variable "^id ^
        "<" ^ si index ^ "> to have function type with signature " ^
        sbt syms.dfns t2 ^
        ", got function type:\n" ^
        sbt syms.dfns t
      )
      else
        let ts = adjust_ts syms index ts in
        Some
        (
          `BEXPR_name (index, ts),t
          (* should equal t ..
          typeofindex_with_ts syms index ts
          *)
        )

    | `BTYP_inst (i,[]) ->
      begin match get_data syms.dfns i  with
      {id=id'} ->
        begin match t2 with
        | `BTYP_inst (j,[]) ->
          begin match get_data syms.dfns j with
          {id=id''} ->
            begin match id',id'' with
            | "string","string" 
            | "ustring","ustring" 
            | "string","int"
            | "ustring","int" -> 
              Some (`BEXPR_name (index, ts),t)
            | _ ->
              clierr sr
              (
                "[lookup_name_in_table_dirs_with_sig] expected variable " ^ 
                id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
                sbt syms.dfns t
              )
            end
          end
        | _ ->
          clierr sr
          (
            "[lookup_name_in_table_dirs_with_sig] expected variable " ^ 
            id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
            sbt syms.dfns t
          )
        end
      end
    | _ ->
      clierr sr
      (
        "[lookup_name_in_table_dirs_with_sig] expected variable " ^ 
        id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
        sbt syms.dfns t
        
      )
    end

and lookup_name_in_table_dirs_with_sig (table, dirs) 
  syms 
  env idx_fixlist expr_fixlist depth 
  sra srn name ts t2 
: tbexpr_t option
=
  (*
  print_endline 
  (
    "LOOKUP NAME "^name ^"["^
    catmap "," (sbt syms.dfns) ts ^
    "] IN TABLE DIRS WITH SIG " ^ sbt syms.dfns t2
  ); 
  *)
  let result:entry_set_t =
    match lookup_name_in_htab table name  with
    | Some x -> x
    | None -> FunctionEntry []
  in
  match result with
  | NonFunctionEntry (index) ->
    begin match get_data syms.dfns index with
    {id=id;sr=sr;parent=parent;vs=vs;symdef=entry}->
    begin match entry with
    | `SYMDEF_inherit _ -> 
      clierr sra "Woops found inherit in lookup_name_in_table_dirs_with_sig"
    | `SYMDEF_inherit_fun _ -> 
      clierr sra "Woops found inherit function in lookup_name_in_table_dirs_with_sig"

    | `SYMDEF_cstruct _
    | `SYMDEF_struct _
      ->
        (*
        print_endline "lookup_name_in_table_dirs_with_sig finds struct constructor";
        *)
        let ro = 
          resolve_overload 
          syms sra [index] name t2 ts
        in
          begin match ro with 
          | Some (index,t,mgu,ts) ->
            let tb : tbexpr_t =
              handle_function 
              syms 
              env idx_fixlist expr_fixlist depth 
              sra srn name ts index
            in 
              Some tb 
          | None -> None
          end

    | `SYMDEF_const (t,_,_)
    | `SYMDEF_var t
    | `SYMDEF_val t 
    | `SYMDEF_parameter t
      -> handle_variable syms env index id srn vs ts t t2
    | _ 
      -> 
        clierr sra 
        (
          "Expected " ^id^
          " to be struct or variable of function type, got " ^ 
          string_of_symdef entry id vs
        )
    end
    end

  | FunctionEntry fs ->
    let ro = 
      resolve_overload 
      syms sra fs name t2 ts
    in
    (*
    print_endline "Resolved overload ..";
    *)
    match ro with 
      | Some (index,t,mgu,ts) ->
        (*
        print_endline "got result ..";
        *)
        let ((_,tt) as tb) =
          handle_function 
          syms 
          env idx_fixlist expr_fixlist depth 
          sra srn name ts index
        in 
          (*
          print_endline ("SUCCESS: overload chooses " ^ full_string_of_entry_kind syms.dfns index);
          print_endline ("Value of ts is " ^ catmap "," (sbt syms.dfns) ts);
          print_endline ("Instantiated closure value is " ^ sbe syms.dfns tb);
          print_endline ("type is " ^ sbt syms.dfns tt);
          *)
          Some tb 

      | None ->
        (*
        print_endline "NOT FOUND, trying opens";
        *)
        let opens : entry_set_t list = 
          List.concat
          (
            List.map
            (fun table -> 
              match lookup_name_in_htab table name with
              | Some x -> [x]
              | None -> []
            )
            dirs
          )
        in
          (*
          print_endline (si (length opens) ^ " OPENS BUILT");
          *)
          let fs:entry_kind_t list = merge_functions opens name in
          let ro = 
            resolve_overload
            syms sra fs name t2 ts
          in
          (*
          print_endline "OVERLOAD RESOLVED .. ";
          *)
          match ro with
          | Some (result,t,mgu,ts) ->
            let tb : tbexpr_t = 
              handle_function 
              syms 
              env idx_fixlist expr_fixlist depth 
              sra srn name ts result
            in 
              Some tb
          | None -> 
            (*
            print_endline "FAILURE"; flush stdout; 
            *)
            None

and bind_regdef syms env idx_fixlist regexp_exclude e =
  let bd e = bind_regdef syms env idx_fixlist regexp_exclude e in
  match e with
  | REGEXP_seq (e1,e2) -> REGEXP_seq (bd e1, bd e2)
  | REGEXP_alt (e1,e2) -> REGEXP_alt (bd e1, bd e2)
  | REGEXP_aster e -> REGEXP_aster (bd e)
  | REGEXP_name qn ->
    begin match lookup_qn_in_env syms env qn with
    | i,_ ->
      if List.mem i regexp_exclude
      then 
        let sr = src_of_expr (qn:>expr_t) in
        clierr sr
        (
          "[bind_regdef] Regdef " ^ string_of_qualified_name qn ^
          " depends on itself"
        )
      else
        begin
          match get_data syms.dfns i with
          {symdef=entry} ->
          match entry with
          | `SYMDEF_regdef e ->
            bind_regdef syms env idx_fixlist (i::regexp_exclude) e
          | _ -> 
            let sr = src_of_expr (qn:>expr_t) in
            clierr sr
            (
              "[bind_regdef] Expected " ^ string_of_qualified_name qn ^
              " to be regdef"
            ) 
        end
    end 

  | x -> x

and handle_map sr (f,ft) (a,at) =
    let t =
      match ft with
      | `BTYP_function (d,c) ->
        begin match at with
        | `BTYP_inst (i,[t]) ->
          if t <> d 
          then clierr sr 
            ("map type of data structure index " ^ 
            "must agree with function domain")
          else
            `BTYP_inst (i,[c])
        | _ -> clierr sr "map requires instance"
        end
      | _ -> clierr sr "map non-function"
    in
      (* actually this part is easy, it's just
      applies ((map[i] f) a) where map[i] denotes
      the map function generated for data structure i
      *)
      failwith "MAP NOT IMPLEMENTED"
 
and bind_expression' syms env idx_fixlist expr_fixlist depth e 
: tbexpr_t = 
  (*
  print_endline ("[bind_expression'] " ^ string_of_expr e);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  if List.mem_assq e expr_fixlist
  then raise (Expr_recursion e)
  ;
  let be e' = bind_expression' syms env idx_fixlist ((e,depth)::expr_fixlist) (depth+1) e' in
  let bt sr t = 
    (* we're really wanting to call bind type and propagate depth ? *)
    let t = bind_type' syms env 
      idx_fixlist [] [] ((e,depth)::expr_fixlist) (depth+1) 
      sr t [] 
    in
    let t = beta_reduce syms [] t in
    t
  in
  let ti i ts = 
    inner_typeofindex_with_ts syms 
    idx_fixlist ((e,depth)::expr_fixlist) (depth+1) i ts 
         (* CHANGED THIS ------------------*******)
  in

  let lookup sr f (sign:btypecode_t) =
    match f with
      
    | #qualified_name_t as name -> 
      let srn = src_of_expr name in
      lookup_qn_with_sig'
        syms 
        sr srn env 
        idx_fixlist ((e,depth)::expr_fixlist) depth 
        name sign

    | e -> be e
  in

  (* model infix operator as function call *)
  let apl2 (sri:range_srcref) (fn : string) (tup:expr_t list) = 
    let sr = rslist tup in
    `AST_apply 
    (
      sr, 
      (
        `AST_name (sri,fn,[]), 
        `AST_tuple (sr,tup)
      )
    )
  in
  (*
  print_endline ("Binding expression " ^ string_of_expr e ^ " depth=" ^ string_of_int depth);
  print_endline ("environment is:");
  print_env env;
  print_endline "==";
  *)
  let sr = src_of_expr e in
  match e with
  | `AST_type_match _ 
  | `AST_noexpand _
  | `AST_letin _ 
  | `AST_cond _ 
  | `AST_typeof _
  | `AST_as _
  | `AST_void _
  | `AST_arrow _ 
  | `AST_superscript _ 
  | `AST_ellipsis _ 
    -> 
      clierr sr 
     "[bind_expression] Unexpected in expression" 

  | `AST_expr (sr,s,t) -> 
    let t = bt sr t in 
    `BEXPR_expr (s,t),t

  | `AST_sum (sri,ls) -> 
    begin let mksum a b = apl2 sri "add" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mksum h t)
    | [] -> clierr sri "Not expecting empty product (unit)"
    end
    
  | `AST_product (sri,ls) ->
    begin let mkprod a b = apl2 sri "mul" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mkprod h t)
    | [] -> clierr sri "Not expecting empty sum (void)"
    end

  | `AST_coercion (sr,(m,t)) -> 
    let m' = be m in
    let t' = bt sr t in
    `BEXPR_coercion (m',t'),t'

  | `AST_get_n (sr,(n,e')) -> 
    let expr,typ = be e' in
    let ctyp = match unfold typ with 
    | `BTYP_tuple ts -> 
      let len = List.length ts in
      if n<0 or n>len-1
      then clierr sr
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1)
        )
      else List.nth ts n
    | _ -> 
      clierr sr 
      (
        "[bind_expression] Expected tuple " ^ 
        string_of_expr e' ^ 
        " to have tuple type, got " ^ 
        sbt syms.dfns typ
      )
    in 
      `BEXPR_get_n (n, (expr,typ)), ctyp

  | `AST_case_tag (sr,v) ->
     clierr sr "plain case tag not allowed in expression (only in pattern)"

  | `AST_typed_case (sr,v,t) ->
    let t = bt sr t in
    ignore (try unfold t with _ -> failwith "AST_typed_case unfold screwd");
    begin match unfold t with
    | `BTYP_sum ls ->
      if v<1 or v> List.length ls
      then clierr sr "Case index out of range of sum"
      else let vt = List.nth ls (v-1) in
      let ct = 
        match vt with
        | `BTYP_tuple [] -> t        (* const ctor *)
        | _ -> `BTYP_function (vt,t) (* non-const ctor *)
      in
      `BEXPR_case (v,t), ct
    | _ ->
      clierr sr 
      (
        "[bind_expression] Type of case must be sum, got " ^
        sbt syms.dfns t
      )
    end

  | `AST_name (sr,name,ts) ->
    (*
    print_endline ("AST_name " ^ name ^ "[" ^ catmap "," string_of_typecode ts^ "]");
    *)
    let ts = map (bt sr) ts in
    begin match lookup_name_in_env syms env sr name with
    | NonFunctionEntry (index) -> 
      (*
      print_endline ("[bind_expression] FOUND INDEX " ^ si index);
      *)
      let n = length ts in
      let ts = adjust_ts syms index ts in
      `BEXPR_name (index,ts),
      let t = ti index ts in
      (*
      print_endline ("typ " ^name^ "=" ^ sbt syms.dfns t);
      *)
      t

    | FunctionEntry fs -> 
      clierr sr
      (
        "[bind_expression] Simple name " ^ name ^ 
        " binds to function set in\n" ^
        short_string_of_src sr
      )
    end

  | `AST_the(_,`AST_name (sr,name,ts)) ->
    (*
    print_endline ("AST_name " ^ name ^ "[" ^ catmap "," string_of_typecode ts^ "]");
    *)
    let ts = map (bt sr) ts in
    begin match lookup_name_in_env syms env sr name with
    | NonFunctionEntry (index) -> 
      let n = length ts in
      let ts = adjust_ts syms index ts in
      `BEXPR_name (index,ts),
      let t = ti index ts in
      t

    | FunctionEntry [index] -> 
      let n = length ts in
      let ts = adjust_ts syms index ts in
      `BEXPR_closure (index,ts),
      let t = ti index ts in
      t


    | FunctionEntry _ -> 
      clierr sr
      (
        "[bind_expression] Simple 'the' name " ^ name ^ 
        " binds to non-singleton function set"
      )
    end
  | `AST_the (sr,q) -> clierr sr "invalid use of 'the' "

  | (`AST_lookup (sr,(e,name,ts))) as qn ->
    let ts = map (bt sr) ts in
    let entry = 
      match 
          eval_module_expr 
          syms 
          env 
          e 
      with 
      | (Simple_module (impl, ts, htab,dirs)) ->
        let env' = mk_bare_env syms impl in
        let tables = get_pub_tables syms env' dirs in
        let result = lookup_name_in_table_dirs htab tables sr name in
        result

    in 
      begin match entry with
      | Some entry -> 
        begin match entry with
        | NonFunctionEntry (i) ->  
          begin match Hashtbl.find syms.dfns i with
          | {sr=srn; symdef=`SYMDEF_inherit qn} -> be (qn :> expr_t)
          | _ ->
            let ts = adjust_ts syms i ts in
            `BEXPR_name (i,ts), 
            ti i ts
          end

        | FunctionEntry fs ->
          clierr sr 
          (
            "[bind_expression] Qualified name " ^ 
            string_of_qualified_name qn ^ 
            " binds to function set"
          )
        end

      | None ->
        clierr sr
        (
          "Can't find " ^ name
        )
      end

  | `AST_suffix (sr,(f,suf)) ->
    let sign = bt sr suf in
    lookup sr (f:>expr_t) sign

  | `AST_ref (_,(`AST_deref (sr,e))) -> be e

  | `AST_lvalue (srr,e) ->
    let (e',t') as et' = be e in 
    begin match e' with
    | `BEXPR_name (index,ts) ->
      begin match get_data syms.dfns index with
      {id=id; sr=sr; symdef=entry} ->
      begin match entry with
      | `SYMDEF_inherit _ -> clierr srr "Woops, bindexpr yielded inherit"
      | `SYMDEF_inherit_fun _ -> clierr srr "Woops, bindexpr yielded inherit fun"
      | `SYMDEF_var _ -> et'

      | `SYMDEF_parameter _ -> 
         clierr2 srr sr
        (
          "[bind_expression] " ^
          "Use parameter " ^ id ^ " as lvalue " 
        )
      | `SYMDEF_const _
      | `SYMDEF_val _ ->
        clierr2 srr sr
        (
          "[bind_expression] " ^
          "Use value or const " ^ id ^ " as lvalue " 
        )
      | _ -> 
         clierr2 srr sr
        (
          "[bind_expression] " ^
          "Use non variable " ^ id ^ " as lvalue "
        )
      end
      end

    | `BEXPR_apply_prim (i,_,_) ->
      begin match get_data syms.dfns i with
      {id=id; sr=sr; symdef=entry} ->
      print_endline 
      (
        "WARNING: application of primitive '"^id^"' should be an lvalue"
      )
      end
      ;
      et'

    | _ ->
       clierr srr 
        (
          "[bind_expression:lvalue] " ^
          "Address non variable"
        )
    end

 
  | `AST_ref (sr,(`AST_dot (_,(e,id)))) ->
    let ref_name = "ref_" ^ id in
    be 
    (
      `AST_apply 
      (
        sr,
        (
          `AST_name (sr, ref_name,[]),
          `AST_ref (sr,e)
        )
      )
    )

  | `AST_ref (srr,e) -> 
    let e',t' = be e in 
    begin match e' with
    | `BEXPR_name (index,ts) ->
      begin match get_data syms.dfns index with
      {id=id; sr=sr; symdef=entry} ->
      begin match entry with
      | `SYMDEF_inherit _ -> clierr srr "Woops, bindexpr yielded inherit"
      | `SYMDEF_inherit_fun _ -> clierr srr "Woops, bindexpr yielded inherit fun"
      | `SYMDEF_var _ ->
        let vtype = 
          inner_typeofindex_with_ts syms 
          idx_fixlist ((e,depth)::expr_fixlist) 
          (depth+1) 
         index ts
        in
          `BEXPR_ref (index,ts), `BTYP_pointer vtype

      | `SYMDEF_parameter _ -> 
         clierr2 srr sr
        (
          "[bind_expression] " ^
          "Address value parameter " ^ id 
        )
      | `SYMDEF_const _
      | `SYMDEF_val _ ->
        clierr2 srr sr
        (
          "[bind_expression] " ^
          "Can't address a value or const " ^ id
        )
      | _ -> 
         clierr2 srr sr
        (
          "[bind_expression] " ^
          "Address non variable " ^ id 
        )
      end
      end
    | _ ->
       clierr srr 
        (
          "[bind_expression] " ^
          "Address non variable"
        )
    end

  | `AST_deref (_,`AST_ref (sr,e)) -> be e

  | `AST_deref (sr,e) -> 
    let e,t = be e in
    begin match unfold t with 
    | `BTYP_pointer t' -> `BEXPR_deref (e,t),t'
    | _ -> clierr sr "Dereference non pointer"
    end

  | `AST_literal (sr,v) -> 
    let t = typeof_literal syms env sr v in
    `BEXPR_literal v, t

  | `AST_method_apply (sra,(fn,e2)) -> 
    let be2,t2 = be e2 in
    let tbe1 = 
      match t2 with
      | `BTYP_inst (index,ts) ->
        begin match get_data syms.dfns index with
        {id=id; parent=parent;sr=sr;symdef=entry} ->
        match parent with
        | None -> clierr sra "Koenig lookup: No parent for method apply (can't handle global yet)"
        | Some index' ->
          match get_data syms.dfns index' with
          {id=id';sr=sr';parent=parent';vs=vs';pubmap=name_map;dirs=dirs;symdef=entry'}
          ->
          match entry' with
          | `SYMDEF_module ->
            koenig_lookup syms sra id' name_map fn t2 ts

          | _ -> clierr sra ("Koenig lookup: parent for method apply not module")
        end
      | _ -> clierr sra "apply method to nongenerative type"
    in
      cal_apply syms sra tbe1 (be2, t2)

  | `AST_map (sr,f,a) ->
    handle_map sr (be f) (be a)
  
  | `AST_apply (sr,(f',a')) ->
    let (ba, ta) as a = be a' in
    (*
    print_endline ("bind apply: "^string_of_expr f'^" sig=" ^ sbt syms.dfns ta);
    *)
    let _ = 
      try unfold ta
      with _ -> print_endline " .. free fixpoint"; raise (Free_fixpoint ta) 
    in
    let f = lookup sr f' ta in
    begin 
      match f,a with
      | (_,`BTYP_inst (i1,[])),(_,`BTYP_inst (i2,[])) ->
        begin
          match get_data syms.dfns i1 with {id=id1; symdef=entry1} ->
          match get_data syms.dfns i2 with {id=id2; symdef=entry2} ->
          let apl name =
            be 
            (
              `AST_apply 
              (
                sr,
                (
                  `AST_name (sr,name,[]),
                  `AST_tuple (sr,[f';a'])
                )
              )
            )
          in
            match id1,id2 with
            | "string","string" -> apl "add"
            | "ustring","ustring" -> apl "add"
            | "string","int" -> apl "add"
            | "ustring","int" -> apl "add"
            | _ -> cal_apply syms sr f a
        end
      | _ -> cal_apply syms sr f a
    end

  | `AST_tuple (_,es) -> 
    let bets = List.map be es in
    let _, bts = List.split bets in
    let t = `BTYP_tuple bts in
    `BEXPR_tuple bets, t

  | `AST_dot (sr,(e,id)) ->
    let get_name = "get_" ^ id in
    be (`AST_method_apply (sr,(get_name,e)))

  | `AST_match_case (sr,(v,e)) ->
     `BEXPR_match_case (v,be e),flx_bbool

  | `AST_match_ctor (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name,ts) -> 
      let fname = `AST_name (sr,"_match_ctor_" ^ name,ts) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(context,name,ts)) ->
      let fname = `AST_lookup (sr,(context,"_match_ctor_" ^ name,ts)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
       be (`AST_match_case (sr,(v,e)))

    | _ -> clierr sr "Expected variant constructor name in union decoder"
    end
    
  | `AST_case_arg (sr,(v,e)) ->
     let (_,t) as e' = be e in
    ignore (try unfold t with _ -> failwith "AST_case_arg unfold screwd");
     begin match unfold t with
     | `BTYP_sum ls ->
       let n = List.length ls in
       if v<1 or v>n 
       then clierr sr "Invalid sum index"
       else let t = List.nth ls (v-1) in
       `BEXPR_case_arg (v, e'),t
     | _ -> clierr sr "Expected sum type"
     end 

  | `AST_ctor_arg (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name,ts) -> 
      let fname = `AST_name (sr,"_ctor_arg_" ^ name,ts) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(e,name,ts)) ->
      let fname = `AST_lookup (sr,(e,"_ctor_arg_" ^ name,ts)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
      be (`AST_case_arg (sr,(v,e)))

    | _ -> clierr sr "Expected variant constructor name in union dtor"
    end

  | `AST_regmatch (sr,(e,cls)) ->
    syserr sr
    (
      "[bind_expression] "  ^
      "Unexpected regmatch when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_reglex (sr,(p1,p2,cls)) ->
    syserr sr
    (
      "[bind_expression] " ^
      "Unexpected reglex when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_lambda (sr,_) -> 
    syserr sr
    (
      "[bind_expression] " ^
      "Unexpected lambda when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_match (sr,_) -> 
    clierr sr
    (
      "[bind_expression] " ^
      "Unexpected match when binding expression (should have been lifted out)"
    )

and resolve_overload
  syms
  sr
  (fs : entry_kind_t list)
  (name: string)
  (suf : btypecode_t)
  (ts:btypecode_t list)
: (entry_kind_t * btypecode_t * (int * btypecode_t) list * btypecode_t list) option =

  let bt sr i t =
    let env = build_env syms (Some i) in
    bind_type syms env sr t
  in
    let fs = trclose syms sr fs in
    overload syms bt sr fs name suf ts

(* an environment is a list of hastables, mapping
   names to definition indicies. Each entity defining
   a scope contains one hashtable, and a pointer to
   its parent, if any. The name 'root' is special,
   it is the name of the single top level module
   created by the desugaring phase. We have to be
   able to find this name, so if when we run out
   of parents, which is when we hit the top module,
   we create a parent name map with a single entry
   'top'->NonFunctionEntry 0. 
*)

and split_dirs dirs :
    qualified_name_t list *
    qualified_name_t list *
    (string * qualified_name_t) list
=
  let opens = 
     List.concat
     (
       List.map
       (fun x -> match x with 
         | DIR_open qn -> [qn]
         | DIR_inject_module qn -> []
         | DIR_use (n,qn) -> []
       )
       dirs
     )
  and includes = 
     List.concat
     (
       List.map
       (fun x -> match x with 
         | DIR_open qn -> []
         | DIR_inject_module qn -> [qn]
         | DIR_use (n,qn) -> []
       )
       dirs
     )
  and uses = 
     List.concat
     (
       List.map
       (fun x -> match x with 
         | DIR_open qn -> []
         | DIR_inject_module qn -> []
         | DIR_use (n,qn) -> [n,qn]
       )
       dirs
     )
  in opens, includes, uses

and  get_includes' syms includes index =
  if not (mem index !includes) then
  begin
    includes := index :: !includes;
    let env = mk_bare_env syms index in
    match Hashtbl.find syms.dfns index with
    {id=id;sr=sr;parent=parent;vs=vs;pubmap=table;dirs=dirs} ->
    List.iter
    (fun x -> match x with 
      | DIR_open _
      | DIR_use _ -> ()
      | DIR_inject_module qn -> 
        let i,ts =
          try lookup_qn_in_env syms env qn 
          with Not_found -> failwith "QN NOT FOUND"
        in 
          get_includes' syms includes i
    )
    dirs
  end

and bind_dir 
  syms 
  (env:env_t)
  qn 
: int =
  let sr = ("dummy",0,0,0,0) in
  let result = 
    try lookup_qn_in_env syms env qn 
    with Not_found -> failwith "QN NOT FOUND"
  in
  match result with
  | i,ts -> i

and pub_table_dir 
  syms 
  i 
: name_map_t =
  match get_data syms.dfns i with
  | {sr=sr; pubmap=table;symdef=`SYMDEF_module} -> table
  | {sr=sr} -> clierr sr "[map_dir] Expected module"


and get_pub_tables syms env dirs =
  let _,includes,_ = split_dirs dirs in
  let opens = uniq_list (map (bind_dir syms env) includes) in
  let includes = ref [] in
  iter (get_includes' syms includes) opens;
  let includes = uniq_list !includes in
  let tables = map (pub_table_dir syms) includes in
  tables

and mk_bare_env syms index = 
  match Hashtbl.find syms.dfns index with
  {id=id;parent=parent;privmap=table} -> (index,id,table,[]) :: 
  match parent with 
  | None -> [] 
  | Some index -> mk_bare_env syms index

and merge_opens syms env (opens,includes,uses) =
  let use_map = Hashtbl.create 97 in
  List.iter
  (fun (n,qn) ->
    let entry,_ = lookup_qn_in_env2 syms env qn in
    match entry with
    
    | NonFunctionEntry _ ->
      if Hashtbl.mem use_map n
      then failwith "Duplicate non function used"
      else Hashtbl.add use_map n entry

    | FunctionEntry ls ->
      let entry2 = 
        try Hashtbl.find use_map  n 
        with Not_found -> FunctionEntry []
      in
      match entry2 with
      | NonFunctionEntry _ ->
        failwith "Use function and non-function kinds"
      | FunctionEntry ls2 ->
        Hashtbl.replace use_map n (FunctionEntry (ls @ ls2))
  )
  uses 
  ;
  let opens = uniq_list (map (bind_dir syms env) opens) in
  let opens = uniq_cat opens (map (bind_dir syms env) includes) in

  let includes = ref [] in
  iter (get_includes' syms includes) opens;
  let includes = uniq_list !includes in
  let tables = map (pub_table_dir syms) includes in
  use_map::tables 

and build_env'' syms index : env_t =
  match Hashtbl.find syms.dfns index with
  {id=id; parent=parent;privmap=table;dirs=dirs} ->
  let opens,includes,uses = split_dirs dirs in
  let env = build_env syms parent in
  let env' = (index,id,table,[])::env in
  let second = merge_opens syms env' (opens,includes,uses) in
  (index,id,table,second)::env
  
and build_env syms parent : env_t =
  match parent with
  | None -> []
  | Some i ->
    try 
      Hashtbl.find syms.env_cache i
    with 
      Not_found ->
       let env = build_env'' syms i in
       Hashtbl.add syms.env_cache i env;
       env

(*===========================================================*)
(* MODULE STUFF *)
(*===========================================================*)

(* This routine takes a bound type, and produces a unique form
   of the bound type, by again factoring out type aliases.
   The type aliases can get reintroduced by map_type,
   if an abstract type is mapped to a typedef, so we have
   to factor them out again .. YUK!!
*)
   
and rebind_btype syms env sr ts t: btypecode_t =
  let rbt t = rebind_btype syms env sr ts t in
  match t with
  | `BTYP_inst (i,_) ->
    begin match get_data syms.dfns i with
    | {symdef=`SYMDEF_type_alias t'} ->
      bind_type syms env sr t'
    | _ -> t
    end
  | `BTYP_tuple ts -> `BTYP_tuple (List.map rbt ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map rbt ts)
  | `BTYP_function (a,r) -> `BTYP_function (rbt a, rbt r) 
  | `BTYP_pointer t -> `BTYP_pointer (rbt t)
  | `BTYP_array (t1,t2) -> `BTYP_array (rbt t1, rbt t2)
  | `BTYP_void -> `BTYP_void
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> clierr sr ("[rebind_type] Unexpected type variable " ^ sbt syms.dfns t)
  | _ -> clierr sr ("[rebind_type] Unexpected " ^ sbt syms.dfns t)


and check_module syms name sr entries ts =
    begin match entries with
    | NonFunctionEntry (index) ->
      begin match get_data syms.dfns index with
      | {dirs=dirs;pubmap=table;symdef=`SYMDEF_module} -> 
        Simple_module (index,ts,table,dirs)
      | {id=id;sr=sr'} -> 
        clierr sr
        (
          "Expected '" ^ id ^ "' to be module in: " ^
          short_string_of_src sr ^ ", found: " ^
          short_string_of_src sr'
        )
      end
    | _ -> 
      failwith
      (
        "Expected non function entry for " ^ name
      )
    end

(* the top level table only has a single entry,
  the root module, which is the whole file

  returns the root name, table index, and environment
*)

and eval_module_expr syms env e : module_rep_t = 
  match e with
  | `AST_name (sr,name,ts) ->
    let entries = lookup_name_in_env syms env sr name in
    check_module syms name sr entries ts

  | `AST_lookup (sr,(e,name,ts)) ->
    let result = eval_module_expr syms env e in
    begin match result with
      | Simple_module (index,ts',htab,dirs) ->
      let env' = mk_bare_env syms index in
      let tables = get_pub_tables syms env' dirs in
      let result = lookup_name_in_table_dirs htab tables sr name in
        begin match result with
        | Some x -> 
          check_module syms name sr x (ts' @ ts)

        | None -> clierr sr 
          (
            "Can't find " ^ name ^ " in module"
          )
        end

    end 

  | _ ->
    let sr = src_of_expr e in
    clierr sr
    (
      "Invalid module expression " ^ 
      string_of_expr e
    )


