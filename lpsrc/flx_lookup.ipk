@head(1,"Name Lookup")
@h = tangler("src/flx_lookup.mli")
@select(h)
open Flx_types

val build_env:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  int list -> (* excluded modules *)
  int option -> (* parent *)
  env_t

val lookup_name_in_env :
  env_t ->
  range_srcref ->
  id_t -> 
  entry_set_t

val lookup_qn_in_env :
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded modules *)
  qualified_name_t -> 
  entry_kind_t

val lookup_sn_in_env :
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded modules *)
  suffixed_name_t -> 
  int

val bind_type:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded modules *)
  range_srcref ->
  typecode_t ->
  btypecode_t

val eval_module_expr:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded modules *)
  expr_t ->
  module_rep_t

val resolve_overload:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  int list -> (* excluded modules *)
  range_srcref ->
  entry_kind_t list ->  
  id_t -> 
  btypecode_t ->
  entry_kind_t option

val bind_expression :
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded types *)
  int list -> (* excluded modules *)
  expr_t ->
  tbexpr_t

val typeofindex :
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  int list -> (* excluded types *)
  int list -> (* excluded modules *)
  int ->
  btypecode_t

val typeof_literal:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  range_srcref ->
  literal_t ->
  btypecode_t

val lookup_qn_with_sig:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  range_srcref ->
  range_srcref ->
  env_t ->
  int list ->
  int list ->
  qualified_name_t ->
  btypecode_t ->
  tbexpr_t

val print_env: (* debugging *)
  env_t -> unit

@h = tangler("src/flx_lookup.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List
open Flx_srcref

let bool_t = `BTYP_sum [`BTYP_tuple[]; `BTYP_tuple[]];

exception Found of int

type result = 
  | Unique of int * btypecode_t
  | Pair of (int * btypecode_t) * int

type kind_t = Parameter | Other

 
let print_env e = 
  let print_entry k v = 
    print_endline 
    (
      "  " ^ k ^ 
      (
        match v with 
        | (NonFunctionEntry (Simple i)) -> " Simple " ^ string_of_int i
        | _ -> ""
      )
    )
  in 
  let print_table htab = 
    print_endline "--"; Hashtbl.iter print_entry htab

  in 
  let print_level (htab,htabs) = print_table htab in 

  List.iter print_level e

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_lookup.get_data] No definition of <" ^ string_of_int index ^ ">")

let lookup_name_in_htab htab name : entry_set_t option =
  (* print_endline ("Lookup name in htab: " ^ name); *)
  try Some (Hashtbl.find htab name)
  with Not_found -> None
  
let merge_functions 
  (opens:entry_set_t list) 
  name 
: entry_kind_t list = 
  List.fold_left
    (fun init x -> match x with
    | FunctionEntry ls -> init @ ls
    | _ -> failwith ("Expected " ^ name ^ " to be function overload set in all open modules")
    )
  []
  opens

let lookup_name_in_table_dirs table dirs sr name : entry_set_t option =
  (* print_endline ("Lookup name " ^ name ^ " in table dirs");*)
  flush stdout;
  match lookup_name_in_htab table name with
  | Some x as y -> 
    (* print_endline "Found in table"; flush stdout; *)
    y
  | None ->
    (* print_endline "Not found: calculating opens";*)
    flush stdout;
  let opens = 
    List.concat
    (
      List.map
      (fun table -> 
        match lookup_name_in_htab table name with
        | Some x -> [x]
        | None -> [] 
      )
      dirs
    )
  in match opens with
  | [x] -> Some x
  | FunctionEntry ls :: rest ->
    Some (FunctionEntry (merge_functions opens name))

  | (NonFunctionEntry _)::_ -> 
    (* FIX: it might not be so! Could be two typedefs
      of the same thing, later, when I implement it,
      injected names
    *)
    failwith ("Conflicting values for "^name ^" found in open modules")
  | [] -> None

let lookup_name_in_env env sr name : entry_set_t =
  (* print_endline "Lookup name in env"; *)
  let rec aux env = 
    match env with 
    | [] -> None
    | (table,dirs) :: tail ->
      match lookup_name_in_table_dirs table dirs sr name with
      | Some x as y -> y
      | None -> aux tail
  in 
    match aux env with
    | Some x -> 
      (* print_endline ("Found name "^name^" in env"); flush stdout; *) 
      x
    | None ->
      failwith 
      (
        "[lookup_name_in_env]: Name '" ^ 
        name ^ 
        "' not found in environment (depth "^
        string_of_int (List.length env)^ "\n" ^
        "): " ^
        short_string_of_src sr 
      )

let lookup_in_bound_module 
  dfns iface binding sr 
  (t:string) 
: entry_set_t option  =
  match Hashtbl.find dfns iface with
  | (_,_,_,`SYMDEF_interface (table,dirs)) ->
    let src = lookup_name_in_htab table t  in
    begin match src with
    | None -> None
    | Some x -> match x with
    | NonFunctionEntry (Simple ix) ->
      let dst = Hashtbl.find binding ix in
      Some (NonFunctionEntry (Bound (ix,dst)))

    | NonFunctionEntry _ ->
      failwith
      (
        "[lookup_qn_in_bound_module] Expected simple nonfunction entry got binding"
      )
    | FunctionEntry ls ->
      let ns = ref [] in
      List.iter
      (fun ix ->
        match ix with
        | Simple ix ->
          let dst = Hashtbl.find binding ix in
          ns := Bound (ix,dst) :: !ns;
          (* print_endline (string_of_int ix ^ " ==> " ^ string_of_int dst) *)
        | _ -> failwith "Woops, expected Simple"
      )
      ls
      ;
      Some (FunctionEntry !ns)
    end

  | _ -> 
    failwith "Lookup in bound module expected interface"

(* This routine looks up a qualified name in the
   environment. The result is never a function or
   functor decl, although it could be a variable
   of function type.
*)

let rec lookup_qn_in_env 
  dfns 
  counter 
  (freg:instantiation_registry_t) 
  (env:env_t) 
  excluded_dirs
  (qn: qualified_name_t)
  : entry_kind_t 
=
  match qn with
  | `AST_void _ -> failwith "qualified name is void"
  | `AST_root _ -> failwith "Can't lookup root yet"
  | `AST_case_tag _ -> failwith "Can't lookup a case tag"
  | `AST_typed_case _ -> failwith "Can't lookup a case tag"
  | `AST_name (sr,name) ->
    begin match lookup_name_in_env env sr name with
    | NonFunctionEntry x -> x
    | FunctionEntry _ ->
      failwith 
      (
        "Not expecting " ^ name ^
        " to be function set in\n" ^
        short_string_of_src sr
      )
    end

  | `AST_lookup (sr,(me,name)) ->
    match eval_module_expr dfns counter freg env excluded_dirs me with 
    | Module_product _ ->
      failwith "Unexpected module product"

    | Functor_set _ ->
      failwith "Unexpected Functor"

    | Simple_module (impl, htab,dirs) ->
      begin match
        try Hashtbl.find htab name with 
        | Not_found -> 
          failwith
          (
            "Can't find " ^ name ^ " in\n" ^
            short_string_of_src sr
          )
      with
      | NonFunctionEntry x -> x
      | _ -> 
        failwith 
        (
          "Not expecting " ^ string_of_qualified_name qn ^
          " to be function set in\n" ^
          short_string_of_src sr
        )
      end

    | Bound_module (iface,impl,binding) ->
      match lookup_in_bound_module dfns iface binding sr name with
      | None -> 
        failwith 
        (
          "Can't find " ^ 
          string_of_qualified_name qn ^
          " in\n" ^
          short_string_of_src sr
        )
      | Some x -> match x with
        | NonFunctionEntry x -> x
        | FunctionEntry _ ->
          failwith
          (
            "Not expecting " ^ string_of_qualified_name qn ^
            " to be function set in\n" ^
            short_string_of_src sr
          )
and lookup_sn_in_env 
  dfns 
  counter 
  (freg:instantiation_registry_t) 
  (env:env_t) 
  excluded_dirs
  (sn: suffixed_name_t)
  : int 
= 
  match sn with
  | #qualified_name_t as x ->
    begin match
      lookup_qn_in_env dfns counter freg env excluded_dirs x
    with
    | Simple index -> index
    | Bound _ -> failwith "Expecting simple entry"
    end

  | `AST_suffix (sr,(qn,suf)) ->
    let bsuf = bind_type dfns counter freg env excluded_dirs sr suf in
    let be,t = 
      lookup_qn_with_sig
      dfns counter freg 
      sr sr 
      env [] excluded_dirs 
      qn bsuf
    in match be with
    | `BEXPR_name index -> index
    | `BEXPR_closure index -> index
    | _ -> failwith "Expected expression to be index"

(* this routine takes a bound type from an interface,
   and applies the binding functor to produce a bound
   type in the functors domain, which is a module.
   Note that the target might be a typedef, so the result
   is not necessarily unique. Rebind_type must be applied
   to factor out the typedefs again.
*)
and map_type 
  iface 
  dfns counter freg 
  mmap ienv binding excluded_dirs isr msr t 
: btypecode_t = 
  let map t = map_type iface dfns counter freg mmap ienv binding excluded_dirs isr msr t in
  match t with
  | `BTYP_name index ->
    `BTYP_name
    (
      get_unique_binding iface dfns counter freg 
        mmap ienv binding index excluded_dirs 
        isr msr
    )
  | `BTYP_function (a, r) -> `BTYP_function (map a, map r)
  | `BTYP_tuple ls -> `BTYP_tuple (List.map map ls)
  | `BTYP_sum ls -> `BTYP_sum (List.map map ls)
  | `BTYP_pointer t -> `BTYP_pointer (map t)
  | `BTYP_binding (a,b) ->
    failwith "[map type] Unexpected type binding"

  | `BTYP_void -> `BTYP_void
  | `BTYP_none -> `BTYP_none 
  | `BTYP_fix i -> `BTYP_fix i
 
(* NOTE ON COMPARISONS: 
  We don't allow a val to match a const. Probably,
  we should: they're both 'constants', the only difference
  is the form of initialisation: we'd write
  val x:int = "1"; instead of const x:int = 1;
  except that the initialiser of the first form looks
  like a string. 
 
  Note that there IS a difference: 'consts' live 
  in the global frame, values live in the thread frame.
  This is ad hoc'ery: C++ constants can be initialised
  independently of each other, Felix values can't.
  
  Note that we DO allow an function declaration to match
  either a Felix function or a primitive function.
*)

and compare_defn 
  iface 
  dfns counter freg 
  mmap name 
  ienv ientry 
  menv mentry 
  binding excluded_dirs 
  isr msr
=
  (*
  print_endline 
  (
    "comparing iface element '" ^ string_of_symdef ientry name ^ "'" ^
    "\n with module element '"  ^
    string_of_symdef mentry name ^ "'"
  );
  *)
  let ibt t: btypecode_t = bind_type dfns counter freg ienv excluded_dirs isr t in
  let rt t: btypecode_t= rebind_btype dfns counter freg menv excluded_dirs msr t in 
  let mt t: btypecode_t = 
    map_type iface 
    dfns counter freg 
    mmap ienv binding 
    excluded_dirs 
    isr msr 
    t
  in
  let rmb t: btypecode_t = rt (mt (ibt t)) in
  let mbt t: btypecode_t = bind_type dfns counter freg menv excluded_dirs msr t in
    
  match ientry,mentry with
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_type_alias _)
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_abs _)
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_union _)
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_struct _)
  | `SYMDEF_if_type,`SYMDEF_if_type
    ->   true

  | `SYMDEF_dcl (`DCL_fun (ips,iret,ict)),`SYMDEF_dcl (`DCL_fun (mps,mret,mct)) ->
    let it = `TYP_function ( typeof_list ips , iret) in
    let mt = `TYP_function ( typeof_list mps , mret) in
    let it = rmb it and mt = mbt mt in
    ict = mct && 
    it = mt
  
  | `SYMDEF_dcl (`DCL_proc (ips,ict)),`SYMDEF_dcl (`DCL_proc (mps,mct)) ->
    let it = typeof_list ips in
    let mt = typeof_list mps in
    let it = rmb it and mt = mbt mt in
    ict = mct && 
    it = mt

  | `SYMDEF_if_proc (it), `SYMDEF_dcl (`DCL_proc (mps,mct)) ->
    let mt = typeof_list mps in
    let it = rmb it and mt = mbt mt in
    it = mt
 
  | `SYMDEF_if_fun (it),`SYMDEF_dcl (`DCL_fun (ps,ret,mct))  ->
    let mt = `TYP_function ( typeof_list ps , ret) in
    let it = rmb it and mt = mbt mt in
    it = mt
  
  | `SYMDEF_if_fun (it),`SYMDEF_if_fun (mt) 
  | `SYMDEF_if_proc (it),`SYMDEF_if_proc (mt) ->
    let it = rmb it and mt = mbt mt in
    it = mt
    
  | `SYMDEF_if_fun (it),`SYMDEF_function (ps,ret,_,_,_) ->
    let mt = `TYP_function ( paramtype ps , ret) in
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_if_proc (it),`SYMDEF_procedure (ps,_,_,_) ->
    let mt =  paramtype ps in
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_dcl (`DCL_const (it,ict)), `SYMDEF_dcl (`DCL_const (mt,mct)) ->
    let it = rmb it and mt = mbt mt in
    it = mt &&
    ict = mct


  | `SYMDEF_dcl (`DCL_val it), `SYMDEF_dcl (`DCL_val mt) 
  | `SYMDEF_dcl (`DCL_var it), `SYMDEF_dcl (`DCL_var mt) ->
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_dcl (`DCL_var it), `SYMDEF_dcl (`DCL_var_typeof e)
  | `SYMDEF_dcl (`DCL_val it), `SYMDEF_dcl (`DCL_val_typeof e) ->
    let mt = snd (bind_expression dfns counter freg menv [] excluded_dirs e)
    and it = rmb it in
    it = mt

  | `SYMDEF_dcl (`DCL_union ics), `SYMDEF_dcl (`DCL_union mcs)
  | `SYMDEF_dcl (`DCL_struct ics), `SYMDEF_dcl (`DCL_struct mcs) ->
    List.fold_left2
    (fun b (iname,it) (mname,mt) ->
      let it = rmb it and mt = mbt mt in
      b &&
      iname = mname &&
      it = mt
    )
    true ics mcs

  | it,mt -> 
    failwith 
    (
      "Unexpected pair matching interface to module:" ^
      "\nIface  " ^ string_of_symdef it name ^
      "\nModule " ^ string_of_symdef mt name
    )

(* GIVEN an index, if the index refers to an entity
   declared in the interface, return what it binds
   to in the module,
   otherwise just return it

   These semantics to support binding a a type in
   the interface down to a type in the module
*)
and get_unique_binding iface dfns counter freg 
  mmap ienv (binding: index_map_t) iindex excluded_dirs 
  isr msr
: bid_t 
=
  try Hashtbl.find binding iindex
  with Not_found ->
    let iid,isr,iparent,isymdef = Hashtbl.find dfns iindex in
    if iparent <> Some iface then iindex
    else begin try
      match Hashtbl.find mmap iid with
      | NonFunctionEntry (Simple mindex) ->

        (* NOTE: I'm not sure this is sound!
           We insert the binding first, THEN check it,
           to prevent infinite recursion with recursive
           union and struct types -- this causes the
           initial lookup in this routine to succeed
           the second time around.
        *)
        Hashtbl.add binding iindex mindex;
        let mid,msr,mparent,msymdef = Hashtbl.find dfns mindex in
        assert(iid=mid);
        (* print_endline "BUILD ENV, GET UNIQUE BINDING"; *)
        let menv = build_env dfns counter freg excluded_dirs mparent in
        if 
        (
          compare_defn iface dfns counter freg 
          mmap mid ienv isymdef menv msymdef binding excluded_dirs
          isr msr
        )
        then mindex
        else 
          failwith 
          (
            "interface entry '"^ iid ^ 
            "' doesn't match the one in the module"
          )
      | NonFunctionEntry _ ->
        failwith
        (
          "Expected Simple non function entry, got binding"
        )
      | FunctionEntry _ ->
        failwith 
        (
          "Non function entry '" ^ iid ^ 
          "' in interface, found functions in module"
        )
    with 
      | Not_found -> 
        failwith 
        (
          "Name " ^ iid ^ " of interface not found in module"
        )
    end

and match_interface_entry 
  iface dfns counter freg 
  mmap ienv binding excluded_dirs 
  isr msr
  name ientry 
=
  (*
  print_endline ("matching interface name " ^ name);
  *)
  match ientry with
  | NonFunctionEntry (Simple iindex) ->
    ignore(get_unique_binding iface dfns counter freg mmap ienv binding iindex excluded_dirs isr msr)
  | NonFunctionEntry _ ->
    failwith
    (
      "Expected simple Nonfunction entry, got binding"
    )
  | FunctionEntry ls ->
    List.iter
    (fun iindex ->
      match iindex with
      | Simple iindex ->
        let iid,iesr,iparent,isymdef = Hashtbl.find dfns iindex in
        begin try
          match Hashtbl.find mmap name with
          | NonFunctionEntry _ ->
            failwith
            (
              "Function entry '" ^
              name ^
              "' in interface , found non function in module"
            )
          | FunctionEntry ls ->
            begin try List.iter
            (fun mindex ->
              match mindex with
              | Simple mindex ->
                let mid,mesr,mparent,msymdef = Hashtbl.find dfns mindex in
                (* print_endline "BUILD ENV, MATCH INTERFACE ENTRY"; *)
                let menv = build_env dfns counter freg excluded_dirs mparent in
                if 
                (
                  compare_defn iface dfns counter freg 
                  mmap name ienv isymdef menv msymdef binding excluded_dirs
                  iesr mesr
                )
                then raise (Found mindex);
              | _ -> failwith "Expected Simple"
            )
            ls
            ;
            failwith 
            (
              "interface entry '"^
              string_of_symdef isymdef name ^ "' in\n" ^
              short_string_of_src iesr ^
              "\ndoesn't match any one in the module\n" ^
              short_string_of_src msr ^
              "\nCandidates are\n" ^
              String.concat "\n"
              (
                List.map 
                (fun x -> match x with 
                  | Simple index ->
                    let mid,mesr,mparent,msymdef = Hashtbl.find dfns index in
                    string_of_symdef msymdef name 
                  | Bound (i,j) -> 
                    "binding "  ^ 
                    string_of_int i ^ 
                    " => " ^
                    string_of_int j
                )
                ls
              )
            )
            with Found mindex-> 
              Hashtbl.add binding iindex mindex
            end
        with 
          | Not_found -> 
            failwith 
            (
              "Name " ^ name ^ " of interface not found in module"
            )
        end
      | _ -> 
        failwith
        (
          "Expected simple entry, got binding"
        )
    )
    ls
  
and match_interface 
  (iface:int) 
  (dfns:symbol_table_t)
  (counter:int ref)
  (freg:instantiation_registry_t)
  (mmap:name_map_t)
  (ienv:env_t)
  (imap:name_map_t)
  (excluded_dirs:int list)
  isr msr
=
  let binding = Hashtbl.create 97 in
  try 
    Hashtbl.iter
    (match_interface_entry iface 
      dfns counter freg mmap ienv binding excluded_dirs 
      isr msr
    )
    imap
    ;
    Some binding
  with 
    | Failure x -> 
      print_endline ("WARNING: interface doesn't match module:\n" ^ x);
      None

and compose_bindings b1 b2 = (* reverse polish: b(i)= b2(b1(i)) *)
  let b = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i j ->
    let k = Hashtbl.find b2 j in
    Hashtbl.add b i k
  )
  b1
  ;
  b

and rebind_entry binding v =
  let apply ix = Hashtbl.find binding ix in
  match v with
  | NonFunctionEntry (Simple iix) ->
    let bix = apply iix in
    NonFunctionEntry (Bound (iix,bix))

  | NonFunctionEntry _ -> 
    failwith "Expected Simple interface entry"
  | FunctionEntry ls ->
    let ls' = 
      List.map
      (fun entry -> match entry with
        | Simple iix ->
          let bix = apply iix in
          Bound (iix,bix)
        | _ -> failwith "Expected Simple interface entry"
      )
      ls 
    in
    FunctionEntry ls'

and apply_binding imap binding : name_map_t = (* reverse polish *)
  let bmap = Hashtbl.create 97 in
  let add k v = Hashtbl.add bmap k v in
  Hashtbl.iter 
  (fun k v -> add k (rebind_entry binding v))
  imap
  ;
  bmap

and handle_coercion dfns counter freg env sr excluded_dirs  m t : module_rep_t =
  (* print_endline "HANDLING COERCION"; *)
  let m' = eval_module_expr dfns counter freg env excluded_dirs m in
  let t' = bind_type dfns counter freg env excluded_dirs sr t in
  handle_module_coercion dfns counter freg env sr excluded_dirs m' t' 

and handle_module_coercion dfns counter freg env sr excluded_dirs m t =
  match t with
  | `BTYP_sum _ -> failwith "Can't handle module sums yet"
  | `BTYP_tuple ts ->
    begin match m with
    | Module_product ms ->
      let nms = List.length ms and nts = List.length ts in
      if nms <> nts then 
        Module_product 
          (List.map2 (handle_module_coercion dfns counter freg env sr excluded_dirs) ms ts)
      else failwith 
      (
        "Can't coerce product of " ^ string_of_int nms ^ " modules " ^
        "with " ^ string_of_int nts ^ " interfaces"
      )
    | _ -> 
      failwith 
      (
        "Coercion to interface tuple requires module tuple"
      )
    end

  | `BTYP_name index ->
    let id,isr,parent,symdef = Hashtbl.find dfns index in
    (* print_endline "BUILD_ENV, MODULE COERCION"; *)
    let ienv = build_env dfns counter freg excluded_dirs (Some index) in
    begin match symdef with
    | `SYMDEF_interface (imap,dirs) ->
      begin match m with
      | Functor_set _ ->
        failwith "Can't coerce functor (yet)"

      | Module_product _ ->
        failwith "Can't coerce module product to single interface"
        
      | Simple_module (impl,module_map,dirs) ->
        begin match
          match_interface index 
          dfns counter freg 
          module_map ienv imap 
          excluded_dirs 
          isr sr
        with
          | Some binding ->
            Bound_module (index,impl,binding)
          | None -> failwith "Module doesn't match interface"
        end
      | Bound_module (iface,impl,binding) ->
        let _,isr,_,ientry = Hashtbl.find dfns iface in
        begin match ientry with
        | `SYMDEF_interface (module_map,dirs) ->
          begin match
            match_interface index 
              dfns counter freg 
              module_map 
              ienv imap 
              excluded_dirs 
              isr sr
          with
            | Some binding' ->
              print_endline ("Interface matches interface '"^id^"' OK");
              let binding=compose_bindings binding' binding in
              print_endline "Binding is:";
              Hashtbl.iter
              (fun i j -> 
                print_endline 
                (
                  let iid,_,_,ie = Hashtbl.find dfns i 
                  and mid,_,_,me = Hashtbl.find dfns j
                  in
                  iid ^
                  "[" ^ string_of_int i ^ "] -> " ^
                  mid ^
                  "[" ^ string_of_int j ^ "]"
                )
              )
              binding
              ;
              Bound_module (index,impl,binding)

            | None -> failwith "Interface doesn't match interface"
          end
        | _ -> failwith "Expected interface"
        end
      end

    | x -> 
      failwith 
      (
        "[eval_module_expr]: Expected interface, got: " ^ 
        string_of_symdef x id
      )
    end
  | _ -> 
    failwith 
    (
      "Exected module type to be an interface name (functors later), got: " ^
      string_of_btypecode dfns t
    )

and compare_module_expr_with_type dfns counter freg excluded_dirs sr t m =
  (* print_endline "COMPARING MODULE EXPR WITH TYPE"; *)
  match m with
  | Module_product ls -> 
    (* print_endline "..MODULE PRODUCT";*)
    begin match t with
    | `BTYP_tuple ts ->
      if List.length ts = List.length ls
      then
        List.fold_left2
        (fun b t m -> b && 
          (
            compare_module_expr_with_type 
            dfns counter freg excluded_dirs sr t m
          )
        )
        true ts ls
      else false
    | _ -> false
    end
 | Bound_module (index,_,_) ->
   (* print_endline "..BOUND MODULE";*)
   begin match t with
   | `BTYP_name index2 -> index = index2
   | _ -> false
   end
 | Simple_module (impl,mmap,dirs) ->
   (* print_endline "..SIMPLE MODULE"; *)
   begin match t with
   | `BTYP_name iface ->
     let _,isr,p,ientry = Hashtbl.find dfns iface in
     begin match ientry with
     | `SYMDEF_interface (imap,dirs) ->
       begin match
         (* print_endline "BUILD ENV, COMPARE MODULE EXPR"; *)
         let ienv = build_env dfns counter freg excluded_dirs p in
         match_interface iface 
         dfns counter freg 
         mmap ienv imap 
         excluded_dirs isr sr
       with
        | Some binding' -> true
        | None -> false
       end
     | _ -> failwith "Expected interface"
     end
   | _ -> false
   end
 | Functor_set _ -> failwith "Can't compare functor set with single type"
 
and resolve_functor_overload dfns counter freg env excluded_dirs sr ls m' =
  (* print_endline "RESOLVING FUNCTOR OVERLOAD"; *)
  List.filter
  (fun index -> 
    let id,sr,parent,entry = Hashtbl.find dfns index in
    match entry with 
    | `SYMDEF_typed_functor (ps,t,e,nm,dirs) ->
      let t = 
        match List.map snd ps  with
        | [x] -> x
        | x -> `TYP_tuple x
      in
      let t = bind_type dfns counter freg env excluded_dirs sr t
      in 
        (* print_endline ("Type of functor signature is " ^ string_of_btypecode dfns t); *)
        compare_module_expr_with_type dfns counter freg excluded_dirs sr t m'
    | `SYMDEF_untyped_functor (ps,e,nm,dirs) ->
      let t = 
        match List.map snd ps  with
        | [x] -> x
        | x -> `TYP_tuple x
      in
      let t = bind_type dfns counter freg env excluded_dirs sr t
      in 
        (* print_endline ("Type of functor signature is " ^ string_of_btypecode dfns t); *)
        compare_module_expr_with_type dfns counter freg excluded_dirs sr t m'
    | _ -> failwith "Expected FUnctor"
  )
  ls


and copy_entry dfns counter parent binding_list index =
  let index' = !counter in incr counter;
  let id,sr,_,entry = Hashtbl.find dfns index in
  let kind,symdef = 
    match entry with
    | `SYMDEF_function (ps,t,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,`SYMDEF_function (ps,t,es,table',dirs)
      
    | `SYMDEF_procedure (ps,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,`SYMDEF_procedure (ps,es,table',dirs)

    | `SYMDEF_match_handler (p,u,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,`SYMDEF_match_handler (p,u,es,table',dirs)

    | `SYMDEF_typed_functor (ps,t,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,`SYMDEF_typed_functor (ps,t,es,table',dirs)

    | `SYMDEF_untyped_functor (ps,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,`SYMDEF_untyped_functor (ps,es,table',dirs)

    | `SYMDEF_parameter _ ->
      begin try
        let iidx,midx,binding = List.assoc id binding_list in
        Parameter,`SYMDEF_module_binding 
        (
          `AST_bound_module (sr,(iidx,midx,binding))
        ) 
      with Not_found -> Other,entry
      end
    | _ -> Other,entry
  in
    (*
    print_endline 
    (
      "//   " ^ string_of_int index' ^ 
      " -> " ^
      (match kind with 
        | Other -> "copyof " 
        | Parameter -> "binding "
      )^ 
      id ^ "["^string_of_int index^"]: " ^ 
      short_string_of_src sr
    );
    *)
    Hashtbl.add dfns index' (id,sr,parent,symdef)
    ;
    index'

and copy_table dfns counter parent binding_list name_map =
  let name_map' = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v -> match v with
    | NonFunctionEntry (Simple i) ->
      let i' = copy_entry dfns counter parent binding_list i in
      Hashtbl.add name_map' k (NonFunctionEntry (Simple i'))
      
    | NonFunctionEntry _ -> 
      failwith "instantiate not expecting bound entry"
    | FunctionEntry ls ->
      let fs = 
        List.map
        (fun e -> match e with
          | Simple i ->
            Simple (copy_entry dfns counter parent binding_list i)
          | _ -> 
            failwith "instantiate not expecting bound entry"
        )
        ls
      in
        Hashtbl.add name_map' k (FunctionEntry fs)
  )
  name_map
  ;
  name_map'

and instantiate_functor 
  dfns counter (freg:instantiation_registry_t)
  sr excluded_dirs findex (m: module_rep_t) 
: module_rep_t =
  (* print_endline "CHECKING FOR FUNCTOR INSTANTIATION"; *)
  try 
    let afidx = Hashtbl.find freg (findex, m) in
    let _,_,_,entry = Hashtbl.find dfns afidx in
    match entry with
    | `SYMDEF_module (name_map,dirs) -> Simple_module (afidx,name_map,dirs)
    | _ -> failwith "Expected instantiation to be simple module"
  with Not_found ->
  (* print_endline "INSTANTIATING FUNCTOR"; *)
  let _,_,parent,entry = Hashtbl.find dfns findex in
  let ps,asms,name_map,dirs = 
    match entry with 
    | `SYMDEF_typed_functor (ps,rt,asms,name_map,dirs) -> ps,asms,name_map,dirs
    | `SYMDEF_untyped_functor (ps,asms,name_map,dirs) -> ps,asms,name_map,dirs
    | _ -> failwith "Expected functor"
  in
  let env = build_env dfns counter freg excluded_dirs parent in

  let rec aux ps (m:module_rep_t) : functor_arg_binding_t =
    match m with
    | Bound_module (iindex,impl,binding) ->
      begin match ps with
      | [x] -> [fst x,(iindex,impl,binding)]
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Simple_module (impl,mmap,dirs) -> 
      begin match ps with
      | [x] ->
        let t = bind_type dfns counter freg env excluded_dirs sr (snd x) in
        begin match handle_module_coercion dfns counter freg env sr excluded_dirs m t with
        | Bound_module (iindex,impl,binding)  -> 
          [fst x, (iindex,impl,binding)]
        | _ -> failwith "Expected bound module result" 
        end
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Functor_set _ -> failwith "Expected bound module, got Functor set"
    | Module_product ls -> 
      if List.length ls = List.length ps 
      then List.concat ( List.map2 (fun p m -> aux [p] m) ps ls)
      else failwith "Module product wrong length"

  in 
    let binding = aux ps m in
    let mindex = !counter in incr counter; 
    let mname = "_module_" ^ string_of_int mindex in 
    print_endline 
    (
      "// " ^ string_of_int mindex ^ 
      " -> instance " ^ mname ^ ": " ^ 
      short_string_of_src sr
    );
    Hashtbl.add freg (findex,m) mindex; 
    let mtable = copy_table dfns counter (Some mindex) binding name_map in
    Hashtbl.add dfns mindex (mname,sr,parent, (`SYMDEF_module (mtable,dirs))); 
    (*
    print_endline "Instantiated Functor has table:";
    Hashtbl.iter
    (fun k v -> print_endline (" " ^ k ^ " -> " ^ (match v with
      | NonFunctionEntry (Simple i) -> string_of_int i
      | NonFunctionEntry (Bound (i,j)) -> "bound"
      | FunctionEntry ls -> "function overload set"
    )))
    mtable
    ;
    *)
    Simple_module (mindex,mtable,dirs)

and handle_functor_application dfns counter freg env sr excluded_dirs f m =
  (* print_endline "HANDLING FUNCTOR APPLICATION"; *)
  let m' = eval_module_expr dfns counter freg env excluded_dirs m in
  let f' = eval_module_expr dfns counter freg env excluded_dirs f in
  match f' with
  | Functor_set ls ->
    let matches = resolve_functor_overload dfns counter freg env excluded_dirs sr ls m' in
    begin match matches with
    | [index] -> 
        instantiate_functor dfns counter freg sr excluded_dirs index m'
    | [] -> failwith "No match overloading functor"
    | _ -> failwith "Too many matches overloading functor"
    end

  | _ -> failwith "Expected functor"


and check_module dfns counter freg excluded_dirs sr entries =
    begin match entries with
    | FunctionEntry ls -> 
      let ls = 
        List.map
        (function 
          | Simple index -> 
            let id,sr,parent,entry = Hashtbl.find dfns index in
            begin match entry with
            | `SYMDEF_typed_functor _ -> index
            | `SYMDEF_untyped_functor _ -> index
            | _ -> 
              failwith 
              (
                "Expected Functor, got : " ^
                string_of_symdef entry id ^ "\nin "^
                short_string_of_src sr
              )
            end
          | Bound _ -> failwith "Not expecting bound entry for functor"
        )
        ls
      in Functor_set ls

    | NonFunctionEntry (Simple index) ->
      let id,sr',parent,entry = Hashtbl.find dfns index in
      begin match entry with
      | `SYMDEF_module (table,dirs) -> 
        Simple_module (index,table,dirs)
      | `SYMDEF_module_binding e ->
        let env' = build_env dfns counter freg excluded_dirs parent in
        eval_module_expr dfns counter freg env' excluded_dirs e
      | _ -> 
        failwith 
        (
          "Expected '" ^ id ^ "' to be module in: " ^
          short_string_of_src sr ^ ", found: " ^
          short_string_of_src sr'
        )
      end
    | _ -> 
      failwith
      (
        "Expected simple non function entry, got binding"
      )
    end

and make_bound binding x = 
  let bi i = Bound (i, Hashtbl.find binding i) in
  let be e = 
    match e with 
    | Simple i -> bi i
    | Bound _ -> failwith "Entry already bound!"
  in
  match x with
  | NonFunctionEntry e -> NonFunctionEntry (be e)
  | FunctionEntry fs -> FunctionEntry (List.map be fs)

and eval_module_expr dfns counter freg env excluded_dirs e : module_rep_t = 
  (*
  print_endline ("Handling module expression '"^string_of_expr e^"'"); 
  *)
  match e with
  | `AST_root sr ->
    let root_env,_ = list_last env in
    let rec find_root i =
      let id,sr,parent,entry = Hashtbl.find dfns i in
      match parent with 
      | None -> i
      | Some i -> find_root i
    in
    (* THIS IS A HACK! It assumes the last use of the counter
      was for building an entry in the dfns symtab!
    *)
    let root_index = find_root (!counter - 1) in
    (*
    print_endline ("ROOT IS INDEX " ^ string_of_int root_index)
    ;
    *)
    Simple_module (root_index,root_env,[]) 

  | `AST_tuple (sr,es) ->
    Module_product (List.map (eval_module_expr dfns counter freg env excluded_dirs) es)

  | `AST_coercion (sr,(m,t)) ->
    handle_coercion dfns counter freg env sr excluded_dirs m t

  | `AST_bound_module (sr,(iface,impl,binding)) ->
    Bound_module (iface,impl,binding)

  | `AST_apply (sr,(f,m)) ->
    let x = handle_functor_application dfns counter freg env sr excluded_dirs f m in
    (* print_endline "FUNCTOR APPLIED"; *)
    x

  | `AST_name (sr,name) ->
    let entries = lookup_name_in_env env sr name in
    check_module dfns counter freg excluded_dirs sr entries

  | `AST_lookup (sr,(e,name)) ->
    let result = eval_module_expr dfns counter freg env excluded_dirs e in
    let entries = 
      begin match result with
      | Simple_module (index,table,dirs) ->
        begin match lookup_name_in_htab table name with
        | Some x -> x
        | None -> failwith 
          (
            "Can't find " ^ name ^ " in module in\n"  ^ 
            short_string_of_src sr 
          )
        end

      | Bound_module (iface,impl,binding) ->
        let id,sr,parent,entry = Hashtbl.find dfns iface in
        begin match entry with
        | `SYMDEF_interface (table,_) ->
          begin match lookup_name_in_htab table name with
          | Some x ->
            make_bound binding x
          | None -> failwith 
            (
              "Can't find " ^ name ^ " in module in\n"  ^ 
              short_string_of_src sr 
            )
          end

        | _ -> failwith "Expected interface"
        end

      | Functor_set _ -> failwith "Can't lookup in functor set"
      | Module_product _ -> failwith "Can't lookup in module product"
      end 
    in check_module dfns counter freg excluded_dirs sr entries

  | _ ->
    failwith 
    (
      "Invalid module expression " ^ 
      string_of_expr e ^ " in\n" ^
      short_string_of_src (src_of_expr e) 
    )

and bind_index dfns counter freg env exclude depth excluded_dirs sr index = 
  (*
  print_endline ("BINDING INDEX " ^ string_of_int index);
  flush stdout;
  *)
  if List.mem_assoc index exclude 
  then begin
    (*
    print_endline (
      "Recursive type alias " ^
      (
        match get_data dfns index with id,sr,_,_ -> 
          id ^ " defined at " ^
          short_string_of_src sr
      )
    );
    *)
    `BTYP_fix ((List.assoc index exclude)-depth)
  end  
  else begin match get_data dfns index with
  | id,sr,_,entry-> 
    (*
    print_endline (string_of_symdef entry id);
    *)
    match entry with
    | `SYMDEF_dcl (`DCL_type_alias t) -> 
      (*
      print_endline "GOT A TYPE ALIAS";
      *)
      bind_type' dfns counter freg env ((index,depth) :: exclude) [] depth excluded_dirs sr t

    | `SYMDEF_if_type -> `BTYP_name index
    | `SYMDEF_dcl (`DCL_abs _) -> `BTYP_name index
    | `SYMDEF_dcl (`DCL_union _) -> `BTYP_name index
    | `SYMDEF_dcl (`DCL_struct _) -> `BTYP_name index
    | `SYMDEF_interface _ -> `BTYP_name index
    | `SYMDEF_module_binding e ->
      let e' = 
        eval_module_expr dfns counter freg env excluded_dirs e
      in 
      begin match e' with
      | Bound_module (iface,impl,binding) -> 
        `BTYP_binding (`BTYP_name iface, `BTYP_name impl)
      | _ -> failwith "Expected module binding expression to be bound module"
      end
    | _ -> 
      failwith 
      (
        "[bind_index] Type " ^ id ^ 
        " defined at " ^ short_string_of_src sr ^
        " must be abstract, union or struct, got:\n" ^
        string_of_symdef entry id
      )
  end 

(* This routine binds a type expression to a bound type expression.
   Note in particular that a type alias is replaced by what
   it as an alias for, recursively so that the result 
   globally unique
*)

and bind_type dfns counter freg env excluded_dirs sr t : btypecode_t =
  let t' = bind_type' dfns counter freg env [] [] 0 excluded_dirs sr t in
  (*
  print_endline ("TYPE  " ^ string_of_typecode t);
  print_endline ("BOUND " ^ string_of_btypecode dfns t');
  *)
  type_fold t'

and bind_type' dfns counter freg env exclude fixnames depth excluded_dirs sr t : btypecode_t =
  let bt t = bind_type' dfns counter freg env exclude fixnames (depth+1) excluded_dirs sr t in
  let bi i = bind_index dfns counter freg env exclude depth excluded_dirs sr i in
  (*
  print_endline ("BINDING TYPE " ^ string_of_typecode t);
  flush stdout;
  *)
  match t with
  | `AST_root _ -> failwith "Not expecting root in bind type"
  | `TYP_none ->  `BTYP_none
  | `TYP_all (t,s) -> failwith "Can't bind type scheme yet" 
  | `TYP_as (t,s) ->
     (* note depth is not incremented .. "x as x" yields `BTYP_fix 0 *)
     bind_type' 
       dfns counter freg env exclude 
       ((s,depth)::fixnames) depth 
       excluded_dirs sr t 

  | `TYP_tuple ts -> 
    let ts' =List.map bt ts  in
    `BTYP_tuple ts'

  | `TYP_sum ts -> 
    let ts' =List.map bt ts  in
    `BTYP_sum ts'

  | `TYP_function (d,c) -> 
    let 
      d' = bt d  and 
      c' = bt c 
    in 
      (*
      print_endline "DONE (function type)";
      flush stdout;
      *)
      `BTYP_function (bt d, bt c)

  | `TYP_pointer t -> 
     let t' = bt t in 
     (*
     print_endline "Done (pointer type)"; 
     flush stdout; 
     *)
     `BTYP_pointer t'

  | `AST_void _ -> 
    (*
    print_endline "Done (void)"; 
    flush stdout; 
    *)
    `BTYP_void

  | `AST_name (sr,s) when (List.mem_assoc s fixnames) ->
     `BTYP_fix (List.assoc s fixnames - depth)

  | #qualified_name_t as x -> 
    (* print_endline "BIND TYPE DOING LOOKUP QN IN ENV";
    flush stdout;
    *)
    match lookup_qn_in_env dfns counter freg env excluded_dirs x with
    | Bound (i,m) -> 
      (* print_endline "Lookup returns bound type";
      flush stdout;
      *)
      `BTYP_binding (bi i, bi m)

    | Simple index -> 
      (*
      print_endline ("Lookup returns simple index " ^ string_of_int index);
      flush stdout; 
      *)
      bi index

(* This routine takes a bound type, and produces a unique form
   of the bound type, by again factoring out type aliases.
   The type aliases can get reintroduced by map_type,
   if an abstract type is mapped to a typedef, so we have
   to factor them out again .. YUK!!
*)
   
and rebind_btype dfns counter freg env excluded_dirs sr t: btypecode_t =
  let rbt t = rebind_btype dfns counter freg env excluded_dirs sr t in
  match t with
  | `BTYP_name i ->
    let id,sr,parent,entry = Hashtbl.find dfns i in
    begin match entry with
    | `SYMDEF_dcl (`DCL_type_alias t') ->
      bind_type dfns counter freg env excluded_dirs sr t'
    | _ -> t
    end
  | `BTYP_tuple ts -> `BTYP_tuple (List.map rbt ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map rbt ts)
  | `BTYP_function (a,r) -> `BTYP_function (rbt a, rbt r) 
  | `BTYP_pointer t -> `BTYP_pointer (rbt t)
  | `BTYP_void -> `BTYP_void
  | `BTYP_none -> `BTYP_none
  | `BTYP_binding (a,b) -> `BTYP_binding (rbt a,rbt b)
  | `BTYP_fix i -> `BTYP_fix i


and base_typename_of_literal v = match v with
  | `AST_int (t,_) -> t
  | `AST_float (t,_) -> t
  | `AST_string _ -> "string"

and  typeof_literal dfns counter freg env sr v : btypecode_t = 
  let root,_ = List.hd (List.rev env) in
  let name = base_typename_of_literal v in
  match lookup_name_in_env env dummy_sr name with
  | NonFunctionEntry (Simple index) -> 
    `BTYP_name index
  | _ -> 
    failwith 
    (
      "Unable to find simple definition of type " ^ 
      name ^ " of literal " ^
      string_of_literal v
    )
  
and  typeof_list = function 
  | [x] -> x 
  | x -> `TYP_tuple x

and  typlist params = List.map snd params
and  paramtype params = typeof_list (typlist params)

and  sig_of_symdef symdef name = match symdef with 
  | `SYMDEF_lazy (_) 
  | `SYMDEF_match_check (_) 
  | `SYMDEF_match_handler (_,_,_,_,_) -> `TYP_tuple[]

  (* primitives *)
  | `SYMDEF_dcl (`DCL_fun (ps,_,_))
  | `SYMDEF_dcl (`DCL_proc (ps,_)) -> typeof_list ps

  | `SYMDEF_function (ps,_,_,_,_)
  | `SYMDEF_procedure (ps,_,_,_) -> paramtype ps

  | `SYMDEF_if_fun (t) -> 
    begin match t with
    | `TYP_function (a,r) -> a
    | _ -> failwith "[resolve overload] Expected function to have function type"
    end
  | `SYMDEF_if_proc (t) -> t
  
  | symdef -> 
    failwith (
      "[resolve_overload] Expected "^
      name
      ^" to be function or procedure, got " ^
     string_of_symdef symdef name 
    )    

and typeofindex 
  (dfns:symbol_table_t) 
  (counter:int ref)
  (freg:instantiation_registry_t)
  (exclude:int list)
  (excluded_dirs:int list)
  (index:int)
: btypecode_t = 
  (* print_endline ("TYPE OF INDEX " ^ string_of_int index); *)
  flush stdout;
  let id,sr,parent,entry = Hashtbl.find dfns index in
  (*
  print_endline ("Index is id=" ^ id);
  *)
  if List.mem index exclude
  then failwith ("Recursive type dependency for " ^ id);

  (* print_endline "BUILD ENV IN TYPEOFINDEX";  *)
  let env:env_t = build_env dfns counter freg excluded_dirs parent in 
  (* print_endline "ENV BUILT in typeofindex"; *)
  flush stdout;
  let bt t:btypecode_t = 
    (* print_endline ("TYPEOFINDEX binding type " ^ string_of_typecode t); *)
    flush stdout;
    (*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    let t' = bind_type' dfns counter freg env (index::exclude) 0 excluded_dirs sr t in
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)
    let t' = bind_type dfns counter freg env excluded_dirs sr t in
    (* print_endline "TYPE BOUND"; *)
    t'
  in
    (*
    print_endline ("typeofindex finds " ^ string_of_symdef entry id);
    flush stdout;
    *)
  match entry with

  | `SYMDEF_function (ps, rt,_,_,_) -> 
    let pts = List.map snd ps in
    bt (`TYP_function (typeof_list pts, rt))

  | `SYMDEF_procedure(ps,_,_,_) -> 
    (*
    print_endline "typeofindex finds PROCEDURE";
    flush stdout;
    *)
    let pts = List.map snd ps in
    bt (`TYP_function (typeof_list pts, `AST_void sr))

  | `SYMDEF_if_proc (t) -> 
    bt (`TYP_function (t,`AST_void sr))

  | `SYMDEF_dcl (`DCL_const (t,_)) ->
    (*
    print_endline "Found const";
    print_endline (":--->" ^ string_of_symdef entry id);
    flush stdout;
    *)
    bt t

  | `SYMDEF_parameter t ->
    (*
    print_endline "Found param";
    print_endline (":--->" ^ string_of_symdef entry id);
    flush stdout;
    *)
    bt t

  | `SYMDEF_if_fun (t) ->
    (*
    print_endline "Found if_fun";
    print_endline (":--->" ^ string_of_symdef entry id);
    flush stdout;
    *)
    bt t

  | `SYMDEF_dcl (`DCL_val t) ->
    (*
    print_endline "Found val";
    print_endline (":--->" ^ string_of_symdef entry id);
    flush stdout;
    *)
    bt t

  | `SYMDEF_dcl (`DCL_var t) -> 
    (*
    print_endline "Found var";
    print_endline (":--->" ^ string_of_symdef entry id);
    flush stdout;
    *)
    bt t

  | `SYMDEF_dcl (`DCL_val_typeof e)
  | `SYMDEF_dcl (`DCL_var_typeof e) ->
    (*
    print_endline "CALLING BIND EXPRESSION.. (possible recursion)";
    flush stdout;

    ARGG! This is bugged. The expression e might contain a lambda,
    which bind_expression rejects ..

    Worse, the expression sometimes need to be
    evaluated in an unavailable context .. for example,
    match x with | y -> 1+y

    is transformed to have an initialisation

    e = 1 + y

    and y isn't visible where e is declared ..

    .. basically, requiring the user to declared the return type
    of a function won't stick .. too many constructions map
    to functions whose type must be deduced ..

    Unfortunately, the DCL is generated before there is
    a hashtable representing the environment .. so there 
    is no way to specify the environment in which the expression
    is to be evaluated .. or is it .. ??
    *)

    snd(bind_expression dfns counter freg env (index::exclude) excluded_dirs e)

  | `SYMDEF_lazy (e) -> 
    let rt = snd (bind_expression dfns counter freg env (index::exclude) excluded_dirs e) in
    `BTYP_function (`BTYP_tuple [],rt)


  | `SYMDEF_match_check _ ->
    `BTYP_function (`BTYP_tuple [], bool_t)

  | `SYMDEF_match_handler _ ->
    `BTYP_function (`BTYP_tuple [],`BTYP_void)

  | `SYMDEF_match_result handler_index ->
    let handler = Hashtbl.find dfns handler_index in
    begin 
      match handler with (id,sr,parent,sym) ->
      match sym with `SYMDEF_match_handler (pat,mvindex,exes,nmap,dirs) ->
      begin
         let mvname = 
           match Hashtbl.find dfns mvindex with (id,_,_,_) -> id
         in
         let last_instr = list_last exes in
         match last_instr with
         | `EXE_init (match_result_name, e) ->
            assert (match_result_name = mvname ^ "_result");
            (* We need the environment to be the handler body .. *)
            let env:env_t = build_env dfns counter freg excluded_dirs (Some handler_index) in 
            (* print_endline ("Trying to bind expression " ^ string_of_expr e); *)
            snd(bind_expression dfns counter freg env (index::exclude) excluded_dirs e)
         | _ -> assert false
      end
      | _ -> assert false
    end
    
  | `SYMDEF_dcl (`DCL_fun (pts,rt,_)) -> 
    (* print_endline "Found function primitive";
    flush stdout;
    *)
    bt (`TYP_function (typeof_list pts,rt))
    
  | `SYMDEF_dcl (`DCL_proc (pts,_)) -> 
    bt (`TYP_function (typeof_list pts, `AST_void sr))
    
  | `SYMDEF_dcl (`DCL_union _)
  | `SYMDEF_dcl (`DCL_struct _) -> `BTYP_name index

  | _ ->
    failwith 
    (
      "[typeofindex] Expected expression term, got " ^
      id ^ " in " ^
      short_string_of_src sr
    )

and cal_apply dfns ((be1,t1) as tbe1) ((be2,t2) as tbe2) : tbexpr_t =
  let rest =
    match type_unfold t1 with
    | `BTYP_function (argt,rest) ->
      if argt = t2 then rest
      else 
        failwith 
        (
          "[ebind:cal_apply] Function argument " ^
          string_of_bound_expression dfns tbe2 ^
          " has type\n" ^
          string_of_btypecode dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          string_of_btypecode dfns argt 
        )

    | `BTYP_binding (
        `BTYP_function (argt,rest),
        `BTYP_function (argt',rest')
      ) ->
      if argt = lift t2 
      && argt' = lower t2
      then `BTYP_binding (rest, rest')
      else 
        failwith 
        (
          "[ebind:cal_apply] Function argument " ^
          string_of_bound_expression dfns tbe2 ^
          " has type\n" ^
          string_of_btypecode dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          string_of_btypecode dfns argt 
        )

    (* HACKERY TO SUPPORT STRUCT CONSTRUCTORS *)
    | `BTYP_name index -> 
      let id,_,_,entry = Hashtbl.find dfns index in
      begin match entry with
      | `SYMDEF_dcl (`DCL_struct cs) -> t1
      | _ -> 
        failwith 
        (
          "Attempt to apply non-struct " ^ id ^ ", type " ^
          string_of_btypecode dfns t1 ^
          " as constructor"
        )
      end
    | _ -> 
      failwith 
      (
        "Attempt to apply non-function\n" ^
        string_of_bound_expression dfns tbe1 ^ 
        "\nof type\n" ^
        string_of_btypecode dfns t1 ^
        "\nto argument of type\n" ^
        string_of_bound_expression dfns tbe2
      )
  in
  (*
  print_endline 
  (
    "---------------------------------------" ^
    "\nApply type " ^ string_of_btypecode dfns t1 ^
    "\nto argument of type " ^ string_of_btypecode dfns t2 ^ 
    "\nresult type is " ^ string_of_btypecode dfns rest ^
    "\n-------------------------------------"
  );
  *)
  `BEXPR_apply ((be1,lower t1), (be2,lower t2)),rest

and koenig_lookup dfns counter freg sra exclude excluded_dirs id' name_map fn t2 =
  (*
  print_endline "Applying Koenig lookup";
  *)
  let entries =  
    try Hashtbl.find name_map fn 
    with Not_found -> 
      failwith 
      (
        "Koenig lookup: can't find name "^
        fn^ " in " ^ 
        (match id' with 
        | "" -> "top level module"
        | _ -> "module '" ^ id' ^ "'"
        )
      )
  in 
  match entries with
  | FunctionEntry fs ->
    (* print_endline ("Got candidates: "); List.iter (fun x -> print_endline ("  " ^ string_of_int x)) fs ; *)
    begin match resolve_overload dfns counter freg excluded_dirs sra fs fn t2 with
    | Some (Simple index'') ->
      (* print_endline "Overload resolution OK"; *)
      `BEXPR_closure index'',
      (
        match 
          try typeofindex dfns counter freg exclude excluded_dirs index'' 
          with _ -> failwith "typeofindex failed"
        with
        | `BTYP_function _ as t -> t
          (* HANDLE UNKNOWN RETURN TYPE HERE *)
        | t -> 
          failwith 
          (
            "[bind_expression]: Koenig lookup: closure operator expected '"^
            fn ^"' to be function definition, got '"^
            string_of_btypecode dfns t
            ^"', " ^ short_string_of_src sra
          )
      )
    | Some (Bound _ ) -> failwith "[koenig lookup] Can't handle bound result yet"
    | None ->
        let n = ref 0 
        in Hashtbl.iter (fun _ _ -> incr n) name_map; 
        print_endline ("module defines " ^ string_of_int !n^ " entries");
        failwith 
        (
          "[flx_ebind] Koenig lookup: Can't find match for " ^ fn ^ " in " ^
          short_string_of_src sra
        )
    end
  | NonFunctionEntry _ -> failwith "Koenig lookup expected function"

and lookup_qn_with_sig 
  dfns counter freg 
  sra srn 
  env exclude excluded_dirs 
  (qn:qualified_name_t)
  (sign:btypecode_t)
: tbexpr_t =    
  match qn with
  | `AST_void _ -> failwith "qualified-name is void"
  | `AST_root _ -> failwith "Can't handle root yet"
  | `AST_case_tag _ -> failwith "Can't lookup case tag here"
  | `AST_typed_case _ -> failwith "Can't lookup typed case tag here"
  | `AST_name (sr,name) ->
    (*
    print_endline (
      "Lookup unqualified name '"^
      name
      ^"' with sig '"^
      string_of_btypecode dfns sign
      ^"'"
    );
    flush stdout;
    *)
    lookup_name_with_sig 
      dfns counter freg 
      sra srn exclude excluded_dirs 
      env name sign

  | `AST_lookup (sr,(qn',name)) -> 
    (*
    print_endline (
      "Lookup qn '"^
      string_of_qualified_name qn
      ^"' with sig'"^
      string_of_btypecode dfns sign
      ^"'"
    );
    flush stdout;
    *)
    match 
      eval_module_expr 
      dfns counter freg 
      env excluded_dirs 
      qn'
    with 
      | (Module_product _) ->
        failwith "Unexpected module product"

      | (Functor_set _) ->
        failwith "Unexpected Functor"

      | (Simple_module (impl, htab,dirs)) ->
        begin match lookup_name_in_htab htab name with
        | None -> 
          failwith
          (
            "Can't find name " ^ name ^ " in\n" ^
            short_string_of_src sr
          )
        | Some x -> match x with 
        | NonFunctionEntry (Simple index) ->
          let t = typeofindex dfns counter freg exclude excluded_dirs index in
          begin match t with
          | `BTYP_function (a,b) ->
             if a <> sign 
             then 
               failwith
               (
                 "Non function entry has wrong type"
               )
             else 
               `BEXPR_name index,
               typeofindex dfns counter freg exclude excluded_dirs index

          | _ -> 
            failwith
               (
                 "Non function entry not function type"
               )
          end
        | NonFunctionEntry (Bound (i,j)) ->
          failwith "Can't handle bound result yet"
        | FunctionEntry fs ->
          match
            resolve_overload
            dfns counter freg excluded_dirs sra fs name sign
          with
          | Some (Simple index) ->
             `BEXPR_closure index, 
             typeofindex dfns counter freg exclude excluded_dirs index

          | Some (Bound (iface,impl)) -> 
             `BEXPR_closure impl, 
             `BTYP_binding
             (
               typeofindex dfns counter freg exclude excluded_dirs iface,
               typeofindex dfns counter freg exclude excluded_dirs impl
             )

          | None -> 
            failwith 
            (
              "[Simple module] Unable to resolve overload in\n" ^
              short_string_of_src sra
            )
        end

      | (Bound_module (iface,impl,binding)) ->
        let id,_,_,entry = Hashtbl.find dfns iface in
        begin match entry with 
        | `SYMDEF_interface (table,dirs) ->
          let table' = apply_binding table binding in
          begin match lookup_name_in_htab table' name with
          | None -> 
            failwith 
            (
              "Can't find name " ^ name ^ " in\n" ^
              short_string_of_src sra
            )
          | Some x -> match x with
          | NonFunctionEntry (Simple index) ->
            let t = typeofindex dfns counter freg exclude excluded_dirs index in
            begin match t with
            | `BTYP_function (a,b) ->
               if a <> sign  (* WE NEED TO DO A LIFT HERE *)
               then 
                 failwith
                 (
                   "Non function entry has wrong type"
                 )
               else 
                 `BEXPR_name index,
                 typeofindex dfns counter freg exclude excluded_dirs index

            | _ -> 
              failwith
                 (
                   "Non function entry not function type"
                 )
            end
          | NonFunctionEntry (Bound (i,j)) ->
            failwith
            (
              "Can't handle bound non-function result yet"
            )

          | FunctionEntry fs ->
            match
              resolve_overload
              dfns counter freg excluded_dirs sra fs name sign
            with
            | Some (Simple index) ->
               `BEXPR_closure index, 
               typeofindex dfns counter freg exclude excluded_dirs index

            | Some (Bound (iface,impl)) -> 
               `BEXPR_closure impl, 
               `BTYP_binding
               (
                 typeofindex dfns counter freg exclude excluded_dirs iface,
                 typeofindex dfns counter freg exclude excluded_dirs impl
               )

            | None -> 
              failwith 
              (
                "[Bound module] Unable to resolve overload in\n" ^
                short_string_of_src sra
              )

          end
        | _ -> failwith "Expected interface"
        end

and lookup_name_with_sig 
  dfns counter freg 
  sra srn 
  exclude excluded_dirs env 
  name (t2:btypecode_t) 
: tbexpr_t =
  (*
  print_endline ("Lookup_name_with_sig: " ^ name ^ " of " ^ string_of_btypecode dfns t2);
  flush stdout;
  *)
  match env with
  | [] -> 
    failwith 
    (
      "[lookup_name_with_sig] Can't find " ^ name ^ 
      " of " ^ string_of_btypecode dfns t2 ^ "\n" ^
      "in " ^ short_string_of_src srn
    )
  | (table,dirs)::tail ->
    match 
      lookup_name_in_table_dirs_with_sig 
      (table, dirs) 
      dfns counter freg 
      env exclude excluded_dirs 
      sra srn name t2 
    with
    | Some result -> (result:>tbexpr_t)
    | None -> 
      (
        (*
        print_endline "Next level of env";
        flush stdout;
        *)
        (
        lookup_name_with_sig 
          dfns counter freg 
          sra srn 
          exclude excluded_dirs 
          tail name t2
        ):>tbexpr_t
      )

and handle_function 
  dfns counter freg 
  env exclude excluded_dirs 
  sra srn 
  name 
  (overload:entry_kind_t)
: tbexpr_t 
=
  (*
  print_endline "HANDLE FUNCTION";
  *)
  match overload with
    | Bound (i,j) -> 
      print_endline "[handle_function] handle opaque function"; 
      let it =
        match typeofindex dfns counter freg exclude excluded_dirs i with
        | `BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[handle_function]: closure operator expected '"^
            name^"' to be function definition, got '"^
            string_of_btypecode dfns t
            ^"', " ^ short_string_of_src sra
          )
      and mt =
        match typeofindex dfns counter freg exclude excluded_dirs j with
        | `BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[handle_function]: closure operator expected '"^
            name^"' to be function definition, got '"^
            string_of_btypecode dfns t
            ^"', " ^ short_string_of_src sra
          )
      in
        `BEXPR_closure j,
        unify dfns it mt
      
    | Simple index -> 
      (*
      print_endline "HANDLE FUNCTION: SIMPLE INDEX";
      flush stdout;
      *)
      begin 
        match Hashtbl.find dfns index with id,sr,parent,entry 
        -> match entry with
        | `SYMDEF_match_check _
        | `SYMDEF_function _
        | `SYMDEF_dcl(`DCL_proc _ )
        | `SYMDEF_dcl(`DCL_fun _)
        | `SYMDEF_procedure _ 
        | `SYMDEF_match_handler _ 
        | `SYMDEF_lazy _
          ->
          (*
          print_endline ("closure of " ^ name);
          flush stdout;
          *)
          `BEXPR_closure index,
          (
            match typeofindex dfns counter freg exclude excluded_dirs index with
            | `BTYP_function (s,d) as t -> 
              begin match d with
              | `BTYP_none -> failwith "Can't handle Unknown type in handle_function"
              | _ -> t
              end
            | t -> 
              failwith 
              (
                "[handle_function]: closure operator expected '"^name^"' to be function definition, got '"^
                string_of_btypecode dfns t
                ^"', " ^ short_string_of_src sra
              )
          )
        | _ -> 
          failwith 
          (
            "[handle_function] Expected function"
          )
      end 

and lookup_name_in_table_dirs_with_sig (table, dirs) 
  dfns counter freg 
  env exclude excluded_dirs 
  sra srn name t2 
: tbexpr_t option
=
  (* print_endline "LOOKUP NAME IN TABLE DIRS WITH SIG"; *)
  let result:entry_set_t =
    match lookup_name_in_htab table name  with
    | Some x -> x
    | None -> FunctionEntry []
  in
  match result with
  | NonFunctionEntry (Simple index) ->
    (* Struct constructor *)
    (* print_endline "LOOKUP NAME IN TABLE DIRS WITH SIG: Done"; *)
    Some
    (
      `BEXPR_name index, 
      typeofindex dfns counter freg exclude excluded_dirs index
    )

  | NonFunctionEntry _ ->
    failwith "[lookup_name_in_table_dirs_with_sig] expected simple nonfunction entry"

  | FunctionEntry fs ->
    (*
    print_endline "RESOLVING OVERLOAD"; flush stdout;
    *)
    let ro:entry_kind_t option = 
      resolve_overload 
      dfns counter freg excluded_dirs sra fs name t2
    in
    match ro with 
      | Some result ->
        let tb : tbexpr_t =
          handle_function 
          dfns counter freg 
          env exclude excluded_dirs 
          sra srn name result
        in Some tb 

      | None ->
        (*
        print_endline "NOT FOUND, trying opens";
        flush stdout;
        *)
        let opens : entry_set_t list = 
          List.concat
          (
            List.map
            (fun table -> 
              match lookup_name_in_htab table name with
              | Some x -> [x]
              | None -> []
            )
            dirs
          )
        in
          (*
          print_endline "OPENS BUILT"; flush stdout;
          *)
          let fs:entry_kind_t list = merge_functions opens name in
          let ro:entry_kind_t option = 
            resolve_overload
            dfns counter freg excluded_dirs sra fs name t2
          in
          (*
          print_endline "OVERLOAD RESOLVED .. ";
          *)
          match ro with
          | Some result ->
            let tb : tbexpr_t = 
              handle_function 
              dfns counter freg 
              env exclude excluded_dirs 
              sra srn name result
            in 
              (* 
              print_endline "SUCCESS"; flush stdout; 
              *)
              Some tb
          | None -> 
            (*
            print_endline "FAILURE"; flush stdout; 
            *)
            None

and handle_entry dfns counter freg sra srn env exclude excluded_dirs entry t2 name =
  let be e = bind_expression dfns counter freg env exclude excluded_dirs e in
  let lu sr qn = lookup_qn_in_env dfns counter freg env excluded_dirs qn in
  let bt t = bind_type dfns counter freg env excluded_dirs sra t in
  match entry with
  | NonFunctionEntry (Simple index) ->
    Some
    (
      `BEXPR_name index, 
      typeofindex dfns counter freg exclude excluded_dirs index
    )
  | NonFunctionEntry _ ->
    failwith "[handle_entry] expected simple nonfunction entry"

  | FunctionEntry fs -> 
    (* print_endline ("Simple overload: function "^name^" found"); *)
    match 
      resolve_overload 
      dfns counter freg 
      excluded_dirs sra fs name t2 
    with 
    | Some result ->
      Some
      (
        handle_function 
        dfns counter freg 
        env exclude excluded_dirs 
        sra srn 
        name result 
      )
    | None -> None


and bind_expression dfns counter freg env exclude excluded_dirs e : tbexpr_t = 
  let be e = bind_expression dfns counter freg env exclude excluded_dirs e in
  let lu sr qn = lookup_qn_in_env dfns counter freg env excluded_dirs qn in
  let bt sr t = bind_type dfns counter freg env excluded_dirs sr t in
  let ti i = typeofindex dfns counter freg exclude excluded_dirs i in

  (* model infix operator as function call *)
  let apl2 (sri:range_srcref) (fn : string) (tup:expr_t list) = 
    let sr = rslist tup in
    `AST_apply 
    (
      sr, 
      (
        `AST_name (sri,fn), 
        `AST_tuple (sr,tup)
      )
    )
  in
  (*
  print_endline ("Binding expression " ^ string_of_expr e);
  print_endline ("environment is:");
  print_env env;
  print_endline "==";
  *)
  match e with
  | `AST_as (sr, (e1,e2)) -> failwith "Unexpected 'as' in expression" 
  | `AST_all (sr, (e1,e2)) -> failwith "Unexpected 'all' in expression" 

  | `AST_sum (sri,ls) -> 
    begin let mksum a b = apl2 sri "add" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mksum h t)
    | [] -> failwith "Not expecting empty product (unit)"
    end
    
  | `AST_product (sri,ls) ->
    begin let mkprod a b = apl2 sri "mul" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mkprod h t)
    | [] -> failwith "Not expecting empty sum (void)"
    end

  | `AST_void _
  | `AST_arrow _ -> failwith "[bind expression] Not expecting void or arrow"

  | `AST_root _ -> failwith "Can't bind root"
  | `AST_index (sr,i) -> 
    let t = typeofindex dfns counter freg exclude excluded_dirs i in
    `BEXPR_name i,t

  | `AST_bound_module _ -> 
    failwith "[Bind_expression] Not expecting bound module"

  | `AST_coercion (sr,(m,t)) -> 
    let m' = be m in
    let t' = bt sr t in
    `BEXPR_coercion (m',t'),t'

  | `AST_lazy _ -> assert false
  | `AST_get_n (sr,(n,e')) -> 
    let expr,typ = be e' in
    let ctyp = match typ with 
    | `BTYP_tuple ts -> 
      let len = List.length ts in
      if n<1 or n>len
      then failwith 
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 1.." ^
          string_of_int len ^
          " in " ^
          short_string_of_src sr
        )
      else List.nth ts (n-1)
    | _ -> 
      failwith 
      (
        "[bind_expression] Expected tuple " ^ 
        string_of_expr e' ^ 
        " to have tuple type, got " ^ 
        string_of_btypecode dfns typ ^
        " in " ^
        short_string_of_src sr
      )
    in 
      `BEXPR_get_n (n, (expr,typ)), ctyp

  | `AST_case_tag (sr,v) ->
     failwith "plain case tag not allowed in expression (only in pattern)"

  | `AST_typed_case (sr,v,t) ->
     let t = bt sr t in
     begin match type_unfold t with
     | `BTYP_sum ls ->
       if v<1 or v> List.length ls
       then failwith "Case index out of range of sum"
       else let vt = List.nth ls (v-1) in
       let ct = 
         match vt with
         | `BTYP_tuple [] -> t        (* const ctor *)
         | _ -> `BTYP_function (vt,t) (* non-const ctor *)
       in
       `BEXPR_case (v,t), ct
     | _ -> failwith "Type of case must be sum"
     end

  | `AST_name (sr,name) ->
    begin match lookup_name_in_env env sr name with
    | NonFunctionEntry (Simple index) -> 
      `BEXPR_name index, ti index

    | NonFunctionEntry Bound(i,m) ->
      let it = ti i in
      let mt = ti m in
      let t = unify dfns it mt in
      `BEXPR_name m, t

    | FunctionEntry fs -> 
      (* HACK. This is needed as the argument for `AST_suffix,
         and other things that need to do overloading
      *)
      `BEXPR_functions (name,fs), `BTYP_none
    end

  | `AST_lookup (sr,(e,name)) ->
    let entry = 
      match 
          eval_module_expr 
          dfns counter freg 
          env excluded_dirs 
          e 
      with 
      | (Module_product _) ->
        failwith "Unexpected module product"

      | (Functor_set _) ->
        failwith "Unexpected Functor"

      | (Simple_module (impl, htab,dirs)) ->
        lookup_name_in_htab htab name

      | (Bound_module (iface,impl,binding)) ->
        let _,_,_,entry = Hashtbl.find dfns iface in
        begin match entry with 
        | `SYMDEF_interface (table,dirs) ->
          let table' = apply_binding table binding in
          lookup_name_in_htab table' name
        | _ -> failwith "Expected interface"
        end
    in 
      begin match entry with
      | Some entry -> 
        begin match entry with
        | NonFunctionEntry (Simple i) ->  
          `BEXPR_name i, ti i
          
        | NonFunctionEntry (Bound (i,j)) -> 
          `BEXPR_name j, 
          `BTYP_binding (ti i, ti j)
        | FunctionEntry fs ->
          `BEXPR_functions (name,fs),
          `BTYP_none
        end

      | None ->
        failwith
        (
          "Can't find " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      end

  | `AST_suffix (sr,(e,suf)) ->
    let bound_suffix =  bt sr suf in
    begin match be (e:>expr_t) with
    | `BEXPR_functions (name,fs),`BTYP_none ->
      begin match resolve_overload dfns counter freg excluded_dirs sr fs name bound_suffix with
      | Some (Simple index) ->
         `BEXPR_closure index, 
         typeofindex dfns counter freg exclude excluded_dirs index

      | Some (Bound (iface,impl)) -> 
         `BEXPR_closure impl, 
         `BTYP_binding
         (
           typeofindex dfns counter freg exclude excluded_dirs iface,
           typeofindex dfns counter freg exclude excluded_dirs impl
         )

      | None -> 
        failwith 
        (
          "[flx_ebind] Can't find match for " ^ name ^ " in " ^
          short_string_of_src sr ^ 
          "\nCandidates are " ^
          (String.concat "\n"
            (List.map
              (function Simple i | Bound (i,_)  ->
                string_of_int i ^ "==> " ^ 
                string_of_btypecode dfns (typeofindex dfns counter freg [] excluded_dirs i)
              )
              fs
            )
          )
        )
      end
    | _ -> 
      failwith
      (
        "Expected suffix to select from function set in\n" ^
        short_string_of_src sr
      )
    end

  | `AST_ref (_,(`AST_deref (sr,e))) -> be e
  
  | `AST_ref (sr,(`AST_dot (_,(e,id)))) ->
    let ref_name = "ref_" ^ id in
    be 
    (
      `AST_apply 
      (
        sr,
        (
          `AST_name (sr, ref_name),
          `AST_ref (sr,e)
        )
      )
    )

  | `AST_ref (srr,e) -> 
    let e',t' = be e in 
    begin match e' with
    | `BEXPR_name index ->
      let id,sr,parent,entry = Hashtbl.find dfns index in
      begin match entry with
      | `SYMDEF_dcl (`DCL_var _)
      | `SYMDEF_dcl (`DCL_var_typeof _)
      | `SYMDEF_parameter (`TYP_pointer _) -> 
        `BEXPR_ref index, 
        `BTYP_pointer (typeofindex dfns counter freg exclude excluded_dirs index)
      | `SYMDEF_parameter _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          ": Address value parameter " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | `SYMDEF_dcl (`DCL_val _)
      | `SYMDEF_dcl (`DCL_val_typeof _) ->
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Can't address a value " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      end
    | _ ->
      failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable in\n" ^
          short_string_of_src srr
        )
    end

  | `AST_deref (_,`AST_ref (sr,e)) -> be e

  | `AST_deref (_,e) -> 
    let e,t = be e in
    begin match t with 
    | `BTYP_pointer t -> `BEXPR_deref (e,t),t
    | _ -> failwith "Dereference non pointer"
    end

  | `AST_literal (sr,v) -> 
    let t = typeof_literal dfns counter freg env sr v in
    `BEXPR_literal v, t

  | `AST_method_apply (sra,(fn,e2)) -> 
    let be2,t2 = be e2 in
    let tbe1 = 
      begin match t2 with
      | `BTYP_name index ->
        let id,sr,parent,entry = Hashtbl.find dfns index in
        begin match parent with
        | None -> failwith "Koenig lookup: No parent for method apply (can't handle global yet)"
        | Some index' ->
          let id',sr',parent',entry' = Hashtbl.find dfns index' in
          match entry' with
          | `SYMDEF_module (name_map,dirs) ->
            koenig_lookup dfns counter freg sra exclude excluded_dirs id' name_map fn t2

          | `SYMDEF_interface (name_map,dirs) ->
            koenig_lookup dfns counter freg sra exclude excluded_dirs id' name_map fn t2

          | _ -> failwith ("Koenig lookup: parent for method apply not module")
        end
      | _ -> failwith "apply method to nongenerative type"
      end
    in
      cal_apply dfns tbe1 (be2, t2)

  | `AST_apply (sra,(`AST_name (srn,qn) as name,e2)) -> 
    (*
    print_endline ("Apply unqualified name " ^ qn);
    flush stdout;
    *)
    let be2,t2 = be e2 in
    let tbe1 =
      lookup_qn_with_sig 
        dfns counter freg 
        sra srn env 
        exclude excluded_dirs 
        name t2 
    in 
      cal_apply dfns tbe1 (be2,t2)

  | `AST_apply (sr,(e1,e2)) -> 
    (*
    print_endline ("General apply of " ^ string_of_expr e1);
    *)
    let tbe1 = be e1 and (be2,t2) as tbe2 = be e2 in
    begin match tbe1 with
    | `BEXPR_functions (name,fs), `BTYP_none ->
      let entry = resolve_overload 
        dfns counter freg 
        excluded_dirs sr 
        fs name t2 
      in 
      let tbe1' = match entry with
      | None -> 
       failwith (
         "Unable to resolve overload of name " ^ string_of_expr e1 ^
         " with argument of type " ^ string_of_btypecode dfns t2 ^
         "\nin " ^ short_string_of_src sr
       )
      | Some (Simple index) ->
         `BEXPR_closure index, 
         typeofindex dfns counter freg exclude excluded_dirs index

      | Some (Bound (iface,impl)) -> 
         `BEXPR_closure impl, 
         `BTYP_binding
         (
           typeofindex dfns counter freg exclude excluded_dirs iface,
           typeofindex dfns counter freg exclude excluded_dirs impl
         )
      in
        cal_apply dfns tbe1' tbe2

    | _ ->
      cal_apply dfns tbe1 tbe2
    end

  | `AST_tuple (_,es) -> 
    let bets = List.map be es in
    let _, bts = List.split bets in
    `BEXPR_tuple bets, `BTYP_tuple bts

  | `AST_dot (sr,(e,id)) ->
    let get_name = "get_" ^ id in
    be (`AST_method_apply (sr,(get_name,e)))

  | `AST_match_case (sr,(v,e)) ->
     `BEXPR_match_case (v,be e),bool_t

  | `AST_match_ctor (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name) -> 
      let fname = `AST_name (sr,"_match_ctor_" ^ name) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(context,name)) ->
      let fname = `AST_lookup (sr,(context,"_match_ctor_" ^ name)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
       be (`AST_match_case (sr,(v,e)))

    | _ -> failwith "Expected variant constructor name in union decoder"
    end
    
  | `AST_case_arg (sr,(v,e)) ->
     let (_,t) as e' = be e in
     begin match type_unfold t with
     | `BTYP_sum ls ->
       let n = List.length ls in
       if v<1 or v>n 
       then failwith "Invalid sum index"
       else let t = List.nth ls (v-1) in
       `BEXPR_case_arg (v, e'),t
     | _ -> failwith "Expected sum type"
     end 

  | `AST_ctor_arg (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name) -> 
      let fname = `AST_name (sr,"_ctor_arg_" ^ name) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(e,name)) ->
      let fname = `AST_lookup (sr,(e,"_ctor_arg_" ^ name)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
      be (`AST_case_arg (sr,(v,e)))

    | _ -> failwith "Expected variant constructor name in union dtor"
    end

  | `AST_lambda (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "\n[Compiler error] Unexpected lambda when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_match (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "[Compiler error] Unexpected match when binding expression (should have been lifted out)"
    )


and resolve_overload 
  dfns counter freg 
  excluded_dirs sr 
  fs name (suf : btypecode_t) 
: entry_kind_t option=
  let rec resolve i =
    match Hashtbl.find dfns i with (id,sr,parent,symdef) ->
    parent,i,sig_of_symdef symdef id
  in
  let rec aux i =  
    match i with
    | Simple i -> 
      let p,i,t = resolve i in
      let env = build_env dfns counter freg excluded_dirs p in
      let t = bind_type dfns counter freg env excluded_dirs sr t in
      Unique (i,t)

    | Bound (i,j) ->
      let p,i,t = resolve i in
      let env = build_env dfns counter freg excluded_dirs p in
      let t = bind_type dfns counter freg env excluded_dirs sr t in
      Pair ((i,t),j)
  in
  let fun_defs = List.map aux fs in
  match 
    let lift_suf = lift suf in
    List.filter 
    (fun result -> match result with
      | Unique (_,t) 
      | Pair ((_,t),_) -> 
        lift t = lift_suf
    ) 
    fun_defs
  with 
  | [Unique (i,_)] -> Some (Simple i)
  | [Pair ((i,_),j)] -> Some (Bound (i,j))
  | [] -> None
  | _ -> failwith ("Too many candidates match in overloading " ^ name)
  

(* an environment is a list of hastables, mapping
   names to definition indicies. Each entity defining
   a scope contains one hashtable, and a pointer to
   its parent, if any. The name 'top' is special,
   it is the name of the single top level module
   created by the desugaring phase. We have to be
   able to find this name, so if when we run out
   of parents, which is when we hit the top module,
   we create a parent name map with a single entry
   'top'->NonFunctionEntry 0. 
*)
and get_table_dirs_of_index dfns index = 
  match get_data dfns index with
  | (id,sr,parent,entry) ->
    let table,dirs = 
      match entry with
      | `SYMDEF_module (table,dirs) -> table,dirs
      | `SYMDEF_interface (table,dirs) -> table,dirs
      | `SYMDEF_function (ps,t,e,table,dirs) -> table,dirs
      | `SYMDEF_match_handler (pat,ex,e,table,dirs) -> table,dirs
      | `SYMDEF_procedure (ps,e,table,dirs) -> table,dirs
      | `SYMDEF_lazy _ -> Hashtbl.create 97,[]
      | `SYMDEF_match_check _ -> Hashtbl.create 97,[]

      | `SYMDEF_typed_functor (_,_,_,table,dirs) -> table,dirs
      | `SYMDEF_untyped_functor (_,_,table,dirs) -> table,dirs
      | `SYMDEF_module_binding _ -> failwith "[build_env] Can't handle module binding"
      | `SYMDEF_if_fun _ -> failwith "Can't look into function dcl"
      | `SYMDEF_if_proc _ -> failwith "Can't look into proc dcl"
      | `SYMDEF_if_type -> failwith "Can't look into type"
      | `SYMDEF_match_result _  -> failwith "Can't look into match variable"
      | `SYMDEF_parameter _ -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup function, procedure or module as parent, got parameter "^id^"??"
        )
      | `SYMDEF_dcl d -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup of requires function, procedure or module as parent, got " ^ id
        )
    in parent,table,dirs

and build_env' dfns counter freg parent : (name_map_t * qualified_name_t list) list =
  match parent with
  | None -> []

  | Some index ->
     let parent,table,dirs = get_table_dirs_of_index dfns index in
     let qns = 
       List.concat
       (
         List.map
         (fun x -> match x with 
           | DIR_open qn -> [qn]
         )
         dirs
       )
     in
       (table,qns) :: build_env' dfns counter freg parent

and map_dir 
  dfns counter freg 
  (env:env_t)
  excluded_dirs 
  qn 
: name_map_t =
  (* print_endline ("Mapping open " ^ string_of_qualified_name qn); *)
  let sr = ("dummy",0,0,0,0) in
  let result = lookup_qn_in_env dfns counter freg env excluded_dirs qn in
  match result with
  | Simple i ->
    begin match Hashtbl.find dfns i with
    | _,_,_,`SYMDEF_module (table,_) -> table
    | _,_,_,`SYMDEF_module_binding e -> 
      (* print_endline "map_dir got module binding"; *)
      if not (List.mem i excluded_dirs)
      then
        begin match eval_module_expr dfns counter freg env (i::excluded_dirs) e with 
        | Module_product _ ->
          failwith "Unexpected module product"

        | Functor_set _ ->
          failwith "Unexpected Functor"

        | Simple_module (impl, htab,dirs) ->
          htab
        | Bound_module (iface,impl,binding) ->
          (* print_endline "processing bound module"; *)
          let _,_,_,entry = Hashtbl.find dfns iface in
          begin match entry with 
          | `SYMDEF_interface (table,dirs) ->
            (* print_endline "APPLYING BINDING"; *)
            apply_binding table binding
          | _ -> failwith "Expected interface"
          end
        end
      else begin
        (* print_endline ("DUMMY TABLE CREATED FOR EXCLUDED OPEN " ^ string_of_int i); *)
        Hashtbl.create 97
      end

    | _ -> failwith "[map_dir] Expected module"
    end
  | _ -> failwith "Expected module!"

(* WARNING: if a module is opened twice, any ref to it is
  ambiguous .. what SHOULD happen is that such
  apparently ambiguous references are checked to see
  if they refer to the same thing ..
  once that is got working, we can try to exclude duplicate
  opens here .. but better not to try until it is just 
  an optimisation .. since it would hide the most common
  source of this error .. but possibly not the only one ..
  making it hard to test
*)
and build_env dfns counter freg excluded_dirs parent : env_t =
  let basic_env = build_env' dfns counter freg parent in
  let rec resolve_dirs env =
    match env with
    | [] -> []
    | (table,dirs)::tail ->
      let base = resolve_dirs tail in
      let bound_dirs = 
        List.map
        (map_dir dfns counter freg ((table,[])::base) excluded_dirs)
        dirs
      in
        (table,bound_dirs) ::base
   in 
     resolve_dirs basic_env



