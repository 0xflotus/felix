@head(1,"Name Lookup")
@h = tangler("src/flx_lookup.mli")
@select(h)
open Flx_types

val build_env:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  int list -> (* excluded modules *)
  int option -> (* parent *)
  env_t

val lookup_name_in_env :
  env_t ->
  range_srcref ->
  id_t -> 
  entry_set_t

val lookup_qn_in_env :
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  range_srcref ->
  int list -> (* excluded modules *)
  qualified_name_t -> 
  entry_set_t

val bind_type:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded type *)
  int list -> (* excluded modules *)
  typecode_t ->
  btypecode_t

val eval_module_expr:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded modules *)
  expr_t ->
  module_rep_t

val resolve_overload:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  int list -> (* excluded modules *)
  entry_kind_t list ->  
  id_t -> 
  btypecode_t ->
  entry_kind_t option

val bind_expression :
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  int list -> (* excluded types *)
  int list -> (* excluded modules *)
  expr_t ->
  tbexpr_t

val typeofindex :
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  int list -> (* excluded types *)
  int list -> (* excluded modules *)
  int ->
  btypecode_t

val typeof_literal:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  env_t ->
  range_srcref ->
  literal_t ->
  btypecode_t

val lookup_qn_with_sig:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  range_srcref ->
  range_srcref ->
  env_t ->
  int list ->
  int list ->
  qualified_name_t ->
  btypecode_t ->
  tbexpr_t
 
@h = tangler("src/flx_lookup.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List
open Flx_srcref

exception Found of int

type result = 
  | Unique of int * btypecode_t
  | Pair of (int * btypecode_t) * int

type kind_t = Parameter | Other

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_lookup.get_data] No definition of <" ^ string_of_int index ^ ">")

(* lookup a string in a symbol table, return index *)
let lookup_name_in_htab htab sr name : entry_set_t =
  try Hashtbl.find htab name
  with Not_found -> 
    failwith 
    (
      "Unable to find '" ^ name ^ "' in hashtable: " ^
      short_string_of_src sr 
    )
  
(* lookup a list of strings with a starting symbol table,
  return index
*)
let rec lookup_qn_in_htab dfns htab sr qn : entry_set_t =
  match qn with
  | [] -> 
    failwith 
    (
      "[lookup_qn_in_htab] Empty name: " ^ 
      short_string_of_src sr
    )
  | h :: t -> 
    let entry = lookup_name_in_htab htab sr h in
    if t = [] then entry
    else let index = 
      match entry with
      | FunctionEntry _ ->
        failwith 
        (
          "[lookup_qn_in_htab] Expected " ^ h ^ " to be module,\n" ^
          " got overload set: " ^
          short_string_of_src sr
        )
      | NonFunctionEntry (Simple index) -> index
      | NonFunctionEntry _ -> assert false

    in match get_data dfns index with
    | (id,_,_,SYMDEF_module (htab,dirs)) -> 
      assert (id = h);
      lookup_qn_in_htab dfns htab sr t
      
    | (id,_,_,SYMDEF_interface (htab,dirs)) -> 
      assert (id = h);
      print_endline ("[luqn in htb] Look finds interface : " ^ id);
      lookup_qn_in_htab dfns htab sr t

    | (id,_,_,_) -> 
      assert (id = h);
      failwith (
        "[lookup_qn_in_htab] Expected " ^ 
        h ^ 
        "to be interface to find " ^ 
        (String.concat "::" t) ^ 
        " in: " ^
        short_string_of_src sr
      )

(* lookup a string with a starting symbol table stack,
  return data and possible table
*)
let merge_functions opens name = 
  FunctionEntry (
    List.fold_left
    (fun init x -> match x with
    | FunctionEntry ls -> init @ ls
    | _ -> failwith ("Expected " ^ name ^ " to be function overload set in all open modules")
    )
    []
    opens
  )

let lookup_name_in_table_dirs table dirs sr name =
  try Some (lookup_name_in_htab table sr name)
  with _ -> 
  let opens = 
    List.concat
    (
      List.map
      (fun table -> 
        try [lookup_name_in_htab table sr name]
        with Not_found -> []
      )
      dirs
    )
  in match opens with
  | [x] -> Some x
  | FunctionEntry ls :: rest ->
    Some (merge_functions opens name)

  | (NonFunctionEntry _)::_ -> 
    (* FIX: it might not be so! Could be two typedefs
      of the same thing, later, when I implement it,
      injected names
    *)
    failwith ("Conflicting values for "^name ^" found in open modules")
  | [] -> None

let lookup_name_in_env env sr name : entry_set_t =
  let rec aux env = 
    match env with 
    | [] -> None
    | (table,dirs) :: tail ->
      match lookup_name_in_table_dirs table dirs sr name with
      | Some x as y -> y
      | None -> aux tail
  in 
    match aux env with
    | Some x -> x
    | None ->
      failwith 
      (
        "[lookup_name_in_env]: Name '" ^ 
        name ^ 
        "' not found in environment (depth "^
        string_of_int (List.length env)^ "\n" ^
        "): " ^
        short_string_of_src sr 
      )

let lookup_in_bound_module dfns iface binding sr t =
  match Hashtbl.find dfns iface with
  | (_,_,_,SYMDEF_interface (table,dirs)) ->
    let src = lookup_qn_in_htab dfns table sr t  in
    begin match src with
    | NonFunctionEntry (Simple ix) ->
      let dst = Hashtbl.find binding ix in
      (*
      print_endline 
      (
        "Actually got NonFunction binding " ^
        string_of_int ix ^ " ==> " ^ string_of_int dst
      );
      *)
      NonFunctionEntry (Bound (ix,dst))

    | NonFunctionEntry _ ->
      failwith
      (
        "[lookup_qn_in_env: Bound_module] Expected simple nonfunction entry got binding"
      )
    | FunctionEntry ls ->
      (* print_endline ("Actually got Function bindings:"); *)
      let ns = ref [] in
      List.iter
      (fun ix ->
        match ix with
        | Simple ix ->
          let dst = Hashtbl.find binding ix in
          ns := Bound (ix,dst) :: !ns;
          (* print_endline (string_of_int ix ^ " ==> " ^ string_of_int dst) *)
        | _ -> failwith "Woops, expected Simple"
      )
      ls
      ;
      FunctionEntry !ns
    end

  | _ -> 
    failwith "Lookup in bound module expected interface"

(* lookup string list with a starting symbol table stack *)
let rec lookup_qn_in_env 
  dfns 
  counter 
  (freg:instantiation_registry_t) 
  (env:env_t) 
  sr 
  excluded_dirs
  qn 
  : entry_set_t 
=
  (* print_endline ("[luqn_in_env] Searching for " ^ string_of_qualified_name qn); *)
  match qn with
  | [] -> 
    failwith 
    (
      "[lookup_qn_in_env] empty name " ^ 
      short_string_of_src sr
    )
  | h :: t -> 
    if h = ""
    then 
      if List.length env = 0
      then 
        failwith 
        (
          "[lookup_qn_in_env] Empty environment " ^ 
          short_string_of_src sr
        )
      else
        let htab,dirs = List.hd (List.rev env) in
        (* LOOKUP IN DIRS IF FAILURE *)
        lookup_qn_in_htab dfns htab sr t
    else
      let entry = lookup_name_in_env env sr h in
      if t = [] then begin
        (*
        begin match entry with
        | NonFunctionEntry (Simple index) ->
          print_endline ("[luqn_in_env] Found Simple nonfunction " ^ h ^ "="^string_of_int index ^", finished");
        | NonFunctionEntry (Bound (index1,index2)) ->
          print_endline ("[luqn_in_env] Found Bound nonfunction " ^ h ^ "="^string_of_int index1 ^"=>"^string_of_int index2 ^", finished");
        | FunctionEntry _ ->
          print_endline ("[luqn_in_env] Found function " ^ h ^ ", finished");
          
        end
        ;
        *)
        entry
      end
      else let index = 
        match entry with
        | FunctionEntry _ ->
          failwith 
          (
            "[lookup_qn_in_env] Expected " ^ h ^ " to be module,\n" ^
            " got overload set :" ^
            short_string_of_src sr
          )
        | NonFunctionEntry (Simple index) -> index
        | NonFunctionEntry _ -> assert false

      in 
      (* print_endline ("[luqn_in_env] Found " ^ h ^ "="^string_of_int index ^", continuing"); *)
      match get_data dfns index with
      | (id,_,_,SYMDEF_module (htab,dirs)) ->
        assert (id = h);
        lookup_qn_in_htab dfns htab sr t

      | (id,_,_,SYMDEF_module_binding e) ->
        (* print_endline ("Processing module binding " ^ id ^" = " ^ string_of_expression e); *)
        begin match eval_module_expr dfns counter freg env excluded_dirs e with 
        | Module_product _ ->
          failwith "Unexpected module product"

        | Functor_set _ ->
          failwith "Unexpected Functor"

        | Simple_module (impl, htab,dirs) ->
          (*
          print_endline 
          (
            "[luqn in env] Lookup for '"^
            string_of_qualified_name qn^
            "' finds simple_module : " ^ 
            id
          );
          print_endline "table is";
          print_table htab;
          print_endline "NOW DOING LOOKUP IN HTAB";
          *)
          lookup_qn_in_htab dfns htab sr t

        | Bound_module (iface,impl,binding) ->
          (*
          print_endline 
          (
            "[luqn in env] Lookup for '"^
            string_of_qualified_name qn^
            "' finds bound_module : " ^ 
            id
          );
          *)
          lookup_in_bound_module dfns iface binding sr t

        end
        
      | (id,_,_,SYMDEF_interface (htab,dirs)) ->
        assert (id = h);
        print_endline ("[luqn in env] Look finds interface : " ^ id);
        lookup_qn_in_htab dfns htab sr t

      | (_,_,_,SYMDEF_parameter t') ->
        begin match bind_type dfns counter freg env [] excluded_dirs t' with
        | BTYP_name index ->
          let id,sr,parent,entry = Hashtbl.find dfns index in
          begin match entry with
          | SYMDEF_interface (htab,dirs) ->
            print_endline 
            (
              "[luqn in env] Look finds interface parameter : " ^ 
              id ^ 
              "<"^string_of_int index^">"
            );
            lookup_qn_in_htab dfns htab sr t
          | _ -> failwith "Expected parameter to be interface"
          end
        | _ -> 
          failwith
          (
            "Expected parameter to be interface"
          )
        end

      | (id,_,_,_) -> 
        assert (id = h);
        failwith (
          "[lookup_qn_in_env] Expected '" ^ 
          h ^ 
          "' to have symbol table to find " ^ 
          (String.concat "::" t) ^ 
          " in :" ^
          short_string_of_src sr
        )

and map_type 
  iface 
  dfns counter freg 
  mmap ienv binding excluded_dirs t 
: btypecode_t = 
  let map t = map_type iface dfns counter freg mmap ienv binding excluded_dirs t in
  match t with
  | BTYP_name index ->
    BTYP_name
    (
      get_unique_binding iface dfns counter freg 
        mmap ienv binding index excluded_dirs 
    )
  | BTYP_function (a, r) ->
    BTYP_function (map a, map r)
  | BTYP_tuple ls -> BTYP_tuple (List.map map ls)
  | BTYP_pointer t -> BTYP_pointer (map t)
  | BTYP_void -> BTYP_void
  | BTYP_none -> BTYP_none 
  | BTYP_binding (a,b) ->
    failwith "[map type] Unexpected type binding"
 
(* NOTE ON COMPARISONS: 
  We don't allow a val to match a const. Probably,
  we should: they're both 'constants', the only difference
  is the form of initialisation: we'd write
  val x:int = "1"; instead of const x:int = 1;
  except that the initialiser of the first form looks
  like a string. 
 
  Note that there IS a difference: 'consts' live 
  in the global frame, values live in the thread frame.
  This is ad hoc'ery: C++ constants can be initialised
  independently of each other, Felix values can't.
  
  Note that we DO allow an function declaration to match
  either a Felix function or a primitive function.
*)

and compare_defn iface dfns counter freg mmap name ienv ientry menv mentry binding excluded_dirs =
  (*
  print_endline 
  (
    "comparing iface element '" ^ string_of_symdef ientry name ^ "'" ^
    "\n with module element '"  ^
    string_of_symdef mentry name ^ "'"
  );
  *)
  let bt t: btypecode_t = bind_type dfns counter freg ienv [] excluded_dirs t in
  let rt t: btypecode_t= rebind_btype dfns counter freg menv excluded_dirs t in 
  let mt t: btypecode_t = 
    map_type iface dfns counter freg mmap ienv binding excluded_dirs t
  in
  let rmb t: btypecode_t = rt (mt (bt t)) in
    
  match ientry,mentry with
  | SYMDEF_if_type,SYMDEF_dcl (DCL_type_alias _)
  | SYMDEF_if_type,SYMDEF_dcl (DCL_abs _)
  | SYMDEF_if_type,SYMDEF_dcl (DCL_union _)
  | SYMDEF_if_type,SYMDEF_dcl (DCL_struct _)
  | SYMDEF_if_type,SYMDEF_if_type
    ->   true

  | SYMDEF_dcl (DCL_fun (ips,iret,ict)),SYMDEF_dcl (DCL_fun (mps,mret,mct)) ->
    let it = TYP_function ( typeof_list ips , iret) in
    let mt = TYP_function ( typeof_list mps , mret) in
    let it = rmb it and mt = bt mt in
    ict = mct && 
    it = mt
  
  | SYMDEF_dcl (DCL_proc (ips,ict)),SYMDEF_dcl (DCL_proc (mps,mct)) ->
    let it = typeof_list ips in
    let mt = typeof_list mps in
    let it = rmb it and mt = bt mt in
    ict = mct && 
    it = mt

  | SYMDEF_if_proc (it), SYMDEF_dcl (DCL_proc (mps,mct)) ->
    let mt = typeof_list mps in
    let it = rmb it and mt = bt mt in
    it = mt
 
  | SYMDEF_if_fun (it),SYMDEF_dcl (DCL_fun (ps,ret,mct))  ->
    let mt = TYP_function ( typeof_list ps , ret) in
    let it = rmb it and mt = bt mt in
    it = mt
  
  | SYMDEF_if_fun (it),SYMDEF_if_fun (mt) 
  | SYMDEF_if_proc (it),SYMDEF_if_proc (mt) ->
    let it = rmb it and mt = bt mt in
    it = mt
    
  | SYMDEF_if_fun (it),SYMDEF_function (ps,ret,_,_,_) ->
    let mt = TYP_function ( paramtype ps , ret) in
    let it = rmb it and mt = bt mt in
    it = mt

  | SYMDEF_if_proc (it),SYMDEF_procedure (ps,_,_,_) ->
    let mt =  paramtype ps in
    let it = rmb it and mt = bt mt in
    it = mt

  | SYMDEF_dcl (DCL_const (it,ict)), SYMDEF_dcl (DCL_const (mt,mct)) ->
    let it = rmb it and mt = bt mt in
    it = mt &&
    ict = mct


  | SYMDEF_dcl (DCL_val it), SYMDEF_dcl (DCL_val mt) 
  | SYMDEF_dcl (DCL_var it), SYMDEF_dcl (DCL_var mt) ->
    let it = rmb it and mt = bt mt in
    it = mt

  | SYMDEF_dcl (DCL_var it), SYMDEF_dcl (DCL_var_typeof e)
  | SYMDEF_dcl (DCL_val it), SYMDEF_dcl (DCL_val_typeof e) ->
    let mt = snd (bind_expression dfns counter freg menv [] excluded_dirs e)
    and it = rmb it in
    it = mt

  | SYMDEF_dcl (DCL_union ics), SYMDEF_dcl (DCL_union mcs)
  | SYMDEF_dcl (DCL_struct ics), SYMDEF_dcl (DCL_struct mcs) ->
    List.fold_left2
    (fun b (iname,it) (mname,mt) ->
      let it = rmb it and mt = bt mt in
      b &&
      iname = mname &&
      it = mt
    )
    true ics mcs

  | it,mt -> 
    failwith 
    (
      "Unexpected pair matching interface to module:" ^
      "\nIface  " ^ string_of_symdef it name ^
      "\nModule " ^ string_of_symdef mt name
    )

(* GIVEN an index, if the index refers to an entity
   declared in the interface, return what it binds
   to in the module,
   otherwise just return it

   These semantics to support binding a a type in
   the interface down to a type in the module
*)
and get_unique_binding iface dfns counter freg 
  mmap ienv (binding: index_map_t) iindex excluded_dirs 
: bid_t 
=
  try Hashtbl.find binding iindex
  with Not_found ->
    let iid,isr,iparent,isymdef = Hashtbl.find dfns iindex in
    if iparent <> Some iface then iindex
    else begin try
      match Hashtbl.find mmap iid with
      | NonFunctionEntry (Simple mindex) ->

        (* NOTE: I'm not sure this is sound!
           We insert the binding first, THEN check it,
           to prevent infinite recursion with recursive
           union and struct types -- this causes the
           initial lookup in this routine to succeed
           the second time around.
        *)
        Hashtbl.add binding iindex mindex;
        let mid,msr,mparent,msymdef = Hashtbl.find dfns mindex in
        assert(iid=mid);
        (* print_endline "BUILD ENV, GET UNIQUE BINDING"; *)
        let menv = build_env dfns counter freg excluded_dirs mparent in
        if 
        (
          compare_defn iface dfns counter freg 
          mmap mid ienv isymdef menv msymdef binding excluded_dirs
        )
        then mindex
        else 
          failwith 
          (
            "interface entry '"^ iid ^ 
            "' doesn't match the one in the module"
          )
      | NonFunctionEntry _ ->
        failwith
        (
          "Expected Simple non function entry, got binding"
        )
      | FunctionEntry _ ->
        failwith 
        (
          "Non function entry '" ^ iid ^ 
          "' in interface, found functions in module"
        )
    with 
      | Not_found -> 
        failwith 
        (
          "Name " ^ iid ^ " of interface not found in module"
        )
    end

and match_interface_entry 
  iface dfns counter freg 
  mmap ienv binding excluded_dirs name ientry 
=
  (*
  print_endline ("matching interface name " ^ name);
  *)
  match ientry with
  | NonFunctionEntry (Simple iindex) ->
    ignore(get_unique_binding iface dfns counter freg mmap ienv binding iindex excluded_dirs)
  | NonFunctionEntry _ ->
    failwith
    (
      "Expected simple Nonfunction entry, got binding"
    )
  | FunctionEntry ls ->
    List.iter
    (fun iindex ->
      match iindex with
      | Simple iindex ->
        let iid,isr,iparent,isymdef = Hashtbl.find dfns iindex in
        begin try
          match Hashtbl.find mmap name with
          | NonFunctionEntry _ ->
            failwith
            (
              "Function entry '" ^
              name ^
              "' in interface , found non function in module"
            )
          | FunctionEntry ls ->
            begin try List.iter
            (fun mindex ->
              match mindex with
              | Simple mindex ->
                let mid,msr,mparent,msymdef = Hashtbl.find dfns mindex in
                (* print_endline "BUILD ENV, MATCH INTERFACE ENTRY"; *)
                let menv = build_env dfns counter freg excluded_dirs mparent in
                if 
                (
                  compare_defn iface dfns counter freg 
                  mmap name ienv isymdef menv msymdef binding excluded_dirs
                )
                then raise (Found mindex);
              | _ -> failwith "Expected Simple"
            )
            ls
            ;
            failwith 
            (
              "interface entry '"^
              name^
              "' doesn't match any one in the module"
            )
            with Found mindex-> 
              Hashtbl.add binding iindex mindex
            end
        with 
          | Not_found -> 
            failwith 
            (
              "Name " ^ name ^ " of interface not found in module"
            )
        end
      | _ -> 
        failwith
        (
          "Expected simple entry, got binding"
        )
    )
    ls
  
and match_interface 
  (iface:int) 
  (dfns:symbol_table_t)
  (counter:int ref)
  (freg:instantiation_registry_t)
  (mmap:name_map_t)
  (ienv:env_t)
  (imap:name_map_t)
  (excluded_dirs:int list)
=
  let binding = Hashtbl.create 97 in
  try 
    Hashtbl.iter
    (match_interface_entry iface dfns counter freg mmap ienv binding excluded_dirs)
    imap
    ;
    Some binding
  with 
    | Failure x -> 
      print_endline ("WARNING: interface doesn't match module:\n" ^ x);
      None

and compose_bindings b1 b2 = (* reverse polish: b(i)= b2(b1(i)) *)
  let b = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i j ->
    let k = Hashtbl.find b2 j in
    Hashtbl.add b i k
  )
  b1
  ;
  b

and rebind_entry binding v =
  let apply ix = Hashtbl.find binding ix in
  match v with
  | NonFunctionEntry (Simple iix) ->
    let bix = apply iix in
    NonFunctionEntry (Bound (iix,bix))

  | NonFunctionEntry _ -> 
    failwith "Expected Simple interface entry"
  | FunctionEntry ls ->
    let ls' = 
      List.map
      (fun entry -> match entry with
        | Simple iix ->
          let bix = apply iix in
          Bound (iix,bix)
        | _ -> failwith "Expected Simple interface entry"
      )
      ls 
    in
    FunctionEntry ls'

and apply_binding imap binding : name_map_t = (* reverse polish *)
  let bmap = Hashtbl.create 97 in
  let add k v = Hashtbl.add bmap k v in
  Hashtbl.iter 
  (fun k v -> add k (rebind_entry binding v))
  imap
  ;
  bmap

and handle_coercion dfns counter freg env sr excluded_dirs  m t : module_rep_t =
  (* print_endline "HANDLING COERCION"; *)
  let m' = eval_module_expr dfns counter freg env excluded_dirs m in
  let t' = bind_type dfns counter freg env [] excluded_dirs t in
  handle_module_coercion dfns counter freg env sr excluded_dirs m' t' 

and handle_module_coercion dfns counter freg env sr excluded_dirs m t =
  match t with
  | BTYP_tuple ts ->
    begin match m with
    | Module_product ms ->
      let nms = List.length ms and nts = List.length ts in
      if nms <> nts then 
        Module_product 
          (List.map2 (handle_module_coercion dfns counter freg env sr excluded_dirs) ms ts)
      else failwith 
      (
        "Can't coerce product of " ^ string_of_int nms ^ " modules " ^
        "with " ^ string_of_int nts ^ " interfaces"
      )
    | _ -> 
      failwith 
      (
        "Coercion to interface tuple requires module tuple"
      )
    end

  | BTYP_name index ->
    let id,sr,parent,symdef = Hashtbl.find dfns index in
    (* print_endline "BUILD_ENV, MODULE COERCION"; *)
    let ienv = build_env dfns counter freg excluded_dirs (Some index) in
    begin match symdef with
    | SYMDEF_interface (imap,dirs) ->
      begin match m with
      | Functor_set _ ->
        failwith "Can't coerce functor (yet)"

      | Module_product _ ->
        failwith "Can't coerce module product to single interface"
        
      | Simple_module (impl,module_map,dirs) ->
        begin match
          match_interface index dfns counter freg module_map ienv imap excluded_dirs
        with
          | Some binding ->
            Bound_module (index,impl,binding)
          | None -> failwith "Module doesn't match interface"
        end
      | Bound_module (iface,impl,binding) ->
        let _,_,_,ientry = Hashtbl.find dfns iface in
        begin match ientry with
        | SYMDEF_interface (module_map,dirs) ->
          begin match
            match_interface index dfns counter freg module_map ienv imap excluded_dirs
          with
            | Some binding' ->
              print_endline ("Interface matches interface '"^id^"' OK");
              let binding=compose_bindings binding' binding in
              print_endline "Binding is:";
              Hashtbl.iter
              (fun i j -> 
                print_endline 
                (
                  let iid,_,_,ie = Hashtbl.find dfns i 
                  and mid,_,_,me = Hashtbl.find dfns j
                  in
                  iid ^
                  "[" ^ string_of_int i ^ "] -> " ^
                  mid ^
                  "[" ^ string_of_int j ^ "]"
                )
              )
              binding
              ;
              Bound_module (index,impl,binding)

            | None -> failwith "Interface doesn't match interface"
          end
        | _ -> failwith "Expected interface"
        end
      end

    | x -> 
      failwith 
      (
        "[eval_module_expr]: Expected interface, got: " ^ 
        string_of_symdef x id
      )
    end
  | _ -> 
    failwith 
    (
      "Exected module type to be an interface name (functors later), got: " ^
      string_of_btypecode dfns t
    )

and compare_module_expr_with_type dfns counter freg excluded_dirs t m =
  (* print_endline "COMPARING MODULE EXPR WITH TYPE"; *)
  match m with
  | Module_product ls -> 
    (* print_endline "..MODULE PRODUCT";*)
    begin match t with
    | BTYP_tuple ts ->
      if List.length ts = List.length ls
      then
        List.fold_left2
        (fun b t m -> b && (compare_module_expr_with_type dfns counter freg excluded_dirs t m))
        true ts ls
      else false
    | _ -> false
    end
 | Bound_module (index,_,_) ->
   (* print_endline "..BOUND MODULE";*)
   begin match t with
   | BTYP_name index2 -> index = index2
   | _ -> false
   end
 | Simple_module (impl,mmap,dirs) ->
   (* print_endline "..SIMPLE MODULE"; *)
   begin match t with
   | BTYP_name iface ->
     let _,_,p,ientry = Hashtbl.find dfns iface in
     begin match ientry with
     | SYMDEF_interface (imap,dirs) ->
       begin match
         (* print_endline "BUILD ENV, COMPARE MODULE EXPR"; *)
         let ienv = build_env dfns counter freg excluded_dirs p in
         match_interface iface dfns counter freg mmap ienv imap excluded_dirs
       with
        | Some binding' -> true
        | None -> false
       end
     | _ -> failwith "Expected interface"
     end
   | _ -> false
   end
 | Functor_set _ -> failwith "Can't compare functor set with single type"
 
and resolve_functor_overload dfns counter freg env excluded_dirs ls m' =
  (* print_endline "RESOLVING FUNCTOR OVERLOAD"; *)
  List.filter
  (fun index -> 
    let id,sr,parent,entry = Hashtbl.find dfns index in
    match entry with 
    | SYMDEF_functor (ps,t,e,nm,dirs) ->
      let t = 
        match List.map snd ps  with
        | [x] -> x
        | x -> TYP_tuple x
      in
      let t = bind_type dfns counter freg env [] excluded_dirs t
      in 
        (* print_endline ("Type of functor signature is " ^ string_of_btypecode dfns t); *)
        compare_module_expr_with_type dfns counter freg excluded_dirs t m'
    | _ -> failwith "Expected FUnctor"
  )
  ls


and copy_entry dfns counter parent binding_list index =
  let index' = !counter in incr counter;
  let id,sr,_,entry = Hashtbl.find dfns index in
  let kind,symdef = 
    match entry with
    | SYMDEF_function (ps,t,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,SYMDEF_function (ps,t,es,table',dirs)
      
    | SYMDEF_procedure (ps,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,SYMDEF_procedure (ps,es,table',dirs)

    | SYMDEF_match_handler (p,u,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,SYMDEF_match_handler (p,u,es,table',dirs)

    | SYMDEF_functor (ps,t,es,table,dirs) ->
      let table' = copy_table dfns counter (Some index') [] table in
      Other,SYMDEF_functor (ps,t,es,table',dirs)

    | SYMDEF_parameter _ ->
      begin try
        let iidx,midx,binding = List.assoc id binding_list in
        Parameter,SYMDEF_module_binding 
        (
          AST_bound_module (sr,(iidx,midx,binding))
        ) 
      with Not_found -> Other,entry
      end
    | _ -> Other,entry
  in
    print_endline 
    (
      "//   " ^ string_of_int index' ^ 
      " -> " ^
      (match kind with 
        | Other -> "copyof " 
        | Parameter -> "binding "
      )^ 
      id ^ "["^string_of_int index^"]: " ^ 
      short_string_of_src sr
    );
    Hashtbl.add dfns index' (id,sr,parent,symdef)
    ;
    index'

and copy_table dfns counter parent binding_list name_map =
  let name_map' = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v -> match v with
    | NonFunctionEntry (Simple i) ->
      let i' = copy_entry dfns counter parent binding_list i in
      Hashtbl.add name_map' k (NonFunctionEntry (Simple i'))
      
    | NonFunctionEntry _ -> 
      failwith "instantiate not expecting bound entry"
    | FunctionEntry ls ->
      let fs = 
        List.map
        (fun e -> match e with
          | Simple i ->
            Simple (copy_entry dfns counter parent binding_list i)
          | _ -> 
            failwith "instantiate not expecting bound entry"
        )
        ls
      in
        Hashtbl.add name_map' k (FunctionEntry fs)
  )
  name_map
  ;
  name_map'

and instantiate_functor 
  dfns counter (freg:instantiation_registry_t)
  sr excluded_dirs findex (m: module_rep_t) 
: module_rep_t =
  (* print_endline "CHECKING FOR FUNCTOR INSTANTIATION"; *)
  try 
    let afidx = Hashtbl.find freg (findex, m) in
    let _,_,_,entry = Hashtbl.find dfns afidx in
    match entry with
    | SYMDEF_module (name_map,dirs) -> Simple_module (afidx,name_map,dirs)
    | _ -> failwith "Expected instantiation to be simple module"
  with Not_found ->
  (* print_endline "INSTANTIATING FUNCTOR"; *)
  let _,_,parent,entry = Hashtbl.find dfns findex in
  let ps,rt,asms,name_map,dirs = 
    match entry with 
    | SYMDEF_functor (ps,rt,asms,name_map,dirs) -> ps,rt,asms,name_map,dirs
    | _ -> failwith "Expected functor"
  in
  let env = build_env dfns counter freg excluded_dirs parent in

  let rec aux ps (m:module_rep_t) : functor_arg_binding_t =
    match m with
    | Bound_module (iindex,impl,binding) ->
      begin match ps with
      | [x] -> [fst x,(iindex,impl,binding)]
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Simple_module (impl,mmap,dirs) -> 
      begin match ps with
      | [x] ->
        let t = bind_type dfns counter freg env [] excluded_dirs (snd x) in
        begin match handle_module_coercion dfns counter freg env sr excluded_dirs m t with
        | Bound_module (iindex,impl,binding)  -> 
          [fst x, (iindex,impl,binding)]
        | _ -> failwith "Expected bound module result" 
        end
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Functor_set _ -> failwith "Expected bound module, got Functor set"
    | Module_product ls -> 
      if List.length ls = List.length ps 
      then List.concat ( List.map2 (fun p m -> aux [p] m) ps ls)
      else failwith "Module product wrong length"

  in 
    let binding = aux ps m in
    let mindex = !counter in incr counter; 
    let mname = "_module_" ^ string_of_int mindex in 
    print_endline 
    (
      "// " ^ string_of_int mindex ^ 
      " -> instance " ^ mname ^ ": " ^ 
      short_string_of_src sr
    );
    Hashtbl.add freg (findex,m) mindex; 
    let mtable = copy_table dfns counter (Some mindex) binding name_map in
    Hashtbl.add dfns mindex (mname,sr,parent, (SYMDEF_module (mtable,dirs))); 
    (*
    print_endline "Instantiated Functor has table:";
    Hashtbl.iter
    (fun k v -> print_endline (" " ^ k ^ " -> " ^ (match v with
      | NonFunctionEntry (Simple i) -> string_of_int i
      | NonFunctionEntry (Bound (i,j)) -> "bound"
      | FunctionEntry ls -> "function overload set"
    )))
    mtable
    ;
    *)
    Simple_module (mindex,mtable,dirs)

and handle_functor_application dfns counter freg env sr excluded_dirs f m =
  (* print_endline "HANDLING FUNCTOR APPLICATION"; *)
  let m' = eval_module_expr dfns counter freg env excluded_dirs m in
  let f' = eval_module_expr dfns counter freg env excluded_dirs f in
  match f' with
  | Functor_set ls ->
    let matches = resolve_functor_overload dfns counter freg env excluded_dirs ls m' in
    begin match matches with
    | [index] -> 
        instantiate_functor dfns counter freg sr excluded_dirs index m'
    | [] -> failwith "No match overloading functor"
    | _ -> failwith "Too many matches overloading functor"
    end

  | _ -> failwith "Expected functor"

and eval_module_expr dfns counter freg env excluded_dirs e : module_rep_t = 
  (* print_endline ("Handling module expression '"^string_of_expression e^"'");  *)
  match e with
  | AST_tuple (sr,es) ->
    Module_product (List.map (eval_module_expr dfns counter freg env excluded_dirs) es)

  | AST_coercion (sr,(m,t)) ->
    handle_coercion dfns counter freg env sr excluded_dirs m t

  | AST_bound_module (sr,(iface,impl,binding)) ->
    Bound_module (iface,impl,binding)

  | AST_apply (sr,(f,m)) ->
    let x = handle_functor_application dfns counter freg env sr excluded_dirs f m in
    (* print_endline "FUNCTOR APPLIED"; *)
    x

  | AST_name (sr,(qn,TYP_none)) ->
    let entries = lookup_qn_in_env dfns counter freg env sr excluded_dirs qn in
    begin match entries with
    | FunctionEntry ls -> 
      let ls = 
        List.map
        (function 
          | Simple index -> 
            let id,sr,parent,entry = Hashtbl.find dfns index in
            begin match entry with
            | SYMDEF_functor _ -> index
            | _ -> 
              failwith 
              (
                "Expected Functor, got : " ^
                string_of_symdef entry id ^ "\nin "^
                short_string_of_src sr
              )
            end
          | Bound _ -> failwith "Not expecting bound entry for functor"
        )
        ls
      in Functor_set ls

    | NonFunctionEntry (Simple index) ->
      let id,sr',parent,entry = Hashtbl.find dfns index in
      begin match entry with
      | SYMDEF_module (table,dirs) -> 
        Simple_module (index,table,dirs)
      | SYMDEF_module_binding e ->
        print_endline "RECURSION?";
        let env' = build_env dfns counter freg excluded_dirs parent in
        eval_module_expr dfns counter freg env' excluded_dirs e
      | _ -> 
        failwith 
        (
          "Expected '" ^ id ^ "' to be module in: " ^
          short_string_of_src sr ^ ", found: " ^
          short_string_of_src sr'
        )
      end
    | _ -> 
      failwith
      (
        "Expected simple non function entry, got binding"
      )
    end

  | _ ->
    failwith "Invalid module expression"

and bind_index dfns counter freg env exclude excluded_dirs index = 
  if List.mem index exclude 
  then failwith (
    "Recursive type alias " ^
    (
      match get_data dfns index with id,sr,_,_ -> 
        id ^ " defined at " ^
        short_string_of_src sr
    )
  )
  else begin match get_data dfns index with
  | _,_,_,SYMDEF_dcl (DCL_type_alias t) -> 
    bind_type dfns counter freg env (index :: exclude) excluded_dirs t

  | _,_,_,SYMDEF_if_type -> BTYP_name index
  | _,_,_,SYMDEF_dcl (DCL_abs _) -> BTYP_name index
  | _,_,_,SYMDEF_dcl (DCL_union _) -> BTYP_name index
  | _,_,_,SYMDEF_dcl (DCL_struct _) -> BTYP_name index
  | _,_,_,SYMDEF_interface _ -> BTYP_name index
  | _,_,_,SYMDEF_module_binding e ->
    let e' = 
      eval_module_expr dfns counter freg env excluded_dirs e
    in 
    begin match e' with
    | Bound_module (iface,impl,binding) -> 
      BTYP_binding (BTYP_name iface, BTYP_name impl)
    | _ -> failwith "Expected module binding expression to be bound module"
    end
  | id,sr,_,entry -> 
    failwith 
    (
      "[bind_index] Type " ^ id ^ 
      " defined at " ^ short_string_of_src sr ^
      " must be abstract, union or struct, got:\n" ^
      string_of_symdef entry id
    )
  end 

and bind_type dfns counter freg env exclude excluded_dirs t : btypecode_t =
  let bt t = bind_type dfns counter freg env exclude excluded_dirs t in
  let dummy_sr = ("type binding",0,0,0,0) in
  let lu qn = lookup_qn_in_env dfns counter freg env dummy_sr excluded_dirs qn in
  match t with
  | TYP_tuple ts -> BTYP_tuple (List.map bt ts)
  | TYP_function (d,c) -> BTYP_function (bt d, bt c)
  | TYP_pointer t -> BTYP_pointer (bt t)
  | TYP_void -> BTYP_void
  | TYP_none -> BTYP_none
  | TYP_name qn ->
    match lu qn with
    | NonFunctionEntry (Bound (i,m)) -> 
      let i = bind_index dfns counter freg env exclude excluded_dirs i in
      let m = bind_index dfns counter freg env exclude excluded_dirs m in
      BTYP_binding (i,m)

    | FunctionEntry _ -> 
      failwith 
      (
        "[bind_types] Expected "^
        string_of_qualified_name qn^
        " to be a type, got function overload set"
      )

    | NonFunctionEntry (Simple index) ->
      bind_index dfns counter freg env exclude excluded_dirs index

and rebind_btype dfns counter freg env excluded_dirs t: btypecode_t =
  let rbt t = rebind_btype dfns counter freg env excluded_dirs t in
  match t with
  | BTYP_name i ->
    let id,sr,parent,entry = Hashtbl.find dfns i in
    begin match entry with
    | SYMDEF_dcl (DCL_type_alias t') ->
      bind_type dfns counter freg env [] excluded_dirs t'
    | _ -> t
    end
  | BTYP_tuple ts -> BTYP_tuple (List.map rbt ts)
  | BTYP_function (a,r) -> BTYP_function (rbt a, rbt r) 
  | BTYP_pointer t -> BTYP_pointer (rbt t)
  | BTYP_void -> BTYP_void
  | BTYP_none -> BTYP_none
  | BTYP_binding (a,b) -> BTYP_binding (rbt a,rbt b)


and base_typename_of_literal v = match v with
  | AST_int (t,_) -> t
  | AST_float (t,_) -> t
  | AST_string _ -> "string"
  | AST_bool _ -> "bool"

and  qualified_typename_of_literal v =
  [""; base_typename_of_literal v]

and  typeof_literal dfns counter freg env sr v : btypecode_t = 
  let t = qualified_typename_of_literal v in
  match lookup_qn_in_env dfns counter freg env sr [] t with
  | NonFunctionEntry (Simple index) -> BTYP_name index
  | _ -> failwith (
      "[type_of_literal] Expected " ^ 
      string_of_qualified_name t ^ 
      " to be simple non function " ^
      short_string_of_src sr
    )

and  typeof_list = function 
  | [x] -> x 
  | x -> TYP_tuple x

and  typlist params = List.map snd params
and  paramtype params = typeof_list (typlist params)

and  sig_of_symdef symdef name = match symdef with 
  | SYMDEF_lazy (_) 
  | SYMDEF_match_check (_) 
  | SYMDEF_match_handler (_,_,_,_,_) -> TYP_tuple[]

  (* primitives *)
  | SYMDEF_dcl (DCL_fun (ps,_,_))
  | SYMDEF_dcl (DCL_proc (ps,_)) -> typeof_list ps

  | SYMDEF_function (ps,_,_,_,_)
  | SYMDEF_procedure (ps,_,_,_) -> paramtype ps

  | SYMDEF_if_fun (t) -> 
    begin match t with
    | TYP_function (a,r) -> a
    | _ -> failwith "[resolve overload] Expected function to have function type"
    end
  | SYMDEF_if_proc (t) -> t
  
  | symdef -> 
    failwith (
      "[resolve_overload] Expected "^
      name
      ^" to be function or procedure, got " ^
     string_of_symdef symdef name 
    )    

and typeofindex 
  (dfns:symbol_table_t) 
  (counter:int ref)
  (freg:instantiation_registry_t)
  (exclude:int list)
  (excluded_dirs:int list)
  (index:int)
: btypecode_t = 
  let id,sr,parent,entry = Hashtbl.find dfns index in

  if List.mem index exclude
  then failwith ("Recursive type dependency for " ^ id);

  (* print_endline "BUILD ENV IN TYPEOFINDEX"; *)
  let env:env_t = build_env dfns counter freg excluded_dirs parent in 
  let bt t:btypecode_t = bind_type dfns counter freg env (index::exclude) excluded_dirs t in
  match entry with

  | SYMDEF_function (ps, rt,_,_,_) -> 
    let pts = List.map snd ps in
    bt (TYP_function (typeof_list pts, rt))

  | SYMDEF_procedure(ps,_,_,_) -> 
    let pts = List.map snd ps in
    bt (TYP_function (typeof_list pts, TYP_void))

  | SYMDEF_if_proc (t) -> 
    bt (TYP_function (t,TYP_void))

  | SYMDEF_dcl (DCL_const (t,_))
  | SYMDEF_parameter t
  | SYMDEF_if_fun (t)
  | SYMDEF_dcl (DCL_val t)
  | SYMDEF_dcl (DCL_var t) -> bt t

  | SYMDEF_dcl (DCL_val_typeof e)
  | SYMDEF_dcl (DCL_var_typeof e) ->
    snd(bind_expression dfns counter freg env (index::exclude) excluded_dirs e)

  | SYMDEF_lazy (e) -> 
    let rt = snd (bind_expression dfns counter freg env (index::exclude) excluded_dirs e) in
    BTYP_function (BTYP_tuple [],rt)


  | SYMDEF_match_check _ ->
    let bool_t = typeof_literal dfns counter freg env sr (AST_bool true) in
    BTYP_function (BTYP_tuple [], bool_t)

  | SYMDEF_match_handler _ ->
    BTYP_function (BTYP_tuple [],BTYP_void)

  | SYMDEF_dcl (DCL_fun (pts,rt,_)) -> 
    bt (TYP_function (typeof_list pts,rt))
    
  | SYMDEF_dcl (DCL_proc (pts,_)) -> 
    bt (TYP_function (typeof_list pts, TYP_void))
    
  | SYMDEF_dcl (DCL_union _)
  | SYMDEF_dcl (DCL_struct _) -> BTYP_name index

  | _ ->
    failwith 
    (
      "[typeofindex] Expected expression term, got " ^
      id ^ " in " ^
      short_string_of_src sr
    )

and cal_apply dfns tbe1 tbe2 : tbexpr_t =
  match tbe1,tbe2 with (_,t1),(_,t2) ->
  let rest =
    match t1 with
    | BTYP_function (argt,rest) ->
      if argt = t2 then rest
      else 
        failwith 
        (
          "[ebind:cal_apply] Function argument " ^
          string_of_bound_expression dfns tbe2 ^
          " has type\n" ^
          string_of_btypecode dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          string_of_btypecode dfns argt 
        )

    (* HACKERY TO SUPPORT STRUCT CONSTRUCTORS *)
    | BTYP_name index -> 
      let _,_,_,entry = Hashtbl.find dfns index in
      begin match entry with
      | SYMDEF_dcl (DCL_struct cs) -> t1
      | _ -> 
        failwith 
        (
          "Attempt to apply non-struct " ^
          string_of_btypecode dfns t1 ^
          " as constructor"
        )
      end
    | _ -> 
      failwith 
      (
        "Attempt to apply non-function type " ^
        string_of_btypecode dfns t1
      )
  in
  (*
  print_endline 
  (
    "---------------------------------------" ^
    "\nApply type " ^ string_of_btypecode dfns t1 ^
    "\nto argument of type " ^ string_of_btypecode dfns t2 ^ 
    "\nresult type is " ^ string_of_btypecode dfns rest ^
    "\n-------------------------------------"
  );
  *)
  BEXPR_apply (tbe1, tbe2),rest

 
and koenig_lookup dfns counter freg sra exclude excluded_dirs id' name_map fn t2 =
  let entries =  
    try Hashtbl.find name_map fn 
    with Not_found -> 
      failwith 
      (
        "Koenig lookup: can't find name "^
        fn^ " in " ^ 
        (match id' with 
        | "" -> "top level module"
        | _ -> "module '" ^ id' ^ "'"
        )
      )
  in 
  match entries with
  | FunctionEntry fs ->
    (* print_endline ("Got candidates: "); List.iter (fun x -> print_endline ("  " ^ string_of_int x)) fs ; *)
    begin match resolve_overload dfns counter freg excluded_dirs fs fn t2 with
    | Some (Simple index'') ->
      (* print_endline "Overload resolution OK"; *)
      BEXPR_closure index'',
      (
        match 
          try typeofindex dfns counter freg exclude excluded_dirs index'' 
          with _ -> failwith "typeofindex failed"
        with
        | BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[bind_expression]: Koenig lookup: closure operator expected '"^
            fn ^"' to be function definition, got '"^
            string_of_btypecode dfns t
            ^"', " ^ short_string_of_src sra
          )
      )
    | Some (Bound _ ) -> failwith "[koenig lookup] Can't handle bound result yet"
    | None ->
        let n = ref 0 
        in Hashtbl.iter (fun _ _ -> incr n) name_map; 
        print_endline ("module defines " ^ string_of_int !n^ " entries");
        failwith 
        (
          "[flx_ebind] Koenig lookup: Can't find match for " ^ fn ^ " in " ^
          short_string_of_src sra
        )
    end
  | NonFunctionEntry _ -> failwith "Koenig lookup expected function"

and lookup_qn_with_sig dfns counter freg sra srn env exclude excluded_dirs qn t2 =    
  match qn with
  | [] -> failwith "empty qualified name"
  | [name] ->
    lookup_name_with_sig dfns counter freg sra srn exclude excluded_dirs env name t2 
  | qn -> 
    let entry = lookup_qn_in_env dfns counter freg env srn excluded_dirs qn in
    let name = string_of_qualified_name qn in
    match handle_entry dfns counter freg sra srn env exclude excluded_dirs entry t2 name with
    | Some result -> result
    | None ->
      failwith 
      (
        "[lookup_qn_with_sig] Can't find match for " ^ string_of_qualified_name qn ^ " in " ^
        short_string_of_src srn ^
        "\nArgtype is " ^ string_of_btypecode dfns t2 
      )

and lookup_name_with_sig dfns counter freg sra srn exclude excluded_dirs env name t2 =
  match env with
  | [] -> 
    failwith 
    (
      "Environment exhasuted: Can't find " ^ name ^ " in " ^
      short_string_of_src srn
    )
  | (table,dirs)::tail ->
    match lookup_name_in_table_dirs table dirs srn name with
    | None -> 
      lookup_name_with_sig dfns counter freg sra srn exclude excluded_dirs tail name t2
    | Some entry -> 
      match handle_entry dfns counter freg sra srn env exclude excluded_dirs entry t2 name with
      | Some x -> x
      | None ->
        lookup_name_with_sig dfns counter freg sra srn exclude excluded_dirs tail name t2

and handle_entry dfns counter freg sra srn env exclude excluded_dirs entry t2 name =
  let be e = bind_expression dfns counter freg env exclude excluded_dirs e in
  let lu sr qn = lookup_qn_in_env dfns counter freg env sr excluded_dirs qn in
  let bt t = bind_type dfns counter freg env [] excluded_dirs t in
  match entry with
  | NonFunctionEntry (Simple index) ->
    Some
    (
      BEXPR_name index, 
      typeofindex dfns counter freg exclude excluded_dirs index
    )
  | NonFunctionEntry _ ->
    failwith "[lookup_qn_with_sig] expected simple nonfunction entry"

  | FunctionEntry fs -> 
    (* print_endline ("Simple overload: function "^name^" found"); *)
    match resolve_overload dfns counter freg excluded_dirs fs name t2 with
    | Some (Bound (i,j) ) -> 
      (* print_endline "[lookup_qn_with_sig] handle opaque function"; *)
      let it =
        match typeofindex dfns counter freg exclude excluded_dirs i with
        | BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[lookup_qn_with_sig]: closure operator expected '"^
            name^"' to be function definition, got '"^
            string_of_btypecode dfns t
            ^"', " ^ short_string_of_src sra
          )
      and mt =
        match typeofindex dfns counter freg exclude excluded_dirs j with
        | BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[lookup_qn_with_sig]: closure operator expected '"^
            name^"' to be function definition, got '"^
            string_of_btypecode dfns t
            ^"', " ^ short_string_of_src sra
          )
      in
        Some
        (
          BEXPR_closure j,
          unify dfns it mt
        )
      
    | Some (Simple index) -> 
      begin 
        match Hashtbl.find dfns index with id,sr,parent,entry 
        -> match entry with
        | SYMDEF_match_check _
        | SYMDEF_function _
        | SYMDEF_dcl(DCL_proc _ )
        | SYMDEF_dcl(DCL_fun _)
        | SYMDEF_procedure _ 
        | SYMDEF_match_handler _ 
        | SYMDEF_lazy _
          ->
          (* print_endline ("closure of " ^ name); *)
          Some
          (
            BEXPR_closure index,
            (
              match typeofindex dfns counter freg exclude excluded_dirs index with
              | BTYP_function _ as t -> t
              | t -> 
                failwith 
                (
                  "[lookup_qn_with_sig]: closure operator expected '"^name^"' to be function definition, got '"^
                  string_of_btypecode dfns t
                  ^"', " ^ short_string_of_src sra
                )
            )
          )
        | _ -> 
          failwith 
          (
            "[lookup_qn_with_sig] Expected function"
          )
      end 

    | None -> None

and print_entry k v = 
  print_endline 
  (
    "  " ^ k ^ 
    (
      match v with 
      | (NonFunctionEntry (Simple i)) -> " Simple " ^ string_of_int i
      | _ -> ""
    )
  )
and print_table htab = 
  print_endline "--"; Hashtbl.iter print_entry htab

and print_env e = List.iter print_table e

and bind_expression dfns counter freg env exclude excluded_dirs e : tbexpr_t = 
  let be e = bind_expression dfns counter freg env exclude excluded_dirs e in
  let lu sr qn = lookup_qn_in_env dfns counter freg env sr excluded_dirs qn in
  let bt t = bind_type dfns counter freg env [] excluded_dirs t in
  (*
  print_endline ("Binding expression " ^ string_of_expression e);
  print_endline ("environment is:");
  print_env env;
  print_endline "==";
  *)
  match e with
  | AST_index (sr,i) -> 
    let t = typeofindex dfns counter freg exclude excluded_dirs i in
    BEXPR_name i,t

  | AST_bound_module _ -> 
    failwith "[Bind_expression] Not expecting bound module"

  | AST_coercion (sr,(m,t)) -> 
    (* print_endline "Value Coercion!"; *)
    let m' = be m in
    (*
    print_endline "Bound src module";
    *)
    let t' = bt t in
    (*
    print_endline "Bound src interface";
    *)
    BEXPR_coercion (m',t'),t'

  | AST_lazy _ -> assert false
  | AST_get_n (sr,(n,e')) -> 
    let expr,typ = be e' in
    let ctyp = match typ with 
    | BTYP_tuple ts -> 
      let len = List.length ts in
      if n<0 or n>len-1
      then failwith 
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1) ^
          " in " ^
          short_string_of_src sr
        )
      else List.nth ts n
    | _ -> 
      failwith 
      (
        "[bind_expression] Expected tuple " ^ 
        string_of_expression e' ^ 
        " to have tuple type, got " ^ 
        string_of_btypecode dfns typ ^
        " in " ^
        short_string_of_src sr
      )
    in 
      BEXPR_get_n (n, (expr,typ)), ctyp
    
  | AST_name (sr,(qn,suf)) -> 
    begin match suf with
    | TYP_none ->
      begin match lu sr qn with
      | NonFunctionEntry (Simple index) -> 
        let t = typeofindex dfns counter freg exclude excluded_dirs index in
        (*
        print_endline 
        (
          "Name " ^ string_of_qualified_name qn ^ 
          " has simple type " ^
          string_of_btypecode dfns t 
        );
        *)
        BEXPR_name index, t

      | NonFunctionEntry Bound(i,m) ->
        let it = typeofindex dfns counter freg exclude excluded_dirs i in
        let mt = typeofindex dfns counter freg exclude excluded_dirs m in
        let t = unify dfns it mt in
        (*
        print_endline 
        (
          "Name " ^ string_of_qualified_name qn ^ 
          " has bound type " ^
          string_of_btypecode dfns t 
        );
        *)
        BEXPR_name m, t


      | FunctionEntry _ -> 
        (* This case should have been handled by bind_expression,
           with case AST_apply (AST_name (...), ...)
        *)
        failwith 
        (
          "unsuffixed name "^
          string_of_qualified_name qn ^
          " must not bind to function (except as first argument of an application or call)" ^
          short_string_of_src sr
        )
      end
    | _ -> 
      let bound_suffix =  bt suf in
      match lu sr qn with
      | NonFunctionEntry _ -> failwith "Suffixed name must bind to function overload set"
      | FunctionEntry fs ->
        let name = string_of_qualified_name qn in
        let suf' = bt suf in
        match resolve_overload dfns counter freg excluded_dirs fs name suf' with
        | Some (Simple index) ->
           BEXPR_closure index, 
           typeofindex dfns counter freg exclude excluded_dirs index

        | Some (Bound (iface,impl)) -> 
           BEXPR_closure impl, 
           BTYP_binding
           (
             typeofindex dfns counter freg exclude excluded_dirs iface,
             typeofindex dfns counter freg exclude excluded_dirs impl
           )

        | None -> 
          failwith 
          (
            "[flx_ebind] Can't find match for " ^ string_of_qualified_name qn ^ " in " ^
            short_string_of_src sr ^ 
            "\nCandidates are " ^
            (String.concat "\n"
              (List.map
                (function Simple i | Bound (i,_)  ->
                  string_of_int i ^ "==> " ^ 
                  string_of_btypecode dfns (typeofindex dfns counter freg [] excluded_dirs i)
                )
                fs
              )
            )
          )
    end

  | AST_ref (srr,AST_name (srn,(qn,suf))) -> 
    begin match lu srn qn with
    | NonFunctionEntry (Simple index) -> 
      let id,sr,parent,entry = Hashtbl.find dfns index in
      begin match entry with
      | SYMDEF_dcl (DCL_var _)
      | SYMDEF_dcl (DCL_var_typeof _)
      | SYMDEF_parameter (TYP_pointer _) -> 
        BEXPR_ref index, 
        BTYP_pointer (typeofindex dfns counter freg exclude excluded_dirs index)
      | SYMDEF_parameter _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          ": Address value parameter " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | SYMDEF_dcl (DCL_val _)
      | SYMDEF_dcl (DCL_val_typeof _) ->
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Can't address a value " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      end
    | NonFunctionEntry _ ->
      failwith
      (
        "[ebind] Expected simple nonfunction entry"
      )
    
    | FunctionEntry _ -> 
      failwith 
      (
        "[bind_expression] " ^
        short_string_of_src srr ^
        ": Address function " ^ string_of_qualified_name qn
      )
    end

  | AST_ref (_,(AST_deref (sr,e))) -> be e
  
  | AST_ref (sr,(AST_dot (_,(e,id)))) ->
    let ref_name = "ref_" ^ id in
    be 
    (
      AST_apply 
      (
        sr,
        (
          name_of_string sr ref_name,
          AST_ref (sr,e)
        )
      )
    )

  | AST_ref (sr,_) -> 
    failwith 
    (
      short_string_of_src sr ^
      ": Can't take address of expression"
    )

  | AST_deref (_,AST_ref (sr,e)) -> be e

  | AST_deref (_,e) -> 
    let e,t = be e in
    begin match t with 
    | BTYP_pointer t -> BEXPR_deref (e,t),t
    | _ -> failwith "Dereference non pointer"
    end

  | AST_literal (sr,v) -> 
    let t = typeof_literal dfns counter freg env sr v in
    BEXPR_literal v, t

  | AST_method_apply (sra,(fn,e2)) -> 
    let be2,t2 = be e2 in
    let tbe1 = 
      begin match t2 with
      | BTYP_name index ->
        let id,sr,parent,entry = Hashtbl.find dfns index in
        begin match parent with
        | None -> failwith "Koenig lookup: No parent for method apply (can't handle global yet)"
        | Some index' ->
          let id',sr',parent',entry' = Hashtbl.find dfns index' in
          match entry' with
          | SYMDEF_module (name_map,dirs) ->
            koenig_lookup dfns counter freg sra exclude excluded_dirs id' name_map fn t2

          | SYMDEF_interface (name_map,dirs) ->
            koenig_lookup dfns counter freg sra exclude excluded_dirs id' name_map fn t2

          | _ -> failwith ("Koenig lookup: parent for method apply not module")
        end
      | _ -> failwith "apply method to nongenerative type"
      end
    in
      cal_apply dfns tbe1 (be2, t2)

  | AST_apply (sra,(AST_name (srn,(qn,typ)),e2)) -> 
    let be2,t2 = be e2 in
    let typ' = bind_type dfns counter freg env [] excluded_dirs typ in
    if typ' <> BTYP_none && t2 <> typ'
    then 
      failwith 
      (
        "Type suffix doesn't agree with argument in " ^
        short_string_of_src sra
      )
    else 
      let tbe1 =
        lookup_qn_with_sig dfns counter freg sra srn env exclude excluded_dirs qn t2 
      in cal_apply dfns tbe1 (be2,t2)

  | AST_apply (_,(e1,e2)) -> 
    let tbe1 = be e1 and tbe2 = be e2 in
    cal_apply dfns tbe1 tbe2 

  | AST_tuple (_,es) -> 
    let bets = List.map be es in
    let _, bts = List.split bets in
    BEXPR_tuple bets, BTYP_tuple bts

  | AST_dot (sr,(e,id)) ->
    let get_name = "get_" ^ id in
    be (AST_method_apply (sr,(get_name,e)))

  | AST_match_ctor (sr,(qn,e)) ->
    let ctor, prefix = match List.rev qn with 
      | h::t -> h,List.rev t 
      | [] -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src sr ^
          ": Empty qualified name in AST_match_ctor"
        )
    in
    (* print_endline ("Matching ctor " ^ string_of_qualified_name qn ^
      " with " ^ string_of_expression e
    );
    *)
    be (AST_apply (
      sr,
      (
        AST_name (sr,(prefix @ ["_match_ctor_" ^ ctor],TYP_none)),
        e
      )
    ))
    
  | AST_ctor_arg (sr,(qn,e)) ->
   let ctor, prefix = match List.rev qn with 
     | h::t -> h, List.rev t 
     | [] -> 
       failwith 
       (
        "[bind_expression] " ^
         short_string_of_src sr ^
         ": Empty qualified name in AST_ctor_arg"
       )
    in
    be (AST_apply (sr,
      (
        AST_name (sr,(prefix @ ["ctor_arg_" ^ ctor],TYP_none)),
        e
      )
    ))
   
  | AST_lambda (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "[Compiler error] Unexpected lambda binding expression"
    )

and resolve_overload dfns counter freg excluded_dirs fs name (suf : btypecode_t) =
  let rec resolve i =
    match Hashtbl.find dfns i with (id,sr,parent,symdef) ->
    parent,i,sig_of_symdef symdef id
  in
  let rec aux i =  
    match i with
    | Simple i -> 
      let p,i,t = resolve i in
      let env = build_env dfns counter freg excluded_dirs p in
      let t = bind_type dfns counter freg env [] excluded_dirs t in
      Unique (i,t)

    | Bound (i,j) ->
      let p,i,t = resolve i in
      let env = build_env dfns counter freg excluded_dirs p in
      let t = bind_type dfns counter freg env [] excluded_dirs t in
      Pair ((i,t),j)
  in
  let fun_defs = List.map aux fs in
  match 
    let lift_suf = lift suf in
    List.filter 
    (fun result -> match result with
      | Unique (_,t) 
      | Pair ((_,t),_) -> 
        lift t = lift_suf
    ) 
    fun_defs
  with 
  | [Unique (i,_)] -> 
    (*
    print_endline ("..resolved to basic function " ^ string_of_int i); 
    *)
    Some (Simple i)

  | [Pair ((i,_),j)] ->
    (*
    print_endline (
      "..resolved to binding " ^ string_of_int i ^
      " ==> " ^ string_of_int j
    ); 
    *)
    Some (Bound (i,j))

  | [] -> None

  | _ -> failwith ("Too many candidates match in overloading " ^ name)
  

(* an environment is a list of hastables, mapping
   names to definition indicies. Each entity defining
   a scope contains one hashtable, and a pointer to
   its parent, if any. The name 'top' is special,
   it is the name of the single top level module
   created by the desugaring phase. We have to be
   able to find this name, so if when we run out
   of parents, which is when we hit the top module,
   we create a parent name map with a single entry
   'top'->NonFunctionEntry 0. 
*)
and get_table_dirs_of_index dfns index = 
  match get_data dfns index with
  | (id,sr,parent,entry) ->
    let table,dirs = 
      match entry with
      | SYMDEF_module (table,dirs) -> table,dirs
      | SYMDEF_interface (table,dirs) -> table,dirs
      | SYMDEF_function (ps,t,e,table,dirs) -> table,dirs
      | SYMDEF_match_handler (pat,ex,e,table,dirs) -> table,dirs
      | SYMDEF_procedure (ps,e,table,dirs) -> table,dirs
      | SYMDEF_lazy _ -> Hashtbl.create 97,[]
      | SYMDEF_match_check _ -> Hashtbl.create 97,[]

      | SYMDEF_functor (_,_,_,table,dirs) -> table,dirs
      | SYMDEF_module_binding _ -> failwith "[build_env] Can't handle module binding"
      | SYMDEF_if_fun _ -> failwith "Can't look into function dcl"
      | SYMDEF_if_proc _ -> failwith "Can't look into proc dcl"
      | SYMDEF_if_type -> failwith "Can't look into type"
      | SYMDEF_parameter _ -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup function, procedure or module as parent, got parameter "^id^"??"
        )
      | SYMDEF_dcl d -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup of requires function, procedure or module as parent, got " ^ id
        )
    in parent,table,dirs

and build_env' dfns counter freg parent : (name_map_t * qualified_name_t list) list =
  match parent with
  | None -> []

  | Some index ->
     let parent,table,dirs = get_table_dirs_of_index dfns index in
     let qns = 
       List.concat
       (
         List.map
         (fun x -> match x with 
           | DIR_open qn -> [qn]
         )
         dirs
       )
     in
       (table,qns) :: build_env' dfns counter freg parent

and map_dir dfns counter freg (env:env_t) excluded_dirs qn : name_map_t =
  (* print_endline ("Mapping open " ^ string_of_qualified_name qn); *)
  let sr = ("dummy",0,0,0,0) in
  let result = lookup_qn_in_env dfns counter freg env sr excluded_dirs qn in
  match result with
  | NonFunctionEntry (Simple i) ->
    begin match Hashtbl.find dfns i with
    | _,_,_,SYMDEF_module (table,_) -> table
    | _,_,_,SYMDEF_module_binding e -> 
      (* print_endline "map_dir got module binding"; *)
      if not (List.mem i excluded_dirs)
      then
        begin match eval_module_expr dfns counter freg env (i::excluded_dirs) e with 
        | Module_product _ ->
          failwith "Unexpected module product"

        | Functor_set _ ->
          failwith "Unexpected Functor"

        | Simple_module (impl, htab,dirs) ->
          htab
        | Bound_module (iface,impl,binding) ->
          (* print_endline "processing bound module"; *)
          let _,_,_,entry = Hashtbl.find dfns iface in
          begin match entry with 
          | SYMDEF_interface (table,dirs) ->
            (* print_endline "APPLYING BINDING"; *)
            apply_binding table binding
          | _ -> failwith "Expected interface"
          end
        end
      else begin
        (* print_endline ("DUMMY TABLE CREATED FOR EXCLUDED OPEN " ^ string_of_int i); *)
        Hashtbl.create 97
      end

    | _ -> failwith "[map_dir] Expected module"
    end
  | NonFunctionEntry _ -> failwith "Can't open binding yet"
  | _ -> failwith "Expected module!"

and build_env dfns counter freg excluded_dirs parent : env_t =
  let basic_env = build_env' dfns counter freg parent in
  let rec resolve_dirs env =
    match env with
    | [] -> []
    | (table,dirs)::tail ->
      let base = resolve_dirs tail in
      let bound_dirs = 
        List.map
        (map_dir dfns counter freg ((table,[])::base) excluded_dirs)
        dirs
      in
        (table,bound_dirs) ::base
   in 
     resolve_dirs basic_env



