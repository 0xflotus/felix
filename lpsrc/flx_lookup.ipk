@head(1,"Name Lookup")
There are some tricky issues with the name binding
rules. First, name binding is complicated by the fact
we support overloading. This defeats a simple linear
binding scheme: instead, we need to bind the type
of the argument of the application of a named function.
@p()
In addition, felix provides simple first order
generics by allowing declared name to be parameterised
by types.
@p()
There are two names then: simple and indexed.
Indexed names must of course refer to declarations
with the right number of parameters.
@p()
However, a non-indexed name may refer to a non-generic
entity, or, refer to a local generic entity, in which
case the arguments are just the list of parameter names.
@p()
Actually we can further generalise because of nesting.
Name binding consists of uniquely identifying
every name, and replacing the concrete name with
its canonical representation. Each declared name 
is number in order of writing, and takes type
parameters in a single list which is the concatenation
of the visible parameters in order of writing, in
other words starting with the outermost construction:
we can assume all names are parameterised by a list
of types, modeling non-generic names as if they had
0 type parameters.
@p()
We need to note now how our code is driven.
We start with certain non-genertc root functions,
and recurse through the call structure. In the root
of course, the type arguments used for a name must
selves be monomorphic (free of type variables),
so the binding itself is monomorphic.
@p()
What this all means is that routines like
bind_type and bind_expression are always accepting
and returning monomorphic data. What all this
means is that the indexing scheme never needs any
bound type variables: a name denoting a type parameter
is always being replaced by a monotype directly,
without any need to first go to variables and then
instantiate them.
@p()
Hmm .. messy .. consider:
@begin_displayed_code()
val x0 = 1;
module p1[t1] {
  val x1 = x0;
  module p2[t2] {
    va1 x2a = x1 + x2; // x1[t1] + x2[t1,t2]
    va1 x2b = x1 + p2[int]::x2; // x1[t1] + x2[t1,int]

  .. fine .. but the equivalent function structure:

val x0 = 1;
proc p1[t1]() {
  val x1 = x0;
  proc p2[t2]() {
    va1 x2a = x1 + x2; // x1[t1] + x2[t1,t2]
    // explicit indexing here is not allowed
    // for *variables* since
    // we have to refer to a a stack from on
    // the display which has fixed type
    // parameters .. but it IS allowed for
    // enclosed types (since type are static ..)
@end_displayed_code()
SUMMARY .. the total number of variables needed to
instaniate a name is the length of the list
of the concatenation of the type vaiable lists
of the entities ancestors including itself.
If any indexes are given explicitly, they're
always most local, and replace the last so many
bindings from context. Note the number of *implicit*
variables needed may be less than those given
if the name is defined in a parent: in this case
we just take first part of the argument list.
@p()
With this mechanism a simply list of bound
type indices suffices provided when a lookup
is done we calculate how many values are needed.
@p()
Hmm: this may cause a LOT of pain, if we're looking
up generic functions .. since we assumed the lookup
could select on the number of arguments .. well,
it can, by adjusting as the search deepens .. nice!
@p()
Technology: given an index i, find its vs list including
that of its parents (string -> int) form.

@h = tangler("src/flx_lookup.mli")
@select(h)
open Flx_ast
open Flx_types

val build_env:
  sym_state_t ->
  int list -> (* excluded modules *)
  int option -> (* parent *)
  env_t

val lookup_name_in_env :
  env_t ->
  range_srcref ->
  id_t -> 
  entry_set_t

val lookup_qn_in_env :
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  qualified_name_t -> 
  entry_kind_t * typecode_t list

val lookup_sn_in_env :
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  suffixed_name_t -> 
  int * btypecode_t list

(** This routine takes an unbound type term 
and binds it. The term may contain explicit
type variables. If the term denotes a generative
type (abstract, union, or struct) then an instance
is made with type variables for the indices.

Note that the result of binding a term with type
variables is not a type function.
*)

val bind_type:
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  range_srcref ->
  typecode_t ->
  btypecode_t

val eval_module_expr:
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  expr_t ->
  module_rep_t

val resolve_overload:
  sym_state_t ->
  int list -> (* excluded modules *)
  range_srcref ->
  entry_kind_t list ->  
  id_t -> 
  btypecode_t ->
  btypecode_t list ->      (* explicit param/arg bindings *)
  (entry_kind_t * btypecode_t * (int * btypecode_t) list * btypecode_t list) option

val bind_expression :
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  expr_t ->
  tbexpr_t

val typeofindex :
  sym_state_t ->
  int list -> (* excluded modules *)
  int ->
  btypecode_t

val typeofindex_with_ts:
  sym_state_t ->
  int list -> (* excluded modules *)
  int ->
  btypecode_t list ->
  btypecode_t

val typeof_literal:
  sym_state_t ->
  env_t ->
  range_srcref ->
  literal_t ->
  btypecode_t

val lookup_qn_with_sig:
  sym_state_t ->
  range_srcref ->
  range_srcref ->
  env_t ->
  int list ->
  int list ->
  qualified_name_t ->
  btypecode_t ->
  tbexpr_t

val print_env: (* debugging *)
  env_t -> unit

val bind_regdef:
  sym_state_t ->
  env_t ->
  int list ->
  int list ->
  int list ->
  regexp_t ->
  regexp_t

@h = tangler("src/flx_lookup.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_exceptions
open Flx_mtypes
open Flx_typing
open List
open Flx_srcref
open Flx_unify
open Flx_beta
open Flx_generic
open Flx_name

exception Found of int
exception Tfound of btypecode_t

type overload_result = 
 int *  (* index of function *)
 btypecode_t * (* type of function signature *)
 (int * btypecode_t) list * (* mgu *)
 btypecode_t list (* ts *)

type result = 
  | Unique of overload_result
  | Pair of overload_result * int
  | Fail

type kind_t = Parameter | Other

let print_env e = 
  let print_entry k v = 
    print_endline 
    (
      "  " ^ k ^ 
      (
        match v with 
        | (NonFunctionEntry (Simple i)) -> " Simple " ^ string_of_int i
        | _ -> ""
      )
    )
  in 
  let print_table htab = 
    print_endline "--"; Hashtbl.iter print_entry htab

  in 
  let print_level (htab,htabs) = print_table htab in 

  List.iter print_level e

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_lookup.get_data] No definition of <" ^ string_of_int index ^ ">")

let lookup_name_in_htab htab name : entry_set_t option =
  (* print_endline ("Lookup name in htab: " ^ name); *)
  try Some (Hashtbl.find htab name)
  with Not_found -> None
  
let merge_functions 
  (opens:entry_set_t list) 
  name 
: entry_kind_t list = 
  List.fold_left
    (fun init x -> match x with
    | FunctionEntry ls -> init @ ls
    | _ -> failwith ("Expected " ^ name ^ " to be function overload set in all open modules")
    )
  []
  opens

let lookup_name_in_table_dirs table dirs sr name : entry_set_t option =
  (* print_endline ("Lookup name " ^ name ^ " in table dirs");*)
  flush stdout;
  match lookup_name_in_htab table name with
  | Some x as y -> 
    y
  | None ->
    flush stdout;
  let opens = 
    List.concat
    (
      List.map
      (fun table -> 
        match lookup_name_in_htab table name with
        | Some x -> [x]
        | None -> [] 
      )
      dirs
    )
  in match opens with
  | [x] -> Some x
  | FunctionEntry ls :: rest ->
    Some (FunctionEntry (merge_functions opens name))

  | (NonFunctionEntry _)::_ -> 
    (* FIX: it might not be so! Could be two typedefs
      of the same thing, later, when I implement it,
      injected names
    *)
    clierr sr ("Conflicting values for "^name ^" found in open modules")
  | [] -> None

let lookup_name_in_env (env:env_t) sr name : entry_set_t =
  (* print_endline "Lookup name in env"; *)
  let rec aux env = 
    match env with 
    | [] -> None
    | (table,dirs) :: tail ->
      match lookup_name_in_table_dirs table dirs sr name with
      | Some x as y -> y
      | None -> aux tail
  in 
    match aux env with
    | Some x -> 
      (* print_endline ("Found name "^name^" in env"); flush stdout; *) 
      x
    | None ->
      clierr sr 
      (
        "[lookup_name_in_env]: Name '" ^ 
        name ^ 
        "' not found in environment (depth "^
        string_of_int (List.length env)^ ")" 
      )

let lookup_in_bound_module 
  dfns iface binding sr 
  (t:string) 
: entry_set_t option  =
  match get_data dfns iface with
  | { pubmap=table;dirs=dirs;symdef=`SYMDEF_interface} ->
    let src = lookup_name_in_htab table t  in
    begin match src with
    | None -> None
    | Some x -> match x with
    | NonFunctionEntry (Simple ix) ->
      let dst = Hashtbl.find binding ix in
      Some (NonFunctionEntry (Bound (ix,dst)))

    | NonFunctionEntry _ ->
      failwith
      (
        "[lookup_qn_in_bound_module] Expected simple nonfunction entry got binding"
      )
    | FunctionEntry ls ->
      let ns = ref [] in
      List.iter
      (fun ix ->
        match ix with
        | Simple ix ->
          let dst = Hashtbl.find binding ix in
          ns := Bound (ix,dst) :: !ns;
          (* print_endline (string_of_int ix ^ " ==> " ^ string_of_int dst) *)
        | _ -> failwith "Woops, expected Simple"
      )
      ls
      ;
      Some (FunctionEntry !ns)
    end

  | _ -> 
    failwith "Lookup in bound module expected interface"

(* This routine looks up a qualified name in the
   environment and returns an entry_set_t:
   can be either non-function or function set
*)

let rec lookup_qn_in_env2
  syms
  (env:env_t) 
  excluded_dirs
  (qn: qualified_name_t)
  : entry_set_t * typecode_t list
=
  match qn with
  | `AST_void _ -> failwith "[lookup_qn_in_env2] qualified name is void"
  | `AST_case_tag _ -> failwith "[lookup_qn_in_env2] Can't lookup a case tag"
  | `AST_typed_case _ -> failwith "[lookup_qn_in_env2] Can't lookup a typed case tag"

  | `AST_name (sr,name,ts) -> 
    lookup_name_in_env env sr name, ts

  | `AST_lookup (sr,(me,name,ts)) ->
    match eval_module_expr syms env excluded_dirs me with 
    | Module_product _ ->
      failwith "Unexpected module product"

    | Functor_set _ ->
      failwith "Unexpected Functor"

    | Simple_module (impl, htab,dirs) ->
      begin try Hashtbl.find htab name, ts
      with Not_found -> 
        failwith
        (
          "[lookup_qn_in_env2] Can't find " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      end

    | Bound_module (iface,impl,binding) ->
      match lookup_in_bound_module syms.dfns iface binding sr name with
      | None -> 
        failwith 
        (
          "[lookup_qn_in_env2] Can't find " ^ 
          string_of_qualified_name qn ^
          " in\n" ^
          short_string_of_src sr
        )
      | Some x -> x,ts

and lookup_qn_in_env 
  syms
  (env:env_t) 
  excluded_dirs
  (qn: qualified_name_t)
  : entry_kind_t  * typecode_t list
=
  match lookup_qn_in_env2 syms env excluded_dirs qn with
    | NonFunctionEntry x,ts -> x,ts
    | FunctionEntry _,_ ->
      failwith 
      (
        "[lookup_qn_in_env] Not expecting " ^ 
        string_of_qualified_name qn ^
        " to be function set"
      )

and lookup_sn_in_env 
  syms
  (env:env_t) 
  excluded_dirs
  (sn: suffixed_name_t)
  : int * btypecode_t list
= 
  let sr = src_of_expr (sn:>expr_t) in
  let bt t = bind_type syms env excluded_dirs sr t in
  match sn with
  | #qualified_name_t as x ->
    begin match
      lookup_qn_in_env syms env excluded_dirs x
    with
    | Simple index,ts -> index,map bt ts
    | Bound _,_ -> failwith "Expecting simple entry"
    end

  | `AST_suffix (sr,(qn,suf)) ->
    let bsuf = bind_type syms env excluded_dirs sr suf in
    (* OUCH HACKERY *)
    let (be,t) = 
      lookup_qn_with_sig'
      syms 
      sr sr 
      env [] [] 0 excluded_dirs 
      qn bsuf
    in match be with
    | `BEXPR_name (index,ts) -> 
      index,ts
    | `BEXPR_closure (index,ts) -> index,ts

    | _ -> failwith "Expected expression to be index"

(* This routine binds a type expression to a bound type expression.
   Note in particular that a type alias is replaced by what
   it as an alias for, recursively so that the result 
   globally unique

   if params is present it is a list mapping strings to types
   possibly bound type variable

   THIS IS WEIRD .. expr_fixlist is propagated, but 'depth'
   isn't. But the depth is essential to insert the correct
   fixpoint term .. ????

   i think this arises from:

   val x = e1 + y;
   val y = e2 + x;
 
   here, the implied typeof() operator is used
   twice: the first bind expression invoking a second
   bind expression which would invoke the first again ..
   here we have to propagate the bind_expression
   back to the original call on the first term,
   but we don't want to accumulate depths? Hmmm...
   I should test that ..
   
*)
and bind_type syms env excluded_dirs sr t : btypecode_t =
  (*
  print_endline ("[bind_type] " ^ string_of_typecode t);
  *)
  let t:btypecode_t = 
    bind_type' syms env [] [] [] [] 0 excluded_dirs sr 
    t []
  in
  (*
  print_endline ("Bound type= " ^ sbt syms.dfns t);
  *)
  let t = beta_reduce syms [] t 
  in
    (*
    print_endline ("Beta reduced type= " ^ sbt syms.dfns t);
    *)
    t 

and bind_expression syms env excluded_dirs e  =
 bind_expression' syms env [] [] 0 excluded_dirs e 


(* =========================================== *)
(* INTERNAL BINDING ROUTINES *)
(* =========================================== *)

(* RECURSION DETECTORS

There are FOUR type recursion detectors:

idx_fixlist is a list of indexes, used by
bind_index to detect a recursion determining
the type of a function or variable:
the depth is calculated from the list length:
this arises from bind_expression, which uses
bind type : bind_expression is called to deduce
a function return type from returned expressions

TEST CASE:
  val x = (x,x) // type is ('a * 'a) as 'a

RECURSION CYCLE: 
  typeofindex' -> bind_type'

type_alias_fixlist is a list of indexes, used by
bind_type_index to detect a recursive type alias,
[list contains depth]

TEST CASE:
  typedef a = a * a // type is ('a * 'a) as 'a


RECURSION CYCLE:
  bind_type' -> type_of_type_index
  
as_fixlist is a list of (name,depth) pairs, used by
bind_type' to detect explicit fixpoint variables
from the TYP_as terms (x as fv)
[list contains depth]

TEST CASE:
  typedef a = b * b as b // type is ('a * 'a) as 'a

RECURSION CYCLE:
  typeofindex' -> bind_type'

expr_fixlist is a list of (expression,depth)
used by bind_type' to detect recursion from
typeof(e) type terms
[list contains depth]

TEST CASE:
  val x: typeof(x) = (x,x) // type is ('a * 'a) as 'a

RECURSION CYCLE:
  bind_type' -> bind_expression'

TRAP NOTES: 
  idx_fixlist and expr_fixlist are related :(

  The expr_fixlist handles an explicit typeof(expr)
  term, for an arbitrary expr term.

  idx_fixlist is initiated by typeofindex, and only
  occurs typing a variable or function from its
  declaration when the declaration is omitted
  OR when cal_ret_type is verifying it

BUG: cal_ret_type is used to verify or compute function
return types. However the equivalent for variables
exists, even uninitialised ones. The two cases
should be handled similarly, if not by the same
routine.

Note it is NOT a error for a cycle to occur, even
in the (useless) examples:

   val x = x;
   var x = x;

In the first case, the val simply might not be used.
In the second case, there may be an assignment.
For a function, a recursive call is NOT an error
for the same reason: a function may
contain other calls, or be unused:
  fun f(x:int)= { return if x = 0 then 0 else f (x-1); }
Note two branches, the first determines the return type
as 'int' quite happily.

DEPTH:
  Depth is used to determine the argument of the
  fixpoint term.

  Depth is incremented when we decode a type
  or expression into subterms.

PROPAGATION.
It appears as_fixlist can only occur 
binding a type expression, and doesn't propagate
into bind_expression when a typeof() term is
part of the type expression: it's pure a syntactic
feature of a localised type expression.

  typedef t = a * typeof(x) as a;
  var x : t;

This is NOT the case, for example:

  typedef t = a * typeof (f of (a)) as a;

shows the as_fixlist label has propagated into
the expression: expressions can contain type
terms. However, the 'as' label IS always
localised to a single term.

Clearly, the same thing can happen with a type alias:

  typedef a = a * typeof (f of (a));

However, type aliases are more general because they
can span statement boundaries:

  typedef a = a * typeof (f of (b));
  typedef b = a;

Of course, it comes to the same thing after
substitution .. but lookup and binding is responsible
for that. The key distinction is that an as label
is just a string, whereas a type alias name has
an index in the symtab, and a fully qualified name
can be used to look it up: it's identifid by
its index, not a string label: OTOH non-top level
as labels don't map to any index.

NASTY CASE: It's possible to have this kind of thing:

  typedef a = typeof ( { typedef b = a; return x; } )

so that a type_alias CAN indeed be defined inside a type
expression. That alias can't escape however. In fact,
desugaring restructures this with a lambda (or should):

  typedef a = typeof (f of ());
  fun f() { typedef b = a; return x; }

This should work BUT if an as_label is propagated
we get a failure:

  typedef a = typeof ( { typedef c = b; return x; } ) as b;

This can be made to work by lifting the as label too,
which means creating a typedef. Hmmm. All as labels 
could be replaced by typedefs ..


MORE NOTES:
Each of these traps is used to inject a fixpoint
term into the expression, ensuring analysis terminates
and recursions are represented in typing.

excluded_dirs is also a recursion trap, but of a different
kind, it is used by the lookup routines to ensure when
attempting to open a module, that the lookup of the module
name doesn't recursively try to open the module whose name
is being looked up .. if you can follow that :-)

It is sometimes a bit tricky to know when to pass, and when
to reset these detectors: in bind_type' and inner
bind_type of a subterm should usually pass the detectors
with a pushed value in appropriate cases, however and
independent typing, say of an instance index value,
should start with reset traps.

*)

(*
  we match type patterns by cheating a bit:
  we convert the pattern to a type, replacing
  the _ with a dummy type variable. We then
  record the 'as' terms of the pattern as a list
  of equations with the as variable index
  on the left, and the type term on the right:
  the RHS cannot contain any as variables.

  The generated type can contain both,
  but we can factor the as variables out
  and leave the type a function of the non-as
  pattern variables
*)

and type_of_tpattern syms p : 
  typecode_t * 
  (int * string) list *     (* variables found *)
  (int * typecode_t) list   (* as terms *)
= 
  let sr = "unk",0,0,0,0 in
  let vars = ref [] in
  let eqns = ref [] in
  let rec tp p = 
    match p with
    | `TPAT_function (a,b) -> `TYP_function (tp a, tp b)
    | `TPAT_tuple ps -> `TYP_tuple (map tp ps)
    | `TPAT_sum ps -> `TYP_sum (map tp ps)
    | `TPAT_pointer p -> `TYP_pointer (tp p)
    | `TPAT_name (n,ps) -> `AST_name (sr,n,map tp ps)
    | `TPAT_void -> `AST_void sr

    | `TPAT_var n -> 
      let j = !(syms.counter) in 
      incr (syms.counter); 
      vars := (j,n) :: !vars;
      `TYP_var j 

    | `TPAT_any -> 
      let j = !(syms.counter) in 
      incr (syms.counter); 
      `TYP_var j

    | `TPAT_as (t,n) ->
      let t = tp t in
      let j = !(syms.counter) in 
      incr (syms.counter); 
      vars := (j,n) :: !vars;
      eqns := (j,t) :: !eqns;
      t
  in 
    let t = tp p in
    t,!vars, !eqns

(* params is list of string * bound type *)

and bind_type' 
  syms env 
  idx_fixlist type_alias_fixlist as_fixlist expr_fixlist depth 
  excluded_dirs 
  sr t params
: btypecode_t =
  let btp t params = bind_type' syms env 
    idx_fixlist type_alias_fixlist as_fixlist expr_fixlist (depth+1) 
    excluded_dirs sr t params 
  in
  let bt t = btp t params in
  let bi i ts = bind_type_index syms 
    idx_fixlist type_alias_fixlist as_fixlist expr_fixlist depth 
    excluded_dirs sr i ts 
  in
  (*
  print_endline ("[bind_type'] " ^ string_of_typecode t);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  (*
  if length params <> 0 then
  begin
    print_endline ("  [" ^
    catmap ", " 
    (fun (s,t) -> s ^ " -> " ^ sbt syms.dfns t)
    params
    ^ "]"
    )
  end else print_endline  ""
  ;
  *)
  let t = 
  match t with

  (* We first attempt to perform the match
    at binding time as an optimisation, if that
    fails, we generate a delayed matching construction.
    The latter will be needed when the argument is a type
    variable.
  *)
  | `TYP_type_match (t,ps) ->
    let t = bt t in
    (*
    print_endline ("Typematch " ^ sbt syms.dfns t);
    *)
    let pts = ref [] in
    begin try 
      iter
      (fun (p',t') ->
        let p',vars,eqns = type_of_tpattern syms p' in
        (*
        print_endline ("Type of pattern is " ^ string_of_typecode p');
        *)
        let p' = bt p' in
        (*
        print_endline ("Bound Type of pattern is " ^ string_of_btypecode syms.dfns p');
        *)
        let eqns = map (fun (j,t) -> j, bt t) eqns in
        let u = maybe_unification syms.dfns [p', t] in
        match u with
        | Some mgu 
          when not (var_list_occurs (map fst mgu) t) ->
          (*
          print_endline "UNIFIED";
          *)
          (* bind the subterms of 'as' patterns,
            substituting in any variables found
          *)
          let eqns = 
            map 
            (fun (j,t) -> j, list_subst mgu t) 
            eqns 
          in

          (* join up the lists of variable assignments *)
          let args = mgu @ eqns in

          (* replace the variable index with its string name *)
          let args' = ref [] in
          iter
          (fun (j,t) -> 
            try args' := (assoc j vars,t) :: !args'
            with Not_found -> ()
          ) 
          args 
          ;
          let args = !args' in

          (* bind the result type, substituting the variables out *)
          let t' = btp t' args in
          raise (Tfound t')

        | Some _
        | None -> 
          (*
          print_endline "Not unified";
          *)
          let args = map (fun (i,s) -> s,`BTYP_var i) vars in
          let t' = btp t' args in
          let t' = list_subst eqns t' in
          pts := (p',t') :: !pts
      )
      ps
      ;
      `BTYP_type_match (t,rev !pts)
      (* clierr sr "[bind_type] typematch failure" *)

    with 
    | Tfound t -> t
    end

  | `TYP_dual t ->
    let t = bt t in
    dual t

  | `TYP_proj (i,t) -> 
    let t = bt t in
    begin match unfold t with 
    | `BTYP_tuple ls ->
      if i < 1 or i>List.length ls
      then 
        failwith 
        (
          short_string_of_src sr ^
          "\nproduct type projection index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (List.length ls)
        )
      else List.nth ls (i-1)

    | _ -> 
      failwith 
      (
        short_string_of_src sr ^
        "\ntype projection requires product type"
      )
    end

  | `TYP_dom t -> 
    let t = bt t in 
    begin match unfold t with
    | `BTYP_function (a,b) -> a
    | _ ->
      failwith 
      (
        short_string_of_src sr ^
        "\ntype domain requires function" 
      )
    end
  | `TYP_cod t -> 
    let t = bt t in 
    begin match unfold t with
    | `BTYP_function (a,b) -> b
    | _ ->
      failwith 
      (
        short_string_of_src sr ^
        "\ntype codomain requires function" 
      )
    end

  | `TYP_case_arg (i,t) ->
    let t = bt t in
    begin match unfold t with
    | `BTYP_sum ls ->
      if i < 1 or i>List.length ls
      then 
        failwith 
        (
          short_string_of_src sr ^
          "\nsum type extraction index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (List.length ls)
        )
      else List.nth ls (i-1)

    | _ -> 
      failwith 
      (
        short_string_of_src sr ^
        "\nsum type extraction requires sum type"
      )
    end

 
  | `TYP_none ->  
    failwith "Unexpected `TYP_none in bind type"

  | `TYP_var i ->  `BTYP_var i
  | `TYP_as (t,s) -> 
    bind_type' syms env 
    idx_fixlist type_alias_fixlist 
    ((s,depth)::as_fixlist) expr_fixlist depth 
    excluded_dirs sr t params

  | `TYP_typeof e ->
    (*
    print_endline ("Evaluating typeof(" ^ string_of_expr e ^ ")");
    *)
    let t =
      if List.mem_assq e expr_fixlist
      then begin
        let outer_depth = List.assq e expr_fixlist in
        let fixdepth = outer_depth -depth in
        (*
        print_endline ("OUTER DEPTH IS " ^ string_of_int outer_depth);
        print_endline ("CURRENT DEPTH " ^ string_of_int depth);
        print_endline ("FIXPOINT IS " ^ string_of_int fixdepth);
        *)
        `BTYP_fix fixdepth
      end
      else 
        snd(bind_expression' syms env [] expr_fixlist depth excluded_dirs e)
    in 
      (*
      print_endline ("typeof --> " ^ sbt syms.dfns t);
      *)
      t

  | `TYP_array (t1,t2)-> 
    `BTYP_array (bt t1, bt t2)

  | `TYP_tuple ts -> 
    let ts' =List.map bt ts  in
    `BTYP_tuple ts'

  | `TYP_sum ts -> 
    let ts' =List.map bt ts  in
    `BTYP_sum ts'

  | `TYP_function (d,c) -> 
    let 
      d' = bt d  and 
      c' = bt c 
    in 
      `BTYP_function (bt d, bt c)

  | `TYP_pointer t -> 
     let t' = bt t in 
     `BTYP_pointer t'

  | `AST_void _ -> 
    `BTYP_void

  | `TYP_typefun (ps,r,body) -> 
    let data = 
      List.rev_map 
      (fun x -> 
        fst x, 
        bt (snd x), 
        let n = !(syms.counter) in 
        incr (syms.counter); 
        n
      ) 
      ps 
    in
    let pnames =  (* reverse order .. *)
      List.map (fun (n, t, i) -> (n,`BTYP_var i)) data 
    in
    let bbody = 
      bind_type' syms env idx_fixlist type_alias_fixlist 
      as_fixlist expr_fixlist (depth+1) 
      excluded_dirs sr 
      body (pnames@params)
    in
      let bparams = (* order as written *)
        List.rev_map (fun (n,t,i) -> (i,t)) data 
      in
      `BTYP_typefun (bparams, bt r, bbody)

  | `TYP_apply (t1,t2) ->
    let t1 = bt t1 in
    let t2 = bt t2 in
    let t = `BTYP_apply (t1,t2) in
    (*
    let t = beta_reduce syms [] t in
    *)
    t

  | `TYP_type_tuple ts ->
    `BTYP_type_tuple (List.map bt ts)

  | `TYP_type -> `BTYP_type

  | `AST_name (sr,s,[]) when List.mem_assoc s as_fixlist ->
    `BTYP_fix ((List.assoc s as_fixlist)-depth)

  (* this is deprecated .. ??? *)
  | `AST_name (sr,s,[]) when List.mem_assoc s params ->
    (*
    print_endline "Found in assoc list .. ";
    *)
    List.assoc s params

  (* QUALIFIED OR UNQUALIFIED NAME *)
  | #qualified_name_t as x ->
    (*
    print_endline ("Matched qualified name " ^ string_of_qualified_name x);
    *)
    match lookup_qn_in_env syms env excluded_dirs x with
    | Bound (i,m),ts -> 
      let ts = map bt ts in
      `BTYP_binding (bi i ts, bi m ts)

    | Simple i,ts ->
      let ts = map bt ts in
      (*
      print_endline ("Qualified name lookup finds index " ^ si i ^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
      *)
      bi i ts
  in
    (*
    print_endline ("Bound type is " ^ sbt syms.dfns t);
    *)
    t

and bind_type_index syms 
  idx_fixlist type_alias_fixlist as_fixlist expr_fixlist depth 
  excluded_dirs 
  sr index ts 
= 
  (*
  print_endline 
  (
    "BINDING INDEX " ^ string_of_int index ^ 
    " with ["^
    catmap ", " 
    (sbt syms.dfns)
    ts^
    "]"
  );
  *)
  if List.mem_assoc index type_alias_fixlist 
  then begin
    (*
    print_endline (
      "Making fixpoint for Recursive type alias " ^
      (
        match get_data syms.dfns index with {id=id;sr=sr}-> 
          id ^ " defined at " ^
          short_string_of_src sr
      )
    );
    *)
    `BTYP_fix ((List.assoc index type_alias_fixlist)-depth)
  end  
  else begin let ts = adjust_ts syms index ts in
  match get_data syms.dfns index with
  | {id=id;sr=sr;parent=parent;vs=vs;pubmap=tabl;dirs=dirs;symdef=entry} ->
    (*
    if length vs <> length ts 
    then 
      clierr sr 
      (
        "[bind_type_index] Wrong number of type arguments for " ^ id ^
        ", expected " ^ 
        si (length vs) ^ " got " ^ si (length ts)
      );
    *)
    match entry with
    | `SYMDEF_typevar _ -> (* not sure if kind is not TYPE .. *)
      `BTYP_var index

    (* type alias RECURSE *)
    | `SYMDEF_type_alias t -> 
      (*
      print_endline ("Unravelling type alias " ^ id);
      *)
      let params = make_params syms index ts in
      let env:env_t = build_env syms [] (Some index) in
      let t = 
        bind_type' syms env idx_fixlist ((index,depth) :: type_alias_fixlist) as_fixlist 
        expr_fixlist depth excluded_dirs sr t params 
      in
        (*
        print_endline ("Unravelled and bound is " ^ sbt syms.dfns t);
        *)
        let t = beta_reduce syms [] t in
        (*
        print_endline ("Beta reduced: " ^ sbt syms.dfns t);
        *)
        t


    | `SYMDEF_interface 
    | `SYMDEF_if_type 
      -> `BTYP_inst (index,[]) (* temporary hack *)

    | `SYMDEF_abs _ -> 
      `BTYP_inst (index,ts)

    | `SYMDEF_union _
    | `SYMDEF_struct _ 
      ->
      `BTYP_inst (index,ts)


    | `SYMDEF_module_binding e ->
      let e' = 
        let env = build_env syms [] parent in (* parent?? *)
        eval_module_expr syms env excluded_dirs e
      in 
      begin match e' with
      | Bound_module (iface,impl,binding) -> 
        `BTYP_binding (`BTYP_inst (iface,ts), `BTYP_inst (impl,ts))
      | _ -> failwith "Expected module binding expression to be bound module"
      end
    | _ -> 
      failwith 
      (
        "[bind_type_index] Type " ^ id ^ 
        " defined at " ^ short_string_of_src sr ^
        " must be a type [alias, abstract, union, struct], got:\n" ^
        string_of_symdef entry id vs
      )
  end 


and base_typename_of_literal v = match v with
  | `AST_int (t,_) -> t
  | `AST_float (t,_) -> t
  | `AST_string _ -> "string"
  | `AST_wstring _ -> "wstring"
  | `AST_ustring _ -> "string"

and  typeof_literal syms env sr v : btypecode_t = 
  let root,_ = List.hd (List.rev env) in
  let name = base_typename_of_literal v in
  match lookup_name_in_env env dummy_sr name with
  | NonFunctionEntry (Simple index) -> 
    `BTYP_inst (index,[])
  | _ -> 
    failwith 
    (
      "Unable to find simple definition of type " ^ 
      name ^ " of literal " ^
      string_of_literal v
    )
  
and  typeof_list = function 
  | [x] -> x 
  | x -> `TYP_tuple x

and  typlist params = List.map snd params
and  paramtype params = typeof_list (typlist params)

and  sig_of_symdef symdef name = match symdef with 
  | `SYMDEF_match_check (_) 
    -> `TYP_tuple[]

  (* primitives *)
  | `SYMDEF_fun (ps,r,_)
    -> typeof_list ps

  | `SYMDEF_function (ps,r,_)
    -> paramtype ps

  | `SYMDEF_if_fun (t) -> 
    begin match t with
    | `TYP_function (a,r) -> a
    | _ -> failwith "[sig_of_symdef] Expected function to have function type"
    end

  | `SYMDEF_struct ls ->
    typeof_list (map snd ls)

  | symdef -> 
    failwith (
      "[sig_of_symdef] Expected "^
      name
      ^" to be function or procedure, got " ^
     string_of_symdef symdef name []
    )    

and typeofindex_with_ts
  syms 
  (excluded_dirs:int list)
  (index:int)
  ts
=
  let t = typeofindex syms excluded_dirs index in
  let varmap = make_varmap syms index ts in
  let t = varmap_subst varmap t in
  t

(* This routine should ONLY 'fail' if the return type
  is indeterminate. This cannot usually happen.

  Otherwise, the result may be recursive, possibly
  Fix 0 -- which is determinate 'indeterminate' value :-)
  
  For example: fun f(x:int) { return f x; }

  should yield fix 0, and NOT fail.
*)


(* cal_ret_type uses the private name map *)
(* args is string,btype list *)
and cal_ret_type syms idx_fixlist expr_fixlist depth excluded_dirs index args =
  (*
  print_endline ("[cal_ret_type] index " ^ si index);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  let env = build_env syms excluded_dirs (Some index) in
  match (get_data syms.dfns index) with
  | {id=id;sr=sr;parent=parent;vs=vs;privmap=name_map;dirs=dirs;symdef=`SYMDEF_function (ps,rt,exes)} ->
    let rt = bind_type' syms env idx_fixlist [] [] expr_fixlist depth excluded_dirs sr rt args in
    let rt = beta_reduce syms [] rt in
    let ret_type = ref rt in
    (*
    begin match rt with
    | `BTYP_var i when i = index -> 
      print_endline "No return type given"
    | _ -> 
      print_endline (" .. given type is " ^ sbt syms.dfns rt)
    end
    ;
    *)
    begin match exes with
    (* a bit hacky: in principle this is a multi-branch return statement,
      so it could be used wherever a return statement is used, however
      really regmatch is a function, but we use a normal function wrapper
      and a special instruction because the processing is lighter
    *)
    | [sr,`EXE_reglex (_,_,cls)] 
    | [sr,`EXE_regmatch (_,cls)] ->
      (*
      print_endline 
      (
       "Calc ret type of regmatch, initially " ^
       sbt syms.dfns !ret_type
      );
      *)

      List.iter
      (
       fun (re,e) ->
         let t = snd 
         (
           bind_expression' syms env 
           (index::idx_fixlist) expr_fixlist depth 
           excluded_dirs e
          ) 
         in
         (*
         print_endline 
         (
           "regmatch instance " ^ string_of_expr e ^ ", type " ^ 
           sbt syms.dfns t
         );
         *)
         if do_unify syms !ret_type t
         then 
           ret_type := varmap_subst syms.varmap !ret_type
         else 
           failwith 
           (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
           )
      )
      cls
      (*
      ;
      print_endline ("type is " ^ sbt syms.dfns !ret_type)
      *)
        
    | _ ->
      let return_counter = ref 0 in
      List.iter
      (fun exe -> match exe with
      | (sr,`EXE_fun_return e) ->
        incr return_counter;
        (*
        print_endline ("  .. Handling return of " ^ string_of_expr e);
        *)
        begin try
          let t = 
            (* this is bad code .. we lose detection
            of errors other than recursive dependencies ..
            which shouldn't be errors anyhow ..
            *)
              snd 
              (
                bind_expression' syms env 
                (index::idx_fixlist) expr_fixlist depth 
                excluded_dirs e
              ) 
          in
          if do_unify syms !ret_type t (* the argument order is crucial *)
          then 
            ret_type := varmap_subst syms.varmap !ret_type
          else begin
            print_endline 
            (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
            )
            ;
            failwith 
            (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
            )
          end
        with 
          | Stack_overflow -> failwith "[cal_ret_type] Stack overflow"
          | Expr_recursion e -> () 
          | Free_fixpoint t -> () 
          | Unresolved_return (sr,s) -> () 
          | x -> 
          print_endline ("  .. Unable to compute type of " ^ string_of_expr e);
          print_endline ("Reason: " ^ Printexc.to_string x);
          ()
        end
      | _ -> ()
      )
      exes
      ;
      if !return_counter = 0 then (* it's a procedure .. *)
      begin 
        let mgu = do_unify syms !ret_type `BTYP_void in
        ret_type := varmap_subst syms.varmap !ret_type
      end
    end
    ;
    (* not sure if this is needed or not .. 
      if a type variable is computed during evaluation,
      but the evaluation fails .. substitute now
    ret_type := varmap_subst syms.varmap !ret_type
    ;
    *)
    (*
    let ss = ref "" in 
    Hashtbl.iter 
    (fun i t -> ss:=!ss ^si i^ " --> " ^sbt syms.dfns t^ "\n") 
    syms.varmap;
    print_endline ("syms.varmap=" ^ !ss);
    print_endline ("  .. ret type index " ^ si index ^ " = " ^ sbt syms.dfns !ret_type);
    *)
    !ret_type

  | _ -> assert false

  
and inner_typeofindex_with_ts
  syms 
  (idx_fixlist:int list) expr_fixlist depth
  (excluded_dirs:int list)
  (index:int)
  (ts: btypecode_t list)
: btypecode_t = 
 (*
 print_endline "Inner type of index with ts ..";
 *)
 let t = inner_typeofindex syms idx_fixlist expr_fixlist depth excluded_dirs index in
 let varmap = make_varmap syms index ts in
 varmap_subst varmap t
 

(* this routine is called to find the type of a function
or variable .. so there's no type_alias_fixlist .. 
*)

and typeofindex 
  syms 
  (excluded_dirs:int list)
  (index:int)
: btypecode_t = 
    (*
    let () = print_endline ("Top level type of index " ^ si index) in
    *)
    if Hashtbl.mem syms.ticache index
    then begin
      let t = Hashtbl.find syms.ticache index in
      (*
      let () = print_endline ("Cached .." ^ sbt syms.dfns t) in
      *)
      t
    end
    else 
      let t = inner_typeofindex syms [] [] 0 excluded_dirs index in
      let _ = try unfold t with _ ->
        print_endline "typeofindex produced free fixpoint";
        failwith "[typeofindex] free fixpoint constructed"
      in
      (*
      print_endline ("Type of index "^ si index ^ " is " ^ sbt syms.dfns t);
      *)
      (match t with (* HACK .. *)
      | `BTYP_fix _ -> ()
      | _ -> Hashtbl.add syms.ticache index t
      );
      t

and inner_typeofindex
  syms 
  (idx_fixlist:int list) expr_fixlist depth
  (excluded_dirs:int list)
  (index:int)
: btypecode_t = 
  (*
  print_endline ("[inner_type_of_index] " ^ si index);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  (* check the cache *)
  try Hashtbl.find syms.ticache index
  with Not_found ->   


  (* check index recursion *)
  if List.mem index idx_fixlist
  then `BTYP_fix (-depth)
  else

  match get_data syms.dfns index with
  | {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs;symdef=entry} 
  ->

  let env:env_t = build_env syms excluded_dirs (Some index) in 

  let bt t:btypecode_t = 
    let t' = bind_type' syms env idx_fixlist [] [] expr_fixlist depth excluded_dirs sr t [] in
    let t' = beta_reduce syms [] t' in
    t'
  in
  match entry with
  | `SYMDEF_function (ps, rt,_) -> 
    let pts = List.map snd ps in
    let rt' = 
      try Hashtbl.find syms.varmap index with Not_found ->
      cal_ret_type syms (index::idx_fixlist) expr_fixlist depth excluded_dirs index [] 
    in 
      (* this really isn't right .. need a better way to 
        handle indeterminate result .. hmm .. 
      *)
      if var_i_occurs index rt' then 
        raise (Unresolved_return (sr,
        (
          "[typeofindex'] " ^ 
          "function "^id^"<"^string_of_int index^
          ">: Can't resolve return type, got : " ^ 
          sbt syms.dfns rt' ^ 
          "\nPossibly each returned expression depends on the return type" ^
          "\nTry adding an explicit return type annotation"
        )))
      else
        let t = `BTYP_function (bt (typeof_list pts), rt') in
        t

  | `SYMDEF_if_fun (t) 
    -> bt t

  | `SYMDEF_const (t,_)
  | `SYMDEF_parameter (t)
  | `SYMDEF_val (t)
  | `SYMDEF_var (t)
    -> bt t

  | `SYMDEF_match_check _ ->
    `BTYP_function (`BTYP_tuple [], flx_bbool)

  | `SYMDEF_fun (pts,rt,_) -> 
    let t = `TYP_function (typeof_list pts,rt) in
    bt t
    
  | `SYMDEF_union _ ->
    failwith ("Union "^id^" doesn't have a type")

  (* struct as function *)
  | `SYMDEF_struct (ls) -> 
    (* ARGGG WHAT A MESS *)
    let ts = map (fun (s,i) -> `AST_name (sr,s,[])) vs in
    let ts = map bt ts in
    let ts = adjust_ts syms index ts in
    let t = `BTYP_function(bt (paramtype ls),`BTYP_inst (index,ts)) in
    (*
    print_endline ("Struct as function type is " ^ sbt syms.dfns t);
    *)
    t

  | _ ->
    failwith 
    (
      "[typeofindex] Expected declaration of typed entity for index "^string_of_int index^", got " ^
      id ^ " declared at " ^
      short_string_of_src sr
    )

and cal_apply syms sr ((be1,t1) as tbe1) ((be2,t2) as tbe2) : tbexpr_t =
  let rest =
    match t1 with
    | `BTYP_function (argt,rest) ->
      if argt = t2 then rest
      else 
        clierr sr
        (
          "[cal_apply] Function " ^
          sbe syms.dfns tbe1 ^
          "\nof type " ^
          sbt syms.dfns t1 ^
          "\napplied to argument " ^
          sbe syms.dfns tbe2 ^
          "\n of type " ^
          sbt syms.dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          sbt syms.dfns argt 
        )

    | `BTYP_binding (
        `BTYP_function (argt,rest),
        `BTYP_function (argt',rest')
      ) ->
      if argt = lift t2 
      && argt' = lower t2
      then `BTYP_binding (rest, rest')
      else 
        clierr sr
        (
          "[cal_apply] Function argument " ^
          sbe syms.dfns tbe2 ^
          " has type\n" ^
          sbt syms.dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          sbt syms.dfns argt 
        )

    (* HACKERY TO SUPPORT STRUCT CONSTRUCTORS *)
    | `BTYP_inst (index,ts) ->
      begin match get_data syms.dfns index with
      { id=id;vs=vs;symdef=entry} ->
        begin match entry with
        | `SYMDEF_struct (cs) -> t1
        | _ -> 
          clierr sr
          (
            "[cal_apply] Attempt to apply non-struct " ^ id ^ ", type " ^
            sbt syms.dfns t1 ^
            " as constructor"
          )
        end
      end
    | _ -> 
      clierr sr
      (
        "Attempt to apply non-function\n" ^
        sbe syms.dfns tbe1 ^ 
        "\nof type\n" ^
        sbt syms.dfns t1 ^
        "\nto argument of type\n" ^
        sbe syms.dfns tbe2
      )
  in
  (*
  print_endline 
  (
    "---------------------------------------" ^
    "\nApply type " ^ sbt syms.dfns t1 ^
    "\nto argument of type " ^ sbt syms.dfns t2 ^ 
    "\nresult type is " ^ sbt syms.dfns rest ^
    "\n-------------------------------------"
  );
  *)

  let rest = varmap_subst syms.varmap rest in
  (* We have to allow type variables now .. the result
  should ALWAYS be determined, and independent of function
  return type unknowns, even if that means it is a recursive
  type, perhaps like 'Fix 0' ..: we should really test
  for the *function* return type variable not being
  eliminated ..
  *)
  (* 
  if var_occurs rest 
  then 
    clierr sr
    (
      "[cal_apply] Type variable in return type applying\n" ^
        sbe syms.dfns tbe1 ^ 
        "\nof type\n" ^
        sbt syms.dfns t1 ^
        "\nto argument of type\n" ^
        sbe syms.dfns tbe2
    )
  ;
  *)
  `BEXPR_apply ((be1,lower t1), (be2,lower t2)),rest

and koenig_lookup syms sra excluded_dirs id' name_map fn t2 ts =
  (*
  print_endline ("Applying Koenig lookup for " ^ fn);
  *)
  let entries =  
    try Hashtbl.find name_map fn 
    with Not_found -> 
      failwith 
      (
        "Koenig lookup: can't find name "^
        fn^ " in " ^ 
        (match id' with 
        | "" -> "top level module"
        | _ -> "module '" ^ id' ^ "'"
        )
      )
  in 
  match entries with
  | FunctionEntry fs ->
    (*
    print_endline ("Got candidates: " ^ string_of_entry_set entries);
    *)
    begin match resolve_overload syms excluded_dirs sra fs fn t2 ts with
    | Some (Simple index'',t,mgu,ts) ->
      (* print_endline "Overload resolution OK"; *)
      `BEXPR_closure (index'',ts),
       typeofindex_with_ts syms excluded_dirs index'' ts


    | Some (Bound _,_,_,_ ) -> failwith "[koenig lookup] Can't handle bound result yet"
    | None ->
        (*
        let n = ref 0 
        in Hashtbl.iter (fun _ _ -> incr n) name_map; 
        print_endline ("module defines " ^ string_of_int !n^ " entries");
        *)
        clierr sra
        (
          "[flx_ebind] Koenig lookup: Can't find match for " ^ fn ^
          "\ncandidates are: " ^ full_string_of_entry_set syms.dfns entries
        )
    end
  | NonFunctionEntry _ -> failwith "Koenig lookup expected function"

(* this routine has to return a function or procedure .. *)
and lookup_qn_with_sig
  syms 
  sra srn 
  env idx_fixlist excluded_dirs 
  (qn:qualified_name_t)
  (sign:btypecode_t)
=
lookup_qn_with_sig'
  syms 
  sra srn 
  env idx_fixlist [] 0 excluded_dirs 
  qn
  sign

and lookup_qn_with_sig'
  syms 
  sra srn 
  env idx_fixlist expr_fixlist depth excluded_dirs 
  (qn:qualified_name_t)
  (sign:btypecode_t)
: tbexpr_t =    
  (*
  print_endline ("[lookup_qn_with_sig] " ^ string_of_qualified_name qn);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  let bt sr t = 
    (*
    print_endline "NON PROPAGATING BIND TYPE";
    *)
    bind_type syms env excluded_dirs sr t in
  match qn with
  | `AST_void _ -> failwith "qualified-name is void"

  | `AST_case_tag _ -> failwith "Can't lookup case tag here"

  (* WEIRD .. this is a qualified name syntactically ..
    but semantically it belongs in bind_expression
    where this code is duplicated ..
  *)
  | `AST_typed_case (sr,v,t) ->
    let t = bt sr t in
    begin match t with
    | `BTYP_sum ls ->
      if v<1 or v> List.length ls
      then failwith "Case index out of range of sum"
      else let vt = List.nth ls (v-1) in
      let ct = `BTYP_function (vt,t) in
      `BEXPR_case (v,t), ct

    | _ -> 
      clierr sr 
      (
        "[lookup_qn_with_sig] Type of case must be sum, got " ^
        sbt syms.dfns t
      )
    end

  | `AST_name (sr,name,ts) ->
    let ts = map (bt sr) ts in
    (*
    print_endline ("Lookup qn with sig has name " ^ name ^ "["^catmap "," (sbt syms.dfns) ts^"]");
    *)
    lookup_name_with_sig 
      syms 
      sra srn idx_fixlist expr_fixlist depth excluded_dirs 
      env name ts sign

  | `AST_lookup (sr,(qn',name,ts)) -> 
    let n = length ts in
    let ts = map (bt sr) ts in
    match 
      eval_module_expr 
      syms 
      env excluded_dirs 
      qn'
    with 
      | (Module_product _) ->
        failwith "Unexpected module product"

      | (Functor_set _) ->
        failwith "Unexpected Functor"

      | (Simple_module (impl, htab,dirs)) ->
        begin match lookup_name_in_htab htab name with
        | None -> 
          clierr sr
          (
            "[lookup_qn_with_sig] AST_lookup: Simple_module: Can't find name " ^ name
          )
        | Some x -> match x with 
        | NonFunctionEntry (Simple index) ->
          begin match get_data syms.dfns index with 
          {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs;symdef=entry} 
          ->
            begin match entry with
            | `SYMDEF_struct _ ->
              (*
              print_endline ("Struct constructor found, type= " ^ sbt syms.dfns t);
              *)
              let ts = adjust_ts syms index ts in
              let t = typeofindex_with_ts syms excluded_dirs index ts in
              begin match t with
              | `BTYP_function (a,_) ->
                if a <> sign then
                  clierr sr
                  (
                    "[lookup_qn_with_sig] Struct constructor for "^id^" has wrong signature, got:\n" ^
                    sbt syms.dfns t ^
                    "\nexpected:\n" ^
                    sbt syms.dfns sign
                  )
              | _ -> assert false
              end
              ;
              `BEXPR_closure (index,ts),
              t

            | `SYMDEF_const (t,_) 
            | `SYMDEF_val t 
            | `SYMDEF_var t 
            | `SYMDEF_parameter t
              ->
              let ts = adjust_ts syms index ts in
              let t = bt sr t in
              let t = tsubst vs ts t in
              begin match t with
              | `BTYP_function (a,b) ->
                if a <> sign then 
                clierr srn
                (
                  "[lookup_qn_with_sig] Expected variable "^id ^
                  "<" ^ si index ^ "> to have function type with signature " ^
                  sbt syms.dfns sign ^
                  ", got function type:\n" ^
                  sbt syms.dfns t
                )
                else
                  `BEXPR_name (index, ts),
                  t

              | `BTYP_inst (i,[]) ->
                begin match get_data syms.dfns i with
                { id=id'}->
                begin match sign with
                | `BTYP_inst (j,[]) ->
                  begin match get_data syms.dfns j with 
                  { id=id''} ->
                  begin match id',id'' with
                  | "string","string" 
                  | "ustring","ustring" 
                  | "string","int"
                  | "ustring","int" -> 
                    `BEXPR_name (index, ts),
                     t

                  | _ ->
                    clierr srn
                    (
                      "[lookup_qn_with_sig] expected variable " ^ 
                      id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
                      sbt syms.dfns t
                    )
                  end
                  end
                | _ ->
                  clierr srn
                  (
                    "[lookup_qn_with_sig] expected variable " ^ 
                    id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
                    sbt syms.dfns t
                  )
                end
                end
              | _ ->
                clierr srn
                (
                  "[lookup_qn_with_sig] expected variable " ^ 
                  id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
                  sbt syms.dfns t
                  
                )
              end
            | _ ->
              clierr sr
              (
                "[lookup_qn_with_sig] Named Non function entry "^id^
                "must befunction type requires struct," ^
                "or value or variable of function type"
              )
            end
          end

        | NonFunctionEntry (Bound (i,j)) ->
          failwith "[lookup_qn_with_sig] Can't handle bound result yet"

        | FunctionEntry fs ->
          match
            resolve_overload
            syms excluded_dirs sra fs name sign ts
          with
          | Some (Simple index,t,mgu,ts) ->
            `BEXPR_closure (index,ts),
             typeofindex_with_ts syms excluded_dirs index ts

          | Some (Bound (iface,impl),t,mgu,ts) -> 
             `BEXPR_closure (impl,ts),
             `BTYP_binding
             (
               typeofindex_with_ts syms excluded_dirs iface ts,
               typeofindex_with_ts syms excluded_dirs impl ts
             )

          | None -> 
            clierr sra
            (
              "[lookup_qn_with_sig] (Simple module) Unable to resolve overload of " ^ name 
            )
        end

      | (Bound_module (iface,impl,binding)) ->
        begin match get_data syms.dfns iface with
        {id=id;vs=vs;pubmap=table;dirs=dirs;symdef=entry}
        ->
        begin match entry with 
        | `SYMDEF_interface ->
          let table' = apply_binding table binding in
          begin match lookup_name_in_htab table' name with
          | None -> 
            clierr sra
            (
              "[lookup_qn_with_sig] AST_lookup: bound_module: Can't find name " ^ name
            )
          | Some x -> match x with
          | NonFunctionEntry (Simple index) ->
            let t = typeofindex_with_ts syms excluded_dirs index ts in
            begin match t with
            | `BTYP_function (a,b) ->
               if a <> sign  (* WE NEED TO DO A LIFT HERE *)
               then 
                 failwith
                 (
                   "Non function entry has wrong type"
                 )
               else begin 
                 (`BEXPR_name (index,ts),
                 typeofindex_with_ts syms excluded_dirs index ts
                 )
               end

            | _ -> 
              failwith
                 (
                   "Non function entry not function type"
                 )
            end
          | NonFunctionEntry (Bound (i,j)) ->
            failwith
            (
              "Can't handle bound non-function result yet"
            )

          | FunctionEntry fs ->
            match
              resolve_overload
              syms excluded_dirs sra fs name sign ts
            with
            | Some (Simple index,t,mgu,ts) ->
              `BEXPR_closure (index,ts),
              typeofindex_with_ts syms excluded_dirs index ts


            | Some (Bound (iface,impl),t,mgu,ts) -> 
              `BEXPR_closure (impl,ts),
              `BTYP_binding
              (
                 typeofindex_with_ts syms excluded_dirs iface ts,
                 typeofindex_with_ts syms excluded_dirs impl ts
              )

            | None -> 
              failwith 
              (
                "[Bound module] Unable to resolve overload in\n" ^
                short_string_of_src sra
              )

          end
        | _ -> failwith "Expected interface"
        end
        end

and lookup_name_with_sig 
  syms 
  sra srn 
  idx_fixlist expr_fixlist depth excluded_dirs env 
  (name : string)
  (ts : btypecode_t list)
  (t2:btypecode_t) 
: tbexpr_t =
  (*
  print_endline ("[lookup_name_with_sig] " ^ name ^ " of " ^ sbt syms.dfns t2);
  *)
  match env with
  | [] -> 
    clierr srn
    (
      "[lookup_name_with_sig] Can't find " ^ name ^ 
      " of " ^ sbt syms.dfns t2
    )
  | (table,dirs)::tail ->
    match 
      lookup_name_in_table_dirs_with_sig 
      (table, dirs) 
      syms env 
      idx_fixlist expr_fixlist depth excluded_dirs
      sra srn name ts t2 
    with
    | Some result -> (result:>tbexpr_t)
    | None -> 
      let tbx= 
        lookup_name_with_sig 
          syms 
          sra srn 
          idx_fixlist expr_fixlist depth excluded_dirs 
          tail name ts t2
       in (tbx:>tbexpr_t)
        
and handle_function 
  syms 
  env idx_fixlist expr_fixlist depth excluded_dirs 
  sra srn 
  name 
  ts
  overload 
: tbexpr_t 
=
  match overload with
    | Bound (i,j) -> 
      (*
      print_endline "[handle_function] handle opaque function"; 
      *)
      let it =
        match typeofindex_with_ts syms excluded_dirs i ts with
        | `BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[handle_function]: closure operator expected '"^
            name^"' to be function definition, got '"^
            sbt syms.dfns t
            ^"', " ^ short_string_of_src sra
          )
      and mt =
        match typeofindex_with_ts syms excluded_dirs j ts with
        | `BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[handle_function]: closure operator expected '"^
            name^"' to be function definition, got '"^
            sbt syms.dfns t
            ^"', " ^ short_string_of_src sra
          )
      in
        `BEXPR_closure (j,ts),
        unify syms.dfns it mt
      
    | Simple index -> 
        begin 
          match get_data syms.dfns index with 
          {id=id;sr=sr;vs=vs;parent=parent;privmap=tabl;dirs=dirs;symdef=entry}
          -> match entry with
          | `SYMDEF_match_check _
          | `SYMDEF_function _
          | `SYMDEF_fun _
          | `SYMDEF_struct _
            ->
            (*
            print_endline ("closure of " ^ name);
            flush stdout;
            *)
            `BEXPR_closure (index,ts),
            (
              match inner_typeofindex_with_ts syms 
                idx_fixlist expr_fixlist depth excluded_dirs 
                index ts 
              with
              | `BTYP_function (s,d) as t -> t
              | t -> 
                ignore begin
                  match t with 
                  | `BTYP_fix _ -> raise (Free_fixpoint t)
                  | _ -> try unfold t with
                  | _ -> raise (Free_fixpoint t)
                end
                ;
                failwith 
                (
                  "[handle_function]: closure operator expected '"^name^"' to be function definition, got '"^
                  sbt syms.dfns t
                  ^"', " ^ short_string_of_src sra
                )
            )
          | _ -> 
            failwith 
            (
              "[handle_function] Expected function"
            )
        end 
  
and lookup_name_in_table_dirs_with_sig (table, dirs) 
  syms 
  env idx_fixlist expr_fixlist depth excluded_dirs 
  sra srn name ts t2 
: tbexpr_t option
=
  (*
  print_endline 
  (
    "LOOKUP NAME "^name ^"["^
    catmap "," (sbt syms.dfns) ts ^
    "] IN TABLE DIRS WITH SIG " ^ sbt syms.dfns t2
  ); 
  *)
  (* DOES NOT PROPAGATE EXPR FIXLIST .. *)
  let bt sr t = 
    (*
    print_endline "LOSING EXPR FIXLIST ..";
    *)
    bind_type syms env excluded_dirs sr t in

  let result:entry_set_t =
    match lookup_name_in_htab table name  with
    | Some x -> x
    | None -> FunctionEntry []
  in
  match result with
  | NonFunctionEntry (Simple index) ->
    begin match get_data syms.dfns index with
    {id=id;sr=sr;parent=parent;vs=vs;symdef=entry}->
    begin match entry with
    | `SYMDEF_struct _
      ->
        (*
        print_endline "lookup_name_in_table_dirs_with_sig finds struct constructor";
        *)
        let ro = 
          resolve_overload 
          syms excluded_dirs sra [Simple index] name t2 ts
        in
          begin match ro with 
          | Some (index,t,mgu,ts) ->
            let tb : tbexpr_t =
              handle_function 
              syms 
              env idx_fixlist expr_fixlist depth excluded_dirs 
              sra srn name ts index
            in 
              Some tb 
          | None -> None
          end

    | `SYMDEF_const (t,_)
    | `SYMDEF_var t
    | `SYMDEF_val t 
    | `SYMDEF_parameter t
      ->
      (* we have to check the variable is the right type *) 
      let t = bt sr t in
      let t = tsubst vs ts t in
      begin match t with
      | `BTYP_function (d,c) ->
        if d <> t2 then
        clierr srn
        (
          "[lookup_name_in_table_dirs_with_sig] Expected variable "^id ^
          "<" ^ si index ^ "> to have function type with signature " ^
          sbt syms.dfns t2 ^
          ", got function type:\n" ^
          sbt syms.dfns t
        )
        else
          let ts = adjust_ts syms index ts in
          Some
          (
            `BEXPR_name (index, ts),t
            (* should equal t ..
            typeofindex_with_ts syms excluded_dirs index ts
            *)
          )

      | `BTYP_inst (i,[]) ->
        begin match get_data syms.dfns i  with
        {id=id'} ->
        begin match t2 with
        | `BTYP_inst (j,[]) ->
          begin match get_data syms.dfns j with
          {id=id''} ->
          begin match id',id'' with
          | "string","string" 
          | "ustring","ustring" 
          | "string","int"
          | "ustring","int" -> 
            Some (`BEXPR_name (index, ts),t)
          | _ ->
            clierr srn
            (
              "[lookup_name_in_table_dirs_with_sig] expected variable " ^ 
              id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
              sbt syms.dfns t
            )
          end
          end
        | _ ->
          clierr srn
          (
            "[lookup_name_in_table_dirs_with_sig] expected variable " ^ 
            id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
            sbt syms.dfns t
          )
        end
        end
      | _ ->
        clierr srn
        (
          "[lookup_name_in_table_dirs_with_sig] expected variable " ^ 
          id ^ "<" ^ si index ^ "> to be of function type, got:\n" ^
          sbt syms.dfns t
          
        )
      end
    | _ 
      -> 
        failwith 
        (
          "Expected " ^id^
          " to be struct or variable of function type, got " ^ 
          string_of_symdef entry id vs
        )
    end
    end

  | NonFunctionEntry _ ->
    failwith "[lookup_name_in_table_dirs_with_sig] expected simple nonfunction entry"

  | FunctionEntry fs ->
    let ro = 
      resolve_overload 
      syms excluded_dirs sra fs name t2 ts
    in
    (*
    print_endline "Resolved overload ..";
    *)
    match ro with 
      | Some (index,t,mgu,ts) ->
        (*
        print_endline "got result ..";
        *)
        let ((_,tt) as tb) =
          handle_function 
          syms 
          env idx_fixlist expr_fixlist depth excluded_dirs 
          sra srn name ts index
        in 
          (*
          print_endline ("SUCCESS: overload chooses " ^ full_string_of_entry_kind syms.dfns index);
          print_endline ("Value of ts is " ^ catmap "," (sbt syms.dfns) ts);
          print_endline ("Instantiated closure value is " ^ sbe syms.dfns tb);
          print_endline ("type is " ^ sbt syms.dfns tt);
          *)
          Some tb 

      | None ->
        (*
        print_endline "NOT FOUND, trying opens";
        *)
        let opens : entry_set_t list = 
          List.concat
          (
            List.map
            (fun table -> 
              match lookup_name_in_htab table name with
              | Some x -> [x]
              | None -> []
            )
            dirs
          )
        in
          (*
          print_endline (si (length opens) ^ " OPENS BUILT");
          *)
          let fs:entry_kind_t list = merge_functions opens name in
          let ro = 
            resolve_overload
            syms excluded_dirs sra fs name t2 ts
          in
          (*
          print_endline "OVERLOAD RESOLVED .. ";
          *)
          match ro with
          | Some (result,t,mgu,ts) ->
            let tb : tbexpr_t = 
              handle_function 
              syms 
              env idx_fixlist expr_fixlist depth excluded_dirs 
              sra srn name ts result
            in 
              Some tb
          | None -> 
            (*
            print_endline "FAILURE"; flush stdout; 
            *)
            None

and bind_regdef syms env idx_fixlist excluded_dirs regexp_exclude e =
  let bd e = bind_regdef syms env idx_fixlist excluded_dirs regexp_exclude e in
  match e with
  | REGEXP_seq (e1,e2) -> REGEXP_seq (bd e1, bd e2)
  | REGEXP_alt (e1,e2) -> REGEXP_alt (bd e1, bd e2)
  | REGEXP_aster e -> REGEXP_aster (bd e)
  | REGEXP_name qn ->
    begin match lookup_qn_in_env syms env excluded_dirs qn with
    | Bound _,_ -> failwith "[bind_regdef] Unexpected bound entry"
    | Simple i,_ ->
      if List.mem i regexp_exclude
      then 
        failwith
        (
          "[bind_regdef] Regdef " ^ string_of_qualified_name qn ^
          " depends on itself"
        )
      else
        begin
          match get_data syms.dfns i with
          {symdef=entry} ->
          match entry with
          | `SYMDEF_regdef e ->
            bind_regdef syms env idx_fixlist excluded_dirs (i::regexp_exclude) e
          | _ -> 
            failwith 
            (
              "[bind_regdef] Expected " ^ string_of_qualified_name qn ^
              " to be regdef"
            ) 
        end
    end 

  | x -> x

and bind_expression' syms env idx_fixlist expr_fixlist depth excluded_dirs e 
: tbexpr_t = 
  (*
  print_endline ("[bind_expression'] " ^ string_of_expr e);
  print_endline ("expr_fixlist is " ^ 
    catmap ","
    (fun (e,d) -> string_of_expr e ^ " [depth " ^si d^"]") 
    expr_fixlist
  );
  *)
  if List.mem_assq e expr_fixlist
  then raise (Expr_recursion e)
  ;
  let be e' = bind_expression' syms env idx_fixlist ((e,depth)::expr_fixlist) (depth+1) excluded_dirs e' in
  let bt sr t = 
    (* we're really wanting to call bind type and propagate depth ? *)
    let t = bind_type' syms env 
      idx_fixlist [] [] ((e,depth)::expr_fixlist) (depth+1) 
      excluded_dirs 
      sr t [] 
    in
    let t = beta_reduce syms [] t in
    t
  in
  let ti i ts = inner_typeofindex_with_ts syms 
    idx_fixlist ((e,depth)::expr_fixlist) depth excluded_dirs i ts 
  in

  let lookup sr f (sign:btypecode_t) =
    match f with
      
    | #qualified_name_t as name -> 
      let srn = src_of_expr name in
      lookup_qn_with_sig'
        syms 
        sr srn env 
        idx_fixlist ((e,depth)::expr_fixlist) depth excluded_dirs 
        name sign

    | e -> be e
  in

  (* model infix operator as function call *)
  let apl2 (sri:range_srcref) (fn : string) (tup:expr_t list) = 
    let sr = rslist tup in
    `AST_apply 
    (
      sr, 
      (
        `AST_name (sri,fn,[]), 
        `AST_tuple (sr,tup)
      )
    )
  in
  (*
  print_endline ("Binding expression " ^ string_of_expr e ^ " depth=" ^ string_of_int depth);
  print_endline ("environment is:");
  print_env env;
  print_endline "==";
  *)
  let sr = src_of_expr e in
  match e with
  | `AST_type_match _ 
  | `AST_noexpand _
  | `AST_letin _ 
  | `AST_cond _ 
  | `AST_typeof _
  | `AST_as _
  | `AST_void _
  | `AST_arrow _ 
  | `AST_superscript _ 
  | `AST_bound_module _ 
    -> 
      clierr sr 
     "[bind_expression] Unexpected in expression" 

  | `AST_expr (sr,s,t) -> 
    let t = bt sr t in 
    `BEXPR_expr (s,t),t

  | `AST_sum (sri,ls) -> 
    begin let mksum a b = apl2 sri "add" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mksum h t)
    | [] -> failwith "Not expecting empty product (unit)"
    end
    
  | `AST_product (sri,ls) ->
    begin let mkprod a b = apl2 sri "mul" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mkprod h t)
    | [] -> failwith "Not expecting empty sum (void)"
    end

  | `AST_coercion (sr,(m,t)) -> 
    let m' = be m in
    let t' = bt sr t in
    `BEXPR_coercion (m',t'),t'

  | `AST_get_n (sr,(n,e')) -> 
    let expr,typ = be e' in
    let ctyp = match typ with 
    | `BTYP_tuple ts -> 
      let len = List.length ts in
      if n<0 or n>len-1
      then failwith 
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1) ^
          " in " ^
          short_string_of_src sr
        )
      else List.nth ts n
    | _ -> 
      failwith 
      (
        "[bind_expression] Expected tuple " ^ 
        string_of_expr e' ^ 
        " to have tuple type, got " ^ 
        sbt syms.dfns typ ^
        " in " ^
        short_string_of_src sr
      )
    in 
      `BEXPR_get_n (n, (expr,typ)), ctyp

  | `AST_case_tag (sr,v) ->
     failwith "plain case tag not allowed in expression (only in pattern)"

  | `AST_typed_case (sr,v,t) ->
    let t = bt sr t in
    begin match t with
    | `BTYP_sum ls ->
      if v<1 or v> List.length ls
      then failwith "Case index out of range of sum"
      else let vt = List.nth ls (v-1) in
      let ct = 
        match vt with
        | `BTYP_tuple [] -> t        (* const ctor *)
        | _ -> `BTYP_function (vt,t) (* non-const ctor *)
      in
      `BEXPR_case (v,t), ct
    | _ ->
      clierr sr 
      (
        "[bind_expression] Type of case must be sum, got " ^
        sbt syms.dfns t
      )
    end

  | `AST_name (sr,name,ts) ->
    (*
    print_endline ("AST_name " ^ name ^ "[" ^ catmap "," string_of_typecode ts^ "]");
    *)
    let ts = map (bt sr) ts in
    begin match lookup_name_in_env env sr name with
    | NonFunctionEntry (Simple index) -> 
      (*
      print_endline ("[bind_expression] FOUND INDEX " ^ si index);
      *)
      let n = length ts in
      let ts = adjust_ts syms index ts in
      `BEXPR_name (index,ts),
      let t = ti index ts in
      (*
      print_endline ("typ=" ^ sbt syms.dfns t);
      *)
      t

    | NonFunctionEntry Bound(i,m) ->
      let it = ti i ts in
      let mt = ti m ts in
      let t = unify syms.dfns it mt in
      let ts = [] in (* HACK *)
      `BEXPR_name (m,ts), t

    | FunctionEntry fs -> 
      clierr sr
      (
        "[bind_expression] Simple name " ^ name ^ 
        " binds to function set in\n" ^
        short_string_of_src sr
      )
    end

  | (`AST_lookup (sr,(e,name,ts))) as qn ->
    let ts = map (bt sr) ts in
    let entry = 
      match 
          eval_module_expr 
          syms 
          env excluded_dirs 
          e 
      with 
      | (Module_product _) ->
        failwith "Unexpected module product"

      | (Functor_set _) ->
        failwith "Unexpected Functor"

      | (Simple_module (impl, htab,dirs)) ->
        lookup_name_in_htab htab name

      | (Bound_module (iface,impl,binding)) ->
        match get_data syms.dfns iface with
        {vs=vs;pubmap=table;dirs=dirs;symdef=entry}
        ->
        begin match entry with 
        | `SYMDEF_interface ->
          let table' = apply_binding table binding in
          lookup_name_in_htab table' name
        | _ -> failwith "Expected interface"
        end
    in 
      begin match entry with
      | Some entry -> 
        begin match entry with
        | NonFunctionEntry (Simple i) ->  
          let ts = adjust_ts syms i ts in
          `BEXPR_name (i,ts), 
          ti i ts
          
        | NonFunctionEntry (Bound (i,j)) -> 
          `BEXPR_name (j,ts), 
          `BTYP_binding (ti i ts, ti j ts)

        | FunctionEntry fs ->
          failwith 
          (
            "[bind_expression] Qualified name " ^ string_of_qualified_name qn ^ 
            " binds to function set in\n" ^
            short_string_of_src sr
          )
        end

      | None ->
        failwith
        (
          "Can't find " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      end

  | `AST_suffix (sr,(f,suf)) ->
    let sign = bt sr suf in
    lookup sr (f:>expr_t) sign

  | `AST_ref (_,(`AST_deref (sr,e))) -> be e
  
  | `AST_ref (sr,(`AST_dot (_,(e,id)))) ->
    let ref_name = "ref_" ^ id in
    be 
    (
      `AST_apply 
      (
        sr,
        (
          `AST_name (sr, ref_name,[]),
          `AST_ref (sr,e)
        )
      )
    )

  | `AST_ref (srr,e) -> 
    let e',t' = be e in 
    begin match e' with
    | `BEXPR_name (index,ts) ->
      begin match get_data syms.dfns index with
      {id=id; sr=sr; symdef=entry} ->
      begin match entry with
      | `SYMDEF_var _
      | `SYMDEF_parameter (`TYP_pointer _) -> 
        `BEXPR_ref (index,ts), 
        `BTYP_pointer 
        (
          inner_typeofindex_with_ts syms 
          idx_fixlist ((e,depth)::expr_fixlist) 
          (depth+1) excluded_dirs 
         index ts
        )

      | `SYMDEF_parameter _ -> 
         clierr srr 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          ": Address value parameter " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | `SYMDEF_const _
      | `SYMDEF_val _ ->
        clierr srr 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Can't address a value or const " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | _ -> 
         clierr srr 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      end
      end
    | _ ->
       clierr srr 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable in\n" ^
          short_string_of_src srr
        )
    end

  | `AST_deref (_,`AST_ref (sr,e)) -> be e

  | `AST_deref (sr,e) -> 
    let e,t = be e in
    begin match t with 
    | `BTYP_pointer t -> `BEXPR_deref (e,t),t
    | _ -> clierr sr "Dereference non pointer"
    end

  | `AST_literal (sr,v) -> 
    let t = typeof_literal syms env sr v in
    `BEXPR_literal v, t

  | `AST_method_apply (sra,(fn,e2)) -> 
    let be2,t2 = be e2 in
    let tbe1 = 
      match t2 with
      | `BTYP_inst (index,ts) ->
        begin match get_data syms.dfns index with
        {id=id; parent=parent;sr=sr;symdef=entry} ->
        match parent with
        | None -> failwith "Koenig lookup: No parent for method apply (can't handle global yet)"
        | Some index' ->
          match get_data syms.dfns index' with
          {id=id';sr=sr';parent=parent';vs=vs';pubmap=name_map;dirs=dirs;symdef=entry'}
          ->
          match entry' with
          | `SYMDEF_module ->
            koenig_lookup syms sra excluded_dirs id' name_map fn t2 ts

          | `SYMDEF_interface ->
            koenig_lookup syms sra excluded_dirs id' name_map fn t2 ts

          | _ -> clierr sra ("Koenig lookup: parent for method apply not module")
        end
      | _ -> clierr sra "apply method to nongenerative type"
    in
      cal_apply syms sra tbe1 (be2, t2)

  | `AST_apply (sr,(f',a')) ->
    let (ba, ta) as a = be a' in
    let f = lookup sr f' ta in
    begin 
      match f,a with
      | (_,`BTYP_inst (i1,[])),(_,`BTYP_inst (i2,[])) ->
        begin
          match get_data syms.dfns i1 with {id=id1; symdef=entry1} ->
          match get_data syms.dfns i2 with {id=id2; symdef=entry2} ->
          let apl name =
            be 
            (
              `AST_apply 
              (
                sr,
                (
                  `AST_name (sr,name,[]),
                  `AST_tuple (sr,[f';a'])
                )
              )
            )
          in
            match id1,id2 with
            | "string","string" -> apl "add"
            | "ustring","ustring" -> apl "add"
            | "string","int" -> apl "add"
            | "ustring","int" -> apl "add"
            | _ -> cal_apply syms sr f a
        end
      | _ -> cal_apply syms sr f a
    end

  | `AST_tuple (_,es) -> 
    let bets = List.map be es in
    let _, bts = List.split bets in
    let t = `BTYP_tuple bts in
    `BEXPR_tuple bets, t

  | `AST_dot (sr,(e,id)) ->
    let get_name = "get_" ^ id in
    be (`AST_method_apply (sr,(get_name,e)))

  | `AST_match_case (sr,(v,e)) ->
     `BEXPR_match_case (v,be e),flx_bbool

  | `AST_match_ctor (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name,ts) -> 
      let fname = `AST_name (sr,"_match_ctor_" ^ name,ts) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(context,name,ts)) ->
      let fname = `AST_lookup (sr,(context,"_match_ctor_" ^ name,ts)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
       be (`AST_match_case (sr,(v,e)))

    | _ -> clierr sr "Expected variant constructor name in union decoder"
    end
    
  | `AST_case_arg (sr,(v,e)) ->
     let (_,t) as e' = be e in
     begin match t with
     | `BTYP_sum ls ->
       let n = List.length ls in
       if v<1 or v>n 
       then clierr sr "Invalid sum index"
       else let t = List.nth ls (v-1) in
       `BEXPR_case_arg (v, e'),t
     | _ -> clierr sr "Expected sum type"
     end 

  | `AST_ctor_arg (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name,ts) -> 
      let fname = `AST_name (sr,"_ctor_arg_" ^ name,ts) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(e,name,ts)) ->
      let fname = `AST_lookup (sr,(e,"_ctor_arg_" ^ name,ts)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
      be (`AST_case_arg (sr,(v,e)))

    | _ -> clierr sr "Expected variant constructor name in union dtor"
    end

  | `AST_regmatch (sr,(e,cls)) ->
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "\n[Compiler error] Unexpected regmatch when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_reglex (sr,(p1,p2,cls)) ->
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "\n[Compiler error] Unexpected reglex when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_lambda (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "\n[Compiler error] Unexpected lambda when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_match (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "[Compiler error] Unexpected match when binding expression (should have been lifted out)"
    )

and resolve_overload 
  syms 
  excluded_dirs sr 
  (fs : entry_kind_t list)
  (name: string)
  (suf : btypecode_t) 
  (ts:btypecode_t list) 
: (entry_kind_t * btypecode_t * (int * btypecode_t) list * btypecode_t list) option =

  (*
  print_endline ("Argument sig is " ^ sbt syms.dfns suf);
  print_endline ("Candidates are " ^ catmap "," (string_of_entry_kind) fs);
  *)
  let resolve i =
    match get_data syms.dfns i with 
    {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs;symdef=symdef} ->
    id,parent,i,vs,sig_of_symdef symdef id
  in
  let sign = lift suf in
  let consider i =
    let id,p,i,vs,t = resolve i in
    (*
    print_endline ("Candidate "^si i^" sig is " ^ string_of_typecode t);
    *)
    let env = build_env syms excluded_dirs (Some i) in
    let t = bind_type syms env excluded_dirs sr t in
    let t = lift t in
    (*
    print_endline ("Candidate bound sig is " ^ sbt syms.dfns t);
    *)
    let eqns = make_eqns syms i ts in (* do this first to avoid gratuitous equalities *)
    let ts = adjust_ts syms i ts in
    let eqns = (t, sign) :: eqns in
    let mgu = maybe_unification syms.dfns eqns in
    (match mgu with
    | Some mgu -> 
      if sign <> list_subst mgu sign then
      failwith
      (
        "[resolve_overload] Unification of function " ^ 
        id ^ "<" ^ si i ^ "> signature " ^
        sbt syms.dfns t ^ 
        "\nwith argument type " ^ sbt syms.dfns sign ^
        "\nhas mgu " ^ string_of_varlist syms.dfns mgu ^
        "\nwhich specialises a variable of the argument type"
      )
      ;
      let t' = list_subst mgu t in
      let ts = map (list_subst mgu) ts in
      (*
      print_endline ("Matched with mgu = " ^ string_of_varlist syms.dfns mgu);
      *)
      Some (i,t,mgu,ts)

    | None -> 
      (*
      print_endline "No match"; 
      *)
      None
    )
  in
  let rec aux i =  
    match i with
    | Simple i -> 
      (match consider i with
      | Some x -> Unique x
      | None -> Fail
      )

    | Bound (i,j) ->
      (match consider i with
      | Some x -> Pair (x,j)
      | None -> Fail
      )
  in
  let fun_defs = List.map aux fs in
  let candidates = 
    let lift_suf = lift suf in
    List.filter 
    (fun result -> match result with
      | Unique _ -> true
      | Pair _ -> true
      | Fail -> false
    ) 
    fun_defs
  in
    (*
    print_endline "Got matching candidates .. ";
    *)
  (* start with an empty list, and fold one result
  at a time into it, as follows: if one element
  of the list is greater (more general) than the candidate,
  then add the candidate to the list and remove all
  element greater than the candidate,

  otherwise, if one element of the list is less then
  the candidate, keep the list and discard the candidate.

  The list starts off empty, so that all elements in
  it are vacuously incomparable. It follows either
  the candidate is not less than all the list,
  or not less than all the list: that is, there cannot
  be two element a,b sch that a < c < b, since by
  transitivity a < c would follow, contradicting
  the assumption the list contains no ordered pairs.

  If in case 1, all the greater element are removed and c added,
  all the elements must be less or not comparable to c,
  thus the list remains without comparable pairs,
  otherwise in case 2, the list is retained and c discarded
  and so trivially remains unordered.
  *)

  let candidates = fold_left
  (fun oc r ->
     match r with Unique (_,c,_,_) | Pair ((_,c,_,_),_) -> 
     (*
     print_endline ("Considering candidate sig " ^ sbt syms.dfns c);
     *)
     let rec aux lhs rhs =
       match rhs with
       | [] -> 
         (*
         print_endline "return elements plus candidate";
         *)
         r::lhs (* return all non-greater elements plus candidate *)
       | (Unique(i,typ,mgu,ts) as x)::t 
       | (Pair((i,typ,mgu,ts),_) as x) ::t 
       ->
         (*
         print_endline (" .. comparing with " ^ sbt syms.dfns typ);
         *)
         begin match compare_sigs syms.dfns typ c with
         | `Less -> 
           (*
           print_endline "Candidate is more general, discard it, retain whole list";
           *)
           lhs @ rhs (* keep whole list, discard c *) 
         | `Equal -> 
           failwith "[resolve_overload] Not expecting equal signatures"

         | `Greater -> 
           (*
           print_endline "Candidate is less general: discard this element";
           *)
           aux lhs t (* discard greater element *)
         | `Incomparable -> 
           (*
           print_endline "Candidate is comparable, retail element";
           *)
           aux (x::lhs) t (* keep element *)
       end
       | Fail::_ -> assert false
     in aux [] oc
     | Fail -> assert false
  )
  []
  candidates in
  match candidates with
  | [Unique (i,t,mgu,ts)] -> 
    Some (Simple i,t,mgu,ts)

  | [Pair ((i,t,mgu,ts),j)] -> 
    Some (Bound (i,j),t,mgu,ts)
  | [] -> None
  | _ -> 
    clierr sr 
    (
      "Too many candidates match in overloading " ^ name ^
      " with argument type " ^ sbt syms.dfns sign ^
      "\nOf the matching candidates, the following are most specialised ones are incomparable\n" ^
      catmap "\n" (function 
        | Unique (i,t,_,_) 
        | Pair ((i,t,_,_),_) ->
          qualified_name_of_index syms.dfns i ^ "<" ^ si i ^ "> sig " ^ sbt syms.dfns t
        | Fail -> assert false
      ) 
      candidates
      ^ 
      "\nPerhaps you need to define a function more specialised than all these?"
    )

(* FINAL NOTE: THIS STILL WON'T BE ENOUGH: THE SEARCH ALGORITHM
NEEDS TO BE MODIFIED TO FIND **ALL** FUNCTIONS .. alternatively,
keep the results from overload resolution for each scope, and resubmit
in a deeper scope: then if there is a conflict between signatures
(equal or unordered) the closest is taken if that resolves the 
conflict
*)

(* an environment is a list of hastables, mapping
   names to definition indicies. Each entity defining
   a scope contains one hashtable, and a pointer to
   its parent, if any. The name 'root' is special,
   it is the name of the single top level module
   created by the desugaring phase. We have to be
   able to find this name, so if when we run out
   of parents, which is when we hit the top module,
   we create a parent name map with a single entry
   'top'->NonFunctionEntry 0. 
*)

and build_env' syms parent : 
  (
    name_map_t * 
    qualified_name_t list *
    (string * qualified_name_t) list
  ) list =
  match parent with
  | None -> []

  | Some index ->
     match Hashtbl.find syms.dfns index with
     {id=id;sr=sr;parent=parent;vs=vs;privmap=table;dirs=dirs} ->
     let opens = 
       List.concat
       (
         List.map
         (fun x -> match x with 
           | DIR_open qn -> [qn]
           | DIR_use (n,qn) -> []
         )
         dirs
       )
     and uses = 
       List.concat
       (
         List.map
         (fun x -> match x with 
           | DIR_open qn -> []
           | DIR_use (n,qn) -> [n,qn]
         )
         dirs
       )
     in
       (table,opens, uses) :: build_env' syms parent

and map_dir 
  syms 
  (env:env_t)
  excluded_dirs 
  qn 
: name_map_t =
  let sr = ("dummy",0,0,0,0) in
  let result = 
    try lookup_qn_in_env syms env excluded_dirs qn 
    with Not_found -> failwith "QN NOT FOUND"
  in
  match result with
  | Simple i,ts ->
    begin match get_data syms.dfns i with
    | {pubmap=table;symdef=`SYMDEF_module} -> table
    | {id=id;symdef=`SYMDEF_module_binding e} -> 
      if not (List.mem i excluded_dirs)
      then
        begin 
        let me = 
          try 
            eval_module_expr syms env (i::excluded_dirs) e 
          with _ -> failwith "Module expression eval failed"
        in
        match me with 
        | Module_product _ ->
          failwith "Unexpected module product"

        | Functor_set _ ->
          failwith "Unexpected Functor"

        | Simple_module (impl, htab,dirs) ->
          htab
        | Bound_module (iface,impl,binding) ->
          begin match get_data syms.dfns iface with
          {pubmap=table;symdef=entry} ->
          match entry with 
          | `SYMDEF_interface ->
            apply_binding table binding
          | _ -> failwith "Expected interface"
          end
        end
      else begin
        (* print_endline ("DUMMY TABLE CREATED FOR EXCLUDED OPEN " ^ string_of_int i); *)
        Hashtbl.create 97
      end

    | _ -> failwith "[map_dir] Expected module"
    end
  | _ -> failwith "Expected module!"

and build_env'' syms excluded_dirs parent : env_t =
  let basic_env = build_env' syms parent in
  let rec resolve_dirs env =
    match env with
    | [] -> []
    | (table,dirs,uses)::tail ->
      let base = resolve_dirs tail in
      let env = (table,[])::base in
      let use_map = Hashtbl.create 97 in
      List.iter
      (fun (n,qn) ->
        let entry,_ = lookup_qn_in_env2 syms env excluded_dirs qn in
        match entry with
        
        | NonFunctionEntry _ ->
          if Hashtbl.mem use_map n
          then failwith "Duplicate non function used"
          else Hashtbl.add use_map n entry

        | FunctionEntry ls ->
          let entry2 = 
            try Hashtbl.find use_map  n 
            with Not_found -> FunctionEntry []
          in
          match entry2 with
          | NonFunctionEntry _ ->
            failwith "Use function and non-function kinds"
          | FunctionEntry ls2 ->
            Hashtbl.replace use_map n (FunctionEntry (ls @ ls2))
      )
      uses
      ;
      let bound_dirs = 
        List.map
        (map_dir syms env excluded_dirs)
        dirs
      in
        (table,use_map:: bound_dirs) :: base
   in 
     resolve_dirs basic_env

and build_env syms excluded_dirs parent : env_t =
  match parent with
  | None -> []
  | Some i ->
    try 
      Hashtbl.find syms.env_cache i
    with 
      Not_found ->
       let env = build_env'' syms (i::excluded_dirs) parent in
       Hashtbl.add syms.env_cache i env;
       env

(*===========================================================*)
(* MODULE STUFF *)
(*===========================================================*)

(* This routine takes a bound type, and produces a unique form
   of the bound type, by again factoring out type aliases.
   The type aliases can get reintroduced by map_type,
   if an abstract type is mapped to a typedef, so we have
   to factor them out again .. YUK!!
*)
   
and rebind_btype syms env excluded_dirs sr ts t: btypecode_t =
  let rbt t = rebind_btype syms env excluded_dirs sr ts t in
  match t with
  | `BTYP_inst (i,_)
  | `BTYP_name i ->
    begin match get_data syms.dfns i with
    | {symdef=`SYMDEF_type_alias t'} ->
      bind_type syms env excluded_dirs sr t'
    | _ -> t
    end
  | `BTYP_tuple ts -> `BTYP_tuple (List.map rbt ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map rbt ts)
  | `BTYP_function (a,r) -> `BTYP_function (rbt a, rbt r) 
  | `BTYP_pointer t -> `BTYP_pointer (rbt t)
  | `BTYP_array (t1,t2) -> `BTYP_array (rbt t1, rbt t2)
  | `BTYP_void -> `BTYP_void
  | `BTYP_binding (a,b) -> `BTYP_binding (rbt a,rbt b)
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> failwith "Unexpected type variable in rebind_type"
  | _ -> failwith ("[rebind_type] Unexpected " ^ sbt syms.dfns t)


(* this routine takes a bound type from an interface,
   and applies the binding functor to produce a bound
   type in the functors domain, which is a module.
   Note that the target might be a typedef, so the result
   is not necessarily unique. Rebind_type must be applied
   to factor out the typedefs again.
*)
and map_type 
  iface 
  syms 
  mmap ienv binding excluded_dirs isr msr ts t
: btypecode_t = 
  let mt t = map_type iface syms mmap ienv binding excluded_dirs isr msr ts t in
  match t with
  | `BTYP_inst (index,ts) ->
    `BTYP_inst
    (
      get_unique_binding iface syms 
        mmap ienv binding index excluded_dirs 
        isr msr ts
      ,
      ts
    )
  | `BTYP_function (a, r) -> `BTYP_function (mt a, mt r)
  | `BTYP_tuple ls -> `BTYP_tuple (map mt ls)
  | `BTYP_sum ls -> `BTYP_sum (map mt ls)
  | `BTYP_pointer t -> `BTYP_pointer (mt t)
  | `BTYP_array (t1,t2) -> `BTYP_array (mt t1, mt t2)
  | `BTYP_binding (a,b) ->
    failwith "[map type] Unexpected type binding"

  | `BTYP_void -> `BTYP_void
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> failwith "Unexpected type variable in map_type"
  | _ -> failwith ("[map_type] Unexpected " ^ sbt syms.dfns t)

(* NOTE ON COMPARISONS: 
  We don't allow a val to match a const. Probably,
  we should: they're both 'constants', the only difference
  is the form of initialisation: we'd write
  val x:int = "1"; instead of const x:int = 1;
  except that the initialiser of the first form looks
  like a string. 
 
  Note that there IS a difference: 'consts' live 
  in the global frame, values live in the thread frame.
  This is ad hoc'ery: C++ constants can be initialised
  independently of each other, Felix values can't.
  
  Note that we DO allow an function declaration to match
  either a Felix function or a primitive function.
*)

and compare_defn 
  iface 
  syms 
  mmap name 
  ienv ientry 
  menv mentry 
  binding excluded_dirs 
  isr msr (ts: btypecode_t list)
=
  (*
  print_endline 
  (
    "comparing iface element '" ^ string_of_symdef ientry name [] ^ "'" ^
    "\n with module element '"  ^
    string_of_symdef mentry name [] ^ "'"
  );
  *)
  let ibt t: btypecode_t = bind_type syms ienv excluded_dirs isr t in
  let rt t: btypecode_t= rebind_btype syms menv excluded_dirs msr ts t in 
  let mt t: btypecode_t = 
    map_type iface 
    syms 
    mmap ienv binding 
    excluded_dirs 
    isr msr 
    ts t
  in
  let rmb t: btypecode_t = rt (mt (ibt t)) in
  let mbt t: btypecode_t = bind_type syms menv excluded_dirs msr t in
    
  match ientry,mentry with
  | `SYMDEF_if_type,`SYMDEF_type_alias _
  | `SYMDEF_if_type,`SYMDEF_abs _
  | `SYMDEF_if_type,`SYMDEF_union _
  | `SYMDEF_if_type,`SYMDEF_struct _
  | `SYMDEF_if_type,`SYMDEF_if_type
    ->   true

  | `SYMDEF_fun (ips,iret,ict),`SYMDEF_fun (mps,mret,mct) ->
    let it = `TYP_function ( typeof_list ips , iret) in
    let mt = `TYP_function ( typeof_list mps , mret) in
    let it = rmb it and mt = mbt mt in
    ict = mct && 
    it = mt
 
  | `SYMDEF_if_fun (it),`SYMDEF_fun (ps,ret,mct)  ->
    let mt = `TYP_function ( typeof_list ps , ret) in
    let it = rmb it and mt = mbt mt in
    it = mt
  
  | `SYMDEF_if_fun (it),`SYMDEF_if_fun (mt) 
    ->
    let it = rmb it and mt = mbt mt in
    it = mt
    
  | `SYMDEF_if_fun (it),`SYMDEF_function (ps,ret,_) ->
    let mt = `TYP_function ( paramtype ps , ret) in
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_const (it,ict), `SYMDEF_const (mt,mct) ->
    let it = rmb it and mt = mbt mt in
    it = mt &&
    ict = mct


  | `SYMDEF_val (it), `SYMDEF_val (mt) 
  | `SYMDEF_var (it), `SYMDEF_var (mt) ->
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_union (ics), `SYMDEF_union (mcs)
  | `SYMDEF_struct (ics), `SYMDEF_struct (mcs) ->
    List.fold_left2
    (fun b (iname,it) (mname,mt) ->
      let it = rmb it and mt = mbt mt in
      b &&
      iname = mname &&
      it = mt
    )
    true ics mcs

  | it,mt -> 
    failwith 
    (
      "Unexpected pair matching interface to module:" ^
      "\nIface  " ^ string_of_symdef it name [] ^
      "\nModule " ^ string_of_symdef mt name [] 
    )

(* GIVEN an index, if the index refers to an entity
   declared in the interface, return what it binds
   to in the module,
   otherwise just return it

   These semantics to support binding a a type in
   the interface down to a type in the module
*)
and get_unique_binding iface syms 
  mmap ienv (binding: index_map_t) iindex excluded_dirs 
  isr msr ts
: bid_t 
=
  try Hashtbl.find binding iindex
  with Not_found ->
    match get_data syms.dfns iindex with
    {id=iid;sr=isr;parent=iparent;vs=ivs;symdef=isymdef} ->
    (*
    print_endline ("get binding for " ^ iid ^ "<"^string_of_int iindex^">");
    *)
    if iparent <> Some iface 
    then 
    begin
      (*
      print_endline "Woops, the parent of the interface element isn't the interface";
      *)
      iindex 
    end
    else begin try
      match Hashtbl.find mmap iid with
      | NonFunctionEntry (Simple mindex) ->

        (* NOTE: I'm not sure this is sound!
           We insert the binding first, THEN check it,
           to prevent infinite recursion with recursive
           union and struct types -- this causes the
           initial lookup in this routine to succeed
           the second time around.
        *)
        Hashtbl.add binding iindex mindex;
        begin match get_data syms.dfns mindex with
        {id=mid;sr=msr;parent=mparent;vs=mvs;symdef=msymdef}->
        assert(iid=mid);
        (* print_endline "BUILD ENV, GET UNIQUE BINDING"; *)
        let menv = build_env syms excluded_dirs mparent in
        if 
        (
          compare_defn iface syms 
          mmap mid ienv isymdef menv msymdef binding excluded_dirs
          isr msr ts
        )
        then mindex
        else 
          failwith 
          (
            "interface entry '"^ iid ^ 
            "' doesn't match the one in the module"
          )
        end

      | NonFunctionEntry _ ->
        failwith
        (
          "Expected Simple non function entry, got binding"
        )
      | FunctionEntry _ ->
        failwith 
        (
          "Non function entry '" ^ iid ^ 
          "' in interface, found functions in module"
        )
    with 
      | Not_found -> 
        failwith 
        (
          "Name " ^ iid ^ " of interface not found in module"
        )
    end

and match_interface_entry 
  iface ts syms 
  mmap ienv binding excluded_dirs 
  isr msr
  name ientry 
=
  match ientry with
  | NonFunctionEntry (Simple iindex) ->
    let binds_to =
      get_unique_binding iface syms mmap ienv binding iindex 
      excluded_dirs isr msr []
    in
      (*
      print_endline ("binding " ^ si iindex ^ " -> " ^ si binds_to);
      *)
      ()

  | NonFunctionEntry _ ->
    failwith
    (
      "Expected simple Nonfunction entry, got binding"
    )
  | FunctionEntry ls ->
    List.iter
    (fun iindex ->
      match iindex with
      | Simple iindex ->
        begin match get_data syms.dfns iindex with
        {id=iid;sr=iesr;parent=iparent;vs=ivs;symdef=isymdef} ->
        try
          match Hashtbl.find mmap name with
          | NonFunctionEntry _ ->
            failwith
            (
              "Function entry '" ^
              name ^
              "' in interface , found non function in module"
            )
          | FunctionEntry ls ->
            begin try List.iter
            (fun mindex ->
              match mindex with
              | Simple mindex ->
                begin match get_data syms.dfns mindex with
                {id=mid;sr=mesr;parent=mparent;vs=mvs;symdef=msymdef} ->
                (* print_endline "BUILD ENV, MATCH INTERFACE ENTRY"; *)
                let menv = build_env syms excluded_dirs mparent in
                if 
                (
                  compare_defn iface syms 
                  mmap name ienv isymdef menv msymdef binding excluded_dirs
                  iesr mesr ts
                )
                then raise (Found mindex)
                end
              | _ -> failwith "Expected Simple"
            )
            ls
            ;
            failwith 
            (
              "interface entry '"^
              string_of_symdef isymdef name ivs ^ "' in\n" ^
              short_string_of_src iesr ^
              "\ndoesn't match any one in the module\n" ^
              short_string_of_src msr ^
              "\nCandidates are\n" ^
              String.concat "\n"
              (
                List.map 
                (fun x -> match x with 
                  | Simple index ->
                    begin match get_data syms.dfns index with
                    {vs=mvs;symdef=msymdef} -> string_of_symdef msymdef name mvs
                    end
                  | Bound (i,j) -> 
                    "binding "  ^ 
                    string_of_int i ^ 
                    " => " ^
                    string_of_int j
                )
                ls
              )
            )
            with Found mindex-> 
              (*
              print_endline ("binding " ^ si iindex ^ " -> " ^ si mindex);
              *)
              Hashtbl.add binding iindex mindex
            end
        with 
          | Not_found -> 
            failwith 
            (
              "Name " ^ name ^ " of interface not found in module"
            )
        end
      | _ -> 
        failwith
        (
          "Expected simple entry, got binding"
        )
    )
    ls
  
and match_interface 
  (iface:int) (ts:btypecode_t list)
  syms
  (mmap:name_map_t)
  (ienv:env_t)
  (imap:name_map_t)
  (excluded_dirs:int list)
  isr msr
=
  (*
  print_endline ("match interface " ^ string_of_int iface);
  *)
  let binding = Hashtbl.create 97 in
  try 
    Hashtbl.iter
    (match_interface_entry iface ts
      syms mmap ienv binding excluded_dirs 
      isr msr
    )
    imap
    ;
    Some binding
  with 
    | Failure x -> 
      print_endline ("WARNING: interface doesn't match module:\n" ^ x);
      None

and compose_bindings b1 b2 = (* reverse polish: b(i)= b2(b1(i)) *)
  let b = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i j ->
    let k = Hashtbl.find b2 j in
    Hashtbl.add b i k
  )
  b1
  ;
  b

and rebind_entry binding v =
  let apply ix = 
    try 
      Hashtbl.find binding ix 
    with Not_found ->
      failwith ("[rebind_entry] Can't find index " ^ string_of_int ix ^ " in module binding")
  in
  match v with
  | NonFunctionEntry (Simple iix) ->
    let bix = apply iix in
    NonFunctionEntry (Bound (iix,bix))

  | NonFunctionEntry _ -> 
    failwith "Expected Simple interface entry"

  | FunctionEntry ls ->
    let ls' = 
      List.map
      (fun entry -> match entry with
        | Simple iix ->
          let bix = apply iix in
          Bound (iix,bix)
        | _ -> failwith "Expected Simple interface entry"
      )
      ls 
    in
    FunctionEntry ls'

and apply_binding imap binding : name_map_t = (* reverse polish *)
  let bmap = Hashtbl.create 97 in
  let add k v = Hashtbl.add bmap k v in
  Hashtbl.iter 
  (fun k v -> 
    (* print_endline ("Binding name " ^ k); *)
    if k <> "root"
    then
      add k (rebind_entry binding v)
  )
  imap
  ;
  bmap

and handle_coercion syms env sr excluded_dirs  m t : module_rep_t =
  (* print_endline "HANDLING COERCION"; *)
  let m' = eval_module_expr syms env excluded_dirs m in
  let t' = bind_type syms env excluded_dirs sr t in
  handle_module_coercion syms env sr excluded_dirs m' t'

and handle_module_coercion syms env sr excluded_dirs m t =
  match t with
  | `BTYP_var i -> failwith "Unexpected type variable in handle_module_coercion"
  | `BTYP_sum _ -> failwith "Can't handle module sums yet"
  | `BTYP_tuple typs ->
    begin match m with
    | Module_product ms ->
      let nms = List.length ms and ntyps = List.length typs in
      if nms <> ntyps then 
        Module_product 
        (
          List.map2 
          (handle_module_coercion syms env sr excluded_dirs) 
          ms typs
        )
      else failwith 
      (
        "Can't coerce product of " ^ string_of_int nms ^ " modules " ^
        "with " ^ string_of_int ntyps ^ " interfaces"
      )
    | _ -> 
      failwith 
      (
        "Coercion to interface tuple requires module tuple"
      )
    end

  | `BTYP_inst (index,ts') ->
    if length ts' <> 0 
    then failwith "Can't handle generic modules yet"
    ;

    begin match get_data syms.dfns index with
    {id=id;sr=isr;parent=parent;vs=vs;pubmap=imap;dirs=dirs;symdef=symdef}->

    (* print_endline "BUILD_ENV, MODULE COERCION"; *)
    let ienv = build_env syms excluded_dirs (Some index) in
    begin match symdef with
    | `SYMDEF_interface  ->
      begin match m with
      | Functor_set _ ->
        failwith "Can't coerce functor (yet)"

      | Module_product _ ->
        failwith "Can't coerce module product to single interface"
        
      | Simple_module (impl,module_map,dirs) ->
        begin match
          match_interface index ts'
          syms 
          module_map ienv imap 
          excluded_dirs 
          isr sr
        with
          | Some binding ->
            Bound_module (index,impl,binding)
          | None -> failwith "Module doesn't match interface"
        end
      | Bound_module (iface,impl,binding) ->
        begin match get_data syms.dfns iface with
        {sr=isr;pubmap=module_map;dirs=dirs;symdef=ientry} ->
        match ientry with
        | `SYMDEF_interface ->
          begin match
            match_interface index ts'
              syms 
              module_map 
              ienv imap 
              excluded_dirs 
              isr sr
          with
            | Some binding' ->
              print_endline ("Interface matches interface '"^id^"' OK");
              let binding=compose_bindings binding' binding in
              print_endline "Binding is:";
              Hashtbl.iter
              (fun i j -> 
                print_endline 
                (
                  match get_data syms.dfns i with {id=iid;symdef=ie} ->
                  match get_data syms.dfns j with {id=mid;symdef=me} ->
                  iid ^
                  "[" ^ string_of_int i ^ "] -> " ^
                  mid ^
                  "[" ^ string_of_int j ^ "]"
                )
              )
              binding
              ;
              Bound_module (index,impl,binding)

            | None -> failwith "Interface doesn't match interface"
          end
        | _ -> failwith "Expected interface"
        end
      end

    | x -> 
      failwith 
      (
        "[eval_module_expr]: Expected interface, got: " ^ 
        string_of_symdef x id vs
      )
    end
    end

  | _ -> 
    failwith 
    (
      "Expected module type to be an interface name (functors later), got: " ^
      sbt syms.dfns t
    )

and compare_module_expr_with_type syms excluded_dirs sr t m =
  match m with
  | Module_product ls -> 
    begin match t with
    | `BTYP_tuple ts ->
      if List.length ts = List.length ls
      then
        List.fold_left2
        (fun b t m -> b && 
          (
            compare_module_expr_with_type 
            syms excluded_dirs sr t m
          )
        )
        true ts ls
      else false
    | _ -> false
    end
 | Bound_module (index,_,_) ->
   begin match t with
   | `BTYP_inst (index2,ts) -> index = index2
   | _ -> false
   end
 | Simple_module (impl,mmap,dirs) ->
   begin match t with
   | `BTYP_inst (iface,ts) ->
     begin match get_data syms.dfns iface with
     {sr=isr;parent=p;vs=vs;pubmap=imap;dirs=dirs;symdef=ientry} ->
     match ientry with
     | `SYMDEF_interface ->
       begin match
         (* print_endline "BUILD ENV, COMPARE MODULE EXPR"; *)
         let ienv = build_env syms excluded_dirs p in
         match_interface iface ts
         syms 
         mmap ienv imap 
         excluded_dirs isr sr
       with
        | Some binding' -> true
        | None -> false
       end
     | _ -> failwith "Expected interface"
     end
   | _ -> false
   end
 | Functor_set _ -> failwith "Can't compare functor set with single type"
 
and resolve_functor_overload syms env excluded_dirs sr ls m' =
  (* print_endline "RESOLVING FUNCTOR OVERLOAD"; *)
  let ts = [] in (* KLUDGE *)
  List.filter
  (fun index -> 
    match get_data syms.dfns index with
    {id=id;sr=sr;parent=parent;vs=vs;pubmap=nm;dirs=dirs;symdef=entry} ->
    match entry with 
    | `SYMDEF_typed_functor (ps,t,e) ->
      let t = 
        match List.map snd ps  with
        | [x] -> x
        | x -> `TYP_tuple x
      in
      let t = bind_type syms env excluded_dirs sr t 
      in 
        (* print_endline ("Type of functor signature is " ^ sbt syms.dfns t); *)
        compare_module_expr_with_type syms excluded_dirs sr t m'
    | `SYMDEF_untyped_functor (ps,e) ->
      let t = 
        match List.map snd ps  with
        | [x] -> x
        | x -> `TYP_tuple x
      in
      let t = bind_type syms env excluded_dirs sr t 
      in 
        (* print_endline ("Type of functor signature is " ^ sbt syms.dfns t); *)
        compare_module_expr_with_type syms excluded_dirs sr t m'
    | _ -> failwith "Expected FUnctor"
  )
  ls


and copy_entry syms parent binding_list index =
  let index' = !(syms.counter) in incr (syms.counter);
  match get_data syms.dfns index with
  {id=id;sr=sr;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=entry}->
  let privtab' = copy_table syms (Some index') [] privtab in
  let pubtab' = Hashtbl.copy privtab' in (* HACKED!!!!! *)
  (*
  let ps = 
    List.map 
    (
      fun (s,(i,t)) -> 
        let i'= !(syms.counter) in 
        incr (syms.counter); 
         Hashtbl.add syms.dfns i' (s,sr,Some index',`SYMDEF_parameter t)
        (s,(i',t))
    ) 
    ps 
  in
  *)
  let kind,symdef = 
    match entry with
    | `SYMDEF_function (ps,t,es) ->
      Other,`SYMDEF_function (ps,t,es)
      
    | `SYMDEF_typed_functor (ps,t,es) ->
      Other,`SYMDEF_typed_functor (ps,t,es)

    | `SYMDEF_untyped_functor (ps,es) ->
      Other,`SYMDEF_untyped_functor (ps,es)

    | `SYMDEF_parameter _ ->
      begin try
        let iidx,midx,binding = List.assoc id binding_list in
        Parameter,`SYMDEF_module_binding 
        (
          `AST_bound_module (sr,(iidx,midx,binding))
        ) 
      with Not_found -> Other,entry
      end
    | _ -> Other,entry
  in
    if syms.compiler_options.print_flag then
    print_endline 
    (
      "//   " ^ string_of_int index' ^ 
      " -> " ^
      (match kind with 
        | Other -> "copyof " 
        | Parameter -> "binding "
      )^ 
      id ^ "["^string_of_int index^"]: " ^ 
      short_string_of_src sr
    );
    Hashtbl.add syms.dfns index' 
    {
      id=id;sr=sr;parent=parent;vs=vs;
      pubmap=pubtab';
      privmap=privtab';
      dirs=dirs;
      symdef=symdef
    }
    ;
    index'

and copy_table syms parent binding_list name_map =
  let name_map' = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v -> 
    (* KLUDGE *)
    if k <> "root"
    then
    match v with
    | NonFunctionEntry (Simple i) ->
      let i' = copy_entry syms parent binding_list i in
      Hashtbl.add name_map' k (NonFunctionEntry (Simple i'))
      
    | NonFunctionEntry _ -> 
      failwith "instantiate not expecting bound entry"
    | FunctionEntry ls ->
      let fs = 
        List.map
        (fun e -> match e with
          | Simple i ->
            Simple (copy_entry syms parent binding_list i)
          | _ -> 
            failwith "instantiate not expecting bound entry"
        )
        ls
      in
        Hashtbl.add name_map' k (FunctionEntry fs)
  )
  name_map
  ;
  name_map'

and instantiate_functor syms
  sr excluded_dirs findex (m: module_rep_t) 
: module_rep_t =
  (* print_endline "CHECKING FOR FUNCTOR INSTANTIATION"; *)
  try 
    let afidx = Hashtbl.find syms.freg (findex, m) in
    match get_data syms.dfns afidx with
    | {pubmap=name_map;dirs=dirs;symdef=`SYMDEF_module} -> Simple_module (afidx,name_map,dirs)
    | _ -> failwith "Expected instantiation to be simple module"
  with Not_found ->
  (* print_endline "INSTANTIATING FUNCTOR"; *)
  match get_data syms.dfns findex with
  {parent=parent;vs=vs;pubmap=name_map;dirs=dirs;symdef=entry} ->
  let ps,asms= 
    match entry with 
    | `SYMDEF_typed_functor (ps,rt,asms) -> ps,asms
    | `SYMDEF_untyped_functor (ps,asms) -> ps,asms
    | _ -> failwith "Expected functor"
  in
  let env = build_env syms excluded_dirs parent in (* parent?? *)

  let rec aux ps (m:module_rep_t) : functor_arg_binding_t =
    match m with
    | Bound_module (iindex,impl,binding) ->
      begin match ps with
      | [x] -> [fst x,(iindex,impl,binding)]
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Simple_module (impl,mmap,dirs) -> 
      begin match ps with
      | [x] ->
        let ts = [] in (* KLUDGE *)
        let t = bind_type syms env excluded_dirs sr (snd x) in
        begin match handle_module_coercion syms env sr excluded_dirs m t with
        | Bound_module (iindex,impl,binding)  -> 
          [fst x, (iindex,impl,binding)]
        | _ -> failwith "Expected bound module result" 
        end
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Functor_set _ -> failwith "Expected bound module, got Functor set"
    | Module_product ls -> 
      if List.length ls = List.length ps 
      then List.concat ( List.map2 (fun p m -> aux [p] m) ps ls)
      else failwith "Module product wrong length"

  in 
    let binding = aux ps m in
    let mindex = !(syms.counter) in incr (syms.counter); 
    let mname = "_module_" ^ string_of_int mindex in 
    (*
    print_endline 
    (
      "// " ^ string_of_int mindex ^ 
      " -> instance " ^ mname ^ ": " ^ 
      short_string_of_src sr
    );
    *)
    Hashtbl.add syms.freg (findex,m) mindex; 
    let mtable = copy_table syms (Some mindex) binding name_map in
    Hashtbl.add syms.dfns mindex 
    {
      id=mname;sr=sr;parent=parent;
      vs=vs;pubmap=mtable;privmap=mtable;
      dirs=dirs;symdef=`SYMDEF_module
    }; 
    if syms.compiler_options.print_flag then
    begin
      print_endline "Instantiated Functor has table:";
      Hashtbl.iter
      (fun k v -> 
        print_endline (" " ^ k ^ " -> " ^ string_of_entry_set v)
      )
      mtable
    end
    ;
    Simple_module (mindex,mtable,dirs)

and handle_functor_application syms env sr excluded_dirs f m =
  (* print_endline "HANDLING FUNCTOR APPLICATION"; *)
  let m' = eval_module_expr syms env excluded_dirs m in
  let f' = eval_module_expr syms env excluded_dirs f in
  match f' with
  | Functor_set ls ->
    let matches = resolve_functor_overload syms env excluded_dirs sr ls m' in
    begin match matches with
    | [index] -> 
        instantiate_functor syms sr excluded_dirs index m'
    | [] -> failwith "No match overloading functor"
    | _ -> failwith "Too many matches overloading functor"
    end

  | _ -> failwith "Expected functor"


and check_module syms excluded_dirs sr entries =
    begin match entries with
    | FunctionEntry ls -> 
      let ls = 
        List.map
        (function 
          | Simple index -> 
            begin match get_data syms.dfns index with
            | {symdef=`SYMDEF_typed_functor _} -> index
            | {symdef=`SYMDEF_untyped_functor _} -> index
            | {id=id;vs=vs;sr=sr;symdef=entry} -> 
              failwith 
              (
                "Expected Functor, got : " ^
                string_of_symdef entry id vs ^ "\nin "^
                short_string_of_src sr
              )
            end
          | Bound _ -> failwith "Not expecting bound entry for functor"
        )
        ls
      in Functor_set ls

    | NonFunctionEntry (Simple index) ->
      begin match get_data syms.dfns index with
      | {dirs=dirs;pubmap=table;symdef=`SYMDEF_module} -> 
        Simple_module (index,table,dirs)
      | {parent=parent;symdef=`SYMDEF_module_binding e} ->
        let env' = build_env syms excluded_dirs parent in
        eval_module_expr syms env' excluded_dirs e
      | {id=id;sr=sr'} -> 
        failwith 
        (
          "Expected '" ^ id ^ "' to be module in: " ^
          short_string_of_src sr ^ ", found: " ^
          short_string_of_src sr'
        )
      end
    | _ -> 
      failwith
      (
        "Expected simple non function entry, got binding"
      )
    end

and make_bound binding x = 
  let bi i = Bound (i, Hashtbl.find binding i) in
  let be e = 
    match e with 
    | Simple i -> bi i
    | Bound _ -> failwith "Entry already bound!"
  in
  match x with
  | NonFunctionEntry e -> NonFunctionEntry (be e)
  | FunctionEntry fs -> FunctionEntry (List.map be fs)


(* the top level table only has a single entry,
  the root module, which is the whole file

  returns the root name, table index, and environment
*)

and eval_module_expr syms env excluded_dirs e : module_rep_t = 
  (*
  print_endline ("Handling module expression '"^string_of_expr e^"'"); 
  *)
  match e with
  | `AST_tuple (sr,es) ->
    Module_product (List.map (eval_module_expr syms env excluded_dirs) es)

  | `AST_coercion (sr,(m,t)) ->
    handle_coercion syms env sr excluded_dirs m t

  | `AST_bound_module (sr,(iface,impl,binding)) ->
    Bound_module (iface,impl,binding)

  | `AST_apply (sr,(f,m)) ->
    let x = handle_functor_application syms env sr excluded_dirs f m in
    (* print_endline "FUNCTOR APPLIED"; *)
    x

  | `AST_name (sr,name,ts) ->
    let entries = lookup_name_in_env env sr name in
    check_module syms excluded_dirs sr entries

  | `AST_lookup (sr,(e,name,ts)) ->
    let result = eval_module_expr syms env excluded_dirs e in
    let entries = 
      begin match result with
      | Simple_module (index,table,dirs) ->
        begin match lookup_name_in_htab table name with
        | Some x -> x
        | None -> clierr sr 
          (
            "Can't find " ^ name ^ " in module"
          )
        end

      | Bound_module (iface,impl,binding) ->
        begin match get_data syms.dfns iface with
        { id=id;sr=sr;pubmap=table;symdef=`SYMDEF_interface}  ->
          begin match lookup_name_in_htab table name with
          | Some x -> make_bound binding x
          | None -> 
            clierr sr
            (
              "Can't find " ^ name ^ " in module" 
            )
          end

        | _ -> failwith "Expected interface"
        end

      | Functor_set _ -> failwith "Can't lookup in functor set"
      | Module_product _ -> failwith "Can't lookup in module product"
      end 
    in check_module syms excluded_dirs sr entries

  | _ ->
    failwith 
    (
      "Invalid module expression " ^ 
      string_of_expr e ^ " in\n" ^
      short_string_of_src (src_of_expr e) 
    )


