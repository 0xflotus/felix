@head(1,"Name Lookup")
@h = tangler("src/flx_lookup.mli")
@select(h)
open Flx_types

val build_env:
  sym_state_t ->
  int list -> (* excluded modules *)
  int option -> (* parent *)
  env_t

val lookup_name_in_env :
  env_t ->
  range_srcref ->
  id_t -> 
  entry_set_t

val lookup_qn_in_env :
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  qualified_name_t -> 
  entry_kind_t

val lookup_sn_in_env :
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  suffixed_name_t -> 
  int

val bind_type:
  sym_state_t ->
  env_t ->
  (expr_t * int) list -> (* excluded expressions *)
  int list -> (* excluded modules *)
  range_srcref ->
  typecode_t ->
  btypecode_t

val eval_module_expr:
  sym_state_t ->
  env_t ->
  int list -> (* excluded modules *)
  expr_t ->
  module_rep_t

val resolve_overload:
  sym_state_t ->
  int list -> (* excluded modules *)
  range_srcref ->
  entry_kind_t list ->  
  id_t -> 
  btypecode_t ->
  entry_kind_t option

val bind_expression :
  sym_state_t ->
  env_t ->
  int list -> (* excluded types *)
  (expr_t * int) list -> (* excluded expressions *)
  int -> (* depth *)
  int list -> (* excluded modules *)
  expr_t ->
  tbexpr_t

val typeofindex :
  sym_state_t ->
  int list -> (* excluded types *)
  (expr_t * int) list -> (* excluded expressions *)
  int ->    (* depth *)
  int list -> (* excluded modules *)
  int ->
  btypecode_t

val typeof_literal:
  sym_state_t ->
  env_t ->
  range_srcref ->
  literal_t ->
  btypecode_t

val lookup_qn_with_sig:
  sym_state_t ->
  range_srcref ->
  range_srcref ->
  env_t ->
  int list ->
  int list ->
  qualified_name_t ->
  btypecode_t ->
  tbexpr_t

val print_env: (* debugging *)
  env_t -> unit

val bind_regdef:
  sym_state_t ->
  env_t ->
  int list ->
  int list ->
  int list ->
  regexp_t ->
  regexp_t

@h = tangler("src/flx_lookup.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List
open Flx_srcref
open Flx_unify

let bool_t = `BTYP_sum [`BTYP_tuple[]; `BTYP_tuple[]];

exception Found of int

type result = 
  | Unique of int * btypecode_t
  | Pair of (int * btypecode_t) * int

type kind_t = Parameter | Other

 
let print_env e = 
  let print_entry k v = 
    print_endline 
    (
      "  " ^ k ^ 
      (
        match v with 
        | (NonFunctionEntry (Simple i)) -> " Simple " ^ string_of_int i
        | _ -> ""
      )
    )
  in 
  let print_table htab = 
    print_endline "--"; Hashtbl.iter print_entry htab

  in 
  let print_level (htab,htabs) = print_table htab in 

  List.iter print_level e

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_lookup.get_data] No definition of <" ^ string_of_int index ^ ">")

let lookup_name_in_htab htab name : entry_set_t option =
  (* print_endline ("Lookup name in htab: " ^ name); *)
  try Some (Hashtbl.find htab name)
  with Not_found -> None
  
let merge_functions 
  (opens:entry_set_t list) 
  name 
: entry_kind_t list = 
  List.fold_left
    (fun init x -> match x with
    | FunctionEntry ls -> init @ ls
    | _ -> failwith ("Expected " ^ name ^ " to be function overload set in all open modules")
    )
  []
  opens

let lookup_name_in_table_dirs table dirs sr name : entry_set_t option =
  (* print_endline ("Lookup name " ^ name ^ " in table dirs");*)
  flush stdout;
  match lookup_name_in_htab table name with
  | Some x as y -> 
    (* print_endline "Found in table"; flush stdout; *)
    y
  | None ->
    (* print_endline "Not found: calculating opens";*)
    flush stdout;
  let opens = 
    List.concat
    (
      List.map
      (fun table -> 
        match lookup_name_in_htab table name with
        | Some x -> [x]
        | None -> [] 
      )
      dirs
    )
  in match opens with
  | [x] -> Some x
  | FunctionEntry ls :: rest ->
    Some (FunctionEntry (merge_functions opens name))

  | (NonFunctionEntry _)::_ -> 
    (* FIX: it might not be so! Could be two typedefs
      of the same thing, later, when I implement it,
      injected names
    *)
    failwith ("Conflicting values for "^name ^" found in open modules")
  | [] -> None

let lookup_name_in_env env sr name : entry_set_t =
  (* print_endline "Lookup name in env"; *)
  let rec aux env = 
    match env with 
    | [] -> None
    | (table,dirs) :: tail ->
      match lookup_name_in_table_dirs table dirs sr name with
      | Some x as y -> y
      | None -> aux tail
  in 
    match aux env with
    | Some x -> 
      (* print_endline ("Found name "^name^" in env"); flush stdout; *) 
      x
    | None ->
      failwith 
      (
        "[lookup_name_in_env]: Name '" ^ 
        name ^ 
        "' not found in environment (depth "^
        string_of_int (List.length env)^ "\n" ^
        "): " ^
        short_string_of_src sr 
      )

let lookup_in_bound_module 
  dfns iface binding sr 
  (t:string) 
: entry_set_t option  =
  match Hashtbl.find dfns iface with
  | (_,_,_,`SYMDEF_interface (table,dirs)) ->
    let src = lookup_name_in_htab table t  in
    begin match src with
    | None -> None
    | Some x -> match x with
    | NonFunctionEntry (Simple ix) ->
      let dst = Hashtbl.find binding ix in
      Some (NonFunctionEntry (Bound (ix,dst)))

    | NonFunctionEntry _ ->
      failwith
      (
        "[lookup_qn_in_bound_module] Expected simple nonfunction entry got binding"
      )
    | FunctionEntry ls ->
      let ns = ref [] in
      List.iter
      (fun ix ->
        match ix with
        | Simple ix ->
          let dst = Hashtbl.find binding ix in
          ns := Bound (ix,dst) :: !ns;
          (* print_endline (string_of_int ix ^ " ==> " ^ string_of_int dst) *)
        | _ -> failwith "Woops, expected Simple"
      )
      ls
      ;
      Some (FunctionEntry !ns)
    end

  | _ -> 
    failwith "Lookup in bound module expected interface"

(* This routine looks up a qualified name in the
   environment. The result is never a function or
   functor decl, although it could be a variable
   of function type.
*)

let rec lookup_qn_in_env 
  syms
  (env:env_t) 
  excluded_dirs
  (qn: qualified_name_t)
  : entry_kind_t 
=
  match qn with
  | `AST_void _ -> failwith "qualified name is void"
  | `AST_root _ -> failwith "Can't lookup root yet"
  | `AST_case_tag _ -> failwith "Can't lookup a case tag"
  | `AST_typed_case _ -> failwith "Can't lookup a case tag"
  | `AST_name (sr,name) ->
    begin match lookup_name_in_env env sr name with
    | NonFunctionEntry x -> x
    | FunctionEntry _ ->
      failwith 
      (
        "Not expecting " ^ name ^
        " to be function set in\n" ^
        short_string_of_src sr
      )
    end

  | `AST_lookup (sr,(me,name)) ->
    match eval_module_expr syms env excluded_dirs me with 
    | Module_product _ ->
      failwith "Unexpected module product"

    | Functor_set _ ->
      failwith "Unexpected Functor"

    | Simple_module (impl, htab,dirs) ->
      begin match
        try Hashtbl.find htab name with 
        | Not_found -> 
          failwith
          (
            "Can't find " ^ name ^ " in\n" ^
            short_string_of_src sr
          )
      with
      | NonFunctionEntry x -> x
      | _ -> 
        failwith 
        (
          "Not expecting " ^ string_of_qualified_name qn ^
          " to be function set in\n" ^
          short_string_of_src sr
        )
      end

    | Bound_module (iface,impl,binding) ->
      match lookup_in_bound_module syms.dfns iface binding sr name with
      | None -> 
        failwith 
        (
          "Can't find " ^ 
          string_of_qualified_name qn ^
          " in\n" ^
          short_string_of_src sr
        )
      | Some x -> match x with
        | NonFunctionEntry x -> x
        | FunctionEntry _ ->
          failwith
          (
            "Not expecting " ^ string_of_qualified_name qn ^
            " to be function set in\n" ^
            short_string_of_src sr
          )

and lookup_sn_in_env 
  syms
  (env:env_t) 
  excluded_dirs
  (sn: suffixed_name_t)
  : int 
= 
  match sn with
  | #qualified_name_t as x ->
    begin match
      lookup_qn_in_env syms env excluded_dirs x
    with
    | Simple index -> index
    | Bound _ -> failwith "Expecting simple entry"
    end

  | `AST_suffix (sr,(qn,suf)) ->
    let bsuf = bind_type syms env [] excluded_dirs sr suf in
    let be,t = 
      lookup_qn_with_sig
      syms 
      sr sr 
      env [] excluded_dirs 
      qn bsuf
    in match be with
    | `BEXPR_name index -> index
    | `BEXPR_closure index -> index
    | _ -> failwith "Expected expression to be index"

(* this routine takes a bound type from an interface,
   and applies the binding functor to produce a bound
   type in the functors domain, which is a module.
   Note that the target might be a typedef, so the result
   is not necessarily unique. Rebind_type must be applied
   to factor out the typedefs again.
*)
and map_type 
  iface 
  syms 
  mmap ienv binding excluded_dirs isr msr t 
: btypecode_t = 
  let map t = map_type iface syms mmap ienv binding excluded_dirs isr msr t in
  match t with
  | `BTYP_name index ->
    `BTYP_name
    (
      get_unique_binding iface syms 
        mmap ienv binding index excluded_dirs 
        isr msr
    )
  | `BTYP_function (a, r) -> `BTYP_function (map a, map r)
  | `BTYP_tuple ls -> `BTYP_tuple (List.map map ls)
  | `BTYP_sum ls -> `BTYP_sum (List.map map ls)
  | `BTYP_pointer t -> `BTYP_pointer (map t)
  | `BTYP_binding (a,b) ->
    failwith "[map type] Unexpected type binding"

  | `BTYP_void -> `BTYP_void
  | `BTYP_none -> `BTYP_none 
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> failwith "Unexpected type variable in map_type"
  | _ -> failwith "Unexpected metatype"

(* NOTE ON COMPARISONS: 
  We don't allow a val to match a const. Probably,
  we should: they're both 'constants', the only difference
  is the form of initialisation: we'd write
  val x:int = "1"; instead of const x:int = 1;
  except that the initialiser of the first form looks
  like a string. 
 
  Note that there IS a difference: 'consts' live 
  in the global frame, values live in the thread frame.
  This is ad hoc'ery: C++ constants can be initialised
  independently of each other, Felix values can't.
  
  Note that we DO allow an function declaration to match
  either a Felix function or a primitive function.
*)

and compare_defn 
  iface 
  syms 
  mmap name 
  ienv ientry 
  menv mentry 
  binding excluded_dirs 
  isr msr
=
  (*
  print_endline 
  (
    "comparing iface element '" ^ string_of_symdef ientry name ^ "'" ^
    "\n with module element '"  ^
    string_of_symdef mentry name ^ "'"
  );
  *)
  let ibt t: btypecode_t = bind_type syms ienv [] excluded_dirs isr t in
  let rt t: btypecode_t= rebind_btype syms menv excluded_dirs msr t in 
  let mt t: btypecode_t = 
    map_type iface 
    syms 
    mmap ienv binding 
    excluded_dirs 
    isr msr 
    t
  in
  let rmb t: btypecode_t = rt (mt (ibt t)) in
  let mbt t: btypecode_t = bind_type syms menv [] excluded_dirs msr t in
    
  match ientry,mentry with
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_type_alias _)
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_abs _)
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_union _)
  | `SYMDEF_if_type,`SYMDEF_dcl (`DCL_struct _)
  | `SYMDEF_if_type,`SYMDEF_if_type
    ->   true

  | `SYMDEF_dcl (`DCL_fun (ips,iret,ict)),`SYMDEF_dcl (`DCL_fun (mps,mret,mct)) ->
    let it = `TYP_function ( typeof_list ips , iret) in
    let mt = `TYP_function ( typeof_list mps , mret) in
    let it = rmb it and mt = mbt mt in
    ict = mct && 
    it = mt
  
  | `SYMDEF_dcl (`DCL_proc (ips,ict)),`SYMDEF_dcl (`DCL_proc (mps,mct)) ->
    let it = typeof_list ips in
    let mt = typeof_list mps in
    let it = rmb it and mt = mbt mt in
    ict = mct && 
    it = mt

  | `SYMDEF_if_proc (it), `SYMDEF_dcl (`DCL_proc (mps,mct)) ->
    let mt = typeof_list mps in
    let it = rmb it and mt = mbt mt in
    it = mt
 
  | `SYMDEF_if_fun (it),`SYMDEF_dcl (`DCL_fun (ps,ret,mct))  ->
    let mt = `TYP_function ( typeof_list ps , ret) in
    let it = rmb it and mt = mbt mt in
    it = mt
  
  | `SYMDEF_if_fun (it),`SYMDEF_if_fun (mt) 
  | `SYMDEF_if_proc (it),`SYMDEF_if_proc (mt) ->
    let it = rmb it and mt = mbt mt in
    it = mt
    
  | `SYMDEF_if_fun (it),`SYMDEF_function (ps,ret,_,_,_) ->
    let mt = `TYP_function ( paramtype ps , ret) in
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_if_proc (it),`SYMDEF_procedure (ps,_,_,_) ->
    let mt =  paramtype ps in
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_dcl (`DCL_const (it,ict)), `SYMDEF_dcl (`DCL_const (mt,mct)) ->
    let it = rmb it and mt = mbt mt in
    it = mt &&
    ict = mct


  | `SYMDEF_val it, `SYMDEF_val mt 
  | `SYMDEF_var it, `SYMDEF_var mt ->
    let it = rmb it and mt = mbt mt in
    it = mt

  | `SYMDEF_dcl (`DCL_union ics), `SYMDEF_dcl (`DCL_union mcs)
  | `SYMDEF_dcl (`DCL_struct ics), `SYMDEF_dcl (`DCL_struct mcs) ->
    List.fold_left2
    (fun b (iname,it) (mname,mt) ->
      let it = rmb it and mt = mbt mt in
      b &&
      iname = mname &&
      it = mt
    )
    true ics mcs

  | it,mt -> 
    failwith 
    (
      "Unexpected pair matching interface to module:" ^
      "\nIface  " ^ string_of_symdef it name ^
      "\nModule " ^ string_of_symdef mt name
    )

(* GIVEN an index, if the index refers to an entity
   declared in the interface, return what it binds
   to in the module,
   otherwise just return it

   These semantics to support binding a a type in
   the interface down to a type in the module
*)
and get_unique_binding iface syms 
  mmap ienv (binding: index_map_t) iindex excluded_dirs 
  isr msr
: bid_t 
=
  try Hashtbl.find binding iindex
  with Not_found ->
    let iid,isr,iparent,isymdef = Hashtbl.find syms.dfns iindex in
    if iparent <> Some iface then iindex
    else begin try
      match Hashtbl.find mmap iid with
      | NonFunctionEntry (Simple mindex) ->

        (* NOTE: I'm not sure this is sound!
           We insert the binding first, THEN check it,
           to prevent infinite recursion with recursive
           union and struct types -- this causes the
           initial lookup in this routine to succeed
           the second time around.
        *)
        Hashtbl.add binding iindex mindex;
        let mid,msr,mparent,msymdef = Hashtbl.find syms.dfns mindex in
        assert(iid=mid);
        (* print_endline "BUILD ENV, GET UNIQUE BINDING"; *)
        let menv = build_env syms excluded_dirs mparent in
        if 
        (
          compare_defn iface syms 
          mmap mid ienv isymdef menv msymdef binding excluded_dirs
          isr msr
        )
        then mindex
        else 
          failwith 
          (
            "interface entry '"^ iid ^ 
            "' doesn't match the one in the module"
          )
      | NonFunctionEntry _ ->
        failwith
        (
          "Expected Simple non function entry, got binding"
        )
      | FunctionEntry _ ->
        failwith 
        (
          "Non function entry '" ^ iid ^ 
          "' in interface, found functions in module"
        )
    with 
      | Not_found -> 
        failwith 
        (
          "Name " ^ iid ^ " of interface not found in module"
        )
    end

and match_interface_entry 
  iface syms 
  mmap ienv binding excluded_dirs 
  isr msr
  name ientry 
=
  (*
  print_endline ("matching interface name " ^ name);
  *)
  match ientry with
  | NonFunctionEntry (Simple iindex) ->
    ignore(get_unique_binding iface syms mmap ienv binding iindex excluded_dirs isr msr)
  | NonFunctionEntry _ ->
    failwith
    (
      "Expected simple Nonfunction entry, got binding"
    )
  | FunctionEntry ls ->
    List.iter
    (fun iindex ->
      match iindex with
      | Simple iindex ->
        let iid,iesr,iparent,isymdef = Hashtbl.find syms.dfns iindex in
        begin try
          match Hashtbl.find mmap name with
          | NonFunctionEntry _ ->
            failwith
            (
              "Function entry '" ^
              name ^
              "' in interface , found non function in module"
            )
          | FunctionEntry ls ->
            begin try List.iter
            (fun mindex ->
              match mindex with
              | Simple mindex ->
                let mid,mesr,mparent,msymdef = Hashtbl.find syms.dfns mindex in
                (* print_endline "BUILD ENV, MATCH INTERFACE ENTRY"; *)
                let menv = build_env syms excluded_dirs mparent in
                if 
                (
                  compare_defn iface syms 
                  mmap name ienv isymdef menv msymdef binding excluded_dirs
                  iesr mesr
                )
                then raise (Found mindex);
              | _ -> failwith "Expected Simple"
            )
            ls
            ;
            failwith 
            (
              "interface entry '"^
              string_of_symdef isymdef name ^ "' in\n" ^
              short_string_of_src iesr ^
              "\ndoesn't match any one in the module\n" ^
              short_string_of_src msr ^
              "\nCandidates are\n" ^
              String.concat "\n"
              (
                List.map 
                (fun x -> match x with 
                  | Simple index ->
                    let mid,mesr,mparent,msymdef = Hashtbl.find syms.dfns index in
                    string_of_symdef msymdef name 
                  | Bound (i,j) -> 
                    "binding "  ^ 
                    string_of_int i ^ 
                    " => " ^
                    string_of_int j
                )
                ls
              )
            )
            with Found mindex-> 
              Hashtbl.add binding iindex mindex
            end
        with 
          | Not_found -> 
            failwith 
            (
              "Name " ^ name ^ " of interface not found in module"
            )
        end
      | _ -> 
        failwith
        (
          "Expected simple entry, got binding"
        )
    )
    ls
  
and match_interface 
  (iface:int) 
  syms
  (mmap:name_map_t)
  (ienv:env_t)
  (imap:name_map_t)
  (excluded_dirs:int list)
  isr msr
=
  let binding = Hashtbl.create 97 in
  try 
    Hashtbl.iter
    (match_interface_entry iface 
      syms mmap ienv binding excluded_dirs 
      isr msr
    )
    imap
    ;
    Some binding
  with 
    | Failure x -> 
      print_endline ("WARNING: interface doesn't match module:\n" ^ x);
      None

and compose_bindings b1 b2 = (* reverse polish: b(i)= b2(b1(i)) *)
  let b = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i j ->
    let k = Hashtbl.find b2 j in
    Hashtbl.add b i k
  )
  b1
  ;
  b

and rebind_entry binding v =
  let apply ix = Hashtbl.find binding ix in
  match v with
  | NonFunctionEntry (Simple iix) ->
    let bix = apply iix in
    NonFunctionEntry (Bound (iix,bix))

  | NonFunctionEntry _ -> 
    failwith "Expected Simple interface entry"
  | FunctionEntry ls ->
    let ls' = 
      List.map
      (fun entry -> match entry with
        | Simple iix ->
          let bix = apply iix in
          Bound (iix,bix)
        | _ -> failwith "Expected Simple interface entry"
      )
      ls 
    in
    FunctionEntry ls'

and apply_binding imap binding : name_map_t = (* reverse polish *)
  let bmap = Hashtbl.create 97 in
  let add k v = Hashtbl.add bmap k v in
  Hashtbl.iter 
  (fun k v -> add k (rebind_entry binding v))
  imap
  ;
  bmap

and handle_coercion syms env sr excluded_dirs  m t : module_rep_t =
  (* print_endline "HANDLING COERCION"; *)
  let m' = eval_module_expr syms env excluded_dirs m in
  let t' = bind_type syms env [] excluded_dirs sr t in
  handle_module_coercion syms env sr excluded_dirs m' t' 

and handle_module_coercion syms env sr excluded_dirs m t =
  match t with
  | `BTYP_var i -> failwith "Unexpected type variable in handle_module_coercion"
  | `BTYP_sum _ -> failwith "Can't handle module sums yet"
  | `BTYP_tuple ts ->
    begin match m with
    | Module_product ms ->
      let nms = List.length ms and nts = List.length ts in
      if nms <> nts then 
        Module_product 
          (List.map2 (handle_module_coercion syms env sr excluded_dirs) ms ts)
      else failwith 
      (
        "Can't coerce product of " ^ string_of_int nms ^ " modules " ^
        "with " ^ string_of_int nts ^ " interfaces"
      )
    | _ -> 
      failwith 
      (
        "Coercion to interface tuple requires module tuple"
      )
    end

  | `BTYP_name index ->
    let id,isr,parent,symdef = Hashtbl.find syms.dfns index in
    (* print_endline "BUILD_ENV, MODULE COERCION"; *)
    let ienv = build_env syms excluded_dirs (Some index) in
    begin match symdef with
    | `SYMDEF_interface (imap,dirs) ->
      begin match m with
      | Functor_set _ ->
        failwith "Can't coerce functor (yet)"

      | Module_product _ ->
        failwith "Can't coerce module product to single interface"
        
      | Simple_module (impl,module_map,dirs) ->
        begin match
          match_interface index 
          syms 
          module_map ienv imap 
          excluded_dirs 
          isr sr
        with
          | Some binding ->
            Bound_module (index,impl,binding)
          | None -> failwith "Module doesn't match interface"
        end
      | Bound_module (iface,impl,binding) ->
        let _,isr,_,ientry = Hashtbl.find syms.dfns iface in
        begin match ientry with
        | `SYMDEF_interface (module_map,dirs) ->
          begin match
            match_interface index 
              syms 
              module_map 
              ienv imap 
              excluded_dirs 
              isr sr
          with
            | Some binding' ->
              print_endline ("Interface matches interface '"^id^"' OK");
              let binding=compose_bindings binding' binding in
              print_endline "Binding is:";
              Hashtbl.iter
              (fun i j -> 
                print_endline 
                (
                  let iid,_,_,ie = Hashtbl.find syms.dfns i 
                  and mid,_,_,me = Hashtbl.find syms.dfns j
                  in
                  iid ^
                  "[" ^ string_of_int i ^ "] -> " ^
                  mid ^
                  "[" ^ string_of_int j ^ "]"
                )
              )
              binding
              ;
              Bound_module (index,impl,binding)

            | None -> failwith "Interface doesn't match interface"
          end
        | _ -> failwith "Expected interface"
        end
      end

    | x -> 
      failwith 
      (
        "[eval_module_expr]: Expected interface, got: " ^ 
        string_of_symdef x id
      )
    end
  | _ -> 
    failwith 
    (
      "Exected module type to be an interface name (functors later), got: " ^
      string_of_btypecode syms.dfns t
    )

and compare_module_expr_with_type syms excluded_dirs sr t m =
  (* print_endline "COMPARING MODULE EXPR WITH TYPE"; *)
  match m with
  | Module_product ls -> 
    (* print_endline "..MODULE PRODUCT";*)
    begin match t with
    | `BTYP_tuple ts ->
      if List.length ts = List.length ls
      then
        List.fold_left2
        (fun b t m -> b && 
          (
            compare_module_expr_with_type 
            syms excluded_dirs sr t m
          )
        )
        true ts ls
      else false
    | _ -> false
    end
 | Bound_module (index,_,_) ->
   (* print_endline "..BOUND MODULE";*)
   begin match t with
   | `BTYP_name index2 -> index = index2
   | _ -> false
   end
 | Simple_module (impl,mmap,dirs) ->
   (* print_endline "..SIMPLE MODULE"; *)
   begin match t with
   | `BTYP_name iface ->
     let _,isr,p,ientry = Hashtbl.find syms.dfns iface in
     begin match ientry with
     | `SYMDEF_interface (imap,dirs) ->
       begin match
         (* print_endline "BUILD ENV, COMPARE MODULE EXPR"; *)
         let ienv = build_env syms excluded_dirs p in
         match_interface iface 
         syms 
         mmap ienv imap 
         excluded_dirs isr sr
       with
        | Some binding' -> true
        | None -> false
       end
     | _ -> failwith "Expected interface"
     end
   | _ -> false
   end
 | Functor_set _ -> failwith "Can't compare functor set with single type"
 
and resolve_functor_overload syms env excluded_dirs sr ls m' =
  (* print_endline "RESOLVING FUNCTOR OVERLOAD"; *)
  List.filter
  (fun index -> 
    let id,sr,parent,entry = Hashtbl.find syms.dfns index in
    match entry with 
    | `SYMDEF_typed_functor (ps,t,e,nm,dirs) ->
      let t = 
        match List.map snd ps  with
        | [x] -> x
        | x -> `TYP_tuple x
      in
      let t = bind_type syms env [] excluded_dirs sr t
      in 
        (* print_endline ("Type of functor signature is " ^ string_of_btypecode syms.dfns t); *)
        compare_module_expr_with_type syms excluded_dirs sr t m'
    | `SYMDEF_untyped_functor (ps,e,nm,dirs) ->
      let t = 
        match List.map snd ps  with
        | [x] -> x
        | x -> `TYP_tuple x
      in
      let t = bind_type syms env [] excluded_dirs sr t
      in 
        (* print_endline ("Type of functor signature is " ^ string_of_btypecode syms.dfns t); *)
        compare_module_expr_with_type syms excluded_dirs sr t m'
    | _ -> failwith "Expected FUnctor"
  )
  ls


and copy_entry syms parent binding_list index =
  let index' = !(syms.counter) in incr (syms.counter);
  let id,sr,_,entry = Hashtbl.find syms.dfns index in
  let kind,symdef = 
    match entry with
    | `SYMDEF_function (ps,t,es,table,dirs) ->
      let table' = copy_table syms (Some index') [] table in
      Other,`SYMDEF_function (ps,t,es,table',dirs)
      
    | `SYMDEF_procedure (ps,es,table,dirs) ->
      let table' = copy_table syms (Some index') [] table in
      Other,`SYMDEF_procedure (ps,es,table',dirs)

    | `SYMDEF_typed_functor (ps,t,es,table,dirs) ->
      let table' = copy_table syms (Some index') [] table in
      Other,`SYMDEF_typed_functor (ps,t,es,table',dirs)

    | `SYMDEF_untyped_functor (ps,es,table,dirs) ->
      let table' = copy_table syms (Some index') [] table in
      Other,`SYMDEF_untyped_functor (ps,es,table',dirs)

    | `SYMDEF_parameter _ ->
      begin try
        let iidx,midx,binding = List.assoc id binding_list in
        Parameter,`SYMDEF_module_binding 
        (
          `AST_bound_module (sr,(iidx,midx,binding))
        ) 
      with Not_found -> Other,entry
      end
    | _ -> Other,entry
  in
    (*
    print_endline 
    (
      "//   " ^ string_of_int index' ^ 
      " -> " ^
      (match kind with 
        | Other -> "copyof " 
        | Parameter -> "binding "
      )^ 
      id ^ "["^string_of_int index^"]: " ^ 
      short_string_of_src sr
    );
    *)
    Hashtbl.add syms.dfns index' (id,sr,parent,symdef)
    ;
    index'

and copy_table syms parent binding_list name_map =
  let name_map' = Hashtbl.create 97 in
  Hashtbl.iter
  (fun k v -> match v with
    | NonFunctionEntry (Simple i) ->
      let i' = copy_entry syms parent binding_list i in
      Hashtbl.add name_map' k (NonFunctionEntry (Simple i'))
      
    | NonFunctionEntry _ -> 
      failwith "instantiate not expecting bound entry"
    | FunctionEntry ls ->
      let fs = 
        List.map
        (fun e -> match e with
          | Simple i ->
            Simple (copy_entry syms parent binding_list i)
          | _ -> 
            failwith "instantiate not expecting bound entry"
        )
        ls
      in
        Hashtbl.add name_map' k (FunctionEntry fs)
  )
  name_map
  ;
  name_map'

and instantiate_functor syms
  sr excluded_dirs findex (m: module_rep_t) 
: module_rep_t =
  (* print_endline "CHECKING FOR FUNCTOR INSTANTIATION"; *)
  try 
    let afidx = Hashtbl.find syms.freg (findex, m) in
    let _,_,_,entry = Hashtbl.find syms.dfns afidx in
    match entry with
    | `SYMDEF_module (name_map,dirs) -> Simple_module (afidx,name_map,dirs)
    | _ -> failwith "Expected instantiation to be simple module"
  with Not_found ->
  (* print_endline "INSTANTIATING FUNCTOR"; *)
  let _,_,parent,entry = Hashtbl.find syms.dfns findex in
  let ps,asms,name_map,dirs = 
    match entry with 
    | `SYMDEF_typed_functor (ps,rt,asms,name_map,dirs) -> ps,asms,name_map,dirs
    | `SYMDEF_untyped_functor (ps,asms,name_map,dirs) -> ps,asms,name_map,dirs
    | _ -> failwith "Expected functor"
  in
  let env = build_env syms excluded_dirs parent in

  let rec aux ps (m:module_rep_t) : functor_arg_binding_t =
    match m with
    | Bound_module (iindex,impl,binding) ->
      begin match ps with
      | [x] -> [fst x,(iindex,impl,binding)]
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Simple_module (impl,mmap,dirs) -> 
      begin match ps with
      | [x] ->
        let t = bind_type syms env [] excluded_dirs sr (snd x) in
        begin match handle_module_coercion syms env sr excluded_dirs m t with
        | Bound_module (iindex,impl,binding)  -> 
          [fst x, (iindex,impl,binding)]
        | _ -> failwith "Expected bound module result" 
        end
      | _ -> failwith "Multiple parameters require module product argument"
      end

    | Functor_set _ -> failwith "Expected bound module, got Functor set"
    | Module_product ls -> 
      if List.length ls = List.length ps 
      then List.concat ( List.map2 (fun p m -> aux [p] m) ps ls)
      else failwith "Module product wrong length"

  in 
    let binding = aux ps m in
    let mindex = !(syms.counter) in incr (syms.counter); 
    let mname = "_module_" ^ string_of_int mindex in 
    print_endline 
    (
      "// " ^ string_of_int mindex ^ 
      " -> instance " ^ mname ^ ": " ^ 
      short_string_of_src sr
    );
    Hashtbl.add syms.freg (findex,m) mindex; 
    let mtable = copy_table syms (Some mindex) binding name_map in
    Hashtbl.add syms.dfns mindex (mname,sr,parent, (`SYMDEF_module (mtable,dirs))); 
    (*
    print_endline "Instantiated Functor has table:";
    Hashtbl.iter
    (fun k v -> print_endline (" " ^ k ^ " -> " ^ (match v with
      | NonFunctionEntry (Simple i) -> string_of_int i
      | NonFunctionEntry (Bound (i,j)) -> "bound"
      | FunctionEntry ls -> "function overload set"
    )))
    mtable
    ;
    *)
    Simple_module (mindex,mtable,dirs)

and handle_functor_application syms env sr excluded_dirs f m =
  (* print_endline "HANDLING FUNCTOR APPLICATION"; *)
  let m' = eval_module_expr syms env excluded_dirs m in
  let f' = eval_module_expr syms env excluded_dirs f in
  match f' with
  | Functor_set ls ->
    let matches = resolve_functor_overload syms env excluded_dirs sr ls m' in
    begin match matches with
    | [index] -> 
        instantiate_functor syms sr excluded_dirs index m'
    | [] -> failwith "No match overloading functor"
    | _ -> failwith "Too many matches overloading functor"
    end

  | _ -> failwith "Expected functor"


and check_module syms excluded_dirs sr entries =
    begin match entries with
    | FunctionEntry ls -> 
      let ls = 
        List.map
        (function 
          | Simple index -> 
            let id,sr,parent,entry = Hashtbl.find syms.dfns index in
            begin match entry with
            | `SYMDEF_typed_functor _ -> index
            | `SYMDEF_untyped_functor _ -> index
            | _ -> 
              failwith 
              (
                "Expected Functor, got : " ^
                string_of_symdef entry id ^ "\nin "^
                short_string_of_src sr
              )
            end
          | Bound _ -> failwith "Not expecting bound entry for functor"
        )
        ls
      in Functor_set ls

    | NonFunctionEntry (Simple index) ->
      let id,sr',parent,entry = Hashtbl.find syms.dfns index in
      begin match entry with
      | `SYMDEF_module (table,dirs) -> 
        Simple_module (index,table,dirs)
      | `SYMDEF_module_binding e ->
        let env' = build_env syms excluded_dirs parent in
        eval_module_expr syms env' excluded_dirs e
      | _ -> 
        failwith 
        (
          "Expected '" ^ id ^ "' to be module in: " ^
          short_string_of_src sr ^ ", found: " ^
          short_string_of_src sr'
        )
      end
    | _ -> 
      failwith
      (
        "Expected simple non function entry, got binding"
      )
    end

and make_bound binding x = 
  let bi i = Bound (i, Hashtbl.find binding i) in
  let be e = 
    match e with 
    | Simple i -> bi i
    | Bound _ -> failwith "Entry already bound!"
  in
  match x with
  | NonFunctionEntry e -> NonFunctionEntry (be e)
  | FunctionEntry fs -> FunctionEntry (List.map be fs)

and eval_module_expr syms env excluded_dirs e : module_rep_t = 
  (*
  print_endline ("Handling module expression '"^string_of_expr e^"'"); 
  *)
  match e with
  | `AST_root sr ->
    let root_env,_ = list_last env in
    let rec find_root i =
      let id,sr,parent,entry = Hashtbl.find syms.dfns i in
      match parent with 
      | None -> i
      | Some i -> find_root i
    in
    (* THIS IS A HACK! It assumes the last use of the syms.counter
      was for building an entry in the syms.dfns symtab!
    *)
    let root_index = find_root (!(syms.counter) - 1) in
    (*
    print_endline ("ROOT IS INDEX " ^ string_of_int root_index)
    ;
    *)
    Simple_module (root_index,root_env,[]) 

  | `AST_tuple (sr,es) ->
    Module_product (List.map (eval_module_expr syms env excluded_dirs) es)

  | `AST_coercion (sr,(m,t)) ->
    handle_coercion syms env sr excluded_dirs m t

  | `AST_bound_module (sr,(iface,impl,binding)) ->
    Bound_module (iface,impl,binding)

  | `AST_apply (sr,(f,m)) ->
    let x = handle_functor_application syms env sr excluded_dirs f m in
    (* print_endline "FUNCTOR APPLIED"; *)
    x

  | `AST_name (sr,name) ->
    let entries = lookup_name_in_env env sr name in
    check_module syms excluded_dirs sr entries

  | `AST_lookup (sr,(e,name)) ->
    let result = eval_module_expr syms env excluded_dirs e in
    let entries = 
      begin match result with
      | Simple_module (index,table,dirs) ->
        begin match lookup_name_in_htab table name with
        | Some x -> x
        | None -> failwith 
          (
            "Can't find " ^ name ^ " in module in\n"  ^ 
            short_string_of_src sr 
          )
        end

      | Bound_module (iface,impl,binding) ->
        let id,sr,parent,entry = Hashtbl.find syms.dfns iface in
        begin match entry with
        | `SYMDEF_interface (table,_) ->
          begin match lookup_name_in_htab table name with
          | Some x ->
            make_bound binding x
          | None -> failwith 
            (
              "Can't find " ^ name ^ " in module in\n"  ^ 
              short_string_of_src sr 
            )
          end

        | _ -> failwith "Expected interface"
        end

      | Functor_set _ -> failwith "Can't lookup in functor set"
      | Module_product _ -> failwith "Can't lookup in module product"
      end 
    in check_module syms excluded_dirs sr entries

  | _ ->
    failwith 
    (
      "Invalid module expression " ^ 
      string_of_expr e ^ " in\n" ^
      short_string_of_src (src_of_expr e) 
    )

and bind_index syms env exclude fixlist expr_fixlist depth excluded_dirs sr index params = 
  (*
  print_endline ("BINDING INDEX " ^ string_of_int index);
  flush stdout;
  *)
  if List.mem_assoc index exclude 
  then begin
    print_endline (
      "Making fixpoint for Recursive type alias " ^
      (
        match get_data syms.dfns index with id,sr,_,_ -> 
          id ^ " defined at " ^
          short_string_of_src sr
      )
    );
    `BTYP_fix ((List.assoc index exclude)-depth)
  end  
  else begin match get_data syms.dfns index with
  | id,sr,_,entry-> 
    (*
    print_endline (string_of_symdef entry id);
    *)
    match entry with
    | `SYMDEF_dcl (`DCL_type_alias t) -> 
      (*
      print_endline "GOT A TYPE ALIAS";
      *)
      bind_type' syms env ((index,depth) :: exclude) fixlist expr_fixlist depth excluded_dirs sr t params

    | `SYMDEF_if_type -> `BTYP_name index
    | `SYMDEF_dcl (`DCL_abs _) -> `BTYP_name index
    | `SYMDEF_dcl (`DCL_union _) -> `BTYP_name index
    | `SYMDEF_dcl (`DCL_struct _) -> `BTYP_name index
    | `SYMDEF_interface _ -> `BTYP_name index
    | `SYMDEF_module_binding e ->
      let e' = 
        eval_module_expr syms env excluded_dirs e
      in 
      begin match e' with
      | Bound_module (iface,impl,binding) -> 
        `BTYP_binding (`BTYP_name iface, `BTYP_name impl)
      | _ -> failwith "Expected module binding expression to be bound module"
      end
    | _ -> 
      failwith 
      (
        "[bind_index] Type " ^ id ^ 
        " defined at " ^ short_string_of_src sr ^
        " must be abstract, union or struct, got:\n" ^
        string_of_symdef entry id
      )
  end 

and metatype syms params term =
  let st t = string_of_btypecode syms.dfns t in
  let mt t = metatype syms params t in
  match term with
  | `BTYP_typefun (a,b,c) ->
    let ps = List.map snd a in
    let argt =
      match ps with
      | [x] -> x
      | _ -> `BTYP_tuple ps
    in 
      let rt = metatype syms (a @ params) c in
      if b<>rt
      then 
        failwith 
        (
          "In abstraction\n" ^
          st term ^
          "\nFunction body metatype \n"^
          st rt^
          "\ndoesn't agree with declared type \n" ^ 
          st b
        )
      else `BTYP_function (argt,b)

  | `BTYP_type_tuple ts ->
    `BTYP_tuple (List.map (metatype syms params) ts)

  | `BTYP_apply (a,b) ->
    begin 
      let ta = mt a
      and tb = mt b 
      in match ta with
      | `BTYP_function (x,y) ->
        if x = tb then y
        else 
          failwith "Metatype error: function argument wrong metatype"
      | _ -> failwith "Metatype error: function required for LHS of application"
    end
  | `BTYP_var i -> List.assoc i params
  | _ -> `BTYP_type
  


(* This routine binds a type expression to a bound type expression.
   Note in particular that a type alias is replaced by what
   it as an alias for, recursively so that the result 
   globally unique
*)

and bind_type syms env expr_fixlist excluded_dirs sr t : btypecode_t =
  let t' = bind_type' syms env [] [] expr_fixlist 0 excluded_dirs sr t [] in
  (*
  print_endline ("TYPE  " ^ string_of_typecode t);
  print_endline ("BOUND " ^ string_of_btypecode syms.dfns t');
  *)
  let t'' = beta_reduce syms [] t' in
  (*
  if t' <> t'' then begin
    print_endline ("TYPE  " ^ string_of_typecode t);
    print_endline ("BOUND " ^ string_of_btypecode syms.dfns t');
    print_endline ("REDUCED " ^ string_of_btypecode syms.dfns t'')
  end;
  *)
  t''

(* fixpoint reduction: reduce
   Fix f. Lam x. e ==> Lam x. Fix z. e [f x -> z]
   to replace a recursive function
   with a recursive data structure
*)

and fixup ps body =
 let param = match ps with
   | [] -> assert false
   | [i,_] -> `BTYP_var i
   | x -> `BTYP_type_tuple (List.map (fun (i,_) -> `BTYP_var i) x)
 in
 let rec aux term depth =
   let fx t = aux t (depth+1) in
   match term with
   | `BTYP_apply (`BTYP_fix i, arg) 
     when arg = param 
     && i + depth +1  = 0 (* looking inside application, one more level *)
     -> `BTYP_fix (i+2) (* elide application AND skip under lambda abstraction *)

   | `BTYP_tuple ls -> `BTYP_tuple (List.map fx ls)
   | `BTYP_sum ls -> `BTYP_sum (List.map fx ls)
   | `BTYP_type_tuple ls -> `BTYP_type_tuple (List.map fx ls)
   | `BTYP_function (a,b) -> `BTYP_function (fx a, fx b)
   | `BTYP_binding (a,b) -> `BTYP_binding (fx a, fx b)
   | `BTYP_pointer a -> `BTYP_pointer (fx a)
   | `BTYP_apply(a,b) -> `BTYP_apply (fx a, fx b)
   | `BTYP_typefun (a,b,c) ->
      (* NOTE we have to add 2 to depth here, an extra
      level for the lambda binder.
      NOTE also: this is NOT a recusive call to fixup!
      It doesn't fixup this function.
      *)

      `BTYP_typefun (a, fx b, aux c (depth + 2))
   | _ -> term
 in 
   (* note depth 1: we seek a fix to an abstraction
   of which we're given only the body, that's an 
   extra level in the term structure 
   *)
   aux body 1

and beta_reduce syms params t = 
  let br t = beta_reduce syms params t in
  let st t = string_of_btypecode syms.dfns t in
  let mt t = metatype syms params t in
  match t with
  | `BTYP_apply (t1,t2) ->
    (*
    print_endline "-----------------------";
    print_endline ("Application " ^ st t);
    print_endline "";
    print_endline ("Unreduced function is " ^ st t1);
    print_endline ("Unreduced Argument is " ^ st t2);
    *)
    let t2 = br t2 in (* eager evaluation *)
    let t1 = br t1 in (* eager evaluation *)
    (*
    print_endline ("reduced function is " ^ st t1);
    print_endline ("reduced Argument is " ^ st t2);
    *)
    let mt1 = mt t1
    and mt2 = mt t2 
    in
    (*
    print_endline ("Function metatype is" ^ st mt1);
    print_endline ("Argument metatype is" ^ st mt2);
    *)
    begin match mt1 with
    | `BTYP_function (a,b) ->
      if a <> mt2
      then failwith ("Argument metatype not same as function parameter")
    | _ -> 
      failwith ("Expected LHS of application to be function, got\n" ^ st t1)
    end
    ;
    begin match t1 with
    | `BTYP_typefun (ps,r,body) ->
      let v = Hashtbl.create 97 in
      begin match ps with
      | [] -> ()
      | [i,_] -> Hashtbl.add v i t2
      | _ -> 
        let ts = match t2 with 
        | `BTYP_type_tuple ts -> ts 
        | _ -> assert false 
        in
          if List.length ps <> List.length ts
          then failwith "Wrong number of arguments to typefun"
          else List.iter2 (fun (i,_) y -> Hashtbl.add v i y) ps ts
      end
      ;
      (*
      print_endline "Variable assignments are ";
      Hashtbl.iter
      (fun i t -> print_endline (string_of_int i ^ " -> " ^ st t))
      v
      ;
      print_endline ("Body is " ^ st body);
      *)
      let t = varmap_subst v body in
      (*
      print_endline ("Result of application = " ^ st t);
      *)
      br t

    | `BTYP_var _ -> t (* can't reduce it yet *)
    | _ -> failwith "[beta-reduce] Expected type function or variable"
    end

  | `BTYP_tuple ls -> `BTYP_tuple (List.map br ls)
  | `BTYP_sum ls -> `BTYP_sum (List.map br ls)
  | `BTYP_type_tuple ls -> `BTYP_type_tuple (List.map br ls)
  | `BTYP_function (a,b) -> `BTYP_function (br a, br b)
  | `BTYP_binding (a,b) -> `BTYP_binding (br a, br b)
  | `BTYP_pointer a -> `BTYP_pointer (br a)
  | `BTYP_typefun (p,r,b) -> 
    let p' = List.map (fun (i,t) -> (i, br t)) p in
    (*
    print_endline ("fixing up function " ^ st t);
    print_endline ("body is " ^ st b);
    *)
    let b = fixup p b in
    (*
    print_endline ("After fixup body is " ^ st b);
    *)
    `BTYP_typefun (p', br r, beta_reduce syms (p' @ params) b)

  | _ -> t

and bind_type' syms env exclude fixlist expr_fixlist depth excluded_dirs sr t params : btypecode_t =
  let bt t = bind_type' syms env exclude fixlist expr_fixlist (depth+1) excluded_dirs sr t params in
  let bi i = bind_index syms env exclude fixlist expr_fixlist depth excluded_dirs sr i params in
  (*
  print_endline ("BINDING TYPE " ^ string_of_typecode t);
  flush stdout;
  *)
  match t with
  | `AST_root _ -> failwith "Not expecting root in bind type"
  | `TYP_proj (i,t) -> 
    let t = bt t in
    begin match unfold t with 
    | `BTYP_tuple ls ->
      if i < 1 or i>List.length ls
      then 
        failwith 
        (
          short_string_of_src sr ^
          "\nproduct type projection index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (List.length ls)
        )
      else List.nth ls (i-1)

    | _ -> 
      failwith 
      (
        short_string_of_src sr ^
        "\ntype projection requires product type"
      )
    end

  | `TYP_dom t -> 
    let t = bt t in 
    begin match unfold t with
    | `BTYP_function (a,b) -> a
    | _ ->
      failwith 
      (
        short_string_of_src sr ^
        "\ntype domain requires function" 
      )
    end
  | `TYP_cod t -> 
    let t = bt t in 
    begin match unfold t with
    | `BTYP_function (a,b) -> b
    | _ ->
      failwith 
      (
        short_string_of_src sr ^
        "\ntype codomain requires function" 
      )
    end

  | `TYP_case_arg (i,t) ->
    let t = bt t in
    begin match unfold t with
    | `BTYP_sum ls ->
      if i < 1 or i>List.length ls
      then 
        failwith 
        (
          short_string_of_src sr ^
          "\nsum type extraction index " ^ 
          string_of_int i ^ 
          " out of range 1 to " ^
          string_of_int (List.length ls)
        )
      else List.nth ls (i-1)

    | _ -> 
      failwith 
      (
        short_string_of_src sr ^
        "\nsum type extraction requires sum type"
      )
    end

 
  | `TYP_none ->  `BTYP_none
  | `TYP_var i ->  `BTYP_var i
  | `TYP_as (t,s) -> 
    bind_type' syms env exclude ((s,depth)::fixlist) expr_fixlist depth excluded_dirs sr t params

  | `TYP_typeof e ->
    (*
    print_endline ("Evaluating typeof(" ^ string_of_expr e ^ ")");
    *)
    let t =
      if List.mem_assq e expr_fixlist
      then begin
        let outer_depth = List.assq e expr_fixlist in
        (*
        print_endline ("OUTER DEPTH IS " ^ string_of_int outer_depth);
        print_endline ("CURRENT DEPTH " ^ string_of_int depth);
        *)
        let fixdepth = outer_depth -depth in
        (*
        print_endline ("FIXPOINT IS " ^ string_of_int fixdepth);
        *)
        `BTYP_fix fixdepth
      end
      else
        snd(bind_expression syms env [] ((e,depth)::expr_fixlist) (depth+1) excluded_dirs e)
    in 
      (*
      print_endline ("typeof --> " ^ string_of_btypecode syms.dfns t);
      *)
      t

  | `TYP_tuple ts -> 
    let ts' =List.map bt ts  in
    `BTYP_tuple ts'

  | `TYP_sum ts -> 
    let ts' =List.map bt ts  in
    `BTYP_sum ts'

  | `TYP_function (d,c) -> 
    let 
      d' = bt d  and 
      c' = bt c 
    in 
      (*
      print_endline "DONE (function type)";
      flush stdout;
      *)
      `BTYP_function (bt d, bt c)

  | `TYP_pointer t -> 
     let t' = bt t in 
     (*
     print_endline "Done (pointer type)"; 
     flush stdout; 
     *)
     `BTYP_pointer t'

  | `AST_void _ -> 
    (*
    print_endline "Done (void)"; 
    flush stdout; 
    *)
    `BTYP_void

  | `TYP_typefun (ps,r,body) -> 
    let data = 
      List.rev_map 
      (fun x -> fst x, bt (snd x), let n = !(syms.counter) in incr (syms.counter); n) 
      ps 
    in
    let pnames =  (* reverse order .. *)
      List.map (fun (n, t, i) -> (n,i)) data 
    in
    let bbody = 
      bind_type' syms env exclude 
      fixlist expr_fixlist (depth+1) 
      excluded_dirs sr 
      body (pnames@params) 
    in
      let bparams = (* order as written *)
        List.rev_map (fun (n,t,i) -> (i,t)) data 
      in
      `BTYP_typefun (bparams, bt r, bbody)

  | `TYP_apply (t1,t2) ->
    `BTYP_apply (bt t1, bt t2)

  | `TYP_type -> `BTYP_type

  | `AST_name (sr,s) when List.mem_assoc s fixlist ->
    print_endline ("Binding fixpoint " ^ s);
    `BTYP_fix ((List.assoc s fixlist)-depth)

  | `AST_name (sr,s) when List.mem_assoc s params ->
    `BTYP_var (List.assoc s params)

  | `TYP_type_tuple ts ->
    `BTYP_type_tuple (List.map bt ts)

  | #qualified_name_t as x -> 
    (* print_endline "BIND TYPE DOING LOOKUP QN IN ENV";
    flush stdout;
    *)
    match lookup_qn_in_env syms env excluded_dirs x with
    | Bound (i,m) -> 
      (* print_endline "Lookup returns bound type";
      flush stdout;
      *)
      `BTYP_binding (bi i, bi m)

    | Simple index -> 
      (*
      print_endline ("Lookup returns simple index " ^ string_of_int index);
      flush stdout; 
      *)
      bi index

(* This routine takes a bound type, and produces a unique form
   of the bound type, by again factoring out type aliases.
   The type aliases can get reintroduced by map_type,
   if an abstract type is mapped to a typedef, so we have
   to factor them out again .. YUK!!
*)
   
and rebind_btype syms env excluded_dirs sr t: btypecode_t =
  let rbt t = rebind_btype syms env excluded_dirs sr t in
  match t with
  | `BTYP_name i ->
    let id,sr,parent,entry = Hashtbl.find syms.dfns i in
    begin match entry with
    | `SYMDEF_dcl (`DCL_type_alias t') ->
      bind_type syms env [] excluded_dirs sr t'
    | _ -> t
    end
  | `BTYP_tuple ts -> `BTYP_tuple (List.map rbt ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map rbt ts)
  | `BTYP_function (a,r) -> `BTYP_function (rbt a, rbt r) 
  | `BTYP_pointer t -> `BTYP_pointer (rbt t)
  | `BTYP_void -> `BTYP_void
  | `BTYP_none -> `BTYP_none
  | `BTYP_binding (a,b) -> `BTYP_binding (rbt a,rbt b)
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> failwith "Unexpected type variable in rebind_type"
  | _ -> failwith "Unexpected metatype in rebind_type"


and base_typename_of_literal v = match v with
  | `AST_int (t,_) -> t
  | `AST_float (t,_) -> t
  | `AST_string _ -> "string"

and  typeof_literal syms env sr v : btypecode_t = 
  let root,_ = List.hd (List.rev env) in
  let name = base_typename_of_literal v in
  match lookup_name_in_env env dummy_sr name with
  | NonFunctionEntry (Simple index) -> 
    `BTYP_name index
  | _ -> 
    failwith 
    (
      "Unable to find simple definition of type " ^ 
      name ^ " of literal " ^
      string_of_literal v
    )
  
and  typeof_list = function 
  | [x] -> x 
  | x -> `TYP_tuple x

and  typlist params = List.map snd params
and  paramtype params = typeof_list (typlist params)

and  sig_of_symdef symdef name = match symdef with 
  | `SYMDEF_match_check (_) 
    -> `TYP_tuple[]

  (* primitives *)
  | `SYMDEF_dcl (`DCL_fun (ps,_,_))
  | `SYMDEF_dcl (`DCL_proc (ps,_)) -> typeof_list ps

  | `SYMDEF_function (ps,_,_,_,_)
  | `SYMDEF_procedure (ps,_,_,_) -> paramtype ps

  | `SYMDEF_if_fun (t) -> 
    begin match t with
    | `TYP_function (a,r) -> a
    | _ -> failwith "[resolve overload] Expected function to have function type"
    end
  | `SYMDEF_if_proc (t) -> t
  
  | symdef -> 
    failwith (
      "[resolve_overload] Expected "^
      name
      ^" to be function or procedure, got " ^
     string_of_symdef symdef name 
    )    

and typeofindex 
  syms 
  (exclude:int list)
  expr_fixlist
  depth
  (excluded_dirs:int list)
  (index:int)
: btypecode_t = 
    if Hashtbl.mem syms.ticache index
    then Hashtbl.find syms.ticache index
    else 
      let t = typeofindex' syms exclude expr_fixlist depth excluded_dirs index in
      (match t with (* HACK .. *)
      | `BTYP_fix _ -> ()
      | _ -> Hashtbl.add syms.ticache index t
      );
      t

and cal_ret_type syms exclude expr_fixlist depth excluded_dirs index =
  let env = build_env syms excluded_dirs (Some index) in
  match (Hashtbl.find syms.dfns index) with
  | id,sr,parent,`SYMDEF_function (ps,rt,exes,name_map,dirs) ->
    let rt = bind_type' syms env [] [] expr_fixlist depth excluded_dirs sr rt [] in
    let rt = beta_reduce syms [] rt in
    let ret_type = ref rt in

    begin match exes with
    (* a bit hacky: in principle this is a multi-branch return statement,
      so it could be used wherever a return statement is used, however
      really regmatch is a function, but we use a normal function wrapper
      and a special instruction because the processing is lighter
    *)
    | [`EXE_regmatch (_,cls)] ->
      (*
      print_endline 
      (
       "Calc ret type of regmatch, initially " ^
       string_of_btypecode syms.dfns !ret_type
      );
      *)

      List.iter
      (
       fun (re,e) ->
         let t = snd (bind_expression syms env (index::exclude) expr_fixlist depth excluded_dirs e) in
         (*
         print_endline 
         (
           "regmatch instance " ^ string_of_expr e ^ ", type " ^ 
           string_of_btypecode syms.dfns t
         );
         *)
         if do_unify syms t !ret_type 
         then 
           ret_type := varmap_subst syms.varmap !ret_type
         else 
           failwith 
           (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
           )
      )
      cls
      (*
      ;
      print_endline ("type is " ^ string_of_btypecode syms.dfns !ret_type)
      *)
        
    | _ ->
      let return_counter = ref 0 in
      List.iter
      (fun exe -> match exe with
      | `EXE_return e ->
        incr return_counter;
        begin try
          let t = snd (bind_expression syms env (index::exclude) expr_fixlist depth excluded_dirs e) in
          if do_unify syms t !ret_type 
          then 
            ret_type := varmap_subst syms.varmap !ret_type
          else 
            failwith 
            (
              "Inconsistent return type of " ^ id ^ "<"^string_of_int index^">"
            )
        with _ -> ()
        end
      | _ -> ()
      )
      exes
      ;
      if !return_counter = 0 then (* it's a procedure .. *)
      begin 
        let mgu = do_unify syms `BTYP_void !ret_type in
        ret_type := varmap_subst syms.varmap !ret_type
      end
    end
    ;
    if var_occurs !ret_type
    then 
      failwith 
      (
        "Unable to resolve return type of " ^ id ^ "<"^string_of_int index^">"
      )
    ;
    !ret_type

  | _ -> assert false

  
and typeofindex'
  syms 
  (exclude:int list)
  expr_fixlist
  depth
  (excluded_dirs:int list)
  (index:int)
: btypecode_t = 

  (*
  print_endline ("TYPE OF INDEX " ^ string_of_int index ^ ", depth=" ^ string_of_int depth);
  *)
  let id,sr,parent,entry = Hashtbl.find syms.dfns index in
  (*
  print_endline ("Index is id=" ^ id);
  *)
  if List.mem index exclude
  then failwith ("Recursive type dependency for " ^ id);

  (* print_endline "BUILD ENV IN TYPEOFINDEX";  *)
  let env:env_t = build_env syms excluded_dirs parent in 
  (* print_endline "ENV BUILT in typeofindex"; *)
  flush stdout;
  let bt t:btypecode_t = 
    (* print_endline ("TYPEOFINDEX binding type " ^ string_of_typecode t); *)
    flush stdout;
    let t' = bind_type' syms env [] [] expr_fixlist depth excluded_dirs sr t [] in
    let t' = beta_reduce syms [] t' in
    (* print_endline "TYPE BOUND"; *)
    t'
  in
    (*
    print_endline ("typeofindex finds " ^ string_of_symdef entry id);
    flush stdout;
    *)
  match entry with

  | `SYMDEF_function (ps, rt,_,_,_) -> 
    let pts = List.map snd ps in
    let rt = 
      cal_ret_type syms exclude expr_fixlist depth excluded_dirs index
    in 
      if var_occurs rt 
      then failwith ("function "^id^"<"^string_of_int index^">: return type is not resolved, got: " ^ string_of_btypecode syms.dfns rt)
      else
      `BTYP_function (bt (typeof_list pts), rt)

  | `SYMDEF_procedure(ps,_,_,_) -> 
    let pts = List.map snd ps in
    bt (`TYP_function (typeof_list pts, `AST_void sr))

  | `SYMDEF_if_proc (t) -> 
    bt (`TYP_function (t,`AST_void sr))

  | `SYMDEF_dcl (`DCL_const (t,_)) ->
    bt t

  | `SYMDEF_parameter t ->
    bt t

  | `SYMDEF_val t ->
    bt t

  | `SYMDEF_var t ->
    bt t

  | `SYMDEF_if_fun (t) ->
    bt t

  | `SYMDEF_match_check _ ->
    `BTYP_function (`BTYP_tuple [], bool_t)

  | `SYMDEF_dcl (`DCL_fun (pts,rt,_)) -> 
    (* print_endline "Found function primitive";
    flush stdout;
    *)
    bt (`TYP_function (typeof_list pts,rt))
    
  | `SYMDEF_dcl (`DCL_proc (pts,_)) -> 
    bt (`TYP_function (typeof_list pts, `AST_void sr))
    
  | `SYMDEF_dcl (`DCL_union _)
  | `SYMDEF_dcl (`DCL_struct _) -> `BTYP_name index

  | _ ->
    failwith 
    (
      "[typeofindex] Expected expression term, got " ^
      id ^ " in " ^
      short_string_of_src sr
    )

and cal_apply syms ((be1,t1) as tbe1) ((be2,t2) as tbe2) : tbexpr_t =
  let rest =
    match t1 with
    | `BTYP_function (argt,rest) ->
      if argt = t2 then rest
      else 
        failwith 
        (
          "[ebind:cal_apply] Function " ^
          string_of_bound_expression syms.dfns tbe1 ^
          "\nof type " ^
          string_of_btypecode syms.dfns t1 ^
          "\napplied to argument " ^
          string_of_bound_expression syms.dfns tbe2 ^
          "\n of type " ^
          string_of_btypecode syms.dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          string_of_btypecode syms.dfns argt 
        )

    | `BTYP_binding (
        `BTYP_function (argt,rest),
        `BTYP_function (argt',rest')
      ) ->
      if argt = lift t2 
      && argt' = lower t2
      then `BTYP_binding (rest, rest')
      else 
        failwith 
        (
          "[ebind:cal_apply] Function argument " ^
          string_of_bound_expression syms.dfns tbe2 ^
          " has type\n" ^
          string_of_btypecode syms.dfns t2 ^
          "\nwhich doesn't agree with parameter type\n" ^
          string_of_btypecode syms.dfns argt 
        )

    (* HACKERY TO SUPPORT STRUCT CONSTRUCTORS *)
    | `BTYP_name index -> 
      let id,_,_,entry = Hashtbl.find syms.dfns index in
      begin match entry with
      | `SYMDEF_dcl (`DCL_struct cs) -> t1
      | _ -> 
        failwith 
        (
          "Attempt to apply non-struct " ^ id ^ ", type " ^
          string_of_btypecode syms.dfns t1 ^
          " as constructor"
        )
      end
    | _ -> 
      failwith 
      (
        "Attempt to apply non-function\n" ^
        string_of_bound_expression syms.dfns tbe1 ^ 
        "\nof type\n" ^
        string_of_btypecode syms.dfns t1 ^
        "\nto argument of type\n" ^
        string_of_bound_expression syms.dfns tbe2
      )
  in
  (*
  print_endline 
  (
    "---------------------------------------" ^
    "\nApply type " ^ string_of_btypecode syms.dfns t1 ^
    "\nto argument of type " ^ string_of_btypecode syms.dfns t2 ^ 
    "\nresult type is " ^ string_of_btypecode syms.dfns rest ^
    "\n-------------------------------------"
  );
  *)

  let rest = varmap_subst syms.varmap rest in
  if var_occurs rest 
  then 
    failwith 
    (
      "[cal_apply] Type variable in return type applying\n" ^
        string_of_bound_expression syms.dfns tbe1 ^ 
        "\nof type\n" ^
        string_of_btypecode syms.dfns t1 ^
        "\nto argument of type\n" ^
        string_of_bound_expression syms.dfns tbe2
    )
  ;
  `BEXPR_apply ((be1,lower t1), (be2,lower t2)),rest

and koenig_lookup syms sra exclude excluded_dirs id' name_map fn t2 =
  (*
  print_endline "Applying Koenig lookup";
  *)
  let entries =  
    try Hashtbl.find name_map fn 
    with Not_found -> 
      failwith 
      (
        "Koenig lookup: can't find name "^
        fn^ " in " ^ 
        (match id' with 
        | "" -> "top level module"
        | _ -> "module '" ^ id' ^ "'"
        )
      )
  in 
  match entries with
  | FunctionEntry fs ->
    (* print_endline ("Got candidates: "); List.iter (fun x -> print_endline ("  " ^ string_of_int x)) fs ; *)
    begin match resolve_overload syms excluded_dirs sra fs fn t2 with
    | Some (Simple index'') ->
      (* print_endline "Overload resolution OK"; *)
      `BEXPR_closure index'',
      (
        match 
          try typeofindex syms exclude [] 0 excluded_dirs index'' 
          with _ -> failwith "typeofindex failed"
        with
        | `BTYP_function _ as t -> t
          (* HANDLE UNKNOWN RETURN TYPE HERE *)
        | t -> 
          failwith 
          (
            "[bind_expression]: Koenig lookup: closure operator expected '"^
            fn ^"' to be function definition, got '"^
            string_of_btypecode syms.dfns t
            ^"', " ^ short_string_of_src sra
          )
      )
    | Some (Bound _ ) -> failwith "[koenig lookup] Can't handle bound result yet"
    | None ->
        let n = ref 0 
        in Hashtbl.iter (fun _ _ -> incr n) name_map; 
        print_endline ("module defines " ^ string_of_int !n^ " entries");
        failwith 
        (
          "[flx_ebind] Koenig lookup: Can't find match for " ^ fn ^ " in " ^
          short_string_of_src sra
        )
    end
  | NonFunctionEntry _ -> failwith "Koenig lookup expected function"

and lookup_qn_with_sig 
  syms 
  sra srn 
  env exclude excluded_dirs 
  (qn:qualified_name_t)
  (sign:btypecode_t)
: tbexpr_t =    
  match qn with
  | `AST_void _ -> failwith "qualified-name is void"
  | `AST_root _ -> failwith "Can't handle root yet"
  | `AST_case_tag _ -> failwith "Can't lookup case tag here"
  | `AST_typed_case _ -> failwith "Can't lookup typed case tag here"
  | `AST_name (sr,name) ->
    (*
    print_endline (
      "Lookup unqualified name '"^
      name
      ^"' with sig '"^
      string_of_btypecode syms.dfns sign
      ^"'"
    );
    flush stdout;
    *)
    lookup_name_with_sig 
      syms 
      sra srn exclude excluded_dirs 
      env name sign

  | `AST_lookup (sr,(qn',name)) -> 
    (*
    print_endline (
      "Lookup qn '"^
      string_of_qualified_name qn
      ^"' with sig'"^
      string_of_btypecode syms.dfns sign
      ^"'"
    );
    flush stdout;
    *)
    match 
      eval_module_expr 
      syms 
      env excluded_dirs 
      qn'
    with 
      | (Module_product _) ->
        failwith "Unexpected module product"

      | (Functor_set _) ->
        failwith "Unexpected Functor"

      | (Simple_module (impl, htab,dirs)) ->
        begin match lookup_name_in_htab htab name with
        | None -> 
          failwith
          (
            "Can't find name " ^ name ^ " in\n" ^
            short_string_of_src sr
          )
        | Some x -> match x with 
        | NonFunctionEntry (Simple index) ->
          let t = typeofindex syms exclude [] 0 excluded_dirs index in
          begin match t with
          | `BTYP_function (a,b) ->
             if a <> sign 
             then 
               failwith
               (
                 "Non function entry has wrong type"
               )
             else 
               `BEXPR_name index,
               typeofindex syms exclude [] 0 excluded_dirs index

          | _ -> 
            failwith
               (
                 "Non function entry not function type"
               )
          end
        | NonFunctionEntry (Bound (i,j)) ->
          failwith "Can't handle bound result yet"
        | FunctionEntry fs ->
          match
            resolve_overload
            syms excluded_dirs sra fs name sign
          with
          | Some (Simple index) ->
             `BEXPR_closure index, 
             typeofindex syms exclude [] 0 excluded_dirs index

          | Some (Bound (iface,impl)) -> 
             `BEXPR_closure impl, 
             `BTYP_binding
             (
               typeofindex syms exclude [] 0 excluded_dirs iface,
               typeofindex syms exclude [] 0 excluded_dirs impl
             )

          | None -> 
            failwith 
            (
              "[Simple module] Unable to resolve overload in\n" ^
              short_string_of_src sra
            )
        end

      | (Bound_module (iface,impl,binding)) ->
        let id,_,_,entry = Hashtbl.find syms.dfns iface in
        begin match entry with 
        | `SYMDEF_interface (table,dirs) ->
          let table' = apply_binding table binding in
          begin match lookup_name_in_htab table' name with
          | None -> 
            failwith 
            (
              "Can't find name " ^ name ^ " in\n" ^
              short_string_of_src sra
            )
          | Some x -> match x with
          | NonFunctionEntry (Simple index) ->
            let t = typeofindex syms exclude [] 0 excluded_dirs index in
            begin match t with
            | `BTYP_function (a,b) ->
               if a <> sign  (* WE NEED TO DO A LIFT HERE *)
               then 
                 failwith
                 (
                   "Non function entry has wrong type"
                 )
               else 
                 `BEXPR_name index,
                 typeofindex syms exclude [] 0 excluded_dirs index

            | _ -> 
              failwith
                 (
                   "Non function entry not function type"
                 )
            end
          | NonFunctionEntry (Bound (i,j)) ->
            failwith
            (
              "Can't handle bound non-function result yet"
            )

          | FunctionEntry fs ->
            match
              resolve_overload
              syms excluded_dirs sra fs name sign
            with
            | Some (Simple index) ->
               `BEXPR_closure index, 
               typeofindex syms exclude [] 0 excluded_dirs index

            | Some (Bound (iface,impl)) -> 
               `BEXPR_closure impl, 
               `BTYP_binding
               (
                 typeofindex syms exclude [] 0 excluded_dirs iface,
                 typeofindex syms exclude [] 0 excluded_dirs impl
               )

            | None -> 
              failwith 
              (
                "[Bound module] Unable to resolve overload in\n" ^
                short_string_of_src sra
              )

          end
        | _ -> failwith "Expected interface"
        end

and lookup_name_with_sig 
  syms 
  sra srn 
  exclude excluded_dirs env 
  name (t2:btypecode_t) 
: tbexpr_t =
  (*
  print_endline ("Lookup_name_with_sig: " ^ name ^ " of " ^ string_of_btypecode syms.dfns t2);
  flush stdout;
  *)
  match env with
  | [] -> 
    failwith 
    (
      "[lookup_name_with_sig] Can't find " ^ name ^ 
      " of " ^ string_of_btypecode syms.dfns t2 ^ "\n" ^
      "in " ^ short_string_of_src srn
    )
  | (table,dirs)::tail ->
    match 
      lookup_name_in_table_dirs_with_sig 
      (table, dirs) 
      syms 
      env exclude excluded_dirs 
      sra srn name t2 
    with
    | Some result -> (result:>tbexpr_t)
    | None -> 
      (
        (*
        print_endline "Next level of env";
        flush stdout;
        *)
        (
        lookup_name_with_sig 
          syms 
          sra srn 
          exclude excluded_dirs 
          tail name t2
        ):>tbexpr_t
      )

and handle_function 
  syms 
  env exclude excluded_dirs 
  sra srn 
  name 
  (overload:entry_kind_t)
: tbexpr_t 
=
  (*
  print_endline "HANDLE FUNCTION";
  *)
  match overload with
    | Bound (i,j) -> 
      print_endline "[handle_function] handle opaque function"; 
      let it =
        match typeofindex syms exclude [] 0 excluded_dirs i with
        | `BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[handle_function]: closure operator expected '"^
            name^"' to be function definition, got '"^
            string_of_btypecode syms.dfns t
            ^"', " ^ short_string_of_src sra
          )
      and mt =
        match typeofindex syms exclude [] 0 excluded_dirs j with
        | `BTYP_function _ as t -> t
        | t -> 
          failwith 
          (
            "[handle_function]: closure operator expected '"^
            name^"' to be function definition, got '"^
            string_of_btypecode syms.dfns t
            ^"', " ^ short_string_of_src sra
          )
      in
        `BEXPR_closure j,
        unify syms.dfns it mt
      
    | Simple index -> 
      (*
      print_endline "HANDLE FUNCTION: SIMPLE INDEX";
      flush stdout;
      *)
      begin 
        match Hashtbl.find syms.dfns index with id,sr,parent,entry 
        -> match entry with
        | `SYMDEF_match_check _
        | `SYMDEF_function _
        | `SYMDEF_dcl(`DCL_proc _ )
        | `SYMDEF_dcl(`DCL_fun _)
        | `SYMDEF_procedure _ 
          ->
          (*
          print_endline ("closure of " ^ name);
          flush stdout;
          *)
          `BEXPR_closure index,
          (
            match typeofindex syms exclude [] 0 excluded_dirs index with
            | `BTYP_function (s,d) as t -> 
              begin match d with
              | `BTYP_none -> failwith "Can't handle Unknown type in handle_function"
              | _ -> t
              end
            | t -> 
              failwith 
              (
                "[handle_function]: closure operator expected '"^name^"' to be function definition, got '"^
                string_of_btypecode syms.dfns t
                ^"', " ^ short_string_of_src sra
              )
          )
        | _ -> 
          failwith 
          (
            "[handle_function] Expected function"
          )
      end 

and lookup_name_in_table_dirs_with_sig (table, dirs) 
  syms 
  env exclude excluded_dirs 
  sra srn name t2 
: tbexpr_t option
=
  (* print_endline "LOOKUP NAME IN TABLE DIRS WITH SIG"; *)
  let result:entry_set_t =
    match lookup_name_in_htab table name  with
    | Some x -> x
    | None -> FunctionEntry []
  in
  match result with
  | NonFunctionEntry (Simple index) ->
    (* Struct constructor *)
    (* print_endline "LOOKUP NAME IN TABLE DIRS WITH SIG: Done"; *)
    Some
    (
      `BEXPR_name index, 
      typeofindex syms exclude [] 0 excluded_dirs index
    )

  | NonFunctionEntry _ ->
    failwith "[lookup_name_in_table_dirs_with_sig] expected simple nonfunction entry"

  | FunctionEntry fs ->
    (*
    print_endline "RESOLVING OVERLOAD"; flush stdout;
    *)
    let ro:entry_kind_t option = 
      resolve_overload 
      syms excluded_dirs sra fs name t2
    in
    match ro with 
      | Some result ->
        let tb : tbexpr_t =
          handle_function 
          syms 
          env exclude excluded_dirs 
          sra srn name result
        in Some tb 

      | None ->
        (*
        print_endline "NOT FOUND, trying opens";
        flush stdout;
        *)
        let opens : entry_set_t list = 
          List.concat
          (
            List.map
            (fun table -> 
              match lookup_name_in_htab table name with
              | Some x -> [x]
              | None -> []
            )
            dirs
          )
        in
          (*
          print_endline "OPENS BUILT"; flush stdout;
          *)
          let fs:entry_kind_t list = merge_functions opens name in
          let ro:entry_kind_t option = 
            resolve_overload
            syms excluded_dirs sra fs name t2
          in
          (*
          print_endline "OVERLOAD RESOLVED .. ";
          *)
          match ro with
          | Some result ->
            let tb : tbexpr_t = 
              handle_function 
              syms 
              env exclude excluded_dirs 
              sra srn name result
            in 
              (* 
              print_endline "SUCCESS"; flush stdout; 
              *)
              Some tb
          | None -> 
            (*
            print_endline "FAILURE"; flush stdout; 
            *)
            None

and handle_entry syms sra srn env exclude expr_fixlist excluded_dirs entry t2 name =
  let be e = bind_expression syms env exclude expr_fixlist 0 excluded_dirs e in
  let lu sr qn = lookup_qn_in_env syms env excluded_dirs qn in
  let bt t = bind_type syms env expr_fixlist excluded_dirs sra t in
  match entry with
  | NonFunctionEntry (Simple index) ->
    Some
    (
      `BEXPR_name index, 
      typeofindex syms exclude expr_fixlist 0 excluded_dirs index
    )
  | NonFunctionEntry _ ->
    failwith "[handle_entry] expected simple nonfunction entry"

  | FunctionEntry fs -> 
    (* print_endline ("Simple overload: function "^name^" found"); *)
    match 
      resolve_overload 
      syms 
      excluded_dirs sra fs name t2 
    with 
    | Some result ->
      Some
      (
        handle_function 
        syms 
        env exclude excluded_dirs 
        sra srn 
        name result 
      )
    | None -> None

and bind_regdef syms env exclude excluded_dirs regexp_exclude e =
  let bd e = bind_regdef syms env exclude excluded_dirs regexp_exclude e in
  match e with
  | REGEXP_seq (e1,e2) -> REGEXP_seq (bd e1, bd e2)
  | REGEXP_alt (e1,e2) -> REGEXP_alt (bd e1, bd e2)
  | REGEXP_aster e -> REGEXP_aster (bd e)
  | REGEXP_name qn ->
    begin match lookup_qn_in_env syms env excluded_dirs qn with
    | Bound _ -> failwith "[bind_regdef] Unexpected bound entry"
    | Simple i ->
      if List.mem i regexp_exclude
      then 
        failwith
        (
          "[bind_regdef] Regdef " ^ string_of_qualified_name qn ^
          " depends on itself"
        )
      else
        begin
          let id,sr,parent,entry = Hashtbl.find syms.dfns i in
          match entry with
          | `SYMDEF_dcl (`DCL_regdef e) ->
            bind_regdef syms env exclude excluded_dirs (i::regexp_exclude) e
          | _ -> 
            failwith 
            (
              "[bind_regdef] Expected " ^ string_of_qualified_name qn ^
              " to be regdef"
            ) 
        end
    end 

  | x -> x
  
and bind_expression syms env exclude expr_fixlist depth excluded_dirs e : tbexpr_t = 
  let be e = bind_expression syms env exclude expr_fixlist (depth+1) excluded_dirs e in
  let lu sr qn = lookup_qn_in_env syms env excluded_dirs qn in
  let bt sr t = beta_reduce syms [] (bind_type' syms env [] [] expr_fixlist depth excluded_dirs sr t []) in
  let ti i = typeofindex syms exclude expr_fixlist depth excluded_dirs i in

  (* model infix operator as function call *)
  let apl2 (sri:range_srcref) (fn : string) (tup:expr_t list) = 
    let sr = rslist tup in
    `AST_apply 
    (
      sr, 
      (
        `AST_name (sri,fn), 
        `AST_tuple (sr,tup)
      )
    )
  in
  (*
  print_endline ("Binding expression " ^ string_of_expr e ^ " depth=" ^ string_of_int depth);
  print_endline ("environment is:");
  print_env env;
  print_endline "==";
  *)
  match e with
  | `AST_letin _ -> failwith "Unexpected letin"
  | `AST_cond _ -> failwith "Unexpected conditional expression (should be replaced by match)"
  | `AST_typeof (sr,e) -> failwith "Unexpected 'typeof' in expression"
  | `AST_as (sr, (e1,e2)) -> failwith "Unexpected 'as' in expression" 

  | `AST_sum (sri,ls) -> 
    begin let mksum a b = apl2 sri "add" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mksum h t)
    | [] -> failwith "Not expecting empty product (unit)"
    end
    
  | `AST_product (sri,ls) ->
    begin let mkprod a b = apl2 sri "mul" [a;b] in
    match ls with 
    | h::t -> be (List.fold_left mkprod h t)
    | [] -> failwith "Not expecting empty sum (void)"
    end

  | `AST_void _
  | `AST_arrow _ -> failwith "[bind expression] Not expecting void or arrow"

  | `AST_root _ -> failwith "Can't bind root"
  | `AST_index (sr,i) -> 
    let t = typeofindex syms exclude expr_fixlist depth excluded_dirs i in
    `BEXPR_name i,t

  | `AST_bound_module _ -> 
    failwith "[Bind_expression] Not expecting bound module"

  | `AST_coercion (sr,(m,t)) -> 
    let m' = be m in
    let t' = bt sr t in
    `BEXPR_coercion (m',t'),t'

  | `AST_get_n (sr,(n,e')) -> 
    let expr,typ = be e' in
    let ctyp = match typ with 
    | `BTYP_tuple ts -> 
      let len = List.length ts in
      if n<0 or n>len-1
      then failwith 
        (
          "[bind_expression] Tuple index " ^ 
          string_of_int n ^
          " out of range 0.." ^
          string_of_int (len-1) ^
          " in " ^
          short_string_of_src sr
        )
      else List.nth ts n
    | _ -> 
      failwith 
      (
        "[bind_expression] Expected tuple " ^ 
        string_of_expr e' ^ 
        " to have tuple type, got " ^ 
        string_of_btypecode syms.dfns typ ^
        " in " ^
        short_string_of_src sr
      )
    in 
      `BEXPR_get_n (n, (expr,typ)), ctyp

  | `AST_case_tag (sr,v) ->
     failwith "plain case tag not allowed in expression (only in pattern)"

  | `AST_typed_case (sr,v,t) ->
     let t = bt sr t in
     begin match t with
     | `BTYP_sum ls ->
       if v<1 or v> List.length ls
       then failwith "Case index out of range of sum"
       else let vt = List.nth ls (v-1) in
       let ct = 
         match vt with
         | `BTYP_tuple [] -> t        (* const ctor *)
         | _ -> `BTYP_function (vt,t) (* non-const ctor *)
       in
       `BEXPR_case (v,t), ct
     | _ -> failwith "Type of case must be sum"
     end

  | `AST_name (sr,name) ->
    begin match lookup_name_in_env env sr name with
    | NonFunctionEntry (Simple index) -> 
      `BEXPR_name index, ti index

    | NonFunctionEntry Bound(i,m) ->
      let it = ti i in
      let mt = ti m in
      let t = unify syms.dfns it mt in
      `BEXPR_name m, t

    | FunctionEntry fs -> 
      (* HACK. This is needed as the argument for `AST_suffix,
         and other things that need to do overloading
      *)
      `BEXPR_functions (name,fs), `BTYP_none
    end

  | `AST_lookup (sr,(e,name)) ->
    let entry = 
      match 
          eval_module_expr 
          syms 
          env excluded_dirs 
          e 
      with 
      | (Module_product _) ->
        failwith "Unexpected module product"

      | (Functor_set _) ->
        failwith "Unexpected Functor"

      | (Simple_module (impl, htab,dirs)) ->
        lookup_name_in_htab htab name

      | (Bound_module (iface,impl,binding)) ->
        let _,_,_,entry = Hashtbl.find syms.dfns iface in
        begin match entry with 
        | `SYMDEF_interface (table,dirs) ->
          let table' = apply_binding table binding in
          lookup_name_in_htab table' name
        | _ -> failwith "Expected interface"
        end
    in 
      begin match entry with
      | Some entry -> 
        begin match entry with
        | NonFunctionEntry (Simple i) ->  
          `BEXPR_name i, ti i
          
        | NonFunctionEntry (Bound (i,j)) -> 
          `BEXPR_name j, 
          `BTYP_binding (ti i, ti j)
        | FunctionEntry fs ->
          `BEXPR_functions (name,fs),
          `BTYP_none
        end

      | None ->
        failwith
        (
          "Can't find " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      end

  | `AST_suffix (sr,(e,suf)) ->
    let bound_suffix =  bt sr suf in
    begin match be (e:>expr_t) with
    | `BEXPR_functions (name,fs),`BTYP_none ->
      begin match resolve_overload syms excluded_dirs sr fs name bound_suffix with
      | Some (Simple index) ->
         `BEXPR_closure index, 
         typeofindex syms exclude expr_fixlist depth excluded_dirs index

      | Some (Bound (iface,impl)) -> 
         `BEXPR_closure impl, 
         `BTYP_binding
         (
           typeofindex syms exclude expr_fixlist depth excluded_dirs iface,
           typeofindex syms exclude expr_fixlist depth excluded_dirs impl
         )

      | None -> 
        failwith 
        (
          "[flx_ebind] Can't find match for " ^ name ^ " in " ^
          short_string_of_src sr ^ 
          "\nCandidates are " ^
          (String.concat "\n"
            (List.map
              (function Simple i | Bound (i,_)  ->
                string_of_int i ^ "==> " ^ 
                string_of_btypecode syms.dfns (typeofindex syms [] [] 0 excluded_dirs i)
              )
              fs
            )
          )
        )
      end
    | _ -> 
      failwith
      (
        "Expected suffix to select from function set in\n" ^
        short_string_of_src sr
      )
    end

  | `AST_ref (_,(`AST_deref (sr,e))) -> be e
  
  | `AST_ref (sr,(`AST_dot (_,(e,id)))) ->
    let ref_name = "ref_" ^ id in
    be 
    (
      `AST_apply 
      (
        sr,
        (
          `AST_name (sr, ref_name),
          `AST_ref (sr,e)
        )
      )
    )

  | `AST_ref (srr,e) -> 
    let e',t' = be e in 
    begin match e' with
    | `BEXPR_name index ->
      let id,sr,parent,entry = Hashtbl.find syms.dfns index in
      begin match entry with
      | `SYMDEF_var _
      | `SYMDEF_parameter (`TYP_pointer _) -> 
        `BEXPR_ref index, 
        `BTYP_pointer (typeofindex syms exclude expr_fixlist depth excluded_dirs index)
      | `SYMDEF_parameter _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          ": Address value parameter " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | `SYMDEF_val _ ->
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Can't address a value " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      | _ -> 
        failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable " ^ id ^ " defined at " ^
          short_string_of_src sr
        )
      end
    | _ ->
      failwith 
        (
          "[bind_expression] " ^
          short_string_of_src srr ^
          "Address non variable in\n" ^
          short_string_of_src srr
        )
    end

  | `AST_deref (_,`AST_ref (sr,e)) -> be e

  | `AST_deref (_,e) -> 
    let e,t = be e in
    begin match t with 
    | `BTYP_pointer t -> `BEXPR_deref (e,t),t
    | _ -> failwith "Dereference non pointer"
    end

  | `AST_literal (sr,v) -> 
    let t = typeof_literal syms env sr v in
    `BEXPR_literal v, t

  | `AST_method_apply (sra,(fn,e2)) -> 
    let be2,t2 = be e2 in
    let tbe1 = 
      begin match t2 with
      | `BTYP_name index ->
        let id,sr,parent,entry = Hashtbl.find syms.dfns index in
        begin match parent with
        | None -> failwith "Koenig lookup: No parent for method apply (can't handle global yet)"
        | Some index' ->
          let id',sr',parent',entry' = Hashtbl.find syms.dfns index' in
          match entry' with
          | `SYMDEF_module (name_map,dirs) ->
            koenig_lookup syms sra exclude excluded_dirs id' name_map fn t2

          | `SYMDEF_interface (name_map,dirs) ->
            koenig_lookup syms sra exclude excluded_dirs id' name_map fn t2

          | _ -> failwith ("Koenig lookup: parent for method apply not module")
        end
      | _ -> failwith "apply method to nongenerative type"
      end
    in
      cal_apply syms tbe1 (be2, t2)

  | `AST_apply (sra,(`AST_name (srn,qn) as name,e2)) -> 
    (*
    print_endline ("Apply unqualified name " ^ qn);
    flush stdout;
    *)
    let be2,t2 = be e2 in
    let tbe1 =
      lookup_qn_with_sig 
        syms 
        sra srn env 
        exclude excluded_dirs 
        name t2 
    in 
      cal_apply syms tbe1 (be2,t2)

  | `AST_apply (sr,(e1,e2)) -> 
    (*
    print_endline ("General apply of " ^ string_of_expr e1);
    *)
    let tbe1 = be e1 and (be2,t2) as tbe2 = be e2 in
    begin match tbe1 with
    | `BEXPR_functions (name,fs), `BTYP_none ->
      let entry = resolve_overload 
        syms 
        excluded_dirs sr 
        fs name t2 
      in 
      let tbe1' = match entry with
      | None -> 
       failwith (
         "Unable to resolve overload of name " ^ string_of_expr e1 ^
         " with argument of type " ^ string_of_btypecode syms.dfns t2 ^
         "\nin " ^ short_string_of_src sr
       )
      | Some (Simple index) ->
         `BEXPR_closure index, 
         typeofindex syms exclude expr_fixlist depth excluded_dirs index

      | Some (Bound (iface,impl)) -> 
         `BEXPR_closure impl, 
         `BTYP_binding
         (
           typeofindex syms exclude expr_fixlist depth excluded_dirs iface,
           typeofindex syms exclude expr_fixlist depth excluded_dirs impl
         )
      in
        cal_apply syms tbe1' tbe2

    | _ ->
      cal_apply syms tbe1 tbe2
    end

  | `AST_tuple (_,es) -> 
    let bets = List.map be es in
    let _, bts = List.split bets in
    `BEXPR_tuple bets, `BTYP_tuple bts

  | `AST_dot (sr,(e,id)) ->
    let get_name = "get_" ^ id in
    be (`AST_method_apply (sr,(get_name,e)))

  | `AST_match_case (sr,(v,e)) ->
     `BEXPR_match_case (v,be e),bool_t

  | `AST_match_ctor (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name) -> 
      let fname = `AST_name (sr,"_match_ctor_" ^ name) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(context,name)) ->
      let fname = `AST_lookup (sr,(context,"_match_ctor_" ^ name)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
       be (`AST_match_case (sr,(v,e)))

    | _ -> failwith "Expected variant constructor name in union decoder"
    end
    
  | `AST_case_arg (sr,(v,e)) ->
     let (_,t) as e' = be e in
     begin match t with
     | `BTYP_sum ls ->
       let n = List.length ls in
       if v<1 or v>n 
       then failwith "Invalid sum index"
       else let t = List.nth ls (v-1) in
       `BEXPR_case_arg (v, e'),t
     | _ -> failwith "Expected sum type"
     end 

  | `AST_ctor_arg (sr,(qn,e)) ->
    begin match qn with
    | `AST_name (sr,name) -> 
      let fname = `AST_name (sr,"_ctor_arg_" ^ name) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_lookup (sr,(e,name)) ->
      let fname = `AST_lookup (sr,(e,"_ctor_arg_" ^ name)) in
      be (`AST_apply ( sr, (fname,e)))

    | `AST_typed_case (sr,v,_)
    | `AST_case_tag (sr,v) ->
      be (`AST_case_arg (sr,(v,e)))

    | _ -> failwith "Expected variant constructor name in union dtor"
    end

  | `AST_regmatch (sr,(e,cls)) ->
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "\n[Compiler error] Unexpected regmatch when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_lambda (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "\n[Compiler error] Unexpected lambda when binding expression (should have been lifted out)" ^
      string_of_expr e
    )

  | `AST_match (sr,_) -> 
    failwith 
    (
      "[bind_expression] " ^
      short_string_of_src sr ^
      "[Compiler error] Unexpected match when binding expression (should have been lifted out)"
    )


and resolve_overload 
  syms 
  excluded_dirs sr 
  fs name (suf : btypecode_t) 
: entry_kind_t option=
  let rec resolve i =
    match Hashtbl.find syms.dfns i with (id,sr,parent,symdef) ->
    parent,i,sig_of_symdef symdef id
  in
  let rec aux i =  
    match i with
    | Simple i -> 
      let p,i,t = resolve i in
      let env = build_env syms excluded_dirs p in
      let t = bind_type syms env [] excluded_dirs sr t in
      Unique (i,t)

    | Bound (i,j) ->
      let p,i,t = resolve i in
      let env = build_env syms excluded_dirs p in
      let t = bind_type syms env [] excluded_dirs sr t in
      Pair ((i,t),j)
  in
  let fun_defs = List.map aux fs in
  match 
    let lift_suf = lift suf in
    List.filter 
    (fun result -> match result with
      | Unique (_,t) 
      | Pair ((_,t),_) -> 
        lift t = lift_suf
    ) 
    fun_defs
  with 
  | [Unique (i,_)] -> Some (Simple i)
  | [Pair ((i,_),j)] -> Some (Bound (i,j))
  | [] -> None
  | _ -> failwith ("Too many candidates match in overloading " ^ name)
  

(* an environment is a list of hastables, mapping
   names to definition indicies. Each entity defining
   a scope contains one hashtable, and a pointer to
   its parent, if any. The name 'top' is special,
   it is the name of the single top level module
   created by the desugaring phase. We have to be
   able to find this name, so if when we run out
   of parents, which is when we hit the top module,
   we create a parent name map with a single entry
   'top'->NonFunctionEntry 0. 
*)
and get_table_dirs_of_index dfns index = 
  match get_data dfns index with
  | (id,sr,parent,entry) ->
    let table,dirs = 
      match entry with
      | `SYMDEF_module (table,dirs) -> table,dirs
      | `SYMDEF_interface (table,dirs) -> table,dirs
      | `SYMDEF_function (ps,t,e,table,dirs) -> table,dirs
      | `SYMDEF_procedure (ps,e,table,dirs) -> table,dirs
      | `SYMDEF_match_check _ -> Hashtbl.create 97,[]

      | `SYMDEF_typed_functor (_,_,_,table,dirs) -> table,dirs
      | `SYMDEF_untyped_functor (_,_,table,dirs) -> table,dirs
      | `SYMDEF_module_binding _ -> failwith "[build_env] Can't handle module binding"
      | `SYMDEF_if_fun _ -> failwith "Can't look into function dcl"
      | `SYMDEF_if_proc _ -> failwith "Can't look into proc dcl"
      | `SYMDEF_if_type -> failwith "Can't look into type"
      | `SYMDEF_parameter _
      | `SYMDEF_val _ 
      | `SYMDEF_var _ -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup function, procedure or module as parent, got parameter, value or variable "^id^"??"
        )
      | `SYMDEF_dcl d -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup of requires function, procedure or module as parent, got " ^ id
        )
    in parent,table,dirs

and build_env' syms parent : (name_map_t * qualified_name_t list) list =
  match parent with
  | None -> []

  | Some index ->
     let parent,table,dirs = get_table_dirs_of_index syms.dfns index in
     let qns = 
       List.concat
       (
         List.map
         (fun x -> match x with 
           | DIR_open qn -> [qn]
         )
         dirs
       )
     in
       (table,qns) :: build_env' syms parent

and map_dir 
  syms 
  (env:env_t)
  excluded_dirs 
  qn 
: name_map_t =
  (* print_endline ("Mapping open " ^ string_of_qualified_name qn); *)
  let sr = ("dummy",0,0,0,0) in
  let result = lookup_qn_in_env syms env excluded_dirs qn in
  match result with
  | Simple i ->
    begin match Hashtbl.find syms.dfns i with
    | _,_,_,`SYMDEF_module (table,_) -> table
    | _,_,_,`SYMDEF_module_binding e -> 
      (* print_endline "map_dir got module binding"; *)
      if not (List.mem i excluded_dirs)
      then
        begin match eval_module_expr syms env (i::excluded_dirs) e with 
        | Module_product _ ->
          failwith "Unexpected module product"

        | Functor_set _ ->
          failwith "Unexpected Functor"

        | Simple_module (impl, htab,dirs) ->
          htab
        | Bound_module (iface,impl,binding) ->
          (* print_endline "processing bound module"; *)
          let _,_,_,entry = Hashtbl.find syms.dfns iface in
          begin match entry with 
          | `SYMDEF_interface (table,dirs) ->
            (* print_endline "APPLYING BINDING"; *)
            apply_binding table binding
          | _ -> failwith "Expected interface"
          end
        end
      else begin
        (* print_endline ("DUMMY TABLE CREATED FOR EXCLUDED OPEN " ^ string_of_int i); *)
        Hashtbl.create 97
      end

    | _ -> failwith "[map_dir] Expected module"
    end
  | _ -> failwith "Expected module!"

and build_env'' syms excluded_dirs parent : env_t =
  let basic_env = build_env' syms parent in
  let rec resolve_dirs env =
    match env with
    | [] -> []
    | (table,dirs)::tail ->
      let base = resolve_dirs tail in
      let bound_dirs = 
        List.map
        (map_dir syms ((table,[])::base) excluded_dirs)
        dirs
      in
        (table,bound_dirs) ::base
   in 
     resolve_dirs basic_env

and build_env syms excluded_dirs parent : env_t =
  match parent with
  | None -> []
  | Some i ->
    try Hashtbl.find syms.env_cache i
    with Not_found ->
    let env = build_env'' syms excluded_dirs parent in
    Hashtbl.add syms.env_cache i env;
    env

