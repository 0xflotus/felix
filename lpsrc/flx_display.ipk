@head(1,'Display calcs')
@h = tangler('src/flx_display.mli')
@select(h)
open Flx_types
open Flx_ast
val get_display_list:
  fully_bound_symbol_table_t ->
  bid_t ->
  (bid_t * int) list

val cal_display:
  fully_bound_symbol_table_t ->
  bid_t option ->
  (bid_t * int) list

val strd: 
  string list -> property_t list -> string

@h = tangler('src/flx_display.ml')
@select(h)
open Flx_ast
open Flx_types
open Flx_util
open List

(* inner most at head of list *)
let cal_display bbdfns parent : (bid_t *int) list =
  let rec aux parent display =
    match parent with 
    | None -> rev display
    | Some parent ->
    match 
      try Hashtbl.find bbdfns parent 
      with Not_found -> 
        failwith ("[cal_display] Can't find index " ^ si parent)
    with
    | _,parent',sr,`BBDCL_class (_,vs)
    | _,parent',sr,`BBDCL_procedure (_,vs,_,_)
    | _,parent',sr,`BBDCL_function (_,vs,_,_,_)
    | _,parent',sr,`BBDCL_regmatch (_,vs,_,_,_)
    | _,parent',sr,`BBDCL_reglex (_,vs,_,_,_,_)
    | _,parent',sr,`BBDCL_glr (_,vs,_,_)
      -> aux parent' ((parent,length vs)::display)
    | _ -> assert false
  in aux parent []

(* inner most at head of list *)
let get_display_list bbdfns index : (bid_t * int) list =
  tl (cal_display bbdfns (Some index))

let strd the_display props =
  if length the_display = 0 then
  (if mem `Requires_ptf props then "(FLX_FPAR_PASS_ONLY)" else "()")
  else
  (if mem `Requires_ptf props then "(FLX_FPAR_PASS " else "(") ^ cat ", " the_display ^ ")"
 
