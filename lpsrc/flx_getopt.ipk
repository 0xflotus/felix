@head(1,'Get options')
@h=tangler('src/flx_getopt.mli')
@select(h)
open Flx_types

val parse_option: string -> (string * string) list
val parse_options: string array -> (string * string) list

val check_key_value : 
  (string * string) list -> 
  string-> string ->
  bool

val check_key: 
  (string * string) list -> 
  string ->
  bool

val check_keys: 
  (string * string) list -> 
  string list ->
  bool

val get_key_value : 
  (string * string) list -> 
  string ->
  string option

val get_key_values : 
  (string * string) list -> 
  string ->
  string list

val get_keys_values : 
  (string * string) list -> 
  string list ->
  string list

@h=tangler('src/flx_getopt.ml')
@select(h)
open List
open Flx_util
open Flx_types

let parse_option s =
  let n = String.length s in
  if n > 1 && s.[0]='-' then 
    if n > 2 && s.[1]='-' then 
    begin
      let j = ref 2 in
      while !j < n && s.[!j]<>'=' do incr j done;
      let key = String.sub s 2 (!j - 2) in
      let value = 
        if !j<n && s.[!j]='=' then 
          String.sub s (!j+1) (n - !j - 1)
        else 
          ""
      in
        [key,value]
    end 
    else
      [String.sub s 1 1, String.sub s 2 (n-2)]
  else ["",s]

let parse_options argv = 
  concat (map parse_option (List.tl (Array.to_list argv)))

let get_key_value options key = 
  catch_all (assoc key) options

let check_key options key = 
  is_some (get_key_value options key)

let check_keys options keys = 
  fold_left 
    (fun b key -> b || (check_key options key) )
    false keys

let check_key_value options key value =
  let keyval = key,value in
  let rec aux = function
  | [] -> false
  | h :: t -> if keyval = h then true else aux t
  in aux options

let get_key_values options key =
  let values = ref [] in
  let rec aux  = function
  | [] ->  !values
  | (key',value) :: t -> 
    if key=key' then values := value :: !values;
    aux t
  in rev (aux options)

let get_keys_values options keys =
  concat (map (get_key_values options) keys)

@select(tangler('src/flx_flxopt.mli'))
open Flx_types
open Flx_mtypes2

val get_felix_options:
  (string * string) list -> 
  felix_compiler_options_t

val make_syms:
  felix_compiler_options_t -> sym_state_t

val print_options:
  unit -> unit

val print_chosen:
  (string * string) list ->
  unit

@select(tangler('src/flx_flxopt.ml'))
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_getopt

let print_chosen options =
  print_endline 
  (String.concat ", " 
    (List.map 
      (fun (a, b) -> 
        a ^ "=" ^ b
      )
      options
    )
  )
 
let get_felix_options options =
  {
    elkhound    = 
      begin match get_key_value options "elkhound" with
      | Some s -> s
      | None -> "flx_elkhound"
      end
    ;
    optimise    = check_keys options ["opt"; "optimise"];
    debug       = check_key options "debug";
    with_comments = check_key options "with-comments";
    mangle_names = check_key options "mangle-names";
    include_dirs= get_keys_values options ["I"; "include"];
    print_flag  = check_keys options ["v"; "verbose"];
    generate_axiom_checks  = not (check_keys options ["no-check-axioms"]);
    trace       = check_keys options ["trace" ];
    files       = get_key_values options "";
    raw_options = options;
    reverse_return_parity = check_key options "e"; 
    force_recompile = check_keys options ["force"];
    max_inline_length = 
      begin match get_key_value options "inline" with 
      | Some i -> 
        (
          if i = "none" then 0 else
          if i = "" then 50 else
          try int_of_string i 
          with _ -> 
            failwith ("Invalid value for inline: '" ^ i^"'")
        )
      | None -> 
      begin match check_key options "noinline" with
      | true -> 0
      | false -> 
      begin match check_keys options ["inline";"opt";"optimise"] with
      | true -> 50 
      | false -> 5 
      end
      end
      end
    ;
    compile_only = check_keys options ["c";"compile-only"]
  }

let print_options () =
  print_endline "options:";
  print_endline "  -h, --help : print this help";
  print_endline "  --version: print version info";
  print_endline "  -v, --verbose: print symbol table";
  print_endline "  -q, --quiet: no stdout";
  print_endline "  -c, --compile-only: no code generation";
  print_endline "  -Idir, --include=dir : append dir to include path";
  print_endline "  --inline, --noinline, --optimise";
  print_endline "  --force : force recompilation";
  print_endline "  --with-comments : generate code with comments";
  print_endline "  --mangle-names : generate code with fully mangled names";
  print_endline "  --elkhound=flx_elkhound : set pathname of elkhound executable"

let make_syms options = 
  {
    registry = Hashtbl.create 97;
    counter = ref 1;
    dfns = Hashtbl.create 97;
    varmap = Hashtbl.create 97;
    ticache = Hashtbl.create 97;
    glr_cache = Hashtbl.create 97;
    env_cache = Hashtbl.create 97;
    compiler_options = options;
    instances = Hashtbl.create 97;
    include_files = ref [];
    roots = ref IntSet.empty;
    wrappers = Hashtbl.create 97;
    lexers = Hashtbl.create 7;
    parsers = Hashtbl.create 7;
    quick_names = Hashtbl.create 97;
    bifaces = [];
    reductions = [];
    axioms = [];
    variant_map = Hashtbl.create 97;
  }


