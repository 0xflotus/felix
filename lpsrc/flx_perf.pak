@set_title('Performance Measurements')
@head(1,"How Fast is Felix?")
This module contains codes to compare the Felix translator
with other language translators. Each translator should be run
with switches for a high level of optimisation. Here is
a list of translators with existing or planned
test harness support, along with some biased comments.
@begin_list("keyed")
@item("Felix")
The scripting language with static typing and high
performance, offers functional and procedural
programming with microthreading, and a simple
interface to C/C++. Versions prior to 1.1 offered
extremely poor performance, however 1.1 now 
appears to outperform all other translators
tested.

@item("C")
The traditional systems programming language. We test two
translators: gcc with optimisation switches, 
a plain gcc command is also tested as a baseline.
GNU's C compiler is in widespread use, but has
not been noted for good performance in the past.
Recent versions, however, appear to be doing
considerably better, for example it actually
recognizes tail calls sometimes.

@item("C++")
The popular extension of C to include overloading,
classes, templates and exceptions. Represented by 
the GNU g++ compiler. Felix itself generates C++
code compiled by g++ with the same optimisation switches.

@item("Ada")
A procedural language in the Algol tradition, with
an emphasis on strict control of all details.
we're using the GNU Ada translator system gnat,
which uses the same back end as gcc. Gnat appears
to provide excellent performance.

@item("Haskell")
Haskell is the leading lazy functional programming
language, used by everyone in the functional and
academic communities as a reference language.
We use ghc, the Glorious Glasgow Haskell compiler,
which is an open source community project hosted on Sourceforge.
The GHC programs are the most succinct and expressive,
however the translator leaves something to be desired
in performance.

@item("Ocaml")
Ocaml is an ML family language with rapidly increasing
popularity. It provides eager functional, imperative,
and object oriented programming. The bytecode compiler
is available on a wide variety of platforms, and 
on major platforms a native code compiler is available.
Ocaml is a landmark system in that it clearly
demonstrates an 'academic' functional language can
have superior performance. The Felix compiler is itself
written in Ocaml.

@item("Clean")
We would love to test Clean, a lazy functional language
which uses the type system systematically to locate
and optimise contructs reliably to destructive updates.
It is reputed to provide superior performance, however
I have not been able to get it to work on the AMD64,
and the provided binary is probably 32 bit anyhow.

@item("Java")
Java is a probably the most popular application
programming language in the world today. Earlier
versions suffered from woeful performance,
horrendous startup times, a failure to deliver
promised platform independence, and inherited
most of the serious design faults of C and C++
whilst adding many more of its own, including
a complete lack of any sane kind of polymorphism.
@p()
However it did deliver three important facilities which,
in addition to a huge marketing campaign,
had sufficient merit to ensure its growth.
Java provides garbage collection and a standard
threading model, which C and C++ lack, and came
with a standard GUI library (initially AWT, but
now SWING).
@p()
Because of its popularity, much work has been
done to solve the performance problems, both
with high quality native code compilers,
and also JIT based bytecode interpreters.
In addition Sun has added weak facilities
for polymorphism in version 2 which alleviate
some of the disgusting casting previously
required.
@p()
We're using the GNU gcj native code compiler,
which is reputed to have reasonable performance.
I would like to also test a good JIT based
interpreter.

@item("C#")
Microsofts answer to Java, C# is a better language,
but only marginally. C# had generics right
from the start, and it provides superior integration 
via the .NET platform languages. I haven't figured out
how to get a version yet (my Debian based Ubuntu system
provides a C# compiler but it depends on Mono, which
is not in the archive)

@item("Pascal")
Originally designed for teaching, extended by Borland
in their famous Turbo Pascal system, then again 
in their Delphi system. We're testing both the
GNU pascal front end of gcc and the free pascal compiler.

@end_list()
@p()
We currently generate gnuplot command files to plot
the results as jpg files for our website.  The data can be 
viewed in an interactive graphics console by running
gnuplot without arguments, then typing
@begin_displayed_code()
load "speed/plotters/ack.gpl"
@end_displayed_code()
where 'ack' is replaced by the name of the test.

@def flx_setup():
  tangle("// Felix Performance Test Program")
  tangle('#import <flx.flxh>";')
  tangle("n := atoi(System::argv 1);")
@def showgraph(machine,test,title):
  get_weaver()._write(
    '''<P></P><TABLE BORDER=2 ALIGN=center>
   <CAPTION>'''+title+'''</CAPTION>
   <TR><TD>
   <IMG ALT="'''+title+'''" SRC="images/'''+machine+'/'+test+'''.jpg">
   </TD></TR></TABLE><P></P>
   ''')

@head(2,'The Test Machines')
@head(3,'Rosella: x86-64')
This is my main work machine, an AMD64 K8 3200 with 
1G Ram and an ASUS motherboard running nVidia chipset,
budget price cache memory, 200G SATA drive,
Ubuntu Breezy Linux distribution.

@head(2,'[ack] Ackermanns Function')
Ackermann's function is used to check tail-recursion optimisation
and is heavily dependent on the number of words stacked per function call.

@showgraph('rosella','ack',"Ackermann's function on Rosella (Amd64-k8)")

@select(tangler('speed/src/felix/ack.flx','data'))
@flx_setup()

fun ack(x:int,y:int):int =>
  if x == 0 then y + 1
  elif y == 0 then ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;
v := ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;

@head(3,'C code')
@select(tangler('speed/src/c/ack.c','data'))
#include <stdio.h>
#include <stdlib.h>

int Ack(int M, int N) { 
  if (M==0) return N +1;
  else if(N==0) return Ack(M-1,1);
  else return Ack(M-1, Ack(M,N-1));
}

int main(int argc, char *argv[]) {
    int n = atoi(argv[1]);
    printf("Ack(3,%d): %d\n", n, Ack(3, n));
    return(0);
}

@head(3,'Pascal code')
@select(tangler('speed/src/pascal/ack.pp','data'))
program ack;

function ack(x:longint; y:longint):longint;
  begin
    if x = 0 then ack :=  y + 1
    else if y = 0 then ack := ack(x-1,1)
    else ack := ack(x-1, ack(x, y-1))
  end
;

var
  n,w: integer; s: string;
begin
  s := paramstr(1); val(s, n, w); if w <> 0 then n := 1;
  write('Ack(3,'); write(n); write(') : '); writeln(ack(3,n));
end.

@head(3,'Java code')
@select(tangler('speed/src/java/ack.java','data'))
public class ack {
  public static void main(String[] args) {
    int num = Integer.parseInt(args[0]);
    System.out.println("Ack(3," + num + "): " + Ack(3, num));
  }
  public static int Ack(int m, int n) {
    return 
      (m == 0) ? (n + 1) : 
      ((n == 0) ? Ack(m-1, 1) : Ack(m-1, Ack(m, n - 1)))
    ;
  }
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/ack.ml','data'))
let rec ack m n = match m,n with
  | 0,n -> n + 1
  | m,0 -> ack (m - 1) 1
  | m,n -> ack (m - 1) (ack m (n - 1))
;;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
Printf.printf "Ack(3,%d): %d\n" n (ack 3 n)
;;

@head(3,'Haskell code')
@select(tangler('speed/src/haskell/ack.hs','data'))
import System(getArgs)

main = do ~[num] <- getArgs
	  putStrLn ("Ack(3," ++ num ++ "): " ++ (show (ack 3 (read num))))

ack :: Int -> Int -> Int
ack 0 n = n+1
ack m 0 = ack (m-1) 1
ack m n = ack (m-1) (ack m (n-1));

@head(3,'Ada code')
@select(tangler('speed/src/ada/ack.ada','data'))
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Fixed;
with Ack_F;

procedure Ack is
  Num : Natural;
  function L_Trim(Source : String; Side : Ada.Strings.Trim_End := Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
begin
  if Argument_Count = 1 then
    Num := Natural'Value(Argument(1));
  else
    Num := 1;
  end if;

  Put("Ack(3,");
  Put(L_Trim ( Natural'Image (Num)));
  Put("):");
  Put(Natural'Image (Ack_F (3, Num)));
end Ack;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural is
pragma Suppress(All_Checks);
begin
   if M = 0 then
      return N + 1;
   elsif N = 0 then
      return Ack_F (M - 1, 1);
   else
      return Ack_F (M - 1, Ack_F (M, N - 1));
   end if;
end Ack_F;

@head(2,'[takfp] Takfp')
@showgraph('rosella','takfp',"Takfp on Rosella: amd64-k8")

@select(tangler('speed/src/felix/takfp.flx','data'))
@flx_setup()
open Float;
proc print1: float = 'printf("%.1f\\n",$1);';

fun Tak (x:float, y:float, z:float): float =>
  if (y >= x) then z
  else Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y))
  endif
;

w := float_of n;

print1 (Tak(w*3.0f, w*2.0f, w*1.0f));


@head(3,'C code')
@select(tangler('speed/src/c/takfp.c','data'))
#include <stdio.h>
#include <stdlib.h>

float Tak (float x, float y, float z)
{
    if (y >= x) return z;
    return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
}

int main(int argc, char* argv[])
{
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%.1f\n", Tak(n*3.0, n*2.0, n*1.0));
    return 0;
}

@head(3,'Pascal code')
@select(tangler('speed/src/pascal/takfp.pp','data'))
program takfp;

function tak(x,y,z:real):real;
  begin
    if y >= x then tak := z
    else tak := tak (tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
  end
;

var
  n,w: integer; s: string;
begin
  s := paramstr(1); val(s, n, w); if w <> 0 then n := 1;
  writeln(tak(3*n,2*n,n):0:1);
end.



@head(3,'Java code')
@select(tangler('speed/src/java/takfp.java','data'))
public class takfp {
  public static void main(String args[]) {
    int n = Integer.parseInt(args[0]);
    System.out.println( Tak(n*3.0f, n*2.0f, n*1.0f) );
  }

  public static float Tak (float x, float y, float z) {
    if (y >= x) return z;
    else return Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y));
  }
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/takfp.ml','data'))
let rec tak x y z =
  if y >= x then z
  else tak (tak (x -. 1.) y z) (tak (y -. 1.) z x) (tak (z -. 1.) x y)

let () =
  let n = float_of_string(Array.get Sys.argv 1) in
  Printf.printf "%.1f\n" (tak (3. *. n) (2. *. n) n)
;;

@head(3,'Haskell code')
@select(tangler('speed/src/haskell/takfp.hs','data'))
import System(getArgs)

main = do n <- getArgs >>= readIO.head
          putStrLn (show (tak (3*n) (2*n) n))

tak :: Float -> Float -> Float -> Float
tak x y z | y>=x      = z
          | otherwise = tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y)

@head(3,'Ada code')
@select(tangler('speed/src/ada/takfp.ada','data'))
package Takfp_Pck is
   function Tak (X, Y, Z : Float) return Float;
end Takfp_Pck;

package body Takfp_Pck is

   function Tak (X, Y, Z : Float) return Float is
   begin
      if Y >= X then
         return Z;
      else
         return Tak
           (Tak (X - 1.0, Y, Z), Tak (Y - 1.0, Z, X), Tak (Z - 1.0, X, Y));
      end if;
   end Tak;

end Takfp_Pck;
---------------------------
with Ada.Text_IO;       use Ada.Text_IO;
with Ada.Float_Text_IO; use Ada.Float_Text_IO;
with Ada.Command_Line;  use Ada.Command_Line;
with Takfp_Pck;         use Takfp_Pck;

procedure Takfp is
   N : Float;
begin
   N := Float'Value (Argument (1));
   Put (Tak (N * 3.0, N * 2.0, N * 1.0), 0, 1, 0);
   New_Line;
end Takfp;


@head(1,'Timing script')
Here is the Python script used to compile, execute and time
the programs, and convert the timing data into graphs
using gnuplot.

@select(tangler('speed/measure.py'))
import os
import time
import sys
import random
import signal
import socket

# utility to make a CLEAN directory
def mkdir(p):
  os.system('rm -rf ' + p)
  os.mkdir(p)

env = {}

execfile("config/xlators.py")

# set up any environment needed, this is a temporary hack
for k in env:
  os.putenv(k,env[k])

#define the tests
tests = {
  'ack':(1,5),
  'takfp':(1,5),
}


#------ command line arguments -----------------
max_test_time = 5.0
try: max_test_time = float(sys.argv[1])
except:pass

# maximum allowed time per test, seconds
maxtime = 5.0
try: maxtime = float(sys.argv[2])
except:pass

mintime = 0.5
try: mintime = float(sys.argv[3])
except:pass

gracetime = 10.0
try: gracetime = float(sys.argv[4])
except:pass


process_count = 1
try: process_count = int(sys.argv[5])
except:pass


# ------------ report paramaters ------------------
print "Batch time limit",max_test_time,"minutes"
print "Individual test soft seek range: ",mintime,'-',maxtime,"seconds"
print "Grace before cancellation",gracetime,"seconds"
print "Processes to run in parallel",process_count

# make the output directories
mkdir('speed/exes')
for key,mk,src in xlators:
  print "Using translator",key
  mkdir('speed/exes/'+key)

for t in tests:
  min,max=tests[t]
  print "Running test",t,"initial nrange="+str(min)+":"+str(max)

hostname = socket.gethostname()
print "Host",hostname

#--------- setup -----------------------------
ntests = len(tests)
nlators = len(xlators)

#convert to seconds
max_test_time = max_test_time * 60.0

sleep_time = maxtime+gracetime


print "COMPILING PROGRAMS"
#compile the programs
for xl,mk,src in xlators:
  for test in tests.keys():
    fst,last = tests[test]
    cmd = mk(xl,test) 
    print cmd
    # won't work on Win98, result always 0 for command.com
    result = os.system(cmd)
    if result <> 0: 
      print "Compile failure"
      sys.exit(result)

# fork extra copies of ourself now

tofork = process_count - 1
while tofork > 0:
  if os.fork() == 0: 
    print "PROCESS",tofork,"FORKED"
    random.seed() # reseed the random number generator
    break
  tofork = tofork - 1

# -------------- run -----------------------
#total time for testsing, seconds:
start_time = time.time()

#test date
etime = time.time()
ltime = time.localtime(etime)
date = time.strftime("%Y/%m/%d %H:%M",ltime)

pid = 0
spid = 0
xlt = {}

f = open("speed/results.dat","at")
while time.time() - start_time < max_test_time:
  # pick a random test and a random translator
  test_ix = random.randint(0,ntests-1)
  xlator_ix = random.randint(0,nlators-1)
  test = tests.keys()[test_ix]
  fst,lst = tests[test]
  xl,mk,src = xlators[xlator_ix]
  fst,lst = xlt.setdefault((test,xl),(fst,lst))

  # pick an integer between fst and lst inclusive
  n = random.randint(fst,lst)

  test_file = "speed/exes/"+xl+"/"+test
  test_arg = "%d" % n

  print test_file,test_arg
  start = time.time()
  pid = os.spawnl(os.P_NOWAIT,test_file,"DUMMY",test_arg)
  spid = os.spawnlp(os.P_NOWAIT,"sleep","DUMMY","%d" % int(sleep_time))
  pidx,status = os.wait()
  finish = time.time()
  elapsed = finish - start

  if pidx == spid:
    os.kill(pid,signal.SIGKILL)
    print "TIMEOUT"
    assert (elapsed > maxtime)
  else:
    os.kill(spid,signal.SIGKILL)
  os.wait()


  if  pidx == pid:
    signalled = os.WIFSIGNALED(status)
    exited = os.WIFEXITED(status)
    if not (signalled or exited):
      print "WHAT?? Neither exited nor signalled?"
      exit(2)

    # Killed by signal, possibly timeout, no result
    # can be recorded
    if signalled:
      sig = os.WTERMSIG(status)
      if sig == signal.SIGINT:
        raise KeyboardInterrupt

      if sig == signal.SIGSEGV:
        print "SEGMENTATION FAULT, TERMINATING"
        sys.exit(1)

      if sig != 0:
        print "UNKNOWN SIGNAL",sig,": TERMINATING"
        sys.exit(1)
    else:
      # the process terminated correctly, record a result even
      # if it is out of range
      if status == 0:
        x = hostname + " " + "p"+str(process_count)+" "+date + " %s %s %d %6.4f" % (xl,test,n,elapsed)
        print "#"+str(tofork),x
        f.write(x+"\n")
        f.flush()
      else:
        # the process terminated by gave an error
        # exit because this should not happen
        ret = os.WEXITSTATUS(status)
        if ret != 0:
          print "TEST RETURNED ERROR CODE ",ret,": TERMINATING"
          sys.exit(1)
        else:
          print "WHAT?? Exit code is 0 and not 0?"
          sys.exit(2)

  # overtime
  if elapsed > maxtime: 
    lst = n - 1 
    if lst < fst: fst = lst
    print 'CUT lst to',lst

  # undertime
  elif elapsed < mintime: 
    fst = n + 1
    if lst < fst: lst = fst
    print 'BOOSTED fst to',fst

  #minimum n too high
  elif n == fst:
    fst = fst - 1
    if lst < fst: lst = fst
    print "BUMPED fst down to",fst

  # maximum n too low
  elif n == lst:
    lst = lst + 1
    if lst < fst: fst = lst
    print "BUMPED lst up to",lst
    
  if lst < 1: lst = 1
  if fst < 1: fst = 1
  if fst > lst: fst = lst
  xlt[test,xl] = (fst,lst)

f.close()

@select(tangler('speed/panal.py'))
# generate analysis
# sort data by host, test, processor, n value
import sys
import os
import string
hostsd = {}

args = sys.argv
args = args[1:]
mintime = 0.5
mindata = 5
pload = "p1"

try: 
  mintime = float(args[0])
  args = args[1:]
except:pass

try: 
  mindata = int(args[0])
  args = args[1:]
except:pass

try: 
  pload = args[0]
  args = args[1:]
except:pass

print "Minimum time",mintime
print "Minimum data",mindata
print "Load        ",pload
def chkxl(x):
  return args == [] or x in args
  
def mkdir(p):
  os.system('rm -rf ' + p)
  os.mkdir(p)

mkdir("speed/plotters")
mkdir("speed/images")

fin = open("speed/results.dat")
for line in fin:
  #print line,
  hostname,kind,date,time,xl,tst,n,elapsed = string.split (line)
  n = int(n)
  elapsed=float(elapsed)
  if pload == kind:
    print hostname,kind,date,time,xl,tst,n,elapsed
    hostd = hostsd.setdefault(hostname,{})
    testd = hostd.setdefault(tst,{})
    xld = testd.setdefault(xl,{})
    nd = xld.setdefault(n,[])
    nd.append(elapsed)
fin.close()

print "DATA"
fi = open("speed/mkjpgs.gpl",'w')
fi.write("set terminal jpeg\n")

for h,d in hostsd.iteritems():
  print "host",h
  root = "speed/plotters/"+h
  mkdir(root)
  mkdir("speed/images/"+h)
  for t,xd in d.iteritems():
    print "  test",t
    mkdir(root+'/'+t)
    # one gnuplot file for each test
    fp = open(root+'/'+t+'.gpl','w')
    gx = 'set title "'+hostname+' '+pload+' '+t+'"\n'
    gx = gx + 'set xlabel "N"\n'
    gx = gx + 'set ylabel "secs"\n'
    gx = gx + 'set key left\n'
    gx = gx + 'plot \\\n'

    # one summary per test
    summary = {}
    first = 1
    xls = xd.keys()
    xls.sort()
    for xl in [x for x in xls if chkxl(x)]:
      nd = xd[xl]
      # one datafile for each test/xlator
      fxl = open(root+'/'+t+'/'+xl+'.dat','w')
      print "    xlator",xl
      ns = nd.keys()
      ns.sort()
      lines = 0
      for n in ns:
        es = nd[n]
        count = len(es)
        sum = reduce (lambda x,y: x+y,es)
        average = sum / float(count)
        emin = reduce (lambda x,y:min(x,y),es)
        emax = reduce (lambda x,y:max(x,y),es)
        print "        n %2d -[%3d]-> (%6.2f,%6.2f,%6.2f)" % (n,count,emin,average,emax)
        # one line for each n value
        # skip too low values
        if average >= mintime and count >= mindata:
          fxl.write("%s %d %0.2f\n" % (xl,n,average))
          lines = lines + 1
        summary[(-n,average)]=xl
      fxl.close()

      # gnuplot is too dumb to handle empty files
      if lines > 0:
        if first:
          first = 0
        else:
          gx = gx + ', \\\n'
        gx = gx + '"'+root+'/'+t+'/'+xl+'.dat" using 2:3 title "'+xl+'" with linespoints'
    fp.write(gx+'\n')
    fp.close()

    fi.write('set output "speed/images/'+h+'/'+t+'.jpg"\n')
    fi.write('load "speed/plotters/'+h+'/'+t+'.gpl"\n') 

    keys = summary.keys()
    keys.sort()
    prlimit = 10
    i = 0 
    print "Rankings for",t
    for m,a in keys:
      xl = summary[m,a]
      print "    %-16s %2d %6.2f" % (xl,-m,a)
      i = i + 1
      if i >= prlimit: break
fi.close()

# the client can view individual plots in an x11 console
# with the command 'gnuplot' and then 
# type 'load "filename"'

@head(2,'Standard Build commands')
@select(tangler('speed/xlators_default.py','python'))
# this file defines some standard translators
# DO NOT EDIT this file, instead:
#
# edit config/xlators_local.py to define local translators
# edit config/xlators.py to define the translators actually
# available and desired to be used in the testing
#

# for some weird reason: k is the source language, p is the test name
#
# generic compiler names 
#
# FOR PERSONAL USE ONLY -- MUST NOT BE SUBMITTED TO WEBSITE
# ALWAYS SUBMIT SPECIFIC VERSIONS OF TRANSLATORS TO WEBSITE
#
def mk_gcc(k,p):
  return "gcc -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gccopt(k,p):
  x = "gcc -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_ocamlopt(k,p):
  return "ocamlopt.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)

def mk_ocamlb(k,p):
  return "ocamlc.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)

def mk_felix(k,p):
  x = "bin/flx --test --force --static --optimise -c -DFLX_PTF_STATIC_POINTER "
  x = x + "speed/src/felix/%s && " % p
  x = x + "mv speed/src/felix/%s speed/exes/%s/%s" % (p,k,p)
  return x

def mk_ghc(k,p):
  return "ghc -O3 -fvia-C -optc -O1 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)

def mk_gnat(k,p):
  return "python script/gnatmaker.py speed/src/ada/%s speed/exes/%s " % (p,k)

def mk_gcj(k,p):
  x = "gcj -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x

# ------- SPECIFIC TRANSLATORS --------------------------
def mk_gcc_3_3(k,p):
  return "gcc-3.3 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gcc_3_3_opt(k,p):
  x = "gcc-3.3 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_gcc_4_0(k,p):
  return "gcc-4.0 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gcc_4_0_opt(k,p):
  x = "gcc-4.0 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_gpp_3_3(k,p):
  return "g++-3.3 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gpp_3_3_opt(k,p):
  x = "g++-3.3 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_gpp_4_0(k,p):
  return "g++-4.0 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gpp_4_0_opt(k,p):
  x = "g++-4.0 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

# hack, ocaml doesn't name them
def mk_ocamlopt_3_08_3(k,p):
  return "ocamlopt.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)

def mk_ocamlb_3_08_3(k,p):
  return "ocamlc.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)

# hack, felix doesn't name them
def mk_felix_1_1_0(k,p):
  x = "bin/flx --test --force --static --optimise -c -DFLX_PTF_STATIC_POINTER "
  x = x + "speed/src/felix/%s && " % p
  x = x + "mv speed/src/felix/%s speed/exes/%s/%s" % (p,k,p)
  return x

def mk_ghc_6_2_2(k,p):
  return "ghc-6.2.2 -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)

def mk_ghc_6_4_1(k,p):
  return "ghc-6.4.1.20050704 -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)

def mk_fpc_2_0_0(k,p):
  x = "fpc -O3 speed/src/pascal/%s.pp && " % p
  x = x + "mv speed/src/pascal/%s speed/exes/%s" % (p,k)
  return x

def mk_gpc_2_1_3_3(k,p):
  return "gpc-2.1-3.3 -O3 -o speed/exes/%s/%s speed/src/pascal/%s.pp" % (k,p,p)

def mk_gnat_4_0(k,p):
  return "python script/gnatmaker_4_0.py speed/src/ada/%s speed/exes/%s " % (p,k)

def mk_gcj_4_0(k,p):
  x = "gcj-4.0  -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x

# ----------- environment hack ------------------
env['GHCRTS']='-K8m -k1m' # set stack size for GHC

@select(tangler('script/gnatmaker.py'))
import os
import sys
import string
def xqt(x):
  print x
  os.system(x)

filebase = sys.argv[1]
split = string.split(filebase,'/')
filebase = split[-1]
indir =  string.join(split[:-1],'/')
curdir = os.getcwd()
os.chdir(indir)
outdir = sys.argv[2]
f = os.popen('gnatchop -w ' + filebase + '.ada | grep \\.adb')
units = f.readlines()
f.close()
units = [string.strip (x) for x in units]
for f in units:
  xqt("gcc -c -O3 "+ f)
xqt("gnatbind " + filebase)
xqt("gnatlink " + filebase)
os.chdir(curdir)
xqt("mv "+indir+'/'+filebase+" "+outdir)

@select(tangler('script/gnatmaker_4_0.py'))
import os
import sys
import string
def xqt(x):
  print x
  os.system(x)

filebase = sys.argv[1]
split = string.split(filebase,'/')
filebase = split[-1]
indir =  string.join(split[:-1],'/')
curdir = os.getcwd()
os.chdir(indir)
outdir = sys.argv[2]
f = os.popen('gnatchop -w ' + filebase + '.ada | grep \\.adb')
units = f.readlines()
f.close()
units = [string.strip (x) for x in units]
for f in units:
  xqt("gcc-4.0 -c -O3 "+ f)
xqt("gnatbind " + filebase)
xqt("gnatlink " + filebase)
os.chdir(curdir)
xqt("mv "+indir+'/'+filebase+" "+outdir)


