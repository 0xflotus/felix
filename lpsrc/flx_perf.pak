@set_title('Performance Measurements')

@select(tangler('mkplugins/speed_tests.py'))
import os
import sys
import shutil

from flxbuild.process import Process
from flxbuild.flxutil import mkdirs

import config

class speed_tests(Process):
  help = 'Run comparative tests'

  def __init__(self, *args, **kwds):
    super(speed_tests, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict, *args):
    if self.ran:
      return
    self.ran = True

    flx_perf = os.path.join(config.FLX_LPARCHIVE, 'flx_perf.pak')
    self.shell(config.ISCR, flx_perf)

    import speed.measure
    import speed.panal

    self.shell('gnuplot', os.path.join('speed', 'mkjpgs.gpl'))
    self.shell(config.ISCR,
      '--inhibit-sref=1',
      '--language=en',
      '--weaver=web',
      '--passes=2',
      '--weaver-directory=speed/',
      flx_perf,
    )

    shutil.copy(os.path.join('misc', 'interscript.css'), 'speed')

@select(tangler('spkgs/speed.py'))
pkg_requires = ["flx"]
iscr_source = ["lpsrc/flx_perf.pak"]
weaver_directory = 'speed/'

@head(1,"How Fast is Felix?")
This module contains codes to compare the Felix translator
with other language translators. Each translator should be run
with switches for a high level of optimisation. Here is
a list of translators with existing or planned
test harness support, along with some biased comments.
@begin_list("keyed")
@item("Felix")
The scripting language with static typing and high
performance, offers functional and procedural
programming with microthreading, and a simple
interface to C/C++. Versions prior to 1.1 offered
extremely poor performance, however 1.1 now
appears to outperform all other translators
tested.

@item("C")
The traditional systems programming language. We test two
translators: gcc with optimisation switches,
a plain gcc command is also tested as a baseline.
GNU's C compiler is in widespread use, but has
not been noted for good performance in the past.
Recent versions, however, appear to be doing
considerably better, for example it actually
recognizes tail calls sometimes.

@item("C++")
The popular extension of C to include overloading,
classes, templates and exceptions. Represented by
the GNU g++ compiler. Felix itself generates C++
code compiled by g++ with the same optimisation switches.

@item("Ada")
A procedural language in the Algol tradition, with
an emphasis on strict control of all details.
we're using the GNU Ada translator system gnat,
which uses the same back end as gcc. Gnat appears
to provide excellent performance.

@item("Haskell")
Haskell is the leading lazy functional programming
language, used by everyone in the functional and
academic communities as a reference language.
We use ghc, the Glorious Glasgow Haskell compiler,
which is an open source community project hosted on Sourceforge.
The GHC programs are the most succinct and expressive,
however the translator leaves something to be desired
in performance.

@item("Ocaml")
Ocaml is an ML family language with rapidly increasing
popularity. It provides eager functional, imperative,
and object oriented programming. The bytecode compiler
is available on a wide variety of platforms, and
on major platforms a native code compiler is available.
Ocaml is a landmark system in that it clearly
demonstrates an 'academic' functional language can
have superior performance. The Felix compiler is itself
written in Ocaml.

@item("Clean")
We would love to test Clean, a lazy functional language
which uses the type system systematically to locate
and optimise contructs reliably to destructive updates.
It is reputed to provide superior performance, however
I have not been able to get it to work on the AMD64,
and the provided binary is probably 32 bit anyhow.

@item("Java")
Java is a probably the most popular application
programming language in the world today. Earlier
versions suffered from woeful performance,
horrendous startup times, a failure to deliver
promised platform independence, and inherited
most of the serious design faults of C and C++
whilst adding many more of its own, including
a complete lack of any sane kind of polymorphism.
@p()
However it did deliver three important facilities which,
in addition to a huge marketing campaign,
had sufficient merit to ensure its growth.
Java provides garbage collection and a standard
threading model, which C and C++ lack, and came
with a standard GUI library (initially AWT, but
now SWING).
@p()
Because of its popularity, much work has been
done to solve the performance problems, both
with high quality native code compilers,
and also JIT based bytecode interpreters.
In addition Sun has added weak facilities
for polymorphism in version 2 which alleviate
some of the disgusting casting previously
required.
@p()
We're using the GNU gcj native code compiler,
which is reputed to have reasonable performance.
I would like to also test a good JIT based
interpreter.

@item("C#")
Microsofts answer to Java, C# is a better language,
but only marginally. C# had generics right
from the start, and it provides superior integration
via the .NET platform languages. I haven't figured out
how to get a version yet (my Debian based Ubuntu system
provides a C# compiler but it depends on Mono, which
is not in the archive)

@item("Pascal")
Originally designed for teaching, extended by Borland
in their famous Turbo Pascal system, then again
in their Delphi system. We're testing both the
GNU pascal front end of gcc and the free pascal compiler.

@end_list()
@p()
We currently generate gnuplot command files to plot
the results as jpg files for our website.  The data can be
viewed in an interactive graphics console by running
gnuplot without arguments, then typing
@begin_displayed_code()
load "speed/machine/hostname/plotters/ack.gpl"
@end_displayed_code()
where 'ack' is replaced by the name of the test.

@def flx_setup():
  tangle("// Felix Performance Test Program")
  tangle("n := atoi(System::argv 1);")
@def showgraph(machine,test,title):
  get_weaver()._write(
    '''<P></P><TABLE BORDER=2 ALIGN=center>
   <CAPTION>'''+title+'''</CAPTION>
   <TR><TD>
   <IMG ALT="'''+title+'''" SRC="machine/'''+machine+'''/images/'''+test+'''.jpg">
   </TD></TR></TABLE><P></P>
   ''')

@def showdata(fn):
  begin_displayed_code()
  try:
    f = open(fn)
    data = f.read()
    f.close()
    lines = string.split(data,'\n')
    for line in lines: weave(line+'\n')
  except:
    weave(fn+" not available\n")
  end_displayed_code()


@head(2,'The Test Machines')
@import glob
@raw_machs = glob.glob("speed/machine/*")
@machs = []
@for i in raw_machs: machs.append(i[14:])

@head(3,'Rosella: x86-64')
This is my main work machine, an AMD64 K8 3200 with
1G Ram and an ASUS motherboard running nVidia chipset,
budget price cache memory, 200G SATA drive,
Ubuntu Dapper Linux distribution.

@head(3,'Budgie: x86-64x2 (dual core)')
This is my main work machine, an AMD64x2 K8 3800 with
2G Ram and an ASUS motherboard running nVidia chipset,
budget price cache memory, 200G SATA drive,
Ubuntu Breezy Linux distribution.

@head(2,'[ack] Ackermanns Function')
Ackermann's function is used to check tail-recursion optimisation
and is heavily dependent on the number of words stacked per function call.
@for i in machs:
  showgraph(i,'ack',"Ackermann's function on "+i)
  showdata("speed/machine/"+i+"/rankings/ack.txt")

@select(tangler('speed/__init__.py'))
@select(tangler('speed/xlators/__init__.py'))
@select(tangler('speed/specs/__init__.py'))
@doc()

@select(tangler('speed/specs/ack.py','data'))
descr="Ackerman's function"
min=5
max=10

@select(tangler('speed/src/felix/ack.flx','data'))
@flx_setup()

fun ack(x:int,y:int):int =>
  if x == 0 then y + 1
  elif y == 0 then ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;
v := ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;

@head(3,'C code')
@select(tangler('speed/src/c/ack.c','data'))
#include <stdio.h>
#include <stdlib.h>

int Ack(int M, int N) {
  if (M==0) return N +1;
  else if(N==0) return Ack(M-1,1);
  else return Ack(M-1, Ack(M,N-1));
}

int main(int argc, char *argv[]) {
    int n = atoi(argv[1]);
    printf("Ack(3,%d): %d\n", n, Ack(3, n));
    return(0);
}

@head(3,'Pascal code')
@select(tangler('speed/src/pascal/ack.pp','data'))
program ack;

function ack(x:longint; y:longint):longint;
  begin
    if x = 0 then ack :=  y + 1
    else if y = 0 then ack := ack(x-1,1)
    else ack := ack(x-1, ack(x, y-1))
  end
;

var
  n,w: integer; s: string;
begin
  s := paramstr(1); val(s, n, w); if w <> 0 then n := 1;
  write('Ack(3,'); write(n); write(') : '); writeln(ack(3,n));
end.

@head(3,'Java code')
@select(tangler('speed/src/java/ack.java','data'))
public class ack {
  public static void main(String[] args) {
    int num = Integer.parseInt(args[0]);
    System.out.println("Ack(3," + num + "): " + Ack(3, num));
  }
  public static int Ack(int m, int n) {
    return
      (m == 0) ? (n + 1) :
      ((n == 0) ? Ack(m-1, 1) : Ack(m-1, Ack(m, n - 1)))
    ;
  }
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/ack.ml','data'))
let rec ack m n = match m,n with
  | 0,n -> n + 1
  | m,0 -> ack (m - 1) 1
  | m,n -> ack (m - 1) (ack m (n - 1))
;;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
Printf.printf "Ack(3,%d): %d\n" n (ack 3 n)
;;

@head(3,'Haskell code')
@select(tangler('speed/src/haskell/ack.hs','data'))
import System.Environment (getArgs)
import System.IO
import Text.Printf (hPrintf)
import GHC.Exts

main = do (x1:xs) <- getArgs
          (I# n#) <- return (read x1)
          hPrintf stdout "Ack(3,%d): %d\n" (I# n#) (I# (ack  3# n#))

ack :: Int# -> Int# -> Int#
ack 0# n = n +# 1#
ack m 0# = ack (m -# 1#) 1#
ack m n = ack (m -# 1#) (ack m (n -# 1#))

@head(3,'Ada code')
@select(tangler('speed/src/ada/ack.ada','data'))
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Fixed;
with Ack_F;

procedure Ack is
  Num : Natural;
  function L_Trim(Source : String; Side : Ada.Strings.Trim_End := Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
begin
  if Argument_Count = 1 then
    Num := Natural'Value(Argument(1));
  else
    Num := 1;
  end if;

  Put("Ack(3,");
  Put(L_Trim ( Natural'Image (Num)));
  Put("):");
  Put(Natural'Image (Ack_F (3, Num)));
end Ack;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural is
pragma Suppress(All_Checks);
begin
   if M = 0 then
      return N + 1;
   elsif N = 0 then
      return Ack_F (M - 1, 1);
   else
      return Ack_F (M - 1, Ack_F (M, N - 1));
   end if;
end Ack_F;

@head(2,'[takfp] Takfp')
@for i in machs:
  showgraph(i,'takfp',"Takfp on "+i)
  showdata("speed/machine/"+i+"/rankings/takfp.txt")

@select(tangler('speed/specs/takfp.py','data'))
descr="Taka's function, using floats"
min=5
max=10

@select(tangler('speed/src/felix/takfp.flx','data'))
@flx_setup()
open Float;
proc print1: float = 'printf("%.1f\\n",$1);';

fun Tak (x:float, y:float, z:float): float =>
  if (y >= x) then z
  else Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y))
  endif
;

w := float_of n;

print1 (Tak(w*3.0f, w*2.0f, w*1.0f));


@head(3,'C code')
@select(tangler('speed/src/c/takfp.c','data'))
#include <stdio.h>
#include <stdlib.h>

float Tak (float x, float y, float z)
{
    if (y >= x) return z;
    return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
}

int main(int argc, char* argv[])
{
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%.1f\n", Tak(n*3.0, n*2.0, n*1.0));
    return 0;
}

@head(3,'Pascal code')
@select(tangler('speed/src/pascal/takfp.pp','data'))
program takfp;

function tak(x,y,z:real):real;
  begin
    if y >= x then tak := z
    else tak := tak (tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
  end
;

var
  n,w: integer; s: string;
begin
  s := paramstr(1); val(s, n, w); if w <> 0 then n := 1;
  writeln(tak(3*n,2*n,n):0:1);
end.



@head(3,'Java code')
@select(tangler('speed/src/java/takfp.java','data'))
public class takfp {
  public static void main(String args[]) {
    int n = Integer.parseInt(args[0]);
    System.out.println( Tak(n*3.0f, n*2.0f, n*1.0f) );
  }

  public static float Tak (float x, float y, float z) {
    if (y >= x) return z;
    else return Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y));
  }
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/takfp.ml','data'))
let rec tak x y z =
  if y >= x then z
  else tak (tak (x -. 1.) y z) (tak (y -. 1.) z x) (tak (z -. 1.) x y)

let () =
  let n = float_of_string(Array.get Sys.argv 1) in
  Printf.printf "%.1f\n" (tak (3. *. n) (2. *. n) n)
;;

@head(3,'Haskell code')
@select(tangler('speed/src/haskell/takfp.hs','data'))
import System(getArgs)

main = do n <- getArgs >>= readIO . head
          putStrLn (show (tak (3*n) (2*n) n))

tak :: Float -> Float -> Float -> Float
tak x y z | y>=x      = z
          | otherwise = tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y)

@head(3,'Ada code')
@select(tangler('speed/src/ada/takfp.ada','data'))
package Takfp_Pck is
   function Tak (X, Y, Z : Float) return Float;
end Takfp_Pck;

package body Takfp_Pck is

   function Tak (X, Y, Z : Float) return Float is
   begin
      if Y >= X then
         return Z;
      else
         return Tak
           (Tak (X - 1.0, Y, Z), Tak (Y - 1.0, Z, X), Tak (Z - 1.0, X, Y));
      end if;
   end Tak;

end Takfp_Pck;
---------------------------
with Ada.Text_IO;       use Ada.Text_IO;
with Ada.Float_Text_IO; use Ada.Float_Text_IO;
with Ada.Command_Line;  use Ada.Command_Line;
with Takfp_Pck;         use Takfp_Pck;

procedure Takfp is
   N : Float;
begin
   N := Float'Value (Argument (1));
   Put (Tak (N * 3.0, N * 2.0, N * 1.0), 0, 1, 0);
   New_Line;
end Takfp;

@head(2,'[spectral] spectral norm problem')
A mix of loop index and floating point optimisation issues.
@for i in machs:
  showgraph(i,'spectralnorm',"Spectral-Norm on "+i)
  showdata("speed/machine/"+i+"/rankings/spectralnorm.txt")

@select(tangler('speed/specs/spectralnorm.py','data'))
descr="Spectral-Norm problem"
min=1
max=3

@head(3,'Felix code')
@select(tangler('speed/src/felix/spectralnorm.flx','data'))
@flx_setup()
open Carray;

typedef V = carray[double];

fun eval_A(int i, int j)=>1.0/double(((i+j)*(i+j+1))/2+i+1);

proc eval_A_times_u(int N, u:V, Au:V)
{
  int i; int j;
  for(i=0;i<N;i++)
    {
      Au.[i]=0.0;
      for(j=0;j<N;j++) Au.[i]+=eval_A(i,j)*u.[j];
    };
};

proc eval_At_times_u(int N, u:V, Au:V)
{
  int i; int j;
  for(i=0;i<N;i++)
    {
      Au.[i]=0.0;
      for(j=0;j<N;j++) Au.[i]+=eval_A(j,i)*u.[j];
    };
};


proc eval_AtA_times_u(int N, u:V, AtAu:V)
{ eval_A_times_u(N,u,tmp); eval_At_times_u(N,tmp,AtAu); };

int i;
int N = n * 1000;

u:V := array_alloc[double] N;
v:V := array_alloc[double] N;
tmp:V := array_alloc[double] N;

double vBv;
double vv;

for(i=0;i<N;i++) u.[i]=1;
for(i=0;i<10;i++)
  {
    eval_AtA_times_u(N,u,v);
    eval_AtA_times_u(N,v,u);
  }
;

vBv=0.0;
vv=0.0;
for(i=0;i<N;i++) { vBv+=u.[i]*v.[i]; vv+=v.[i]*v.[i]; };
print$ f"%0.9f\n"$ sqrt(vBv/vv);


@head(3,'C code')
@select(tangler('speed/src/c/spectralnorm.c','data'))
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double eval_A(int i, int j) { return 1.0/((i+j)*(i+j+1)/2+i+1); }

void eval_A_times_u(int N, const double u[], double Au[])
{
  int i,j;
  for(i=0;i<N;i++)
    {
      Au[i]=0;
      for(j=0;j<N;j++) Au[i]+=eval_A(i,j)*u[j];
    }
}

void eval_At_times_u(int N, const double u[], double Au[])
{
  int i,j;
  for(i=0;i<N;i++)
    {
      Au[i]=0;
      for(j=0;j<N;j++) Au[i]+=eval_A(j,i)*u[j];
    }
}

void eval_AtA_times_u(int N, const double u[], double AtAu[])
{ double v[N]; eval_A_times_u(N,u,v); eval_At_times_u(N,v,AtAu); }

int main(int argc, char *argv[])
{
  int i;
  int N = ((argc == 2) ? atoi(argv[1]) : 2) * 1000;
  double u[N],v[N],vBv,vv;
  for(i=0;i<N;i++) u[i]=1.0;
  for(i=0;i<10;i++)
    {
      eval_AtA_times_u(N,u,v);
      eval_AtA_times_u(N,v,u);
    }
  vBv=vv=0;
  for(i=0;i<N;i++) { vBv+=u[i]*v[i]; vv+=v[i]*v[i]; }
  printf("%0.9f\n",sqrt(vBv/vv));
  return 0;
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/spectralnorm.ml','data'))
let eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

let eval_A_times_u u v =
  let n = Array.length u - 1 in
  for i = 0 to n do
    let vi = ref 0.0 in
    for j = 0 to n do
      vi := !vi +. eval_A i j *. Array.unsafe_get u j
    done;
    v.(i) <- !vi
  done


let eval_At_times_u u v =
  let n = Array.length v -1 in
  for i = 0 to n do
    v.(i) <- 0.0;
    for j = 0 to n do v.(i) <- v.(i) +. eval_A j i *. u.(j) done;
  done

let eval_AtA_times_u u v =
  let w = Array.make (Array.length u) 0.0 in
  eval_A_times_u u w; eval_At_times_u w v

let () =
  let n = 1000 * (try int_of_string(Array.get Sys.argv 1) with _ ->  2) in
  let u = Array.make n 1.0  and  v = Array.make n 0.0 in
  for i = 0 to 9 do
    eval_AtA_times_u u v; eval_AtA_times_u v u
  done;

  let vv = ref 0.0  and  vBv = ref 0.0 in
  for i=0 to n-1 do
    vv := !vv +. v.(i) *. v.(i);
    vBv := !vBv +. u.(i) *. v.(i)
  done;
  Printf.printf "%0.9f\n" (sqrt(!vBv /. !vv))

@head(2,'[nbody] N-body problem')
A mix of loop index and floating point optimisation issues.
@for i in machs:
  showgraph(i,'nbody',"N-body on "+i)
  showdata("speed/machine/"+i+"/rankings/nbody.txt")

@select(tangler('speed/specs/nbody.py','data'))
descr="N-body problem"
min=5
max=10

@head(3,'Felix code')
@select(tangler('speed/src/felix/nbody.flx','data'))
@flx_setup()
PI := 3.141592653589793;
SOLAR_MASS := 4.0 * PI * PI;
DAYS_PER_YEAR := 365.24;

typedef vec = array[double,3];

fun add(x:vec,y:vec)=>x.(0)+y.(0), x.(1)+y.(1), x.(2)+y.(2);
fun sub(x:vec,y:vec)=>x.(0)-y.(0), x.(1)-y.(1), x.(2)-y.(2);
fun neg(x:vec)=>-x.(0), -x.(1),-x.(2);
fun mul(x:vec,var y:double)=>x.(0)*y, x.(1)*y, x.(2)*y;
fun div(x:vec,var y:double)=>x.(0)/y, x.(1)/y, x.(2)/y;
fun mul(var y:double,x:vec)=>x.(0)*y, x.(1)*y, x.(2)*y;
fun sqr(x:vec)=>x.(0)*x.(0)+x.(1)*x.(1)+x.(2)*x.(2);
fun norm(x:vec)=>sqrt(sqr x);
fun addr: Body -> &Body = "&$1";

struct Body { pos:vec; vel:vec; mass: double; };

proc Advance(dt: double){
   var i: int; var j:int;
   forall i in 0 upto nbodies-1 do
      bimass := bodies.[i].mass;
      var delta = 0.0,0.0,0.0;
      forall j in i+1 upto nbodies-1 do
         var bjmass = bodies.[j].mass;
         var d = bodies.[i].pos - bodies.[j].pos;
         var d2 = sqr d;
         var distance = sqrt d2;

         delta = delta + d * bjmass * dt / (distance * d2);
         bodies.[j].vel = bodies.[j].vel + d * bimass * dt / (distance * d2);
      done;
      bodies.[i].vel = bodies.[i].vel - delta;
   done;

   forall i in 0 upto nbodies-1 do
      bodies.[i].pos = bodies.[i].pos + dt * bodies.[i].vel;
   done;
}

fun Energy(): double =
{
   var i: int; var j: int;
   var e = 0.0;
   forall i in 0 upto nbodies-1 do
      e = e + 0.5 * bodies.[i].mass * sqr bodies.[i].vel;

      forall j in i+1 upto nbodies-1 do
         d := bodies.[i].pos - bodies.[j].pos;
         distance := norm d;
         e = e - bodies.[i].mass * bodies.[j].mass / distance;
      done;
   done;
   return e;
}


proc OffsetMomentum()
{
  var i: int;
  var p = (0.0,0.0,0.0);
  forall i in 1 upto nbodies-1 do
      p = p + bodies.[i].vel * bodies.[i].mass;
  done;
  bodies.[0].vel = -p / SOLAR_MASS;
}

nticks := 1_000_000 * n;

/* define planetary masses, initial positions, velocities */

jupiter := Body (
 (4.84143144246472090e+00,
 -1.16032004402742839e+00,
 -1.03622044471123109e-01),
 (1.66007664274403694e-03 * DAYS_PER_YEAR,
 7.69901118419740425e-03 * DAYS_PER_YEAR,
 -6.90460016972063023e-05 * DAYS_PER_YEAR),
 9.54791938424326609e-04 * SOLAR_MASS
);

saturn := Body (
 (8.34336671824457987e+00,
 4.12479856412430479e+00,
 -4.03523417114321381e-01),
 (-2.76742510726862411e-03 * DAYS_PER_YEAR,
 4.99852801234917238e-03 * DAYS_PER_YEAR,
 2.30417297573763929e-05 * DAYS_PER_YEAR),
 2.85885980666130812e-04 * SOLAR_MASS
);

uranus := Body (
 (1.28943695621391310e+01,
 -1.51111514016986312e+01,
 -2.23307578892655734e-01),
 (2.96460137564761618e-03 * DAYS_PER_YEAR,
 2.37847173959480950e-03 * DAYS_PER_YEAR,
 -2.96589568540237556e-05 * DAYS_PER_YEAR),
 4.36624404335156298e-05 * SOLAR_MASS
);

neptune :=  Body (
 (1.53796971148509165e+01,
 -2.59193146099879641e+01,
 1.79258772950371181e-01),
 (2.68067772490389322e-03 * DAYS_PER_YEAR,
 1.62824170038242295e-03 * DAYS_PER_YEAR,
 -9.51592254519715870e-05 * DAYS_PER_YEAR),
 5.15138902046611451e-05 * SOLAR_MASS
);

sun := Body ((0.0, 0.0, 0.0), (0.0, 0.0, 0.0), SOLAR_MASS);

var bodies = (sun,jupiter,saturn,uranus,neptune);
nbodies := 5;

OffsetMomentum();

println$ f"%.9f"$ Energy();
var i : int;
forall i in 1 upto nticks do Advance(0.01e+00); done;
println$ f"%.9f"$ Energy();

@head(3,'C code')
@select(tangler('speed/src/c/nbody.c','data'))
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define pi 3.141592653589793
#define solar_mass (4 * pi * pi)
#define days_per_year 365.24

struct planet {
  double x, y, z;
  double vx, vy, vz;
  double mass;
};

void advance(int nbodies, struct planet * bodies, double dt)
{
  int i, j;

  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double distance = sqrt(dx * dx + dy * dy + dz * dz);
      double mag = dt / (distance * distance * distance);
      b->vx -= dx * b2->mass * mag;
      b->vy -= dy * b2->mass * mag;
      b->vz -= dz * b2->mass * mag;
      b2->vx += dx * b->mass * mag;
      b2->vy += dy * b->mass * mag;
      b2->vz += dz * b->mass * mag;
    }
  }
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    b->x += dt * b->vx;
    b->y += dt * b->vy;
    b->z += dt * b->vz;
  }
}

double energy(int nbodies, struct planet * bodies)
{
  double e;
  int i, j;

  e = 0.0;
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    e += 0.5 * b->mass * (b->vx * b->vx + b->vy * b->vy + b->vz * b->vz);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double distance = sqrt(dx * dx + dy * dy + dz * dz);
      e -= (b->mass * b2->mass) / distance;
    }
  }
  return e;
}

void offset_momentum(int nbodies, struct planet * bodies)
{
  double px = 0.0, py = 0.0, pz = 0.0;
  int i;
  for (i = 0; i < nbodies; i++) {
    px += bodies[i].vx * bodies[i].mass;
    py += bodies[i].vy * bodies[i].mass;
    pz += bodies[i].vz * bodies[i].mass;
  }
  bodies[0].vx = - px / solar_mass;
  bodies[0].vy = - py / solar_mass;
  bodies[0].vz = - pz / solar_mass;
}

#define NBODIES 5
struct planet bodies[NBODIES] = {
  {                               /* sun */
    0, 0, 0, 0, 0, 0, solar_mass
  },
  {                               /* jupiter */
    4.84143144246472090e+00,
    -1.16032004402742839e+00,
    -1.03622044471123109e-01,
    1.66007664274403694e-03 * days_per_year,
    7.69901118419740425e-03 * days_per_year,
    -6.90460016972063023e-05 * days_per_year,
    9.54791938424326609e-04 * solar_mass
  },
  {                               /* saturn */
    8.34336671824457987e+00,
    4.12479856412430479e+00,
    -4.03523417114321381e-01,
    -2.76742510726862411e-03 * days_per_year,
    4.99852801234917238e-03 * days_per_year,
    2.30417297573763929e-05 * days_per_year,
    2.85885980666130812e-04 * solar_mass
  },
  {                               /* uranus */
    1.28943695621391310e+01,
    -1.51111514016986312e+01,
    -2.23307578892655734e-01,
    2.96460137564761618e-03 * days_per_year,
    2.37847173959480950e-03 * days_per_year,
    -2.96589568540237556e-05 * days_per_year,
    4.36624404335156298e-05 * solar_mass
  },
  {                               /* neptune */
    1.53796971148509165e+01,
    -2.59193146099879641e+01,
    1.79258772950371181e-01,
    2.68067772490389322e-03 * days_per_year,
    1.62824170038242295e-03 * days_per_year,
    -9.51592254519715870e-05 * days_per_year,
    5.15138902046611451e-05 * solar_mass
  }
};

int main(int argc, char ** argv)
{
  int n = 1000000 * atoi(argv[1]);
  int i;

  offset_momentum(NBODIES, bodies);
  printf ("%.9f\n", energy(NBODIES, bodies));
  for (i = 1; i <= n; i++)
    advance(NBODIES, bodies, 0.01);
  printf ("%.9f\n", energy(NBODIES, bodies));
  return 0;
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/nbody.ml','data'))
let pi = 3.141592653589793
let solar_mass = 4. *. pi *. pi
let days_per_year = 365.24

type planet = { mutable x : float;  mutable y : float;  mutable z : float;
                mutable vx: float;  mutable vy: float;  mutable vz: float;
                mass : float }

let advance bodies dt =
  let n = Array.length bodies - 1 in
  for i = 0 to Array.length bodies - 1 do
    let b = bodies.(i) in
    for j = i+1 to Array.length bodies - 1 do
      let b' = bodies.(j) in
      let dx = b.x -. b'.x  and dy = b.y -. b'.y  and dz = b.z -. b'.z in
      let dist2 = dx *. dx +. dy *. dy +. dz *. dz in
      let mag = dt /. (dist2 *. sqrt(dist2)) in

      b.vx <- b.vx -. dx *. b'.mass *. mag;
      b.vy <- b.vy -. dy *. b'.mass *. mag;
      b.vz <- b.vz -. dz *. b'.mass *. mag;

      b'.vx <- b'.vx +. dx *. b.mass *. mag;
      b'.vy <- b'.vy +. dy *. b.mass *. mag;
      b'.vz <- b'.vz +. dz *. b.mass *. mag;
    done
  done;
  for i = 0 to n do
    let b = bodies.(i) in
    b.x <- b.x +. dt *. b.vx;
    b.y <- b.y +. dt *. b.vy;
    b.z <- b.z +. dt *. b.vz;
  done


let energy bodies =
  let e = ref 0. in
  for i = 0 to Array.length bodies - 1 do
    let b = bodies.(i) in
    e := !e +. 0.5 *. b.mass *. (b.vx *. b.vx +. b.vy *. b.vy +. b.vz *. b.vz);
    for j = i+1 to Array.length bodies - 1 do
      let b' = bodies.(j) in
      let dx = b.x -. b'.x  and dy = b.y -. b'.y  and dz = b.z -. b'.z in
      let distance = sqrt(dx *. dx +. dy *. dy +. dz *. dz) in
      e := !e -. (b.mass *. b'.mass) /. distance
    done
  done;
  !e


let offset_momentum bodies =
  let px = ref 0. and py = ref 0. and pz = ref 0. in
  for i = 0 to Array.length bodies - 1 do
    px := !px +. bodies.(i).vx *. bodies.(i).mass;
    py := !py +. bodies.(i).vy *. bodies.(i).mass;
    pz := !pz +. bodies.(i).vz *. bodies.(i).mass;
  done;
  bodies.(0).vx <- -. !px /. solar_mass;
  bodies.(0).vy <- -. !py /. solar_mass;
  bodies.(0).vz <- -. !pz /. solar_mass


let jupiter = { x = 4.84143144246472090e+00;
                y = -1.16032004402742839e+00;
                z = -1.03622044471123109e-01;
                vx = 1.66007664274403694e-03 *. days_per_year;
                vy = 7.69901118419740425e-03 *. days_per_year;
                vz = -6.90460016972063023e-05 *. days_per_year;
                mass = 9.54791938424326609e-04 *. solar_mass;    }

let saturn = { x = 8.34336671824457987e+00;
               y = 4.12479856412430479e+00;
               z = -4.03523417114321381e-01;
               vx = -2.76742510726862411e-03 *. days_per_year;
               vy = 4.99852801234917238e-03 *. days_per_year;
               vz = 2.30417297573763929e-05 *. days_per_year;
               mass = 2.85885980666130812e-04 *. solar_mass;     }

let uranus = { x = 1.28943695621391310e+01;
               y = -1.51111514016986312e+01;
               z = -2.23307578892655734e-01;
               vx = 2.96460137564761618e-03 *. days_per_year;
               vy = 2.37847173959480950e-03 *. days_per_year;
               vz = -2.96589568540237556e-05 *. days_per_year;
               mass = 4.36624404335156298e-05 *. solar_mass;     }

let neptune = { x = 1.53796971148509165e+01;
                y = -2.59193146099879641e+01;
                z = 1.79258772950371181e-01;
                vx = 2.68067772490389322e-03 *. days_per_year;
                vy = 1.62824170038242295e-03 *. days_per_year;
                vz = -9.51592254519715870e-05 *. days_per_year;
                mass = 5.15138902046611451e-05 *. solar_mass;   }

let sun = { x = 0.;  y = 0.;  z = 0.;  vx = 0.;  vy = 0.; vz = 0.;
            mass = solar_mass; }

let bodies = [| sun; jupiter; saturn; uranus; neptune |]

let () =
  let n = 1000000 * int_of_string(Sys.argv.(1)) in
  offset_momentum bodies;
  Printf.printf "%.9f\n" (energy bodies);
  for i = 1 to n do advance bodies 0.01 done;
  Printf.printf "%.9f\n" (energy bodies)

@head(3,'Ada code')
@select(tangler('speed/src/ada/nbody.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

with Ada.Numerics; use Ada.Numerics;
with Ada.Numerics.Generic_Elementary_Functions;

package Nbody_Pck is

   type Real is Digits 15;

   package Math is new Ada.Numerics.Generic_Elementary_Functions (Real);

   Solar_Mass    : constant Real := 4.0 * Pi * Pi;
   Days_Per_Year : constant Real := 365.24;

   type Data is record
      X, Y, Z    : Real;
      Vx, Vy, Vz : Real;
      Mass       : Real;
   end record;

   type Body_Name is (Sun, Jupiter, Saturn, Uranus, Neptune);

   Bodies : array (Body_Name) of Data :=
              (Jupiter => (X    => 4.84143144246472090e+00,
                           Y    => -1.16032004402742839e+00,
                           Z    => -1.03622044471123109e-01,
                           Vx   => 1.66007664274403694e-03 * Days_Per_Year,
                           Vy   => 7.69901118419740425e-03 * Days_Per_Year,
                           Vz   => -6.90460016972063023e-05 * Days_Per_Year,
                           Mass => 9.54791938424326609e-04 * Solar_Mass),

               Saturn  => (X    => 8.34336671824457987e+00,
                           Y    => 4.12479856412430479e+00,
                           Z    => -4.03523417114321381e-01,
                           Vx   => -2.76742510726862411e-03 * Days_Per_Year,
                           Vy   => 4.99852801234917238e-03 * Days_Per_Year,
                           Vz   => 2.30417297573763929e-05 * Days_Per_Year,
                           Mass => 2.85885980666130812e-04 * Solar_Mass),

               Uranus  => (X    => 1.28943695621391310e+01,
                           y    => -1.51111514016986312e+01,
                           Z    => -2.23307578892655734e-01,
                           Vx   => 2.96460137564761618e-03 * Days_Per_Year,
                           Vy   => 2.37847173959480950e-03 * Days_Per_Year,
                           Vz   => -2.96589568540237556e-05 * Days_Per_Year,
                           Mass => 4.36624404335156298e-05 * Solar_Mass),

               Neptune => (X    => 1.53796971148509165e+01,
                           Y    => -2.59193146099879641e+01,
                           Z    => 1.79258772950371181e-01,
                           Vx   => 2.68067772490389322e-03 * Days_Per_Year,
                           Vy   => 1.62824170038242295e-03 * Days_Per_Year,
                           Vz   => -9.51592254519715870e-05 * Days_Per_Year,
                           Mass => 5.15138902046611451e-05 * Solar_Mass),

               Sun     => (X    => 0.0,
                           Y    => 0.0,
                           Z    => 0.0,
                           Vx   => 0.0,
                           Vy   => 0.0,
                           Vz   => 0.0,
                           Mass => Solar_Mass));

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real);

   function Energy return Real;

   procedure Advance (Dt : in Real);

end Nbody_Pck;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

package body Nbody_Pck is

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real) is
   begin
      Planet.Vx := -Px / Solar_Mass;
      Planet.Vy := -Py / Solar_Mass;
      Planet.Vz := -Pz / Solar_Mass;
   end Offset_Momentum;

   function Energy return Real is
      Dx, Dy, Dz, Distance : Real;
      E                    : Real := 0.0;
   begin
      for I in Bodies'Range loop
        E := E + 0.5 * Bodies (I).Mass
          * (Bodies (I).Vx * Bodies (I).Vx
               + Bodies (I).Vy * Bodies (I).Vy
               + Bodies (I).Vz * Bodies (I).Vz);

        if I /= Body_Name'Last then
           for J in Body_Name'Succ (I) .. Body_Name'Last loop
              Dx := Bodies (I).X - Bodies (J).X;
              Dy := Bodies (I).Y - Bodies (J).Y;
              Dz := Bodies (I).Z - Bodies (J).Z;

              Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
              E := E - (Bodies (I).Mass * Bodies (J).Mass) / Distance;
           end loop;
        end if;
      end loop;
      return E;
   end Energy;

   procedure Advance (Dt : in Real) is
      Dx, Dy, Dz, Distance, Mag : Real;
   begin
      for I in Body_Name'Range loop
         if I /= Body_Name'Last then
            for J in Body_Name'Succ (I) .. Body_Name'Last loop
               Dx := Bodies (I).X - Bodies (J).X;
               Dy := Bodies (I).Y - Bodies (J).Y;
               Dz := Bodies (I).Z - Bodies (J).Z;

               Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
               Mag := Dt / (Distance ** 3);

               Bodies (I).Vx := Bodies (I).Vx - Dx * Bodies (J).Mass * Mag;
               Bodies (I).Vy := Bodies (I).Vy - Dy * Bodies (J).Mass * Mag;
               Bodies (I).Vz := Bodies (I).Vz - Dz * Bodies (J).Mass * Mag;

               Bodies (J).Vx := Bodies (J).Vx + Dx * Bodies (I).Mass * Mag;
               Bodies (J).Vy := Bodies (J).Vy + Dy * Bodies (I).Mass * Mag;
               Bodies (J).Vz := Bodies (J).Vz + Dz * Bodies (I).Mass * Mag;
            end loop;
         end if;
      end loop;

      for I in Body_Name'Range loop
         Bodies (I).X := Bodies (I).X + Dt * Bodies (I).Vx;
         Bodies (I).Y := Bodies (I).Y + Dt * Bodies (I).Vy;
         Bodies (I).Z := Bodies (I).Z + Dt * Bodies (I).Vz;
      end loop;
   end Advance;

end Nbody_Pck;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

with Ada.Command_Line; use Ada.Command_Line;
with Ada.Text_IO;      use Ada.Text_IO;
with Nbody_Pck;        use Nbody_Pck;

procedure Nbody is

   package RIO is new Float_Io (Real);

   procedure Put
     (Item : Real; Fore : Field := 0; Aft : Field := 9;
      Exp  : Field := 0) renames RIO.Put;

   N : constant Integer := 1000000 * Integer'Value (Argument (1));

   Px, Py, Pz : Real := 0.0;

begin
   for I in Body_Name'Range loop
      Px := Px + Bodies (I).Vx * Bodies (I).Mass;
      Py := Py + Bodies (I).Vy * Bodies (I).Mass;
      Pz := Pz + Bodies (I).Vz * Bodies (I).Mass;
   end loop;

   Offset_Momentum (Bodies (Sun), Px, Py, Pz);

   Put (Energy);
   New_Line;

   for K in 1 .. N loop
      Advance (0.01);
   end loop;

   Put (Energy);
   New_Line;
end Nbody;


@head(1,'Timing script')
Here is the Python script used to compile, execute and time
the programs, and convert the timing data into graphs
using gnuplot.

@select(tangler('speed/measure.py'))
import os
import time
import sys
import random
import signal
import socket
import glob
import string

# utility to make a CLEAN directory
def mkdir(p):
  os.system('rm -rf ' + p)
  os.mkdir(p)

env = {}
from config.xlators_local import selected_xlators

xlators = []
for f in glob.glob("speed"+os.sep+"xlators"+os.sep+"*.py"):
  base = os.path.splitext(os.path.basename(f))[0]
  if base == '__init__':
    continue

  module = getattr(__import__('speed.xlators.' + base).xlators, base)
  if base in selected_xlators or not selected_xlators:
    try:
      env.update(module.env)
    except AttributeError:
      pass

    xlators.append((base, module.mk, module.lang))

# set up any environment needed, this is a temporary hack
for k in env:
  os.putenv(k,env[k])

tests = {}
for f in glob.glob("speed"+os.sep+"specs"+os.sep+"*.py"):
  base = os.path.splitext(os.path.basename(f))[0]
  if base == '__init__':
    continue

  module = getattr(__import__('speed.specs.' + base).specs, base)
  tests[base]=(module.descr, module.min, module.max)


#------ command line arguments -----------------
max_test_time = 5.0
try: max_test_time = float(sys.argv[1])
except:pass

# maximum allowed time per test, seconds
maxtime = 5.0
try: maxtime = float(sys.argv[2])
except:pass

mintime = 0.5
try: mintime = float(sys.argv[3])
except:pass

gracetime = 10.0
try: gracetime = float(sys.argv[4])
except:pass


process_count = 1
try: process_count = int(sys.argv[5])
except:pass


# ------------ report paramaters ------------------
print "Batch time limit",max_test_time,"minutes"
print "Individual test soft seek range: ",mintime,'-',maxtime,"seconds"
print "Grace before cancellation",gracetime,"seconds"
print "Processes to run in parallel",process_count

# make the output directories
mkdir('speed/exes')
for key,mk,src in xlators:
  print "Using translator",key
  mkdir('speed/exes/'+key)

for t in tests.keys():
  descr,min,max=tests[t]
  print "Running test",t,"initial nrange="+str(min)+":"+str(max)

hostname = socket.gethostname()
print "Host",hostname

#--------- setup -----------------------------
ntests = len(tests)

#convert to seconds
max_test_time = max_test_time * 60.0

sleep_time = maxtime+gracetime


print "COMPILING PROGRAMS"
#compile the programs
wxlats = []
print "--------------------"
for xl,mk,src in xlators:
  for test in tests.keys():
    descr,fst,last = tests[test]
    cmd = mk(xl,test)
    print "Try compiling",xl,src,test
    print cmd
    sys.stdout.flush()
    # won't work on Win98, result always 0 for command.com
    result = os.system(cmd)
    if result <> 0:
      print "COMPILE FAILURE",xl,src,test
    else:
      print "Compile OK",xl,src,test
      wxlats.append((xl,mk,src,test))
    print "--------------------"
    sys.stdout.flush()

nwxlats = len(wxlats)

for xlat,f,src,tst in wxlats:
  print xlat,src,tst

# fork extra copies of ourself now

tofork = process_count - 1
while tofork > 0:
  if os.fork() == 0:
    print "PROCESS",tofork,"FORKED"
    random.seed() # reseed the random number generator
    break
  tofork = tofork - 1

# -------------- run -----------------------
#total time for testsing, seconds:
start_time = time.time()

#test date
etime = time.time()
ltime = time.localtime(etime)
date = time.strftime("%Y/%m/%d %H:%M",ltime)

pid = 0
spid = 0
xlt = {}

f = open("speed/results.dat","at")
while time.time() - start_time < max_test_time:
  sys.stdout.flush()
  # pick a random test and a random translator
  ix = random.randint(0,nwxlats-1)
  xl,mk,src,test = wxlats[ix]
  descr,fst,lst = tests[test]
  fst,lst = xlt.get((test,xl), (fst,lst))
  xlt[(test,xl)] = (fst,lst)

  if fst != -1: # -1 means failed ..

    # pick an integer between fst and lst inclusive
    n = random.randint(fst,lst)

    test_file = "speed/exes/"+xl+"/"+test
    test_arg = "%d" % n

    print test_file,test_arg
    sys.stdout.flush()
    start = time.time()
    pid = os.spawnl(os.P_NOWAIT,test_file,"DUMMY",test_arg)
    spid = os.spawnlp(os.P_NOWAIT,"sleep","DUMMY","%d" % int(sleep_time))
    pidx,status = os.wait()
    finish = time.time()
    elapsed = finish - start

    ok = 0
    if pidx == spid:
      os.kill(pid,signal.SIGKILL)
      print "TIMEOUT"
      assert (elapsed > maxtime)
      ok = 1
    else:
      os.kill(spid,signal.SIGKILL)
    os.wait()


    if  pidx == pid:
      signalled = os.WIFSIGNALED(status)
      exited = os.WIFEXITED(status)
      if not (signalled or exited):
        print "WHAT?? Neither exited nor signalled?"
        exit(2)

      # Killed by signal, possibly timeout, no result
      # can be recorded
      if signalled:
        sig = os.WTERMSIG(status)
        if sig == signal.SIGINT:
          raise KeyboardInterrupt

        if sig == signal.SIGSEGV:
          print "SEGMENTATION FAULT, TERMINATING"
          #sys.exit(1)

        elif sig != 0:
          print "UNKNOWN SIGNAL",sig,": TERMINATING"
          #sys.exit(1)
      else:
        # the process terminated correctly, record a result even
        # if it is out of range
        if status == 0:
          ok = 1
          x = hostname + " " + "p"+str(process_count)+" "+date + " %s %s %d %6.4f" % (xl,test,n,elapsed)
          print "#"+str(tofork),x
          f.write(x+"\n")
          f.flush()
        else:
          # the process terminated by gave an error
          # exit because this should not happen
          ret = os.WEXITSTATUS(status)
          if ret != 0:
            print "TEST RETURNED ERROR CODE ",ret,": TERMINATING"
            #sys.exit(1)
          else:
            print "WHAT?? Exit code is 0 and not 0?"
            sys.exit(2)


    # overtime
    if ok:
      if elapsed > maxtime:
        lst = n - 1
        if lst < fst: fst = lst
        print 'OVERTIME: CUT max to',lst

      # undertime
      elif elapsed < mintime:
        fst = n + 1
        if lst < fst: lst = fst
        print 'UNDERTIME: BOOSTED min to',fst

      #minimum n too high
      elif n == fst:
        fst = fst - 1
        if lst < fst: lst = fst
        print "BORDERLINE min: CUT min down to",fst

      # maximum n too low
      elif n == lst:
        lst = lst + 1
        if lst < fst: fst = lst
        print "BORDERLINE max: BOOSTED max up to",lst

      if lst < 1: lst = 1
      if fst < 1: fst = 1
      if fst > lst: fst = lst
      xlt[test,xl] = (fst,lst)
    else:
      xlt[test,xl] = (-1,-1)

    sys.stdout.flush()

f.close()

@select(tangler('speed/panal.py'))
# generate analysis
# sort data by host, test, processor, n value
import sys
import os
import string
import math
hostsd = {}

args = sys.argv
args = args[1:]
mintime = 0.5
mindata = 3
pload = "p1"

try:
  mintime = float(args[0])
except:pass

try:
  mindata = int(args[1])
except:pass

try:
  pload = args[1]
except:pass

print "Minimum time",mintime
print "Minimum data",mindata
print "Load        ",pload

args = args[3:]

def chkxl(x):
  return args == [] or x in args

def mkdir(p):
  os.system('rm -rf ' + p)
  os.mkdir(p)

hosts = []
mkdir("speed/machine")
def add_host(h):
  hosts.append(h)
  mkdir("speed/machine/"+h)

def check_host(h):
  if h not in hosts: add_host(h)

fin = open("speed/results.dat")
for line in fin:
  #print line,
  hostname,kind,date,time,xl,tst,n,elapsed = string.split (line)
  check_host(hostname)
  n = int(n)
  elapsed=float(elapsed)
  if pload == kind:
    print hostname,kind,date,time,xl,tst,n,elapsed
    hostd = hostsd.get(hostname,{})
    hostsd[hostname] = hostd
    testd = hostd.get(tst,{})
    hostd[tst] = testd
    xld = testd.get(xl,{})
    testd[xl] = xld
    nd = xld.get(n,[])
    xld[n] = nd
    nd.append(elapsed)
fin.close()

print "DATA"
fi = open("speed/mkjpgs.gpl",'w')
fi.write("set terminal jpeg\n")

for h,d in hostsd.iteritems():
  print "host",h
  root = 'speed/machine/'+h+'/'
  mkdir(root+"images/")
  mkdir(root+"plotters/")
  for t,xd in d.iteritems():
    print "  test",t
    mkdir(root+'/'+t)
    # one gnuplot file for each test
    # one summary per test
    summary = {}
    first = 1
    xls = xd.keys()
    xls.sort()
    gx = ""
    for xl in [x for x in xls if chkxl(x)]:
      nd = xd[xl]
      # one datafile for each test/xlator
      fxl = open(root+'/'+t+'/'+xl+'.dat','w')
      print "    xlator",xl
      ns = nd.keys()
      ns.sort()
      lines = 0
      for n in ns:
        es = nd[n]
        count = len(es)
        sum = reduce (lambda x,y: x+y,es)
        average = sum / float(count)
        emin = reduce (lambda x,y:min(x,y),es)
        emax = reduce (lambda x,y:max(x,y),es)
        edev = 0
        for x in es: edev = edev + (x - average) * (x - average)
        edev = math.sqrt(edev/float(count))
        print "        n %2d -[%3d]-> (%6.2f,%6.2f,%6.2f) sd=%6.2f" % (n,count,emin,average,emax,edev)
        # one line for each n value
        # skip too low values
        if average >= mintime and count >= mindata:
          fxl.write("%s %d %0.2f %d %6.2f\n" % (xl,n,average,count,edev))
          lines = lines + 1
        summary[(-n,average)]=(xl,count,edev)
      fxl.close()

      # gnuplot is too dumb to handle empty files
      if lines > 0:
        if first:
          first = 0
        else:
          gx = gx + ', \\\n'
        gx = gx + '"'+root+'/'+t+'/'+xl+'.dat" using 2:3 title "'+xl+'" with linespoints'

    if len(gx)>0:
      fp = open(root+'plotters/'+t+'.gpl','w')
      gx2 = 'set title "'+h+' '+pload+' '+t+'"\n'
      gx2 = gx2 + 'set xlabel "N"\n'
      gx2 = gx2 + 'set ylabel "secs"\n'
      gx2 = gx2 + 'set key left\n'
      gx2 = gx2 + 'plot \\\n'
      gx2 = gx2 + gx
      fp.write(gx2+'\n')
      fp.close()

      fi.write('set output "'+root+'images/'+t+'.jpg"\n')
      fi.write('load "'+root+'plotters/'+t+'.gpl"\n')

    keys = summary.keys()
    keys.sort()

    prlimit = 10
    i = 0
    print "Rankings for",t,"on",h
    for m,a in keys:
      xl,count,edev = summary[m,a]
      print "    %-16s %2d %6.2f [N=%3d, SD=%6.2f]" % (xl,-m,a,count,edev)
      i = i + 1
      if i >= prlimit: break
    try: os.mkdir(root+'rankings')
    except: pass
    rf = open(root+'rankings/'+t+'.txt','w')
    prlimit = 10
    i = 0
    rf.write("Rankings for "+t+' on '+h+'\n')
    for m,a in keys:
      xl,count,edev = summary[m,a]
      rf.write("    %-16s %2d %6.2f [N=%3d SD=%2d%%]\n" % (xl,-m,a,count,int(edev*100/average)))
      i = i + 1
      if i >= prlimit: break
    rf.close()
fi.close()

# the client can view individual plots in an x11 console
# with the command 'gnuplot' and then
# type 'load "filename"'

@head(2,'Standard Build commands')
@select(tangler('speed/xlators/gcc.py','python'))
def mk(k,p):
  return "gcc -lm -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gccopt.py','python'))
def mk(k,p):
  x = "gcc -lm -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/ocamlopt.py','python'))
def mk(k,p):
  return "ocamlopt.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)
lang="ocaml"

@select(tangler('speed/xlators/ocamlb.py','python'))
def mk(k,p):
  return "ocamlc.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)
lang="ocaml"

@select(tangler('speed/xlators/felix.py','python'))
def mk(k,p):
  x = "bin/flx --test --force --static -c -DFLX_PTF_STATIC_POINTER "
  x = x + "speed/src/felix/%s && " % p
  x = x + "mv speed/src/felix/%s speed/exes/%s/%s" % (p,k,p)
  return x
lang="felix"

@select(tangler('speed/xlators/ghc.py','python'))
env = {'GHCRTS': '-K8m -k1m'} # set stack size for GHC

def mk(k,p):
  return "ghc -O3 -fvia-C -optc -O1 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)
lang="haskell"

@select(tangler('speed/xlators/gnat.py','python'))
def mk(k,p):
  return "python script/gnatmaker.py speed/src/ada/%s speed/exes/%s " % (p,k)
lang="ada"

@select(tangler('speed/xlators/gcj.py','python'))
def mk(k,p):
  x = "gcj -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x
lang="java"

@select(tangler('speed/xlators/gcc_3_3.py','python'))
def mk(k,p):
  return "gcc-3.3 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gcc_3_3_opt.py','python'))
def mk(k,p):
  x = "gcc-3.3 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/gcc_3_4.py','python'))
def mk(k,p):
  return "gcc-3.4 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gcc_3_4_opt.py','python'))
def mk(k,p):
  x = "gcc-3.4 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/gcc_4_0.py','python'))
def mk(k,p):
  return "gcc-4.0 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gcc_4_0_opt.py','python'))
def mk(k,p):
  x = "gcc-4.0 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/gpp_3_3.py','python'))
def mk(k,p):
  return "g++-3.3 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="cpp"

@select(tangler('speed/xlators/gpp_3_3.py','python'))
def mk(k,p):
  x = "g++-3.3 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="cpp"

@select(tangler('speed/xlators/gpp_4_0.py','python'))
def mk(k,p):
  return "g++-4.0 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="cpp"

@select(tangler('speed/xlators/gpp_4_0_opt.py','python'))
def mk(k,p):
  x = "g++-4.0 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="cpp"

@select(tangler('speed/xlators/ghc_6_2_2.py','python'))
def mk(k,p):
  return "ghc-6.2.2 -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)
lang="haskell"

@select(tangler('speed/xlators/ghc_6_4_1.py','python'))
def mk(k,p):
  return "ghc-6.4.1.20050704 -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)
lang="haskell"

@select(tangler('speed/xlators/fpc_2_0_0.py','python'))
def mk(k,p):
  x = "fpc -O3 speed/src/pascal/%s.pp && " % p
  x = x + "mv speed/src/pascal/%s speed/exes/%s" % (p,k)
  return x
lang="pascal"

@select(tangler('speed/xlators/gpc_2_1_3_3.py','python'))
def mk(k,p):
  return "gpc-2.1-3.3 -O3 -o speed/exes/%s/%s speed/src/pascal/%s.pp" % (k,p,p)
lang="pascal"

@select(tangler('speed/xlators/gnat_4_0.py','python'))
def mk_gnat_4_0(k,p):
  return "python script/gnatmaker_4_0.py speed/src/ada/%s speed/exes/%s " % (p,k)
lang="ada"

@select(tangler('speed/xlators/gcj_4_0.py','python'))
def mk(k,p):
  x = "gcj-4.0  -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x
lang="java"

@select(tangler('speed/xlators/gcj_4_1.py','python'))
def mk(k,p):
  x = "gcj-4.1  -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x
lang="java"

@select(tangler('script/gnatmaker.py'))
import os
import sys
import string
def xqt(x):
  print x
  res=os.system(x)
  if res <> 0:
    sys.exit(1)

filebase = sys.argv[1]
split = string.split(filebase,'/')
filebase = split[-1]
indir =  string.join(split[:-1],'/')
curdir = os.getcwd()
os.chdir(indir)
outdir = sys.argv[2]
f = os.popen('gnatchop -w ' + filebase + '.ada | grep \\.adb')
units = f.readlines()
f.close()
units = [string.strip (x) for x in units]
for f in units:
  xqt("gcc -c -O3 "+ f)
xqt("gnatbind " + filebase)
xqt("gnatlink " + filebase)
os.chdir(curdir)
xqt("mv "+indir+'/'+filebase+" "+outdir)

@select(tangler('script/gnatmaker_4_0.py'))
import os
import sys
import string
def xqt(x):
  print x
  os.system(x)

filebase = sys.argv[1]
split = string.split(filebase,'/')
filebase = split[-1]
indir =  string.join(split[:-1],'/')
curdir = os.getcwd()
os.chdir(indir)
outdir = sys.argv[2]
f = os.popen('gnatchop -w ' + filebase + '.ada | grep \\.adb')
units = f.readlines()
f.close()
units = [string.strip (x) for x in units]
for f in units:
  xqt("gcc-4.0 -c -O3 "+ f)
xqt("gnatbind " + filebase)
xqt("gnatlink " + filebase)
os.chdir(curdir)
xqt("mv "+indir+'/'+filebase+" "+outdir)


