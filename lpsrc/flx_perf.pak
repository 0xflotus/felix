@set_title('Performance Measurements')
@head(1,"How Fast is Felix?")
This module contains codes to compare Felix with other
languages.  The translators currently being compared against
are plain gcc, gcc with optimisation switches, ocaml native
code compiler, ocaml bytecode compiler, and felix with
options for static linkage of a single thread. C and Ocaml
are chosen because they're both fast and both available
since they're required for the Felix build. We could add
Python in for this reason too.
@p()
Because the tests are heavily dependent on the precise
translator and switches chosen, we've currently hardcoded
the use of gcc for the C compiler. In the future, these
tests need some modifications to configure for available
translators.
@p()
We'd particularly like to support multiple versions of Felix,
so we can check if new optimisations are effective.
@p()
The results of these tests are collected for analysis.
We currently generate gnuplot command files to plot
the results as jpg files for our website.  The data can be 
viewed in an interactive graphics console by running
gnuplot without arguments, then typing
@begin_displayed_code()
load "speed/plotters/ack.gpl"
@end_displayed_code()
where 'ack' is replaced by the name of the test.

@def flx_setup():
  tangle("// Felix Performance Test Program")
  tangle('include "std";')
  tangle("n := atoi(System::argv 1);")
@def showgraph(test,title):
  get_weaver()._write(
    '''<P></P><TABLE BORDER=2 ALIGN=center>
   <CAPTION>'''+title+'''</CAPTION>
   <TR><TD>
   <IMG ALT="'''+title+'''" SRC="images/'''+test+'''.jpg">
   </TD></TR></TABLE><P></P>
   ''')

@head(2,'[ack] Ackermanns Function')
Ackermann's function is used to check tail-recursion optimisation
and is heavily dependent on the number of words stacked per function call.

@showgraph('ack',"Ackermann performance graph")
@select(tangler('speed/src/felix/ack.flx','data'))
@flx_setup()

fun ack(x:int,y:int):int =>
  if x == 0 then y + 1
  elif y == 0 then ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;
v := ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;

@select(tangler('speed/src/c/ack.c','data'))
#include <stdio.h>
#include <stdlib.h>

int Ack(int M, int N) { return(M ? (Ack(M-1,N ? Ack(M,(N-1)) : 1)) : N+1); }

int main(int argc, char *argv[]) {
    int n = atoi(argv[1]);
    printf("Ack(3,%d): %d\n", n, Ack(3, n));
    return(0);
}

@select(tangler('speed/src/ocaml/ack.ml','data'))
let rec ack m n = match m,n with
  | 0,n -> n + 1
  | m,0 -> ack (m - 1) 1
  | m,n -> ack (m - 1) (ack m (n - 1))
;;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
Printf.printf "Ack(3,%d): %d\n" n (ack 3 n)
;;

@head(2,'[takfp] Takfp')
@showgraph('takfp',"Takfp performance graph")
@select(tangler('speed/src/c/takfp.c','data'))
#include <stdio.h>
#include <stdlib.h>

float Tak (float x, float y, float z)
{
    if (y >= x) return z;
    return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
}

int main(int argc, char* argv[])
{
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%.1f\n", Tak(n*3.0, n*2.0, n*1.0));
    return 0;
}

@select(tangler('speed/src/ocaml/takfp.ml','data'))
let rec tak x y z =
  if y >= x then z
  else tak (tak (x -. 1.) y z) (tak (y -. 1.) z x) (tak (z -. 1.) x y)

let () =
  let n = float_of_string(Array.get Sys.argv 1) in
  Printf.printf "%.1f\n" (tak (3. *. n) (2. *. n) n)
;;

@select(tangler('speed/src/felix/takfp.flx','data'))
@flx_setup()
open Float;
proc print1: float = 'printf("%.1f\\n",$1);';

fun Tak (x:float, y:float, z:float): float =>
  if (y >= x) then z
  else Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y))
  endif
;

w := float_of n;

print1 (Tak(w*3.0f, w*2.0f, w*1.0f));

@head(1,'Timing script')
Here is the Python script used to compile, execute and time
the programs, and convert the timing data into graphs
using gnuplot.

@select(tangler('speed/measure.py'))
import os
import time
import sys
import random
import signal
import socket

# utility to make a directory
def mkdir(p):
  try: os.mkdir(p)
  except: pass

execfile("config/speed_xlators.py")

# make the output directories
mkdir('speed/exes')
for key,mk,src in xlators:
  mkdir('speed/exes/'+key)

#define the tests
tests = {
  'ack':(1,5),
  'takfp':(1,5),
}

#compile the programs
for xl,mk,src in xlators:
  for test in tests.keys():
    fst,last = tests[test]
    cmd = mk(xl,test) 
    os.system(cmd)
  
# maximum allowed time per test, seconds
maxtime = 5.0
mintime = 0.5
sleep_time = 10

#total time for testsing, seconds:
max_test_time = 200.0
start_time = time.time()

#hostname
hostname = socket.gethostname()

#test date
etime = time.time()
ltime = time.localtime(etime)
date = time.strftime("%Y/%m/%d %H:%M",ltime)

ntests = len(tests)
nlators = len(xlators)

pid = 0
spid = 0

f = open("speed/results.dat","at")
while time.time() - start_time < max_test_time:
  # pick a random test and a random translator
  test_ix = random.randint(0,ntests-1)
  xlator_ix = random.randint(0,nlators-1)
  test = tests.keys()[test_ix]
  fst,lst = tests[test]
  xl,mk,src = xlators[xlator_ix]
  n = random.randint(fst,lst+1)

  test_file = "speed/exes/"+xl+"/"+test
  test_arg = "%d" % n

  print test_file,test_arg
  start = time.time()
  pid = os.spawnl(os.P_NOWAIT,test_file,"DUMMY",test_arg)
  spid = os.spawnlp(os.P_NOWAIT,"sleep","DUMMY","%d" % sleep_time)
  pidx,status = os.wait()
  finish = time.time()
  elapsed = finish - start

  if pidx == spid:
    os.kill(pid,signal.SIGKILL)
    print "TIMEOUT"
  else:
    os.kill(spid,signal.SIGKILL)
  os.wait()


  if  pidx == pid:
    signalled = os.WIFSIGNALED(status)
    exited = os.WIFEXITED(status)
    if not (signalled or exited):
      print "WHAT?? Neither exited nor signalled?"
      exit(2)

    if signalled:
      sig = os.WTERMSIG(status)
      if sig == signal.SIGINT:
        raise KeyboardInterrupt

      if sig == signal.SIGSEGV:
        print "SEGMENTATION FAULT, TERMINATING"
        sys.exit(1)

      if sig != 0:
        print "UNKNOWN SIGNAL",sig,": TERMINATING"
        sys.exit(1)
    else:
      if status == 0:
        x = hostname + " " + date + " %s %s %d %6.4f" % (xl,test,n,elapsed)
        print x
        f.write(x+"\n")
        f.flush()
      else:
        ret = os.WEXITSTATUS(status)
        if ret != 0:
          print "TEST RETURNED ERROR CODE ",ret,": TERMINATING"
          sys.exit(1)
        else:
          print "WHAT?? Exit code is 0 and not 0?"
          sys.exit(2)

  if elapsed > maxtime: lst = n - 1 
  if elapsed < mintime: fst = n + 1
  if fst > lst: lst = fst
  tests[test] = (fst,lst)

f.close()

@select(tangler('speed/plot.py'))
# generate gnuplot files
mkdir("speed/plotters")
for test,fst,lst in tests:
  f = open("speed/plotters/"+test+'.gpl','w')
  x = 'set title "'+test+'"\n'
  x = x + 'set xlabel "N"\n'
  x = x + 'set ylabel "secs"\n'
  x = x + 'set key left\n'
  x = x + 'plot \\\n'
  j = 0
  for xl,mk,src in xlators:
    j = j + 1
    x = x + '"speed/exes/'+xl+'/'+test+'.times" using 3:4 title "'+xl+'" with linespoints'
    if  j != len (xlators): x = x + ',\\'
    x = x + '\n'
  f.write(x)
  f.close()

# make a shell script to plot all the results as jpg images
mkdir("speed/images")
f = open("speed/mkjpgs.gpl",'w')
f.write("set terminal jpeg\n")
for test,fst,lst in tests:
  f.write('set output "speed/images/'+test+'.jpg"\n')
  f.write('load "speed/plotters/'+test+'.gpl"\n') 
f.close()

# the client can view individual plots in an x11 console
# with the command 'gnuplot' and then 
# type 'load "filename"'

