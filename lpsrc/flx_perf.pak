@set_title('Performance Measurements')

@select(tangler('mkplugins/speed.py'))
class PLUGIN(Plugin):
  def __init__(self):
    Plugin.__init__(self, "speed", "Run comparative tests")

  def run(self,x):
    print x
    flush()
    result = os.system(ENV+x)
    if result: print "  .. ERROR CODE",hex(result)
    flush()

    if result:
      raise MakeError


  def runme(self):    
    runISCR(FLX_LPARCHIVE+os.sep+'lpsrc/flx_perf.pak')
    self.run("python speed/measure.py")
    self.run("python speed/panal.py")
    self.run("gnuplot speed/mkjpgs.gpl")
    runISCR('--inhibit-sref=1 --language=en --weaver=web --passes=2 '+
      '--weaver-directory=speed/ '+FLX_LPARCHIVE+os.sep+'lpsrc/flx_perf.pak')
    filecopy2dir(os.path.join('misc', 'interscript.css'),"speed")

@select(tangler('spkgs/speed.py'))
pkg_requires = ["flx"]
iscr_source = ["lpsrc/flx_perf.pak"]
weaver_directory = 'speed/'

@head(1,"How Fast is Felix?")
This module contains codes to compare the Felix translator
with other language translators. Each translator should be run
with switches for a high level of optimisation. Here is
a list of translators with existing or planned
test harness support, along with some biased comments.
@begin_list("keyed")
@item("Felix")
The scripting language with static typing and high
performance, offers functional and procedural
programming with microthreading, and a simple
interface to C/C++. Versions prior to 1.1 offered
extremely poor performance, however 1.1 now 
appears to outperform all other translators
tested.

@item("C")
The traditional systems programming language. We test two
translators: gcc with optimisation switches, 
a plain gcc command is also tested as a baseline.
GNU's C compiler is in widespread use, but has
not been noted for good performance in the past.
Recent versions, however, appear to be doing
considerably better, for example it actually
recognizes tail calls sometimes.

@item("C++")
The popular extension of C to include overloading,
classes, templates and exceptions. Represented by 
the GNU g++ compiler. Felix itself generates C++
code compiled by g++ with the same optimisation switches.

@item("Ada")
A procedural language in the Algol tradition, with
an emphasis on strict control of all details.
we're using the GNU Ada translator system gnat,
which uses the same back end as gcc. Gnat appears
to provide excellent performance.

@item("Haskell")
Haskell is the leading lazy functional programming
language, used by everyone in the functional and
academic communities as a reference language.
We use ghc, the Glorious Glasgow Haskell compiler,
which is an open source community project hosted on Sourceforge.
The GHC programs are the most succinct and expressive,
however the translator leaves something to be desired
in performance.

@item("Ocaml")
Ocaml is an ML family language with rapidly increasing
popularity. It provides eager functional, imperative,
and object oriented programming. The bytecode compiler
is available on a wide variety of platforms, and 
on major platforms a native code compiler is available.
Ocaml is a landmark system in that it clearly
demonstrates an 'academic' functional language can
have superior performance. The Felix compiler is itself
written in Ocaml.

@item("Clean")
We would love to test Clean, a lazy functional language
which uses the type system systematically to locate
and optimise contructs reliably to destructive updates.
It is reputed to provide superior performance, however
I have not been able to get it to work on the AMD64,
and the provided binary is probably 32 bit anyhow.

@item("Java")
Java is a probably the most popular application
programming language in the world today. Earlier
versions suffered from woeful performance,
horrendous startup times, a failure to deliver
promised platform independence, and inherited
most of the serious design faults of C and C++
whilst adding many more of its own, including
a complete lack of any sane kind of polymorphism.
@p()
However it did deliver three important facilities which,
in addition to a huge marketing campaign,
had sufficient merit to ensure its growth.
Java provides garbage collection and a standard
threading model, which C and C++ lack, and came
with a standard GUI library (initially AWT, but
now SWING).
@p()
Because of its popularity, much work has been
done to solve the performance problems, both
with high quality native code compilers,
and also JIT based bytecode interpreters.
In addition Sun has added weak facilities
for polymorphism in version 2 which alleviate
some of the disgusting casting previously
required.
@p()
We're using the GNU gcj native code compiler,
which is reputed to have reasonable performance.
I would like to also test a good JIT based
interpreter.

@item("C#")
Microsofts answer to Java, C# is a better language,
but only marginally. C# had generics right
from the start, and it provides superior integration 
via the .NET platform languages. I haven't figured out
how to get a version yet (my Debian based Ubuntu system
provides a C# compiler but it depends on Mono, which
is not in the archive)

@item("Pascal")
Originally designed for teaching, extended by Borland
in their famous Turbo Pascal system, then again 
in their Delphi system. We're testing both the
GNU pascal front end of gcc and the free pascal compiler.

@end_list()
@p()
We currently generate gnuplot command files to plot
the results as jpg files for our website.  The data can be 
viewed in an interactive graphics console by running
gnuplot without arguments, then typing
@begin_displayed_code()
load "speed/machine/hostname/plotters/ack.gpl"
@end_displayed_code()
where 'ack' is replaced by the name of the test.

@def flx_setup():
  tangle("// Felix Performance Test Program")
  tangle('#import <flx.flxh>";')
  tangle("n := atoi(System::argv 1);")
@def showgraph(machine,test,title):
  get_weaver()._write(
    '''<P></P><TABLE BORDER=2 ALIGN=center>
   <CAPTION>'''+title+'''</CAPTION>
   <TR><TD>
   <IMG ALT="'''+title+'''" SRC="machine/'''+machine+'''/images/'''+test+'''.jpg">
   </TD></TR></TABLE><P></P>
   ''')

@def showdata(fn):
  begin_displayed_code()
  try:
    f = open(fn)
    data = f.read()
    f.close()
    lines = string.split(data,'\n')
    for line in lines: weave(line+'\n')
  except:
    weave(fn+" not available\n")
  end_displayed_code()


@head(2,'The Test Machines')
@import glob
@raw_machs = glob.glob("speed/machine/*")
@machs = []
@for i in raw_machs: machs.append(i[14:])

@head(3,'Rosella: x86-64')
This is my main work machine, an AMD64 K8 3200 with 
1G Ram and an ASUS motherboard running nVidia chipset,
budget price cache memory, 200G SATA drive,
Ubuntu Dapper Linux distribution.

@head(3,'Budgie: x86-64x2 (dual core)')
This is my main work machine, an AMD64x2 K8 3800 with 
2G Ram and an ASUS motherboard running nVidia chipset,
budget price cache memory, 200G SATA drive,
Ubuntu Breezy Linux distribution.

@head(2,'[ack] Ackermanns Function')
Ackermann's function is used to check tail-recursion optimisation
and is heavily dependent on the number of words stacked per function call.
@for i in machs:
  showgraph(i,'ack',"Ackermann's function on "+i)
  showdata("speed/machine/"+i+"/rankings/ack.txt")

@select(tangler('speed/specs/ack.py','data'))
descr="Ackerman's function"
min=5
max=10

@select(tangler('speed/src/felix/ack.flx','data'))
@flx_setup()

fun ack(x:int,y:int):int =>
  if x == 0 then y + 1
  elif y == 0 then ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;
v := ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;

@head(3,'C code')
@select(tangler('speed/src/c/ack.c','data'))
#include <stdio.h>
#include <stdlib.h>

int Ack(int M, int N) { 
  if (M==0) return N +1;
  else if(N==0) return Ack(M-1,1);
  else return Ack(M-1, Ack(M,N-1));
}

int main(int argc, char *argv[]) {
    int n = atoi(argv[1]);
    printf("Ack(3,%d): %d\n", n, Ack(3, n));
    return(0);
}

@head(3,'Pascal code')
@select(tangler('speed/src/pascal/ack.pp','data'))
program ack;

function ack(x:longint; y:longint):longint;
  begin
    if x = 0 then ack :=  y + 1
    else if y = 0 then ack := ack(x-1,1)
    else ack := ack(x-1, ack(x, y-1))
  end
;

var
  n,w: integer; s: string;
begin
  s := paramstr(1); val(s, n, w); if w <> 0 then n := 1;
  write('Ack(3,'); write(n); write(') : '); writeln(ack(3,n));
end.

@head(3,'Java code')
@select(tangler('speed/src/java/ack.java','data'))
public class ack {
  public static void main(String[] args) {
    int num = Integer.parseInt(args[0]);
    System.out.println("Ack(3," + num + "): " + Ack(3, num));
  }
  public static int Ack(int m, int n) {
    return 
      (m == 0) ? (n + 1) : 
      ((n == 0) ? Ack(m-1, 1) : Ack(m-1, Ack(m, n - 1)))
    ;
  }
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/ack.ml','data'))
let rec ack m n = match m,n with
  | 0,n -> n + 1
  | m,0 -> ack (m - 1) 1
  | m,n -> ack (m - 1) (ack m (n - 1))
;;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
Printf.printf "Ack(3,%d): %d\n" n (ack 3 n)
;;

@head(3,'Haskell code')
@select(tangler('speed/src/haskell/ack.hs','data'))
import System(getArgs)

main = do ~[num] <- getArgs
  putStrLn ("Ack(3," ++ num ++ "): " ++ (show (ack 3 (read num))))

ack :: Int -> Int -> Int
ack 0 n = n+1
ack m 0 = ack (m-1) 1
ack m n = ack (m-1) (ack m (n-1));

@head(3,'Ada code')
@select(tangler('speed/src/ada/ack.ada','data'))
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Fixed;
with Ack_F;

procedure Ack is
  Num : Natural;
  function L_Trim(Source : String; Side : Ada.Strings.Trim_End := Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
begin
  if Argument_Count = 1 then
    Num := Natural'Value(Argument(1));
  else
    Num := 1;
  end if;

  Put("Ack(3,");
  Put(L_Trim ( Natural'Image (Num)));
  Put("):");
  Put(Natural'Image (Ack_F (3, Num)));
end Ack;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural is
pragma Suppress(All_Checks);
begin
   if M = 0 then
      return N + 1;
   elsif N = 0 then
      return Ack_F (M - 1, 1);
   else
      return Ack_F (M - 1, Ack_F (M, N - 1));
   end if;
end Ack_F;

@head(2,'[takfp] Takfp')
@for i in machs:
  showgraph(i,'takfp',"Takfp on "+i)
  showdata("speed/machine/"+i+"/rankings/takfp.txt")

@select(tangler('speed/specs/takfp.py','data'))
descr="Taka's function, using floats"
min=5
max=10

@select(tangler('speed/src/felix/takfp.flx','data'))
@flx_setup()
open Float;
proc print1: float = 'printf("%.1f\\n",$1);';

fun Tak (x:float, y:float, z:float): float =>
  if (y >= x) then z
  else Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y))
  endif
;

w := float_of n;

print1 (Tak(w*3.0f, w*2.0f, w*1.0f));


@head(3,'C code')
@select(tangler('speed/src/c/takfp.c','data'))
#include <stdio.h>
#include <stdlib.h>

float Tak (float x, float y, float z)
{
    if (y >= x) return z;
    return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
}

int main(int argc, char* argv[])
{
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%.1f\n", Tak(n*3.0, n*2.0, n*1.0));
    return 0;
}

@head(3,'Pascal code')
@select(tangler('speed/src/pascal/takfp.pp','data'))
program takfp;

function tak(x,y,z:real):real;
  begin
    if y >= x then tak := z
    else tak := tak (tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
  end
;

var
  n,w: integer; s: string;
begin
  s := paramstr(1); val(s, n, w); if w <> 0 then n := 1;
  writeln(tak(3*n,2*n,n):0:1);
end.



@head(3,'Java code')
@select(tangler('speed/src/java/takfp.java','data'))
public class takfp {
  public static void main(String args[]) {
    int n = Integer.parseInt(args[0]);
    System.out.println( Tak(n*3.0f, n*2.0f, n*1.0f) );
  }

  public static float Tak (float x, float y, float z) {
    if (y >= x) return z;
    else return Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y));
  }
}

@head(3,'Ocaml code')
@select(tangler('speed/src/ocaml/takfp.ml','data'))
let rec tak x y z =
  if y >= x then z
  else tak (tak (x -. 1.) y z) (tak (y -. 1.) z x) (tak (z -. 1.) x y)

let () =
  let n = float_of_string(Array.get Sys.argv 1) in
  Printf.printf "%.1f\n" (tak (3. *. n) (2. *. n) n)
;;

@head(3,'Haskell code')
@select(tangler('speed/src/haskell/takfp.hs','data'))
import System(getArgs)

main = do n <- getArgs >>= readIO.head
          putStrLn (show (tak (3*n) (2*n) n))

tak :: Float -> Float -> Float -> Float
tak x y z | y>=x      = z
          | otherwise = tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y)

@head(3,'Ada code')
@select(tangler('speed/src/ada/takfp.ada','data'))
package Takfp_Pck is
   function Tak (X, Y, Z : Float) return Float;
end Takfp_Pck;

package body Takfp_Pck is

   function Tak (X, Y, Z : Float) return Float is
   begin
      if Y >= X then
         return Z;
      else
         return Tak
           (Tak (X - 1.0, Y, Z), Tak (Y - 1.0, Z, X), Tak (Z - 1.0, X, Y));
      end if;
   end Tak;

end Takfp_Pck;
---------------------------
with Ada.Text_IO;       use Ada.Text_IO;
with Ada.Float_Text_IO; use Ada.Float_Text_IO;
with Ada.Command_Line;  use Ada.Command_Line;
with Takfp_Pck;         use Takfp_Pck;

procedure Takfp is
   N : Float;
begin
   N := Float'Value (Argument (1));
   Put (Tak (N * 3.0, N * 2.0, N * 1.0), 0, 1, 0);
   New_Line;
end Takfp;


@head(1,'Timing script')
Here is the Python script used to compile, execute and time
the programs, and convert the timing data into graphs
using gnuplot.

@select(tangler('speed/measure.py'))
import os
import time
import sys
import random
import signal
import socket
import glob
import string

# utility to make a CLEAN directory
def mkdir(p):
  os.system('rm -rf ' + p)
  os.mkdir(p)

env = {}
try:
  execfile('config'+os.sep+'xlators_local.py')
except:
  selected_xlators = []

xlators = []
for f in glob.glob("speed"+os.sep+"xlators"+os.sep+"*.py"):
  execfile(f)
  name = string.split(f,os.sep)[2][0:-3]
  if name in selected_xlators or not selected_xlators:
    xlators.append((name,mk,lang))

# set up any environment needed, this is a temporary hack
for k in env:
  os.putenv(k,env[k])

tests = {}
for f in glob.glob("speed"+os.sep+"specs"+os.sep+"*.py"):
  execfile(f)
  base = string.split(f,os.sep)[2][:-3]
  tests[base]=(descr,min,max)


#------ command line arguments -----------------
max_test_time = 5.0
try: max_test_time = float(sys.argv[1])
except:pass

# maximum allowed time per test, seconds
maxtime = 5.0
try: maxtime = float(sys.argv[2])
except:pass

mintime = 0.5
try: mintime = float(sys.argv[3])
except:pass

gracetime = 10.0
try: gracetime = float(sys.argv[4])
except:pass


process_count = 1
try: process_count = int(sys.argv[5])
except:pass


# ------------ report paramaters ------------------
print "Batch time limit",max_test_time,"minutes"
print "Individual test soft seek range: ",mintime,'-',maxtime,"seconds"
print "Grace before cancellation",gracetime,"seconds"
print "Processes to run in parallel",process_count

# make the output directories
mkdir('speed/exes')
for key,mk,src in xlators:
  print "Using translator",key
  mkdir('speed/exes/'+key)

for t in tests.keys():
  descr,min,max=tests[t]
  print "Running test",t,"initial nrange="+str(min)+":"+str(max)

hostname = socket.gethostname()
print "Host",hostname

#--------- setup -----------------------------
ntests = len(tests)

#convert to seconds
max_test_time = max_test_time * 60.0

sleep_time = maxtime+gracetime


print "COMPILING PROGRAMS"
#compile the programs
wxlats = []
for xl,mk,src in xlators:
  for test in tests.keys():
    descr,fst,last = tests[test]
    cmd = mk(xl,test) 
    print cmd
    # won't work on Win98, result always 0 for command.com
    result = os.system(cmd)
    if result <> 0: 
      print "COMPILE FAILURE",xl,src,test
    else:
      print "Compile OK",xl,src,test
      wxlats.append((xl,mk,src,test))

nwxlats = len(wxlats)

for xlat,f,src,tst in wxlats:
  print xlat,src,tst

# fork extra copies of ourself now

tofork = process_count - 1
while tofork > 0:
  if os.fork() == 0: 
    print "PROCESS",tofork,"FORKED"
    random.seed() # reseed the random number generator
    break
  tofork = tofork - 1

# -------------- run -----------------------
#total time for testsing, seconds:
start_time = time.time()

#test date
etime = time.time()
ltime = time.localtime(etime)
date = time.strftime("%Y/%m/%d %H:%M",ltime)

pid = 0
spid = 0
xlt = {}

f = open("speed/results.dat","at")
while time.time() - start_time < max_test_time:
  # pick a random test and a random translator
  ix = random.randint(0,nwxlats-1)
  xl,mk,src,test = wxlats[ix]
  descr,fst,lst = tests[test]
  fst,lst = xlt.get((test,xl), (fst,lst))
  xlt[(test,xl)] = (fst,lst)

  # pick an integer between fst and lst inclusive
  n = random.randint(fst,lst)

  test_file = "speed/exes/"+xl+"/"+test
  test_arg = "%d" % n

  print test_file,test_arg
  start = time.time()
  pid = os.spawnl(os.P_NOWAIT,test_file,"DUMMY",test_arg)
  spid = os.spawnlp(os.P_NOWAIT,"sleep","DUMMY","%d" % int(sleep_time))
  pidx,status = os.wait()
  finish = time.time()
  elapsed = finish - start

  if pidx == spid:
    os.kill(pid,signal.SIGKILL)
    print "TIMEOUT"
    assert (elapsed > maxtime)
  else:
    os.kill(spid,signal.SIGKILL)
  os.wait()


  if  pidx == pid:
    signalled = os.WIFSIGNALED(status)
    exited = os.WIFEXITED(status)
    if not (signalled or exited):
      print "WHAT?? Neither exited nor signalled?"
      exit(2)

    # Killed by signal, possibly timeout, no result
    # can be recorded
    if signalled:
      sig = os.WTERMSIG(status)
      if sig == signal.SIGINT:
        raise KeyboardInterrupt

      if sig == signal.SIGSEGV:
        print "SEGMENTATION FAULT, TERMINATING"
        sys.exit(1)

      if sig != 0:
        print "UNKNOWN SIGNAL",sig,": TERMINATING"
        sys.exit(1)
    else:
      # the process terminated correctly, record a result even
      # if it is out of range
      if status == 0:
        x = hostname + " " + "p"+str(process_count)+" "+date + " %s %s %d %6.4f" % (xl,test,n,elapsed)
        print "#"+str(tofork),x
        f.write(x+"\n")
        f.flush()
      else:
        # the process terminated by gave an error
        # exit because this should not happen
        ret = os.WEXITSTATUS(status)
        if ret != 0:
          print "TEST RETURNED ERROR CODE ",ret,": TERMINATING"
          sys.exit(1)
        else:
          print "WHAT?? Exit code is 0 and not 0?"
          sys.exit(2)

  # overtime
  if elapsed > maxtime: 
    lst = n - 1 
    if lst < fst: fst = lst
    print 'OVERTIME: CUT max to',lst

  # undertime
  elif elapsed < mintime: 
    fst = n + 1
    if lst < fst: lst = fst
    print 'UNDERTIME: BOOSTED min to',fst

  #minimum n too high
  elif n == fst:
    fst = fst - 1
    if lst < fst: lst = fst
    print "BORDERLINE min: CUT min down to",fst

  # maximum n too low
  elif n == lst:
    lst = lst + 1
    if lst < fst: fst = lst
    print "BORDERLINE max: BOOSTED max up to",lst
    
  if lst < 1: lst = 1
  if fst < 1: fst = 1
  if fst > lst: fst = lst
  xlt[test,xl] = (fst,lst)

f.close()

@select(tangler('speed/panal.py'))
# generate analysis
# sort data by host, test, processor, n value
import sys
import os
import string
import math
hostsd = {}

args = sys.argv
args = args[1:]
mintime = 0.5
mindata = 3
pload = "p1"

try: 
  mintime = float(args[0])
except:pass

try: 
  mindata = int(args[1])
except:pass

try: 
  pload = args[1]
except:pass

print "Minimum time",mintime
print "Minimum data",mindata
print "Load        ",pload

args = args[3:]

def chkxl(x):
  return args == [] or x in args
  
def mkdir(p):
  os.system('rm -rf ' + p)
  os.mkdir(p)

hosts = []
mkdir("speed/machine")
def add_host(h):
  hosts.append(h)
  mkdir("speed/machine/"+h)

def check_host(h):
  if h not in hosts: add_host(h)

fin = open("speed/results.dat")
for line in fin:
  #print line,
  hostname,kind,date,time,xl,tst,n,elapsed = string.split (line)
  check_host(hostname)
  n = int(n)
  elapsed=float(elapsed)
  if pload == kind:
    print hostname,kind,date,time,xl,tst,n,elapsed
    hostd = hostsd.get(hostname,{})
    hostsd[hostname] = hostd
    testd = hostd.get(tst,{})
    hostd[tst] = testd
    xld = testd.get(xl,{})
    testd[xl] = xld
    nd = xld.get(n,[])
    xld[n] = nd
    nd.append(elapsed)
fin.close()

print "DATA"
fi = open("speed/mkjpgs.gpl",'w')
fi.write("set terminal jpeg\n")

for h,d in hostsd.iteritems():
  print "host",h
  root = 'speed/machine/'+h+'/'
  mkdir(root+"images/")
  mkdir(root+"plotters/")
  for t,xd in d.iteritems():
    print "  test",t
    mkdir(root+'/'+t)
    # one gnuplot file for each test
    fp = open(root+'plotters/'+t+'.gpl','w')
    gx = 'set title "'+h+' '+pload+' '+t+'"\n'
    gx = gx + 'set xlabel "N"\n'
    gx = gx + 'set ylabel "secs"\n'
    gx = gx + 'set key left\n'
    gx = gx + 'plot \\\n'

    # one summary per test
    summary = {}
    first = 1
    xls = xd.keys()
    xls.sort()
    for xl in [x for x in xls if chkxl(x)]:
      nd = xd[xl]
      # one datafile for each test/xlator
      fxl = open(root+'/'+t+'/'+xl+'.dat','w')
      print "    xlator",xl
      ns = nd.keys()
      ns.sort()
      lines = 0
      for n in ns:
        es = nd[n]
        count = len(es)
        sum = reduce (lambda x,y: x+y,es)
        average = sum / float(count)
        emin = reduce (lambda x,y:min(x,y),es)
        emax = reduce (lambda x,y:max(x,y),es)
        edev = 0
        for x in es: edev = edev + (x - average) * (x - average)
        edev = math.sqrt(edev/float(count))
        print "        n %2d -[%3d]-> (%6.2f,%6.2f,%6.2f) sd=%6.2f" % (n,count,emin,average,emax,edev)
        # one line for each n value
        # skip too low values
        if average >= mintime and count >= mindata:
          fxl.write("%s %d %0.2f %d %6.2f\n" % (xl,n,average,count,edev))
          lines = lines + 1
        summary[(-n,average)]=(xl,count,edev)
      fxl.close()

      # gnuplot is too dumb to handle empty files
      if lines > 0:
        if first:
          first = 0
        else:
          gx = gx + ', \\\n'
        gx = gx + '"'+root+'/'+t+'/'+xl+'.dat" using 2:3 title "'+xl+'" with linespoints'
    fp.write(gx+'\n')
    fp.close()

    fi.write('set output "'+root+'images/'+t+'.jpg"\n')
    fi.write('load "'+root+'plotters/'+t+'.gpl"\n') 

    keys = summary.keys()
    keys.sort()

    prlimit = 10
    i = 0 
    print "Rankings for",t,"on",h
    for m,a in keys:
      xl,count,edev = summary[m,a]
      print "    %-16s %2d %6.2f [N=%3d, SD=%6.2f]" % (xl,-m,a,count,edev)
      i = i + 1
      if i >= prlimit: break
    try: os.mkdir(root+'rankings')
    except: pass
    rf = open(root+'rankings/'+t+'.txt','w')
    prlimit = 10
    i = 0 
    rf.write("Rankings for "+t+' on '+h+'\n')
    for m,a in keys:
      xl,count,edev = summary[m,a]
      rf.write("    %-16s %2d %6.2f [N=%3d SD=%2d%%]\n" % (xl,-m,a,count,int(edev*100/average)))
      i = i + 1
      if i >= prlimit: break
    rf.close()
fi.close()

# the client can view individual plots in an x11 console
# with the command 'gnuplot' and then 
# type 'load "filename"'

@head(2,'Standard Build commands')
@select(tangler('speed/xlators/gcc.py','python'))
def mk(k,p):
  return "gcc -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gccopt.py','python'))
def mk(k,p):
  x = "gcc -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/ocamlopt.py','python'))
def mk(k,p):
  return "ocamlopt.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)
lang="ocaml"

@select(tangler('speed/xlators/ocamlb.py','python'))
def mk(k,p):
  return "ocamlc.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)
lang="ocaml"

@select(tangler('speed/xlators/felix.py','python'))
def mk(k,p):
  x = "bin/flx --test --force --static --optimise -c -DFLX_PTF_STATIC_POINTER "
  x = x + "speed/src/felix/%s && " % p
  x = x + "mv speed/src/felix/%s speed/exes/%s/%s" % (p,k,p)
  return x
lang="felix"

@select(tangler('speed/xlators/ghc.py','python'))
# ----------- environment hack ------------------
env['GHCRTS']='-K8m -k1m' # set stack size for GHC

def mk(k,p):
  return "ghc -O3 -fvia-C -optc -O1 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)
lang="haskell"

@select(tangler('speed/xlators/gnat.py','python'))
def mk(k,p):
  return "python script/gnatmaker.py speed/src/ada/%s speed/exes/%s " % (p,k)
lang="ada"

@select(tangler('speed/xlators/gcj.py','python'))
def mk(k,p):
  x = "gcj -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x
lang="java"

@select(tangler('speed/xlators/gcc_3_3.py','python'))
def mk(k,p):
  return "gcc-3.3 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gcc_3_3_opt.py','python'))
def mk(k,p):
  x = "gcc-3.3 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/gcc_3_4.py','python'))
def mk(k,p):
  return "gcc-3.4 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gcc_3_4_opt.py','python'))
def mk(k,p):
  x = "gcc-3.4 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/gcc_4_0.py','python'))
def mk(k,p):
  return "gcc-4.0 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="c"

@select(tangler('speed/xlators/gcc_4_0_opt.py','python'))
def mk(k,p):
  x = "gcc-4.0 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="c"

@select(tangler('speed/xlators/gpp_3_3.py','python'))
def mk(k,p):
  return "g++-3.3 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="cpp"

@select(tangler('speed/xlators/gpp_3_3.py','python'))
def mk(k,p):
  x = "g++-3.3 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="cpp"

@select(tangler('speed/xlators/gpp_4_0.py','python'))
def mk(k,p):
  return "g++-4.0 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
lang="cpp"

@select(tangler('speed/xlators/gpp_4_0_opt.py','python'))
def mk(k,p):
  x = "g++-4.0 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x
lang="cpp"

@select(tangler('speed/xlators/ghc_6_2_2.py','python'))
def mk(k,p):
  return "ghc-6.2.2 -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)
lang="haskell"

@select(tangler('speed/xlators/ghc_6_4_1.py','python'))
def mk(k,p):
  return "ghc-6.4.1.20050704 -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)
lang="haskell"

@select(tangler('speed/xlators/fpc_2_0_0.py','python'))
def mk(k,p):
  x = "fpc -O3 speed/src/pascal/%s.pp && " % p
  x = x + "mv speed/src/pascal/%s speed/exes/%s" % (p,k)
  return x
lang="pascal"

@select(tangler('speed/xlators/gpc_2_1_3_3.py','python'))
def mk(k,p):
  return "gpc-2.1-3.3 -O3 -o speed/exes/%s/%s speed/src/pascal/%s.pp" % (k,p,p)
lang="pascal"

@select(tangler('speed/xlators/gnat_4_0.py','python'))
def mk_gnat_4_0(k,p):
  return "python script/gnatmaker_4_0.py speed/src/ada/%s speed/exes/%s " % (p,k)
lang="ada"

@select(tangler('speed/xlators/gcj_4_0.py','python'))
def mk(k,p):
  x = "gcj-4.0  -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x
lang="java"

@select(tangler('speed/xlators/gcj_4_1.py','python'))
def mk(k,p):
  x = "gcj-4.1  -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x
lang="java"

@select(tangler('script/gnatmaker.py'))
import os
import sys
import string
def xqt(x):
  print x
  os.system(x)

filebase = sys.argv[1]
split = string.split(filebase,'/')
filebase = split[-1]
indir =  string.join(split[:-1],'/')
curdir = os.getcwd()
os.chdir(indir)
outdir = sys.argv[2]
f = os.popen('gnatchop -w ' + filebase + '.ada | grep \\.adb')
units = f.readlines()
f.close()
units = [string.strip (x) for x in units]
for f in units:
  xqt("gcc -c -O3 "+ f)
xqt("gnatbind " + filebase)
xqt("gnatlink " + filebase)
os.chdir(curdir)
xqt("mv "+indir+'/'+filebase+" "+outdir)

@select(tangler('script/gnatmaker_4_0.py'))
import os
import sys
import string
def xqt(x):
  print x
  os.system(x)

filebase = sys.argv[1]
split = string.split(filebase,'/')
filebase = split[-1]
indir =  string.join(split[:-1],'/')
curdir = os.getcwd()
os.chdir(indir)
outdir = sys.argv[2]
f = os.popen('gnatchop -w ' + filebase + '.ada | grep \\.adb')
units = f.readlines()
f.close()
units = [string.strip (x) for x in units]
for f in units:
  xqt("gcc-4.0 -c -O3 "+ f)
xqt("gnatbind " + filebase)
xqt("gnatlink " + filebase)
os.chdir(curdir)
xqt("mv "+indir+'/'+filebase+" "+outdir)


