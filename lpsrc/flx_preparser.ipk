@from config.flx_data import flx_keywords, flx_syms

@head(1,'Preprocessor Parser')
@h = tangler('src/compiler/frontend/flx_preparse.dyp','data')

@head(2,'Header')
@select(h)
%mltop {
open Flx_token
}
{

(* parser header *)
exception EndOfInput
open Flx_ast
open Flx_mtypes1
open Flx_typing
open Flx_typing2
open Flx_srcref
open Flx_print
open Flx_charset
open Flx_exceptions
open Flx_util
open Ocs_types
open Sex_types
open Dyp
open Flx_pdoc

let silly_strtoken k =
  match k with
  | NAME (_,s) -> s
  | _ -> Dyp_symbols.str_token k


let map = List.map
let map2 = List.map2
let hd = List.hd
let tl = List.tl
let fold_left = List.fold_left
let rev = List.rev
let mem = List.mem
let length = List.length

let list_last lst = List.hd (List.rev lst)
let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) =
  raise (Flx_exceptions.ParseError "Error parsing input")

(* model infix operator as function call *)
let apl2 (sri:srcref) (fn : string) (tup:expr_t list) =
  let sr = rslist tup in
  `AST_apply
  (
    sr,
    (
      `AST_name (slift sri,fn,[]),
      `AST_tuple (sr,tup)
    )
  )

(* model prefix operator as function call *)
let apl (sri:srcref) (fn : string) (arg:expr_t):expr_t =
  let sr = src_of_expr arg in
  `AST_apply
  (
    sr,
    (
      `AST_name (slift sri, fn,[]),
      arg
    )
  )

(* model unary operator as procedure call *)
let call1 (op:string) (sr:range_srcref) (sri:srcref) l =
  `AST_call
  (
    sr, `AST_name (slift sri, op,[]), l
  )

(* model unary operator as procedure call *)
let call2 (op:string) (sr:range_srcref) (sri:srcref) l r =
  `AST_call
  (
    sr,
    `AST_name (slift sri, op,[]),
    `AST_tuple(sr,[l;r])
  )

let mkcurry sr name vs (args:params_t list) return_type kind body =
  `AST_curry (sr,name,vs,args,return_type,kind,body)

let cal_funkind adjs fk =
  match fk with
  | sr,`CFunction -> sr,`CFunction
  | sr,`Generator -> sr,`Generator
  | sr,`Function -> match adjs with
  | [] -> sr,`Function
  | h :: t -> sr,snd h

let dfltvs =
  [],
  {
    raw_type_constraint=`TYP_tuple [];
    raw_typeclass_reqs=[]
  }

let dummysr = "Dummy",0,0,0,0
}

@head(2,'Tokens')
@select(h)

%global_data_type <unit>
%local_data_type <unit>

/* special */
%token <(Flx_ast.srcref * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE
%token SLOSH
%token <(string)> COMMENT
%token <(string)> COMMENT_NEWLINE
%token <(int)> WHITE

/* literals */
%token <(Flx_ast.srcref * string)> NAME
%token <(Flx_ast.srcref * string * prio_t)> NONTERMINAL
%token <(Flx_ast.srcref * string * Flx_ast.bigint)> INTEGER
%token <(Flx_ast.srcref * string * string )> FLOAT
%token <(Flx_ast.srcref * string)> STRING
%token <(Flx_ast.srcref * string)> CSTRING
%token <(Flx_ast.srcref * string)> FSTRING
%token <(Flx_ast.srcref * string)> QSTRING
%token <(Flx_ast.srcref * string)> WSTRING
%token <(Flx_ast.srcref * string)> USTRING
%token <(Flx_ast.srcref * string)> USER_KEYWORD
%token <(string list)> HASH_INCLUDE_FILES
%token <(token list)> TOKEN_LIST
%token DUMMY

%token <local_data_t> LOAD_SYNTAX
%token <string> SAVE_SYNTAX

/* user defined symbols */
%token <(Flx_ast.srcref * string * string)> USER10
%token <(Flx_ast.srcref * (string * string) list * string)> USERLB
%token <(Flx_ast.srcref * string )> USERRB
%token <(Flx_ast.srcref * string * Ocs_types.code)> SCHEME_CODE

@for k,v in flx_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for n,t in flx_keywords:
  tangle("%token <(Flx_ast.srcref)> " + t,inhibit_sref=1)

%start <(Flx_ast.expr_t)> expression
%%

@head(2,'Compilation Unit')
@select(h)
expression:
  | old_expr ENDMARKER { $1 }

/* ******************* OLD STUFF *************************** */

@head(3,'Pattern Matching')
@select(h)
match_expr:
  | MATCH old_expr WITH matchings ENDMATCH
  {
    `AST_match (rstoken $1 $5, ($2, $4))
  }
matchings:
  | matching matchings { $1 :: $2 }
  | matching { [$1] }
matching:
  | VBAR pattern EQRIGHTARROW old_expr { $2, $4 }
  | VBAR EQRIGHTARROW old_expr { let sr = rstoken $1 $2 in `PAT_none sr, $3 }

@doc()
The pattern matching statment analyses the shape and contents of
a value and selects the first matching case from the matching body.

@head(4,'Patterns')
@select(h)
pattern:
  | as_pattern WHEN old_expr
    {
      `PAT_when
      (
        rsrange (src_of_pat $1) (src_of_expr $3),
        $1,
        $3
      )
    }
  | as_pattern { $1 }

as_pattern:
  | variant_pattern AS NAME
    {
      `PAT_as
      (
        rsrange (src_of_pat $1) (slift (fst $3)),
        $1,
        snd $3
      )
    }
  | variant_pattern { $1 }

variant_pattern:
  | tuple_pattern { $1 }
tuple_pattern:
  | coercive_pattern_list
    {
      match $1 with
      | [x] -> x
      | _ -> `PAT_tuple
        (
          rsrange (src_of_pat (List.hd $1)) (src_of_pat (list_last $1)),
          $1
        )
    }

coercive_pattern_list:
  | coercive_pattern COMMA coercive_pattern_list { $1 :: $3 }
  | coercive_pattern { [$1] }

coercive_pattern:
  | atomic_pattern COLON arrow
    {
      let sr = rsrange (src_of_pat $1) (src_of_expr $3) in
      let t = typecode_of_expr $3 in
      `PAT_coercion (sr,$1,t)
    }
  | atomic_pattern { $1 }

atomic_pattern:
  /* constants */
  | STRING { `PAT_string (slift (fst $1), snd $1) }
  | integral
    {
      let sr,t,v = $1 in
      `PAT_int (sr,t,v)
    }
  | NAN { `PAT_nan (slift $1) }

  /* ranges */
  | STRING DOTDOT STRING
    {
      `PAT_string_range (rstoken (fst $1) (fst $3), snd $1, snd $3)
    }
  | integral DOTDOT integral
    {
      let sr1,t1,v1 = $1
      and sr2,t2,v2 = $3
      in
      `PAT_int_range (rsrange sr1 sr2, t1,v1,t2,v2)
    }

  | floating DOTDOT floating
    {
      let sr1,v1 = $1
      and sr2,v2 = $3
      in
      `PAT_float_range
      (
       rsrange sr1 sr2,
       v1, v2
      )
    }

  /* other */
  | ctor_pattern { $1 }
  /*
  | QUEST NAME { `PAT_name (rstoken $1 (fst $2), snd $2) }
  */
  | QUEST NAME { let sr = rstoken $1 (fst $2)in `PAT_as (sr,`PAT_any sr, snd $2) }
  | QUEST { `PAT_any (slift $1) }
  | UNDERSCORE { `PAT_any (slift $1) }
  | LPAR pattern RPAR { $2 }
  | REGEXP STRING LPAR basic_name_comma_list RPAR
    {
      let names = List.map snd $4 in
      `PAT_regexp (rstoken $1 $5, snd $2, names)
    }
  | STRUCT LBRACE pat_assigns RBRACE
    {
      `PAT_record (rstoken $1 $4, $3)
    }

pat_assign:
  | NAME EQUAL pattern SEMI { snd $1, $3 }
pat_assigns:
  | pat_assign pat_assigns  { $1 :: $2 }
  | pat_assign { [$1] }

ctor_pattern:
  | ctor_name atomic_pattern
    {
      `PAT_nonconst_ctor
      (
        rsrange (src_of_expr $1) (src_of_pat $2),
        qualified_name_of_expr $1,
        $2
      )
    }
  | ctor_name
    {
      `PAT_const_ctor
      (
        src_of_expr $1,
        qualified_name_of_expr $1
      )
    }

ctor_name:
  | qualified_name
    {
      $1
      (*
      match $1 with sr,name,ts ->
      `AST_name (sr,name,ts)
      *)
    }

  | CASE INTEGER {
      let sr,t,v = $2 in
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    }

integral:
  | INTEGER { let sr,t,v = $1 in slift sr, t, v }
  | MINUS INTEGER
    {
      let sr,t,v = $2 in
      rstoken $1 sr, t, (Big_int.minus_big_int v)
    }

floating:
  | FLOAT
    {
      let sr,t,v = $1 in
      slift sr, Float_plus (t,v)
    }
  | MINUS FLOAT
    {
      let sr,t,v = $2 in
      rstoken $1 sr, Float_minus (t,v)
    }
  | INF { slift $1, Float_inf }
  | MINUS INF { slift $1, Float_minus_inf }

basic_name:
  | NAME { $1 }

basic_name_comma_list:
  | basic_name COMMA basic_name_comma_list { $1 :: $3 }
  | basic_name { [$1] }
  | { [] }

old_expr:
  | LET pattern EQUAL old_expr IN old_expr
    {
      let sr = rsrange (slift $1) (src_of_expr $6) in
      `AST_letin (sr,($2,$4,$6))
    }
  | dollar_apply { $1 }

dollar_apply:
  | tuple UNLESS old_expr THEN dollar_apply
    {
      let sr = rsrange (src_of_expr $1) (src_of_expr $5) in
      let revcond = apl $2 "lnot" $3 in
      `AST_cond (sr,(revcond,$1,$5))
    }

  | tuple DOLLAR dollar_apply
    {
      let sr = rsexpr $1 $3 in
      `AST_apply (sr, ($1,$3))
    }

  | tuple { $1 }

tuple:
  | or_condition tuple_suffix
    {
      let lst = $1 :: $2 in
      `AST_tuple ( rslist lst, lst)
    }
  | or_condition                        { $1 }

tuple_suffix:
  | COMMA or_condition tuple_suffix     { $2 :: $3 }
  | COMMA or_condition                  { [$2] }

/* oring formation is 'psuedo-associative' */
typeexpr: or_condition { $1 }
or_condition:
  | and_condition OR or_list
    {
      let sr = rsrange
        (src_of_expr $1)
        (src_of_expr (list_last $3))
      in
      `AST_orlist (sr,$1 :: $3)
    }
  | and_condition { $1 }

or_list:
  | and_condition OR or_list              { $1 :: $3 }
  | and_condition                         { [$1] }

/* oring formation is 'psuedo-associative' */
and_condition:
  | not_condition AND and_list
    {
      let sr = rsrange
        (src_of_expr $1)
        (src_of_expr (list_last $3))
      in
      `AST_andlist (sr,$1 :: $3)
    }
  | not_condition { $1 }

and_list:
  | not_condition AND and_list              { $1 :: $3 }
  | not_condition                         { [$1] }

notop:
  | NOT {$1,"lnot"}
not_condition:
  | notop not_condition                 { apl (fst $1) (snd $1) $2 }
  | comparison                          { $1 }

cmp_op:
  | EQEQUAL                            { "eq",$1 }
  | NOTEQUAL                           { "ne",$1 }
  | LESS                               { "lt",$1 }
  | GREATER                            { "gt",$1 }
  | LESSEQUAL                          { "le",$1 }
  | GREATEREQUAL                       { "ge",$1 }
  | ISIN                               { "_isin",$1 }
    /* hack */

comparison:
  | arrow cmp_op arrow        { apl2 (snd $2) (fst $2) [$1; $3] }
  | arrow                 { $1 }

arrow:
  | case_literal RIGHTARROW arrow
    {
      let sr = rsexpr $1 $3 in
      `AST_arrow (sr,($1,$3))
    }
  | case_literal LONGRIGHTARROW arrow
    {
      let sr = rsexpr $1 $3 in
      `AST_longarrow (sr,($1,$3))
    }
  | case_literal { $1 }

case_literal:
  | CASE INTEGER
    {
      let sr,t,v = $2 in
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    }
  | CASE INTEGER OF sum
    {
      let _,_,v = $2 in
      `AST_typed_case
      (
        rsrange (slift $1) (src_of_expr $4),
        Big_int.int_of_big_int v,
        typecode_of_expr $4
      )
    }
  | CASE NAME OF sum
    {
      let sr =  rsrange (slift $1) (src_of_expr $4) in
      let s = snd $2 in
      let e = $4 in
      `AST_variant (sr,(s,e))
    }

  | bor { $1 }

bor:
  | bor SLOSHVBAR bxor { apl2 $2 "bor" [$1;$3] }
  | bxor { $1 }

bxor:
  | bxor SLOSHCIRCUMFLEX band { apl2 $2 "bxor" [$1;$3] }
  | band { $1 }

band:
  | band SLOSHAMPER shift { apl2 $2 "band" [$1;$3] }
  | shift { $1 }

shift:
  | shift LEFTSHIFT sum { apl2 $2 "shl" [$1;$3] }
  | shift RIGHTSHIFT sum { apl2 $2 "shr" [$1;$3] }
  | sum { $1 }

/* sum formation is 'psuedo-associative' */
sum:
  | subtraction PLUS sum_list
    {
      let sr = rsrange
        (src_of_expr $1)
        (src_of_expr (list_last $3))
      in
      `AST_sum (sr,$1 :: $3)
    }
  | subtraction { $1 }

sum_list:
  | subtraction PLUS sum_list { $1 :: $3 }
  | subtraction { [$1] }

subtraction:
  | subtraction MINUS product { apl2 $2 "sub" [$1; $3] }
  | product { $1 }

/* product formation is 'psuedo-associative' */
product:
  | term STAR product_list
    {
      let sr = rsrange
        (src_of_expr $1)
        (src_of_expr (list_last $3))
      in
      `AST_product (sr,$1 :: $3)
    }
  | term                                { $1 }
product_list:
  | term STAR product_list              { $1 :: $3 }
  | term                                { [$1] }


/* division is left associative: note higher precedence
   the product, so that

   a * b/c * d -> a * (b/c) * d
*/
term:
  | term SLASH power                    { apl2 $2 "div" [$1; $3] }
  | term PERCENT power                  { apl2 $2 "mod" [$1; $3] }
  | prefixed { $1 }

/* note weird recursion here: we need to support
  -x ** -x = -(x**(-x))
*/
prefixed:
/*
  | LVAL power
    {
      `AST_lvalue
      (
        rsrange (slift $1) (src_of_expr $2),
        $2
      )
    }
*/
  /*
  | HASH power  { apl $1 "len" $2 }
  */
  | EXCLAMATION power  { apl $1 "excl" $2 }
  | PLUS power  { apl $1 "pos" $2 }
  | MINUS power { apl $1 "neg" $2 }
  | TILDE power { apl $1 "bnot" $2 }
  | power       { $1 }

/* exponentiation is right associative */
power:
  | superscript STARSTAR prefixed      { apl2 $2 "pow" [$1; $3] }
  | superscript { $1 }

superscript:
  | superscript CIRCUMFLEX refr
    {
      let sr = rsrange (src_of_expr $1) (src_of_expr $3) in
      `AST_superscript (sr, ($1, $3))
    }

  | refr { $1 }
refr:
  | AMPER refr
    {
      `AST_ref
      (
        rsrange (slift $1) (src_of_expr $2),
        $2
      )
    }
  | STAR refr { apl $1 "deref" $2 }
  | DEREF refr
    {
      `AST_deref
      (
        rsrange (slift $1) (src_of_expr $2),
        $2
      )
    }
  | NEW refr
    {
      `AST_new
      (
        rsrange (slift $1) (src_of_expr $2),
        $2
      )
    }

  | application { $1 }

/* applications is left associative */
application:
  | application coercion
    {
      `AST_apply (rsexpr $1 $2, ($1, $2))
    }
/*
  | MAP coercion coercion
    {
      `AST_map (rsrange (slift $1) (src_of_expr $3), $2, $3)
    }
*/
  | CASENO coercion {
      let sr = rsrange (slift $1) (src_of_expr $2) in
      `AST_case_index (sr,$2)
    }

  | coercion { $1 }


coercion:
  | coercion COLON factor
    {
      `AST_coercion (slift $2, ($1, typecode_of_expr $3))
    }
  | suffixed_name                  { ($1:>expr_t) }
  | factor                         { $1 }


factor:
  | hash_name                        { ($1:>expr_t) }
  | factor DOT LSQB old_expr RSQB          { apl2 $3 "subscript" [$1; $4] }
  | factor DOT LSQB old_expr TO old_expr RSQB  { apl2 $3 "substring" [$1; $4; $6] }
  | factor DOT LSQB old_expr TO RSQB       { apl2 $3 "copyfrom" [$1; $4] }
  | factor DOT LSQB TO old_expr RSQB       { apl2 $3 "copyto" [$1; $5] }
  | factor DOT simple_name_parts
    {
      let rsr,name,ts = $3 in
      let sr = rsrange (src_of_expr $1) rsr in
      `AST_dot (sr, ($1, `AST_name (sr,name,ts)))
    }
  | factor DOT LPAR INTEGER RPAR
    {
      match $4 with
      | (sr,t,v) ->
        let n =
          try Big_int.int_of_big_int v
          with _ ->
            failwith
            (
              "[parser] Tuple index " ^
              Big_int.string_of_big_int v ^
              " too big in " ^
              short_string_of_src (slift sr)
             )
        in
          let sr = rsrange (src_of_expr $1) (slift $5) in
          `AST_get_n (sr, (n,$1))
    }

hash_name:
  | HASH hash_name { `AST_lift ((slift $1), $2) }
  | the_name { $1 }

the_name:
  | NOEXPAND qualified_name
    {
      let e = ($2:>expr_t) in
      let sr = src_of_expr e in
      let sr = rsrange (slift $1) sr in
      `AST_noexpand (sr,e)
    }
  | THE qualified_name
  {
    let sr = src_of_expr $2 in
    let sr = rsrange (slift $1) sr in
    let qn = qualified_name_of_expr $2 in
    (`AST_the (sr,qn))
  }
  | qualified_name { $1 }
  | QUEST NAME { `AST_patvar (rstoken $1 (fst $2), snd $2) }
  | atom { $1 }

qualified_name:
  | qualified_name COLONCOLON simple_name_parts
    {
      match $3 with sr,name,ts ->
      let sr = rsrange (src_of_expr $1) sr in
      `AST_lookup (sr,($1, name, ts))
    }

  | simple_name_parts
    {
      match $1 with sr,name,ts ->
      (`AST_name (sr,name,ts):>expr_t)
    }

elif:
  | ELIF old_expr THEN old_expr { $2,$4 }

elifs:
  | elifs elif { $2 :: $1 }
  | elif { [$1] }

else_part:
  | elifs ELSE old_expr
    {
      List.fold_left (* actually a right fold cause list is reversed *)
      (fun result (cond,thn) ->
        let sr = rsrange (src_of_expr cond) (src_of_expr result) in
        `AST_cond ( sr, ( cond, thn, result))
      )
      $3 $1
    }
  | ELSE old_expr { $2 }

cond:
  | IF old_expr THEN old_expr else_part ENDIF
    {
      `AST_cond (rstoken $1 $6,($2,$4,$5))
    }

expr_code_prefix:
  | CODE LSQB old_expr RSQB
    {
     $1,
     typecode_of_expr $3
    }



atom:
  | UNDERSCORE { `AST_patany (slift $1) }
  | CALLBACK LSQB qualified_name RSQB
    {
      let sr = rstoken $1 $4 in
      let qn = qualified_name_of_expr $3 in
      `AST_callback (sr,qn)
    }

  | DOTDOTDOT { `AST_ellipsis (slift $1) }

  | expr_code_prefix NAME
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | expr_code_prefix STRING
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | LSQBAR old_expr RSQBAR
    {
      let sr = rstoken $1 $3 in
      match $2 with
      | `AST_tuple (_,ls) -> `AST_arrayof (sr,ls)
      | x -> `AST_arrayof (sr,[x])
    }

  | LBRACE old_expr RBRACE
    {
      let sr = rstoken $1 $3 in
      `AST_lambda
      (
        sr,
        (
          dfltvs,
          [[],None],
          `TYP_none,
          [`AST_fun_return (sr,$2)]
        )
      )
    }
  | match_expr { $1 }
  | LPAR old_expr RPAR      { $2 }
  | LPAR RPAR           { `AST_tuple (rstoken $1 $2,[]) }
  | literal             { $1 }
  | cond                { $1 }
  | FSTRING
    {
      let sr,s = $1 in
      let sr = slift sr in
      `AST_vsprintf (sr,s)
    }
  | QSTRING
    {
      let sr,s = $1 in
      let sr = slift sr in
      `AST_interpolate (sr,s)
    }

literal:
  | integer_literal { $1 }
  | string_literal { $1 }
  | float_literal { $1 }
  | TRUE { `AST_typed_case (slift $1, 1, `TYP_unitsum 2) }
  | FALSE { `AST_typed_case (slift $1, 0, `TYP_unitsum 2) }

integer_literal:
  | INTEGER
    { let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_int (t,v))
    }

float_literal:
  | FLOAT
    {
      let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_float (t,v))
    }

string_literal:
  | STRING
    {
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_string s)
    }

  | WSTRING
    {
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_wstring s)
    }

  | USTRING
    {
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_ustring s)
    }

  | CSTRING
    {
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_cstring s)
    }

simple_name_parts:
  | NAME LSQB old_expr RSQB
    {
      rsrange (slift (fst $1)) (slift $4),
      snd $1,
      match typecode_of_expr $3 with
      | `TYP_type_tuple ls -> ls
      | x -> [x]
    }

  | identifier { $1 }

identifier:
  | NAME
    {
      slift (fst $1),
      snd $1,
      []
    }

suffixed_name:
  | qualified_name OF factor
    {
      `AST_suffix
      (
        rsrange (src_of_expr $1) (src_of_expr $3),
        (qualified_name_of_expr $1, typecode_of_expr $3)
      )
    }

epsilon: | {()}

%mlitop {
open Flx_token
}


