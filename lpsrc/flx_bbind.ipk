@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
val bbind:
  sym_state_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  sym_state_t ->
  (iface_t * int option) list ->
  biface_t list 

@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify
open Flx_exceptions
open Flx_bexe
open List
open Flx_generic

let rec proper_descendant dfns parent =
  match parent with
  | Some parent -> 
    let _,_,parent,vs,_,_,entry = Hashtbl.find dfns parent in
    begin match entry with
    | `SYMDEF_interface  
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _ 
      -> false
    | _ -> proper_descendant dfns parent 
    end
  | None -> true

let find_param name_map s =
  match Hashtbl.find name_map s with
  | NonFunctionEntry (Simple i) -> i
  | _ -> failwith ("[find_param] Can't find parameter " ^ s )

let bbind_sym syms bbdfns i (name,sr,parent,vs,name_map,dirs,bdcl) =
  let bexes env exes rt i tvars = bind_exes syms env sr exes rt name i tvars in
  if syms.compiler_options.print_flag then
  print_endline ("//binding  " ^ name ^ "<"^string_of_int i^">");
  (*
  print_endline ("Parent is " ^ (match parent with | None -> "none" | Some i -> string_of_int i));
  *) 
  if proper_descendant syms.dfns parent
  then begin
    (* let env = build_env syms [] parent in  *)
    let env = build_env syms [] (Some i) in 
    let vs = find_vs syms i in
    let bt t = bind_type syms env [] [] sr t in
    match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_interface
    | `SYMDEF_if_fun _ 
    | `SYMDEF_module
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _
    | `SYMDEF_module_binding _
    | `SYMDEF_typevar _
    | `SYMDEF_if_type  -> ()

    | `SYMDEF_function (ps,rt,exes) -> 
      (*
      print_endline ("//Binding function " ^ string_of_int i ^ " --> " ^ name); 
      print_endline ("given type is " ^ string_of_typecode rt);
      print_endline ("exes are: " ^ (String.concat "\n  " (List.map (string_of_exe 1) exes)));
      *)
      let bps : (string * (int * btypecode_t)) list = 
        List.map (fun (s,t) -> 
        let i = find_param name_map s in
        s,(i,bt t)) 
      ps 
      in
      let env' = build_env syms [] (Some i) in
      let brt = bt rt in
      (*
      print_endline ("return type is stated as " ^ string_of_btypecode syms.dfns brt);
      *)
      let brt',bbexes = bexes env' exes brt i vs in
      (*
      print_endline ("return type is " ^ string_of_btypecode syms.dfns brt');
      *)
      let bbdcl = 
        match brt' with
        | `BTYP_void ->
          `BBDCL_procedure (vs,bps,bbexes,name_map)
        | _ ->
          `BBDCL_function (vs,bps,brt',bbexes,name_map)
      in
        (*
        print_endline "binding done";
        *)
        Hashtbl.add bbdfns i (name,parent,bbdcl);
        (* the types of parameters must use the same type variables
           as the function, so we have to add them here
        *)
        List.iter
        (fun (s,(k,t)) ->
          (*
          print_endline (" .. binding parameter " ^ s ^ "<"^ string_of_int k ^ ">");
          *)
          Hashtbl.add bbdfns k (s,Some i,`BBDCL_val (vs,t))
        )
        bps 
    (* this case is messy: function bind their own parameters,
      but functors do not, we have to do it for them,
      temporarily (this will obviously fail when there are
      type variables around .. we need to get em from the
      functor sig, but they're not parameterised yet
    *)
    | `SYMDEF_parameter (t) -> 
      begin match parent with 
      | None -> failwith "[bbind_sym] expected parameter to have a parent" 
      | Some ip ->
        let id2,sr,parent2,vs,_,_,entry2 = Hashtbl.find syms.dfns ip in
        match entry2 with
        | `SYMDEF_function _ -> ()
        | `SYMDEF_typed_functor _
        | `SYMDEF_untyped_functor _ ->
           let t = bt t in
           Hashtbl.add bbdfns i (name,parent,`BBDCL_val (vs,t))
        | _ -> failwith "[bbind_sym] expected parameter to have function or functor parent"
      end

    | `SYMDEF_match_check (pat,mvindex) ->
      (*
      print_endline ("//Binding match checker " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let t = typeofindex syms [] [] 0 [] mvindex in
      let name_map = Hashtbl.create 97 in
      let arg,sr = match Hashtbl.find syms.dfns mvindex with id,sr,_,_,_,_,_ -> id,sr in
      let exes = 
        [
        `EXE_fun_return (gen_match_check pat (`AST_name (sr,arg,[])))
        ] 
      in
      let brt',bbexes = bexes env exes flx_bbool i [] in
      if brt' <> flx_bbool
      then 
        failwith 
        (
          "expected boolean return from match checker " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_function (vs,[],flx_bbool,bbexes,name_map));
    
    | `SYMDEF_val (t) -> 
      (*
      print_endline ("//Binding value " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let t = bt t in
      (*
      print_endline ("bound type is " ^ sbt syms.dfns t);
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (vs,t))

    | `SYMDEF_var (t) ->
      (*
      print_endline ("//Binding variable " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let t = bt t in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_var (vs,t))

    | `SYMDEF_fun (ts,ret,ct) ->
      (*
      print_endline ("//Binding primitive function " ^ string_of_int i ^ " --> " ^ name);
      *)
      let params : btypecode_t list = List.map bt ts in
      (*
      print_endline "got params";
      *)
      let bret = bt ret in
      let bbdcl = match bret with
        | `BTYP_void ->
          `BBDCL_proc (vs, params,ct)
        | _ ->
          `BBDCL_fun (vs, params,bret,ct)
      in
      Hashtbl.add bbdfns i (name,parent,bbdcl)

    | `SYMDEF_union (cs) ->
      (* print_endline ("//Binding union " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_union (vs,cs'))

    | `SYMDEF_struct (cs) ->
      (* print_endline ("//Binding struct " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_struct (vs,cs'))

    | `SYMDEF_const (t,ct) ->
      (* print_endline ("//Binding constant " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_const (vs,bt t,ct))

    | `SYMDEF_regdef _ -> ()
    | `SYMDEF_type_alias _ -> ()



    | `SYMDEF_abs ct->
      (*
      print_endline ("//Binding abstract type " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_abs (vs,ct))

    | `SYMDEF_header ct ->
      (* print_endline ("//Binding header string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_header ct)

    | `SYMDEF_body ct ->
      (* print_endline ("//Binding body string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_body ct)

    (*
    | x -> 
      failwith
      (
      "[bind_entry] Unexpected entry " ^ string_of_symdef x name vs 
      )
    *) 
    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ "> COMPLETE");
    flush stdout
    *)

let bbind_index syms bbdfns i =
  if Hashtbl.mem bbdfns i then ()
  else let entry = Hashtbl.find syms.dfns i in
  bbind_sym syms bbdfns i entry

let bbind syms = 
  let bbdfns = Hashtbl.create 97 in
  (* loop through all counter values [HACK]
    to get the indices in sequence, AND,
    to ensure any instantiations will be bound,
    (since they're always using the current value
    of syms.counter for an index
  *)
  let i = ref 0 in
  while !i < !(syms.counter) do
    begin 
      try 
        let entry = Hashtbl.find syms.dfns !i in
        bbind_sym syms bbdfns !i entry
      with Not_found -> ()
    end
    ;
    incr i
  done
  ;
  bbdfns

let bind_ifaces syms 
  (ifaces:
    (iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env syms env [] n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | `IFACE_export (sn, cpp_name), parent ->
        let env = build_env syms [] parent in
        let index,ts = lookup_sn_in_env syms env [] sn in
        if length ts = 0 then
          `BIFACE_export (index, cpp_name) 
        else clierr dummy_sr 
        (
          "Can't export generic entity " ^
          string_of_suffixed_name sn
        )
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_flxopt
open Flx_exceptions
;;

let print_help () = print_options(); exit(0)
;;
let reverse_return_parity = ref false
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    raise (Exit 0)
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity :=  compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  (* IF THERE WAS NO INTERFACE FILE, GENERATE ONE *)
  if not have_interface 
  then begin
    print_endline "//No interface file found: generating one";
    let h = open_out iface_file_name in
    let iface = build_interface parse_tree in
    List.iter 
    (
      fun x->
        output_string h
        (
          (string_of_statement 0 x)^"\n"
        )
    ) 
    iface;
    close_out h
  end
  ;
  let counter = ref 1 in
  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in
  let deblocked = desugar_program include_dirs module_name counter parse_tree in

  let root = !(syms.counter) in
  let table, exes, ifaces,dirs = 
    build_tables syms "<top level>" 0 None None root deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let bbdfns = bbind syms in
    let bifaces = bind_ifaces syms ifaces in
    print_endline "//Binding complete";
    Hashtbl.iter
    (fun index (name,parent,entry) -> print_endline
      (
        string_of_int index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns
   
with x -> Flx_terminate.terminate !reverse_return_parity x
;;

