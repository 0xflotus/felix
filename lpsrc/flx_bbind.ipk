@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
val bbind:
  sym_state_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  sym_state_t ->
  (iface_t * int option) list ->
  biface_t list 

@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify

let cal_call dfns (p,pt) e =
  match lower pt with
  | `BTYP_function (_, `BTYP_void) -> 
    `BEXE_call ((p,lower pt), e)
  | _ -> failwith ("call non procedure, type=" ^ string_of_btypecode dfns pt)

exception Found of int

let bool_t = `BTYP_sum [`BTYP_tuple[]; `BTYP_tuple []]

let bind_exes syms env exes ret_type id = 
  (*
  print_endline ("bind_exes.. env depth="^ string_of_int (List.length env));
  print_endline "Dumping Source Executables";
  print_endline "--------------------------";
  let soe e = Flx_print.string_of_expr e in
  List.iter 
    (fun x -> print_endline (string_of_exe 1 x))
    exes
  ;
  print_endline ""
  ;

  print_endline "Binding Executables";
  print_endline "-------------------";
  *)
  let ret_type = ref ret_type in
  let be e = bind_expression syms env [] [] 0 [] e in
  let lun sr n = lookup_name_in_env env sr n in
  let luqn n = lookup_qn_in_env syms env [] n in
  let bt sr t = bind_type syms env [] [] sr t in
  let dummy_sr = ("bind exes",0,0,0,0) in
  let return_count = ref 0 in
  let reachable = ref true in

  let bound_exes = 
    List.map
    (fun x -> 
      (*
      print_endline (string_of_exe 1 x);
      *)
      if not !reachable then 
      begin 
        match x with 
        | `EXE_label _ -> ()
        | `EXE_comment _ -> ()
        | `EXE_nop _ -> ()
        | _ -> print_endline ("WARNING: Unreachable code in "^id^": " ^ string_of_exe 1 x);
      end
      ;
      match x with
      | `EXE_comment s ->       `BEXE_comment s
      | `EXE_label s ->         reachable := true; `BEXE_label s
      | `EXE_goto s ->          reachable := false; `BEXE_goto s

      | `EXE_ifgoto (e,s) ->    
        let e',t = be e in
        if t = bool_t
        then `BEXE_ifgoto ((e',t), s)
        else 
          failwith 
          (
            "[bind_exes:ifgoto] Conditional requires bool argument, got " ^
            string_of_btypecode syms.dfns t
          )

      | `EXE_ifnotgoto (e,s) -> 
        let e',t = be e in
        if t = bool_t
        then `BEXE_ifnotgoto ((e',t), s)
        else 
          failwith 
          (
            "[bind_exes:ifnotgoto] Conditional requires bool argument, got " ^
            string_of_btypecode syms.dfns t
          )

      | `EXE_call (#suffixed_name_t as sn, e2) -> (* OVERLOADING *)
        (*
        print_endline "Handling call of suffixed name";
        flush stdout;
        *)
        let be2,t2 = be e2 in
        (*
        print_endline "Argument bound";
        flush stdout;
        *)
        let tbe1 =
           match sn with
           | #qualified_name_t as qn ->
             lookup_qn_with_sig 
             syms 
             dummy_sr dummy_sr 
             env [] [] 
             qn t2 
           | _ -> be sn
        in  
          (*
          print_endline "Applying call now";
          flush stdout;
          *)
          cal_call syms.dfns tbe1 (be2,t2)

      | `EXE_call (p,e) ->
        let p',pt' = be p and e',et' = be e in
        cal_call syms.dfns (p', pt') (e', et')

      | `EXE_read s ->          
        begin match lun dummy_sr s with
        | NonFunctionEntry (Simple index) -> `BEXE_read index
        | NonFunctionEntry _ -> failwith "not expecting bound entry"
        | FunctionEntry _ -> failwith "Can't read function!"
        end

      | `EXE_return e ->        
        (*
        print_endline "Processsing return";
        *)
        reachable := false;
        incr return_count;
        (*
        print_endline ("Expression is " ^ string_of_expr e);
        *)
        let e',t' = be e in
        begin 
          try 
            (*
            print_endline ("Starting ret type is " ^ string_of_btypecode syms.dfns !ret_type);
            print_endline ("Expression type is   " ^ string_of_btypecode syms.dfns t');
            *)
            let mgu = do_unify syms !ret_type t' in
            ret_type := varmap_subst syms.varmap !ret_type;
            `BEXE_return (e',lower t')
          with 
            Not_found ->
              failwith 
              (
                "Wrong return type,\nexpected : " ^ 
                string_of_btypecode syms.dfns !ret_type ^
                "\nbut we got " ^
                string_of_btypecode syms.dfns t'
              )
        end

      | `EXE_nop s ->           `BEXE_nop s 
      | `EXE_code s ->          `BEXE_code s
      | `EXE_noreturn_code s ->  reachable := false; `BEXE_code s

      | `EXE_init (s,e) -> 
        let sr = src_of_expr e in (* HACK! *)
        begin match lun sr s with
        | FunctionEntry _ -> failwith "Can't init function constant"
        | NonFunctionEntry (Simple index) -> 
          let e',rhst = be e in
          let lhst = typeofindex syms [] [] 0 [] index in
          if type_eq lhst rhst
          then `BEXE_init (index, (e',rhst))
          else failwith (
            "LHS["^s^"]("^string_of_btypecode syms.dfns lhst^
            ") of initialisation must have same type as RHS("^
            string_of_btypecode syms.dfns rhst^")"
          )
        | NonFunctionEntry _ -> failwith "Not expecting bound entry"
        end
        
    )
    exes
  in 
  (*
  print_endline ""
  ;
  List.iter 
    (fun x -> print_endline (string_of_bexe syms.dfns 1 x)) 
    bound_exes
  ;
  print_endline ""
  ;
  print_endline "BINDING COMPLETE"
  ;
  *)

  (* No return statements found: it must be a procedure,
     so unify void
  *)
  if !return_count = 0 then
  begin
    let mgu = do_unify syms !ret_type `BTYP_void in
    ret_type := varmap_subst syms.varmap !ret_type;
  end
  ;

  begin match !ret_type with
  | `BTYP_void ->
    if not !reachable
    then print_endline ("WARNING: procedure " ^id^" doesn't drop thru end, possible infinit loop")
  | _ ->
    if !reachable 
    then print_endline ("WARNING: function "^id^" drops off end, possible missing return statement");
  end
  ;
  !ret_type,bound_exes

let rec proper_descendant dfns parent =
  match parent with
  | Some parent -> 
    let _,_,parent,entry = Hashtbl.find dfns parent in
    begin match entry with
    | `SYMDEF_interface _ 
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _ 
      -> false
    | _ -> proper_descendant dfns parent 
    end
  | None -> true

 
let bbind_sym syms bbdfns i (name,sr,parent,bdcl) =
  let bexes env exes rt = bind_exes syms env exes rt name in
  let dummy_sr = ("Generated dummy",0,0,0,0) in
  (*
  print_endline ("binding symbol " ^ name);
  *)
  if proper_descendant syms.dfns parent
  then begin
    (*
    print_endline "Building ENV";
    *)
    let env = build_env syms [] parent in 
    (* print_env env; *)
    (*
    print_endline "Building ENV Complete";
    *)
    let bt t = bind_type syms env [] [] sr t in
    (*
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ ">");
    *)
    begin match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_interface _
    | `SYMDEF_if_fun _ 
    | `SYMDEF_if_proc _
    | `SYMDEF_module _
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _
    | `SYMDEF_module_binding _
    | `SYMDEF_if_type  -> ()

    | `SYMDEF_function (ps,rt,exes,name_map,dirs) -> 
      (*
      print_endline ("//Binding function " ^ string_of_int i ^ " --> " ^ name); 
      print_endline ("given type is " ^ string_of_typecode rt);
      print_endline ("exes are: " ^ (String.concat "\n  " (List.map (string_of_exe 1) exes)));
      *)
      let brt = bt rt in
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      let env' = build_env syms [] (Some i) in
      let brt',bbexes = bexes env' exes brt in
      (*
      print_endline ("return type is " ^ string_of_btypecode syms.dfns brt');
      *)
      let bbdcl = 
        match brt' with
        | `BTYP_void ->
          `BBDCL_procedure (bps,bbexes,name_map)
        | _ ->
          `BBDCL_function (bps,brt',bbexes,name_map)
      in
        Hashtbl.add bbdfns i (name,parent,bbdcl)

    | `SYMDEF_parameter t -> 
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `SYMDEF_lazy (e) ->
      let e',rt' = bind_expression syms env [] [] 0 [] e in
      let bbexes = [`BEXE_return (e',rt')] in
      Hashtbl.add bbdfns i 
      (name,parent,`BBDCL_function ([],rt',bbexes,Hashtbl.create 97))


    | `SYMDEF_procedure (ps,exes,name_map,dirs) -> 
      (*
      print_endline ("//Binding procedure " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      (*
      print_endline "Procedure type bound";
      flush stdout;
      *)
      let env' = build_env syms [] (Some i) in
      (*
      print_endline "Procedure environment built";
      flush stdout;
      *)
      let brt',bbexes = bexes env' exes `BTYP_void in
      (*
      print_endline "Exes bound";
      flush stdout;
      *)
      if brt' <> `BTYP_void
      then 
        failwith 
        (
          "expected void return from procedure " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,parent,`BBDCL_procedure (bps,bbexes,name_map))
      ;
      (*
      print_endline "procedure bound";
      *)

    | `SYMDEF_match_check (pat,mvindex) ->
      (*
      print_endline ("//Binding match checker " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let t = typeofindex syms [] [] 0 [] mvindex in
      let name_map = Hashtbl.create 97 in
      let arg,sr = match Hashtbl.find syms.dfns mvindex with id,sr,_,_ -> id,sr in
      let exes = 
        [
        `EXE_return (gen_match_check pat (`AST_name (sr,arg)))
        ] 
      in
      let brt',bbexes = bexes env exes bool_t in
      if brt' <> bool_t
      then 
        failwith 
        (
          "expected boolean return from match checker " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_function ([],bool_t,bbexes,name_map));
    
    | `SYMDEF_match_handler (pat,mvindex,exes,name_map,dirs) ->
      (*
      print_endline ("//Binding match handler " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let env = build_env syms [] (Some i) in 
      let mvname,sr = 
        match Hashtbl.find syms.dfns mvindex 
        with name,sr,_,_ -> name,sr
      in
      (* INSERT MATCH VARIABLE ASSIGNMENTS HERE *)
      let vars = Hashtbl.create 97 in
      Flx_mbind.get_pattern_vars vars pat [];
      (* print_endline ("PATTERN IS " ^ string_of_pattern pat ^ ", VARIABLE=" ^ mvname);
      print_endline "VARIABLES ARE";
      Hashtbl.iter (fun vname (sr,extractor) ->
        let component = 
          Flx_mbind.gen_extractor extractor (`AST_name (sr,mvname)) 
        in
        print_endline ("  " ^ vname ^ " := " ^ string_of_expression component);
      ) vars;
      *)
      (* Now, add the variables to the environment
       and initialise them 
      *)
      let exes = ref exes in
      Hashtbl.iter
      (fun vname (sr,extractor) ->
        let component = 
          Flx_mbind.gen_extractor extractor 
          (`AST_name (sr,mvname)) 
        in
        let vid = !(syms.counter) in
        incr (syms.counter);
        (* print_endline ("//adding match variable component value "^string_of_int vid^" --> " ^ vname);
        *)
        Hashtbl.add syms.dfns vid (vname, sr,Some i, 
          (*
          `SYMDEF_val (`TYP_var vid)
          *)
          `SYMDEF_val (`TYP_typeof component)
        );
        let bvtyp = typeofindex syms [] [] 0 [] vid in
        Hashtbl.add bbdfns vid (vname, Some i, 
          `BBDCL_val bvtyp 
        );
        let top_table,_ = List.hd env in
        Hashtbl.add top_table vname (NonFunctionEntry (Simple vid));
        let instr = `EXE_init (vname, component) in
        (* print_endline (string_of_exe 1 instr);
        *)
        exes := instr :: !exes;
      )
      vars;
      let brt',bbexes = bexes env !exes (`BTYP_var i) in
      if brt' = `BTYP_void
      then 
        failwith 
        (
          "expected non-void return from function " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      (*
      print_endline ("Return type is " ^ string_of_btypecode syms.dfns brt');
      *)
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_function ([],brt',bbexes,name_map))
    
    | `SYMDEF_val t -> 
      (*
      print_endline ("//Binding value " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `SYMDEF_var t ->
      (* print_endline ("//Binding variable " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_var (bt t))

    | `SYMDEF_dcl dcl -> match dcl with

    (* ugly special handling of DCLs *)

    | `DCL_type -> ()
    | `DCL_type_alias _ -> ()


    | `DCL_const (t,ct) ->
      (* print_endline ("//Binding constant " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_const (bt t,ct))

    | `DCL_abs ct ->
      (* print_endline ("//Binding abstract type " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_abs ct)

    | `DCL_header ct ->
      (* print_endline ("//Binding header string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_header ct)

    | `DCL_body ct ->
      (* print_endline ("//Binding body string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_body ct)

    | `DCL_fun (ts,ret,ct) ->
      (* print_endline ("//Binding primitive function " ^ string_of_int i ^ " --> " ^ name);  *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_fun (List.map bt ts,bt ret,ct))

    | `DCL_proc (ts,ct) ->
      (* print_endline ("//Binding primitive procedure " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_proc (List.map bt ts,ct))

    | `DCL_union cs ->
      (* print_endline ("//Binding union " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_union cs')

    | `DCL_struct cs ->
      (* print_endline ("//Binding struct " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_struct cs')

    | `DCL_val _ -> failwith "[bind_entry] Unexpected val decl"
    | `DCL_var _ -> failwith "[bind_entry] Unexpected var decl"
    | `DCL_if_fun _ -> failwith "[bind_entry] Unexpected function decl"
    | `DCL_if_proc _ -> failwith "[bind_entry] Unexpected procedure decl"
    | `DCL_interface _ -> failwith "[bind_entry] Unexpected interface"
    | `DCL_module_binding _ -> failwith "[bind_entry] Unexpected module binding"
    | `DCL_untyped_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_typed_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_function _ -> failwith "[bind_entry] Unexpected function"
    | `DCL_procedure  _ -> failwith "[bind_entry] Unexpected procedure"
    | `DCL_module _ -> failwith "[bind_entry] Unexpected module"
    | `DCL_match_handler _ -> failwith "[bind_entry] Unexpected match handler"
    | `DCL_match_check _ -> failwith "[bind_entry] Unexpected match checker"
    | `DCL_lazy _ -> failwith "[bind_entry] Unexpected lazy"
    end
    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ "> COMPLETE");
    flush stdout
    *)

(*
let bbind_index syms bbdfns i =
  if Hashtbl.mem bbdfns i then ()
  else let entry = Hashtbl.find syms.dfns i in
  bbind_sym syms bbdfns i entry
*) 

let bbind syms = 
  let bbdfns = Hashtbl.create 97 in
  Hashtbl.iter 
    (bbind_sym syms bbdfns)
    syms.dfns
  ;
  bbdfns

let bind_ifaces syms 
  (ifaces:
    (iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env syms env [] n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | `IFACE_export (sn, cpp_name), parent ->
        let env = build_env syms [] parent in
        let index = lookup_sn_in_env syms env [] sn in
        `BIFACE_export (index, cpp_name) 
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
;;

try
  let filebase = Sys.argv.(1) in
  let filename = filebase ^ ".flx" in
  print_endline ("Parsing " ^ filename);

  let parse_tree = 
    Flx_parse_ctrl.parse_file 
      filename 
      (Filename.dirname filename)
      []
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "PARSE OK";

  print_endline "----------------------------";
  print_endline "DEBLOCKED:";

  let syms = 
    { 
      counter = ref 1; 
      freg = Hashtbl.create 97;
      dfns = Hashtbl.create 97 ;
      varmap = Hashtbl.create 97;
      ticache = Hashtbl.create 97;
      env_cache = Hashtbl.create 97;
    } 
  in
  let deblocked = desugar_program "DUMMY" (syms.counter) parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "----------------------------";

  let table, exes, ifaces,dirs = 
    build_tables true syms.dfns syms.counter "<top level>" 0 None deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let bbdfns = bbind syms in
    let bifaces = bind_ifaces syms ifaces in
    print_endline "//Binding complete";
    Hashtbl.iter
    (fun index (name,parent,entry) -> print_endline
      (
        string_of_int index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns
   
with x -> flush stdout; print_endline "EXCEPTION"; 
  print_endline (Printexc.to_string x)
;;

