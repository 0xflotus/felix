@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
val bbind:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  symbol_table_t ->
  int ref ->
  instantiation_registry_t ->
  (iface_t * int option) list ->
  biface_t list 

@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref

let cal_call dfns (p,pt) e =
  match lower pt with
  | `BTYP_function (_, `BTYP_void) -> 
    `BEXE_call ((p,lower pt), e)
  | _ -> failwith ("call non procedure, type=" ^ string_of_btypecode dfns pt)

exception Found of int


let bind_exes dfns counter freg env exes ret_type = 
  (*
  print_endline ("bind_exes.. env depth="^ string_of_int (List.length env));
  print_endline "Dumping Source Executables";
  print_endline "--------------------------";
  let soe e = Flx_print.string_of_expr e in
  List.iter 
    (fun x -> print_endline (string_of_exe 1 x))
    exes
  ;
  print_endline ""
  ;

  print_endline "Binding Executables";
  print_endline "-------------------";
  *)
  let be e = bind_expression dfns counter freg env [] [] e in
  let lun sr n = lookup_name_in_env env sr n in
  let luqn n = lookup_qn_in_env dfns counter freg env [] n in
  let bt sr t = bind_type dfns counter freg env [] [] sr t in
  let dummy_sr = ("bind exes",0,0,0,0) in
  let bool_type = bt dummy_sr flx_bool in

  let bound_exes = 
    List.map
    (fun x -> 
      (*
      print_endline (string_of_exe 1 x);
      *)
       match x with
      | `EXE_comment s ->       `BEXE_comment s
      | `EXE_label s ->         `BEXE_label s
      | `EXE_goto s ->          `BEXE_goto s
      | `EXE_ifgoto (e,s) ->    
        let e',t = be e in
        if t = bool_type 
        then `BEXE_ifgoto ((e',t), s)
        else failwith "Conditional requires bool argument"
      | `EXE_ifnotgoto (e,s) -> 
        let e',t = be e in
        if t = bool_type 
        then `BEXE_ifnotgoto ((e',t), s)
        else failwith "Conditional requires bool argument"

      | `EXE_call (#suffixed_name_t as sn, e2) -> (* OVERLOADING *)
        (*
        print_endline "Handling call of suffixed name";
        flush stdout;
        *)
        let be2,t2 = be e2 in
        (*
        print_endline "Argument bound";
        flush stdout;
        *)
        let tbe1 =
           match sn with
           | #qualified_name_t as qn ->
             lookup_qn_with_sig 
             dfns counter freg 
             dummy_sr dummy_sr 
             env [] [] 
             qn t2 
           | _ -> be sn
        in  
          (*
          print_endline "Applying call now";
          flush stdout;
          *)
          cal_call dfns tbe1 (be2,t2)

      | `EXE_call (p,e) ->
        let p',pt' = be p and e',et' = be e in
        cal_call dfns (p', pt') (e', et')

      | `EXE_read s ->          
        begin match lun dummy_sr s with
        | NonFunctionEntry (Simple index) -> `BEXE_read index
        | NonFunctionEntry _ -> failwith "not expecting bound entry"
        | FunctionEntry _ -> failwith "Can't read function!"
        end

      | `EXE_return e ->        
        let e',t' = be e in
         if ret_type <> `BTYP_none && ret_type <> t'
         then
            failwith 
            (
              "Wrong return type,\nexpected : " ^ 
              string_of_btypecode dfns ret_type ^
              "\nbut we got " ^
              string_of_btypecode dfns t'
            )
         else
          `BEXE_return (e',lower t')

      | `EXE_nop s ->           `BEXE_nop s 
      | `EXE_code s ->          `BEXE_code s
      | `EXE_init (s,e) -> 
        let sr = src_of_expr e in (* HACK! *)
        begin match lun sr s with
        | FunctionEntry _ -> failwith "Can't init function constant"
        | NonFunctionEntry (Simple index) -> 
          let e',rhst = be e in
          let lhst = typeofindex dfns counter freg [] [] index in
          if lhst = rhst
          then `BEXE_init (index, (e',rhst))
          else failwith (
            "LHS["^s^"]("^string_of_btypecode dfns lhst^
            ") of initialisation must have same type as RHS("^
            string_of_btypecode dfns rhst^")"
          )
        | NonFunctionEntry _ -> failwith "Not expecting bound entry"
        end
        
    )
    exes
  in 
  (*
  print_endline ""
  ;
  List.iter 
    (fun x -> print_endline (string_of_bexe dfns 1 x)) 
    bound_exes
  ;
  print_endline ""
  ;
  print_endline "BINDING COMPLETE"
  ;
  *)
  bound_exes

let rec proper_descendant dfns parent =
  match parent with
  | Some parent -> 
    let _,_,parent,entry = Hashtbl.find dfns parent in
    begin match entry with
    | `SYMDEF_interface _ 
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _ 
      -> false
    | _ -> proper_descendant dfns parent 
    end
  | None -> true


let bbind dfns counter freg = 
  let bbdfns = Hashtbl.create 97 in
  let bexes env exes rt = bind_exes dfns counter freg env exes rt in
  let dummy_sr = ("Generated dummy",0,0,0,0) in
  Hashtbl.iter
  (fun i (name, sr,parent, bdcl) -> 
  (*
  print_endline ("binding symbol " ^ name);
  *)
  if proper_descendant dfns parent
  then begin
    (*
    print_endline "Building ENV";
    *)
    let env = build_env dfns counter freg [] parent in 
    (* print_env env; *)
    (*
    print_endline "Building ENV Complete";
    *)
    let bt t = bind_type dfns counter freg env [] [] sr t in
    (*
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ ">");
    *)
    begin match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_interface _
    | `SYMDEF_if_fun _ 
    | `SYMDEF_if_proc _
    | `SYMDEF_module _
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _
    | `SYMDEF_module_binding _
    | `SYMDEF_if_type  -> ()

    | `SYMDEF_function (ps,rt,exes,name_map,dirs) -> 
      (* 
      print_endline ("//Binding function " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let brt = bt rt in
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      let env' = build_env dfns counter freg [] (Some i) in
      let bbexes = bexes env' exes brt in
      Hashtbl.add bbdfns i 
      (name,parent,`BBDCL_function (bps,brt,bbexes,name_map))

    | `SYMDEF_parameter t -> 
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `SYMDEF_lazy (e) ->
      let e',rt' = bind_expression dfns counter freg env [] [] e in
      let bbexes = [`BEXE_return (e',rt')] in
      Hashtbl.add bbdfns i 
      (name,parent,`BBDCL_function ([],rt',bbexes,Hashtbl.create 97))


    | `SYMDEF_procedure (ps,exes,name_map,dirs) -> 
      (*
      print_endline ("//Binding procedure " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      (*
      print_endline "Procedure type bound";
      flush stdout;
      *)
      let env' = build_env dfns counter freg [] (Some i) in
      (*
      print_endline "Procedure environment built";
      flush stdout;
      *)
      let bbexes = bexes env' exes `BTYP_void in
      (*
      print_endline "Exes bound";
      flush stdout;
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_procedure (bps,bbexes,name_map))
      ;
      (*
      print_endline "procedure bound";
      *)

    | `SYMDEF_match_check (pat,mvindex) ->
      (*
      print_endline ("//Binding match checker " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let t = typeofindex dfns counter freg [] [] mvindex in
      let true_val = `AST_name (dummy_sr,"true") in
      let _,rt = bind_expression dfns counter freg env [] [] true_val in
      let name_map = Hashtbl.create 97 in
      let arg,sr = match Hashtbl.find dfns mvindex with id,sr,_,_ -> id,sr in
      let exes = 
        [
        `EXE_return (gen_match_check pat (`AST_name (sr,arg)))
        ] 
      in
      let bbexes = bexes env exes rt in
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_function ([],rt,bbexes,name_map));
    
    | `SYMDEF_match_handler (pat,mvindex,exes,name_map,dirs) ->
      (* print_endline ("//Binding match handler " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let env = build_env dfns counter freg [] (Some i) in 
      let mvname,sr = 
        match Hashtbl.find dfns mvindex 
        with name,sr,_,_ -> name,sr
      in
      (* INSERT MATCH VARIABLE ASSIGNMENTS HERE *)
      let vars = Hashtbl.create 97 in
      Flx_mbind.get_pattern_vars vars pat [];
      (* print_endline ("PATTERN IS " ^ string_of_pattern pat ^ ", VARIABLE=" ^ mvname);
      print_endline "VARIABLES ARE";
      Hashtbl.iter (fun vname (sr,extractor) ->
        let component = 
          Flx_mbind.gen_extractor extractor (`AST_name (sr,mvname)) 
        in
        print_endline ("  " ^ vname ^ " := " ^ string_of_expression component);
      ) vars;
      *)
      (* Now, add the variables to the environment
       and initialise them 
      *)
      let exes = ref exes in
      Hashtbl.iter
      (fun vname (sr,extractor) ->
        let component = 
          Flx_mbind.gen_extractor extractor 
          (`AST_name (sr,mvname)) 
        in
        let vid = !counter in
        incr counter;
        (* print_endline ("//adding match variable component value "^string_of_int vid^" --> " ^ vname);
        *)
        Hashtbl.add dfns vid (vname, sr,Some i, 
          `SYMDEF_dcl (`DCL_val_typeof component)
        );
        let bvtyp = typeofindex dfns counter freg [] [] vid in
        Hashtbl.add bbdfns vid (vname, Some i, 
          `BBDCL_val bvtyp 
        );
        let top_table,_ = List.hd env in
        Hashtbl.add top_table vname (NonFunctionEntry (Simple vid));
        let instr = `EXE_init (vname, component) in
        (* print_endline (string_of_exe 1 instr);
        *)
        exes := instr :: !exes;
      )
      vars;
      let bbexes = bexes env !exes `BTYP_void in
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_procedure ([],bbexes,name_map))
    
    | `SYMDEF_match_result _ ->
      let t = typeofindex dfns counter freg [] [] i in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val t)

    | `SYMDEF_dcl dcl -> match dcl with

    (* ugly special handling of DCLs *)

    | `DCL_type -> ()
    | `DCL_type_alias _ -> ()

    | `DCL_val t -> 
      (* print_endline ("//Binding value " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `DCL_var t ->
      (* print_endline ("//Binding variable " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_var (bt t))

    | `DCL_val_typeof e  ->
      (*
      print_endline ("//Binding value(typeof)" ^ string_of_int i ^ " --> " ^ name ^ " = " ^ string_of_expression e); 
      print_endline ("Parent is " ^ match parent with |Some i-> string_of_int i | None -> "none");
      *)
      (*
      print_endline "Now binding ..";
      *)
      let _,t = bind_expression dfns counter freg env [] [] e in
      (*
      print_endline "Binding done";
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val t)

    | `DCL_var_typeof e ->
      (* print_endline ("//Binding variable(typeof) " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let _,t = bind_expression dfns counter freg env [] [] e in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_var t)


    | `DCL_const (t,ct) ->
      (* print_endline ("//Binding constant " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_const (bt t,ct))

    | `DCL_abs ct ->
      (* print_endline ("//Binding abstract type " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_abs ct)

    | `DCL_header ct ->
      (* print_endline ("//Binding header string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_header ct)

    | `DCL_fun (ts,ret,ct) ->
      (* print_endline ("//Binding primitive function " ^ string_of_int i ^ " --> " ^ name);  *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_fun (List.map bt ts,bt ret,ct))

    | `DCL_proc (ts,ct) ->
      (* print_endline ("//Binding primitive procedure " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_proc (List.map bt ts,ct))

    | `DCL_union cs ->
      (* print_endline ("//Binding union " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_union cs')

    | `DCL_struct cs ->
      (* print_endline ("//Binding struct " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_struct cs')

    | `DCL_if_fun _ -> failwith "[bind_entry] Unexpected function decl"
    | `DCL_if_proc _ -> failwith "[bind_entry] Unexpected procedure decl"
    | `DCL_interface _ -> failwith "[bind_entry] Unexpected interface"
    | `DCL_module_binding _ -> failwith "[bind_entry] Unexpected module binding"
    | `DCL_untyped_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_typed_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_function _ -> failwith "[bind_entry] Unexpected function"
    | `DCL_procedure  _ -> failwith "[bind_entry] Unexpected procedure"
    | `DCL_module _ -> failwith "[bind_entry] Unexpected module"
    | `DCL_match_handler _ -> failwith "[bind_entry] Unexpected match handler"
    | `DCL_match_check _ -> failwith "[bind_entry] Unexpected match checker"
    | `DCL_lazy _ -> failwith "[bind_entry] Unexpected lazy"
    end
    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ "> COMPLETE");
    flush stdout
    *)
   )
  dfns
  ;
  bbdfns

let bind_ifaces dfns counter freg 
  (ifaces:
    (iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env dfns counter freg env [] n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | `IFACE_export (sn, cpp_name), parent ->
        let env = build_env dfns counter freg [] parent in
        let index = lookup_sn_in_env dfns counter freg env [] sn in
        `BIFACE_export (index, cpp_name) 
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
;;

try
  let filebase = Sys.argv.(1) in
  let filename = filebase ^ ".flx" in
  print_endline ("Parsing " ^ filename);

  let parse_tree = 
    Flx_parse_ctrl.parse_file 
      filename 
      (Filename.dirname filename)
      []
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "PARSE OK";

  print_endline "----------------------------";
  print_endline "DEBLOCKED:";

  let counter = ref 1 in
  let deblocked = desugar_program "DUMMY" counter parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "----------------------------";

  let dfns = Hashtbl.create 97 in
  let freg = Hashtbl.create 97 in
  let table, exes, ifaces,dirs = 
    build_tables true dfns counter "<top level>" 0 None deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let bbdfns = bbind dfns counter freg in
    let bifaces = bind_ifaces dfns counter freg ifaces in
    print_endline "//Binding complete";
    Hashtbl.iter
    (fun index (name,parent,entry) -> print_endline
      (
        string_of_int index ^ " --> " ^
        string_of_bbdcl dfns entry index
      )
    )
    bbdfns
   
with x -> flush stdout; print_endline "EXCEPTION"; 
  print_endline (Printexc.to_string x)
;;

