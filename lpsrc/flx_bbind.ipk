@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
val bbind:
  sym_state_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  sym_state_t ->
  (iface_t * int option) list ->
  biface_t list 

@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify
open Flx_exceptions
open Flx_bexe
open List
open Flx_generic

let rec proper_descendant dfns parent =
  match parent with
  | Some parent -> 
    let _,_,parent,vs,_,_,entry = Hashtbl.find dfns parent in
    begin match entry with
    | `SYMDEF_interface  
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _ 
      -> false
    | _ -> proper_descendant dfns parent 
    end
  | None -> true

let find_param name_map s =
  match Hashtbl.find name_map s with
  | NonFunctionEntry (Simple i) -> i
  | _ -> failwith ("[find_param] Can't find parameter " ^ s )

let print_vs vs =
  if length vs = 0 then "" else
  "[" ^ catmap "," (fun (s,i) -> s ^ "<"^si i^">") vs^ "]"

let bbind_sym syms bbdfns i (name,sr,parent,vs,name_map,dirs,bdcl) =
  let bexes env exes rt i tvars = bind_exes syms env sr exes rt name i tvars in
  (*
  print_endline ("Parent is " ^ (match parent with | None -> "none" | Some i -> si i));
  *) 
  if proper_descendant syms.dfns parent
  then begin
    (* let env = build_env syms [] parent in  *)
    let env = build_env syms [] (Some i) in 
    let vs = find_vs syms i in
    let bt t = bind_type syms env [] sr t in
    match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_interface
    | `SYMDEF_if_fun _ 
    | `SYMDEF_module
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _
    | `SYMDEF_module_binding _
    | `SYMDEF_typevar _
    | `SYMDEF_if_type  -> ()

    | `SYMDEF_function (ps,rt,exes) -> 
      let bps : (string * (int * btypecode_t)) list = 
        List.map (fun (s,t) -> 
        let i = find_param name_map s in
        s,(i,bt t)) 
      ps 
      in
      let ts = map (fun (s,(i,t)) -> t) bps in
      let env' = build_env syms [] (Some i) in
      let brt = bt rt in
      let brt',bbexes = bexes env' exes brt i vs in
      let bbdcl = 
        match brt' with
        | `BTYP_void ->
          `BBDCL_procedure (vs,bps,bbexes,name_map)
        | _ ->
          `BBDCL_function (vs,bps,brt',bbexes,name_map)
      in
        Hashtbl.add bbdfns i (name,parent,bbdcl);
        begin
          if not (Hashtbl.mem syms.ticache i) then
          let t = fold (`BTYP_function (typeoflist ts,brt')) in
          Hashtbl.add syms.ticache i t
        end
        ;
        let atyp = typeoflist (map (fun (s,(i,t)) -> t) bps) in
        if syms.compiler_options.print_flag then
        print_endline 
        (
          "//bound function " ^ name ^ "<"^si i^">" ^
           print_vs vs ^":" ^
           sbt syms.dfns (`BTYP_function (atyp,brt'))
        )

    | `SYMDEF_parameter (t) -> 
      begin match parent with 
      | None -> failwith "[bbind_sym] expected parameter to have a parent" 
      | Some ip ->
        let id2,sr,parent2,_,_,_,entry2 = Hashtbl.find syms.dfns ip in
        match entry2 with
        | `SYMDEF_function _
        | `SYMDEF_typed_functor _
        | `SYMDEF_untyped_functor _ ->
          let t = typeofindex syms [] i in
          Hashtbl.add bbdfns i (name,parent,`BBDCL_val (vs,t));
          Hashtbl.add syms.varmap i t;

          if syms.compiler_options.print_flag then
          print_endline ("//bound val " ^ name ^ "<"^si i^">" ^
          print_vs vs ^ ":" ^
          sbt syms.dfns t)

        | _ -> failwith "[bbind_sym] expected parameter to have function or functor parent"
      end

    | `SYMDEF_match_check (pat,mvindex) ->
      let t = typeofindex syms [] mvindex in
      let name_map = Hashtbl.create 97 in
      let arg,sr = match Hashtbl.find syms.dfns mvindex with id,sr,_,_,_,_,_ -> id,sr in
      let exes = 
        [
        sr,`EXE_fun_return (gen_match_check pat (`AST_name (sr,arg,[])))
        ] 
      in
      let brt',bbexes = bexes env exes flx_bbool i [] in
      if brt' <> flx_bbool
      then 
        failwith 
        (
          "expected boolean return from match checker " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_function (vs,[],flx_bbool,bbexes,name_map)
      );
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold (`BTYP_function (`BTYP_tuple[],flx_bbool)) in
        Hashtbl.add syms.ticache i t
      end
      ;

      if syms.compiler_options.print_flag then
      print_endline ("//bound match check " ^ name ^ "<"^si i^">" ^
      print_vs vs ^ ":" ^
        sbt syms.dfns (`BTYP_function (`BTYP_tuple[],flx_bbool))
      )
    
    | `SYMDEF_val (t) -> 
      let t = typeofindex syms [] i in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (vs,t));

      if syms.compiler_options.print_flag then
      print_endline ("//bound val " ^ name ^ "<"^si i^">" ^
      print_vs vs ^ ":" ^
      sbt syms.dfns t)

    | `SYMDEF_var (t) ->
      (*
      print_endline ("Binding variable " ^ name ^"<"^ si i ^">");
      *)
      let t = typeofindex syms [] i in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_var (vs,t))
      ;
      if syms.compiler_options.print_flag then
      print_endline ("//bound var " ^ name ^ "<"^si i^">" ^
      print_vs vs ^ ":" ^
      sbt syms.dfns t)
    
    | `SYMDEF_const (t,ct) ->
      let t = typeofindex syms [] i in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_const (vs,t,ct));
      if syms.compiler_options.print_flag then
      print_endline ("//bound const " ^ name ^ "<"^si i^">:" ^
      sbt syms.dfns t)


    | `SYMDEF_fun (ts,ret,ct) ->
      let ts = map bt ts in
      let bret = bt ret in
      let bbdcl = match bret with
        | `BTYP_void ->
          `BBDCL_proc (vs, ts,ct)
        | _ ->
          `BBDCL_fun (vs, ts,bret,ct)
      in
      Hashtbl.add bbdfns i (name,parent,bbdcl);
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold (`BTYP_function (typeoflist ts,bret)) in
        Hashtbl.add syms.ticache i t
      end
      ;
      let atyp = typeoflist ts in
      if syms.compiler_options.print_flag then
      print_endline ("//bound fun " ^ name ^ "<"^si i^">"^
      print_vs vs ^ ":" ^
      sbt syms.dfns (`BTYP_function (atyp,bret)))


    | `SYMDEF_union (cs) ->
      (* print_endline ("//Binding union " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_union (vs,cs'))

    | `SYMDEF_struct (cs) ->
      (* print_endline ("//Binding struct " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_struct (vs,cs'))


    | `SYMDEF_regdef _ -> ()
    | `SYMDEF_type_alias _ -> ()

    | `SYMDEF_abs ct->
      (*
      print_endline ("//Binding abstract type " ^ si i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_abs (vs,ct))

    | `SYMDEF_header ct ->
      (* print_endline ("//Binding header string " ^ si i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_header ct)

    | `SYMDEF_body ct ->
      (* print_endline ("//Binding body string " ^ si i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_body ct)

    (*
    | x -> 
      failwith
      (
      "[bind_entry] Unexpected entry " ^ string_of_symdef x name vs 
      )
    *) 
    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ si i ^ "> COMPLETE");
    flush stdout
    *)

let bbind_index syms bbdfns i =
  if Hashtbl.mem bbdfns i then ()
  else let entry = Hashtbl.find syms.dfns i in
  bbind_sym syms bbdfns i entry

let bbind syms = 
  let bbdfns = Hashtbl.create 97 in
  (* loop through all counter values [HACK]
    to get the indices in sequence, AND,
    to ensure any instantiations will be bound,
    (since they're always using the current value
    of syms.counter for an index
  *)
  let i = ref 0 in
  while !i < !(syms.counter) do
    begin 
      try 
        let entry = Hashtbl.find syms.dfns !i in
        bbind_sym syms bbdfns !i entry
      with Not_found -> ()
    end
    ;
    incr i
  done
  ;
  bbdfns

let bind_ifaces syms 
  (ifaces:
    (iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env syms env [] n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | `IFACE_export (sn, cpp_name), parent ->
        let env = build_env syms [] parent in
        let index,ts = lookup_sn_in_env syms env [] sn in
        if length ts = 0 then
          `BIFACE_export (index, cpp_name) 
        else clierr dummy_sr 
        (
          "Can't export generic entity " ^
          string_of_suffixed_name sn
        )
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_flxopt
open Flx_exceptions
open Flx_use
;;

let print_help () = print_options(); exit(0)
;;
let reverse_return_parity = ref false
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    raise (Exit 0)
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity :=  compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  (* IF THERE WAS NO INTERFACE FILE, GENERATE ONE *)
  if not have_interface 
  then begin
    print_endline "//No interface file found: generating one";
    let h = open_out iface_file_name in
    let iface = build_interface parse_tree in
    List.iter 
    (
      fun x->
        output_string h
        (
          (string_of_statement 0 x)^"\n"
        )
    ) 
    iface;
    close_out h
  end
  ;
  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in
  let deblocked = desugar_program syms module_name parse_tree in

  let root = !(syms.counter) in
  let table, exes, ifaces,dirs = 
    build_tables syms "<top level>" 0 None None root deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let bbdfns = bbind syms in
    let bifaces = bind_ifaces syms ifaces in
    print_endline "//Binding complete";

    let root_proc = 
      let id,sr,parent,vs,name_map,_,entry = 
        try Hashtbl.find syms.dfns root 
        with Not_found ->
          failwith 
          (
            "Can't find root module " ^ si root ^
            " in symbol table?"
          )
      in
      begin match entry with
        | `SYMDEF_module -> ()
        | _ -> failwith "Expected to find top level module ''"
      end
      ;
      let entry = 
        try Hashtbl.find name_map "_init_" 
        with Not_found ->
          failwith "Can't find name _init_ in top level module's name map"
      in
      let index = match entry with
        | FunctionEntry [Simple x] -> x
        | FunctionEntry [] -> failwith "Couldn't find '_init_'"
        | FunctionEntry _ -> failwith "Too many top level procedures called '_init_'"
        | NonFunctionEntry _ -> failwith "_init_ found but not procedure"
      in 
      if compiler_options.print_flag 
      then print_endline ("//root module's init procedure has index " ^ si index);
      index
    in

    Hashtbl.iter
    (fun index (name,parent,entry) -> print_endline
      (
        si index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns
    ;
    print_endline "//OPTIMISING";
    print_endline "//----------";
    let bbdfns = elide_unused syms bbdfns root_proc bifaces in
    Hashtbl.iter
    (fun index (name,parent,entry) -> print_endline
      (
        si index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns

   
with x -> Flx_terminate.terminate !reverse_return_parity x
;;

