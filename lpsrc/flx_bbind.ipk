@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
open Flx_ast
open Flx_mtypes1


val bbind:
  sym_state_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  sym_state_t ->
  (range_srcref * iface_t * int option) list ->
  biface_t list 

val cal_children:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (bid_t, bid_t list) Hashtbl.t


@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_ast
open Flx_mtypes1
open Flx_print
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify
open Flx_exceptions
open Flx_bexe
open List
open Flx_generic

let find_param name_map s =
  match Hashtbl.find name_map s with
  | NonFunctionEntry (i) -> i
  | _ -> failwith ("[find_param] Can't find parameter " ^ s )

let print_vs vs =
  if length vs = 0 then "" else
  "[" ^ catmap "," (fun (s,i) -> s ^ "<"^si i^">") vs^ "]"

let rec find_true_parent dfns child parent = 
  match parent with 
  | None -> None
  | Some parent ->
    match Hashtbl.find dfns parent with
    | {id=id; parent=grandparent; symdef=bdcl} ->
      match bdcl with 
      | `SYMDEF_module -> find_true_parent dfns id grandparent
      | `SYMDEF_function _ -> Some parent
      | _ -> None
    
let bind_req syms env sr tag =
  lookup_code_in_env syms env sr tag


let bind_reqs syms env sr reqs : bid_t list =
  let add lst i = if mem i lst then lst else i :: lst in
  fold_left 
  (fun lst tag ->
    let entries = bind_req syms env sr tag in
    fold_left (fun lst (x) -> add lst x) lst entries
  ) 
  [] 
  reqs
  
let bbind_sym syms bbdfns i {id=name;sr=sr;parent=parent;vs=vs;privmap=name_map;dirs=dirs;symdef=bdcl} =
  let qname = qualified_name_of_index syms.dfns i in
  let true_parent = find_true_parent syms.dfns name parent in
  let bexes env exes rt i tvars = bind_exes syms env sr exes rt name i tvars in
  (*
  print_endline ("Parent is " ^ (match parent with | None -> "none" | Some i -> si i));
  *) 
  begin
    (* let env = build_env syms parent in  *)
    let env = build_env syms (Some i) in 
    let bind_reqs reqs = bind_reqs syms env sr reqs in
    let vs = find_vs syms i in
    let bt t = bind_type syms env sr t in
    match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_module
    | `SYMDEF_typevar _
      -> ()

    | `SYMDEF_function (ps,rt,props,exes) -> 
      let bps : (string * (int * btypecode_t)) list = 
        List.map (fun (s,t) -> 
        let i = find_param name_map s in
        s,(i,bt t)) 
      ps 
      in
      let ts = map (fun (s,(i,t)) -> t) bps in
      let env' = build_env syms (Some i) in
      let brt = bt rt in
      let brt',bbexes = bexes env' exes brt i vs in
      let bbdcl = 
        match brt' with
        | `BTYP_void ->
          `BBDCL_procedure (props,vs,bps,bbexes)
        | _ ->
          `BBDCL_function (props,vs,bps,brt',bbexes)
      in
        Hashtbl.add bbdfns i (name,true_parent,sr,bbdcl);
        begin
          if not (Hashtbl.mem syms.ticache i) then
          let t = fold (`BTYP_function (typeoflist ts,brt')) in
          Hashtbl.add syms.ticache i t
        end
        ;
        let atyp = typeoflist (map (fun (s,(i,t)) -> t) bps) in
        if syms.compiler_options.print_flag then
        print_endline 
        (
          "//bound function " ^ qname ^ "<"^si i^">" ^
           print_vs vs ^":" ^
           sbt syms.dfns (`BTYP_function (atyp,brt'))
        )

    | `SYMDEF_parameter (t) -> 
      begin match parent with 
      | None -> failwith "[bbind_sym] expected parameter to have a parent" 
      | Some ip ->
        match Hashtbl.find syms.dfns ip with
        | {symdef=`SYMDEF_function _} ->
          let t = typeofindex syms i in
          Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_val (vs,t));
          Hashtbl.add syms.varmap i t;

          if syms.compiler_options.print_flag then
          print_endline ("//bound val " ^ name ^ "<"^si i^">" ^
          print_vs vs ^ ":" ^
          sbt syms.dfns t)

        | _ -> failwith "[bbind_sym] expected parameter to have function or functor parent"
      end

    | `SYMDEF_match_check (pat,mvindex) ->
      let t = typeofindex syms mvindex in
      let name_map = Hashtbl.create 97 in
      let arg,sr = 
        match Hashtbl.find syms.dfns mvindex with 
        {id=id;sr=sr}->id,sr
      in
      let exes = 
        [
        sr,`EXE_fun_return (gen_match_check pat (`AST_name (sr,arg,[])))
        ] 
      in
      let brt',bbexes = bexes env exes flx_bbool i [] in
      if brt' <> flx_bbool
      then 
        failwith 
        (
          "expected boolean return from match checker " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,true_parent,sr,
        `BBDCL_function ([`Inline],vs,[],flx_bbool,bbexes)
      );
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold (`BTYP_function (`BTYP_tuple[],flx_bbool)) in
        Hashtbl.add syms.ticache i t
      end
      ;

      if syms.compiler_options.print_flag then
      print_endline ("//bound match check " ^ name ^ "<"^si i^">" ^
      print_vs vs ^ ":" ^
        sbt syms.dfns (`BTYP_function (`BTYP_tuple[],flx_bbool))
      )
    
    | `SYMDEF_val (t) -> 
      let t = typeofindex syms i in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_val (vs,t));

      if syms.compiler_options.print_flag then
      print_endline ("//bound val " ^ name ^ "<"^si i^">" ^
      print_vs vs ^ ":" ^
      sbt syms.dfns t)

    | `SYMDEF_var (t) ->
      (*
      print_endline ("Binding variable " ^ name ^"<"^ si i ^">");
      *)
      let t = typeofindex syms i in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_var (vs,t))
      ;
      if syms.compiler_options.print_flag then
      print_endline ("//bound var " ^ name ^ "<"^si i^">" ^
      print_vs vs ^ ":" ^
      sbt syms.dfns t)
    
    | `SYMDEF_const (t,ct,reqs) ->
      let t = typeofindex syms i in
      let reqs = bind_reqs reqs in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_const (vs,t,ct,reqs));
      if syms.compiler_options.print_flag then
      print_endline ("//bound const " ^ name ^ "<"^si i^">:" ^
      sbt syms.dfns t)


    | `SYMDEF_fun (ts,ret,ct,reqs) ->
      let ts = map bt ts in
      let bret = bt ret in
      let reqs = bind_reqs reqs in
      let bbdcl = match bret with
        | `BTYP_void ->
          `BBDCL_proc (vs, ts,ct,reqs)
        | _ ->
          `BBDCL_fun (vs, ts,bret,ct,reqs)
      in
      Hashtbl.add bbdfns i (name,None,sr,bbdcl);
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold (`BTYP_function (typeoflist ts,bret)) in
        Hashtbl.add syms.ticache i t
      end
      ;
      let atyp = typeoflist ts in
      if syms.compiler_options.print_flag then
      print_endline ("//bound fun " ^ name ^ "<"^si i^">"^
      print_vs vs ^ ":" ^
      sbt syms.dfns (`BTYP_function (atyp,bret)))


    | `SYMDEF_union (cs) ->
      (* print_endline ("//Binding union " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_union (vs,cs'))

    | `SYMDEF_struct (cs) ->
      (* print_endline ("//Binding struct " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_struct (vs,cs'))

    | `SYMDEF_cstruct (cs) ->
      (* print_endline ("//Binding cstruct " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_cstruct (vs,cs'))


    | `SYMDEF_regdef _ -> ()
    | `SYMDEF_type_alias _ -> ()
    | `SYMDEF_inherit _ -> ()
    | `SYMDEF_inherit_fun _ -> ()

    | `SYMDEF_abs (complete,ct,reqs)->
      (*
      print_endline ("//Binding abstract type " ^ si i ^ " --> " ^ name); 
      *)
      let reqs = bind_reqs reqs in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_abs (vs,complete,ct,reqs))

    | `SYMDEF_header (ct,reqs) ->
      (* print_endline ("//Binding header string " ^ si i ^ " --> " ^ name); 
      *)
      let reqs = bind_reqs reqs in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_header (ct,reqs))

    | `SYMDEF_body (ct,reqs) ->
      (* print_endline ("//Binding body string " ^ si i ^ " --> " ^ name); 
      *)
      let reqs = bind_reqs reqs in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_body (ct,reqs))

    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ si i ^ "> COMPLETE");
    flush stdout
    *)

let bbind_index syms bbdfns i =
  if Hashtbl.mem bbdfns i then ()
  else let entry = Hashtbl.find syms.dfns i in
  bbind_sym syms bbdfns i entry

let cal_children syms bbdfns =
  let child_map = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i (id,parent,sr,entry) ->
    match parent with
    | Some parent ->
      Hashtbl.replace child_map parent
      (i ::
        (
          try Hashtbl.find child_map parent
          with Not_found -> []
        )
      )
    | None -> ()
  )
  bbdfns
  ;
  child_map

let bbind syms = 
  let bbdfns = Hashtbl.create 97 in
  (* loop through all counter values [HACK]
    to get the indices in sequence, AND,
    to ensure any instantiations will be bound,
    (since they're always using the current value
    of syms.counter for an index
  *)
  let i = ref 0 in
  while !i < !(syms.counter) do
    begin 
      try 
        let entry = Hashtbl.find syms.dfns !i in
        bbind_sym syms bbdfns !i entry
      with Not_found -> ()
    end
    ;
    incr i
  done
  ;
  bbdfns

let bind_ifaces syms 
  (ifaces:
    (range_srcref * iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env syms env n in
  let bound_ifaces = 
    List.map
    (function 
      | sr,`IFACE_export_fun (sn, cpp_name), parent ->
        let env = build_env syms parent in
        let index,ts = lookup_sn_in_env syms env sn in
        if length ts = 0 then
          `BIFACE_export_fun (sr,index, cpp_name) 
        else clierr sr 
        (
          "Can't export generic entity " ^
          string_of_suffixed_name sn
        )
      
      | sr,`IFACE_export_type (typ, cpp_name), parent ->
        let env = build_env syms parent in
        let t = bind_type syms env dummy_sr typ in
        if var_occurs t then
        clierr sr 
        (
          "Can't export generic type " ^
          string_of_btypecode syms.dfns t
        )
        else
          `BIFACE_export_type (sr, t, cpp_name) 
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_flxopt
open Flx_exceptions
open Flx_mtypes1
open Flx_use
;;

let print_help () = print_options(); exit(0)
;;
let reverse_return_parity = ref false
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    raise (Exit 0)
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity :=  compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in
  let deblocked = desugar_program syms module_name parse_tree in

  let root = !(syms.counter) in
  let table, _, exes, ifaces,dirs = 
    build_tables syms "<top level>" 0 None None root deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let bbdfns = bbind syms in
    let child_map = cal_children syms bbdfns in
    let bifaces = bind_ifaces syms ifaces in
    print_endline "//Binding complete";

    let root_proc = 
      match 
        try Hashtbl.find syms.dfns root 
        with Not_found ->
          failwith 
          (
            "Can't find root module " ^ si root ^
            " in symbol table?"
          )
      with {id=id; sr=sr; parent=parent;vs=vs;pubmap=name_map;symdef=entry} ->
      begin match entry with
        | `SYMDEF_module -> ()
        | _ -> failwith "Expected to find top level module ''"
      end
      ;
      let entry = 
        try Hashtbl.find name_map "_init_" 
        with Not_found ->
          failwith "Can't find name _init_ in top level module's name map"
      in
      let index = match entry with
        | FunctionEntry [x] -> x
        | FunctionEntry [] -> failwith "Couldn't find '_init_'"
        | FunctionEntry _ -> failwith "Too many top level procedures called '_init_'"
        | NonFunctionEntry _ -> failwith "_init_ found but not procedure"
      in 
      if compiler_options.print_flag 
      then print_endline ("//root module's init procedure has index " ^ si index);
      index
    in

    Hashtbl.iter
    (fun index (name,parent,sr,entry) -> print_endline
      (
        si index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns
    ;
    print_endline "//OPTIMISING -- pass 1";
    print_endline "//---------------------";
    let () = Flx_use.find_roots syms bbdfns root_proc bifaces in
    let bbdfns = Flx_useless.elide_unused syms (child_map,bbdfns) in
    let child_map = cal_children syms bbdfns in
    Hashtbl.iter
    (fun index (name,parent,sr,entry) -> print_endline
      (
        si index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns
    ;
    print_endline "//OPTIMISING -- pass 2";
    print_endline "//---------------------";
    let bbdfns = Flx_useless.elide_unused syms (child_map,bbdfns) in
    Hashtbl.iter
    (fun index (name,parent,sr,entry) -> print_endline
      (
        si index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns

   
with x -> Flx_terminate.terminate !reverse_return_parity x
;;

