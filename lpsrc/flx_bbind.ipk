@head(1,"Name Binding")

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
val bbind:
  sym_state_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  sym_state_t ->
  (iface_t * int option) list ->
  biface_t list 

@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref

let cal_call dfns (p,pt) e =
  match lower pt with
  | `BTYP_function (_, `BTYP_void) -> 
    `BEXE_call ((p,lower pt), e)
  | _ -> failwith ("call non procedure, type=" ^ string_of_btypecode dfns pt)

exception Found of int

let bool_t = `BTYP_sum [`BTYP_tuple[]; `BTYP_tuple []]

(* This function takes some unbound executables and a 
   bound return type, and if everything works,
   returns a bound return type and bound executable code.

   The type `BTYP_none can be used if the return type
   is unknown. Here are the rules:

   1) If a return type other than void is specified,
   there must be at least one return statement,
   and the type of every return must match the specified type.

   2) if void is specified, there must not be any return statements.

   3) if none is specified, there must be at least one
   return statement, and the type of every return statement
   must agree, this type is returned.
  

   THIS ROUTINE IS SOMEWHAT BRAIN DEAD--
   IT DOESN'T UNDERSTAND GOTOS.

   WE SHOULD:
     (a) check for unreachable code
     (b) check for tail recursion
     (c) check functions can't drop off the end:
         they must end in 
         1. an unconditional goto, 
         2. a return
         3. a call to a non-returning procedure or function 

  This latter case is nasty because we can't tell
  if a procedure returns or not... this must be fixed.
  NOTE: a procedure may be either non-terminating (infinite loop)
  or it may terminate with an abnormal exit (non-local goto)

*)

let bind_exes sym_state env id sr index exes in_ret = 
  (*
  print_endline ("Binding exes of " ^ id ^ "<"^string_of_int index^">");
  print_endline ("bind_exes.. env depth="^ string_of_int (List.length env));
  print_endline "Dumping Source Executables";
  print_endline "--------------------------";
  let soe e = Flx_print.string_of_expr e in
  List.iter 
    (fun x -> print_endline (string_of_exe 1 x))
    exes
  ;
  print_endline ""
  ;

  print_endline "Binding Executables";
  print_endline "-------------------";
  *)

  (* initialise calculated return type to void, since
     we haven't seen any return statements yet
  *)
  let cal_ret = ref `BTYP_none in
  let be e = bind_expression sym_state env [] [] e in
  let lun sr n = lookup_name_in_env env sr n in
  let luqn n = lookup_qn_in_env sym_state env [] n in
  let bt sr t = bind_type sym_state env [] sr t in

  (* this routine isn't really recursive, just a hack
     to make EXE_set easier to code ..
  *)
  let reachable = ref true in
  let return_count = ref 0 in
  let rec bind_exe (x:exe_t) = 
    (*
    print_endline (string_of_exe 1 x);
    *)

    match x with
    | `EXE_comment s ->       `BEXE_comment s
    | `EXE_label s ->         reachable := true; `BEXE_label s
    | `EXE_nop s ->           `BEXE_nop s
    | _ when not !reachable -> 
       print_endline "UNREACHABLE CODE .. IGNORED";
       `BEXE_nop "Unreachable"

    | `EXE_goto s ->          reachable := false; `BEXE_goto s
    | `EXE_ifgoto (e,s) ->    
      let e',t = be e in
      if t = bool_t
      then `BEXE_ifgoto ((e',t), s)
      else 
        failwith 
        (
          "[bind_exes:ifgoto] Conditional requires bool argument, got " ^
          string_of_btypecode sym_state.dfns t
        )

    | `EXE_ifnotgoto (e,s) -> 
      let e',t = be e in
      if t = bool_t
      then `BEXE_ifnotgoto ((e',t), s)
      else 
        failwith 
        (
          "[bind_exes:ifnotgoto] Conditional requires bool argument, got " ^
          string_of_btypecode sym_state.dfns t
        )

    | `EXE_call (#suffixed_name_t as sn, e2) -> (* OVERLOADING *)
      (*
      print_endline "Handling call of suffixed name";
      flush stdout;
      *)
      let sr = src_of_expr sn in
      let be2,t2 = be e2 in
      (*
      print_endline "Argument bound";
      flush stdout;
      *)
      let tbe1 =
         match sn with
         | #qualified_name_t as qn ->
           lookup_qn_with_sig sym_state
           sr sr 
           env [] [] 
           qn t2 
         | _ -> be sn
      in  
        (*
        print_endline "Applying call now";
        flush stdout;
        *)
        cal_call sym_state.dfns tbe1 (be2,t2)

    | `EXE_call (p,e) ->
      let p',pt' = be p and e',et' = be e in
      cal_call sym_state.dfns (p', pt') (e', et')

    | `EXE_read s ->          
      begin match lun sr s with
      | NonFunctionEntry (Simple index) -> `BEXE_read index
      | NonFunctionEntry _ -> failwith "not expecting bound entry"
      | FunctionEntry _ -> failwith "Can't read function!"
      end

    | `EXE_return e ->        
      reachable := false;
      incr return_count;
      if in_ret = `BTYP_void then 
        failwith 
        (
          "Procedure "^id^" has value return, in:\n" ^
          short_string_of_src sr
        )
      else 
      let e',t' = be e in
        if in_ret <> `BTYP_none then 
          begin 
            if not (type_eq in_ret t') then
              failwith 
              (
                "In " ^ short_string_of_src sr ^ "\n" ^
                "Function "^id^" has wrong return type,\nexpected : " ^ 
                string_of_btypecode sym_state.dfns in_ret ^
                "\nbut we got " ^
                string_of_btypecode sym_state.dfns t'
              )
          end 
        else 
          begin
            if !cal_ret <> `BTYP_none then 
              if not (type_eq !cal_ret t') then 
                failwith 
                (
                  "In " ^ short_string_of_src sr ^ "\n" ^
                  "Function "^id^" has inconsistent return type,\nexpected : " ^ 
                  string_of_btypecode sym_state.dfns !cal_ret ^
                  "\nbut we got " ^
                  string_of_btypecode sym_state.dfns t'
                )
          end
      ;
      if !cal_ret = `BTYP_none then cal_ret := t'
      ; 
      begin match e' with
      | `BEXPR_apply ((`BEXPR_closure index',_) ,a) when index = index' ->
         print_endline "POSSIBLE TAIL RECURSION ..[closure]" 
      | _ -> ()
      end
      ;
      `BEXE_return (e',lower t')

    | `EXE_code s ->          `BEXE_code s

    | `EXE_init (s,e) -> 
      let sr = src_of_expr e in (* HACK! *)
      begin match lun sr s with
      | FunctionEntry _ -> failwith "Can't init function constant"
      | NonFunctionEntry (Simple index) -> 
        let e',rhst = be e in
        let lhst = typeofindex sym_state [] [] index in

        (* EQUI RECURSIVE COMPARISON NOW .. *)
        if type_eq lhst rhst
        then `BEXE_init (index, (e',rhst))
        else failwith (
          "LHS["^s^"]("^string_of_btypecode sym_state.dfns lhst^
          ") of initialisation must have same type as RHS("^
          string_of_btypecode sym_state.dfns rhst^")"
        )
      | NonFunctionEntry _ -> failwith "Not expecting bound entry"
      end
      
    | `EXE_set (s,e) -> 
       begin try
         let sr = rsexpr s e in
         let set_name = `AST_name (sr,"set") in
         let set_arg = `AST_tuple (sr,[s;e]) in
         bind_exe (`EXE_call (set_name, set_arg))
       with _ ->
         print_endline "WARNING: can't find set method, using C++ assignment";
         `BEXE_set (be s, be e)
       end

  in
  let bound_exes = 
    list_omap bind_exe exes
  in 
  (*
  print_endline ""
  ;
  List.iter 
    (fun x -> print_endline (string_of_bexe sym_state.dfns 1 x)) 
    bound_exes
  ;
  print_endline ""
  ;
  print_endline "BINDING COMPLETE"
  ;
  *)

  (* if we reach the end, its a procedure *)
  if !reachable && !return_count = 0
  then begin 
    if !cal_ret = `BTYP_none
    then cal_ret := `BTYP_void
    else assert false
  end
  ;

  (* if there is a specified non-void return type, 
     there should be
     at least one return statement
  *)
  if in_ret <> `BTYP_void && in_ret <> `BTYP_none && !return_count = 0
  then
    failwith 
    (
      "in " ^ short_string_of_src sr ^ "\n" ^
      "Function "^id^" doesn't return a value"
    )
  ;

  (* if its a procedure, the end must be reachable *)
  if in_ret = `BTYP_void && not !reachable
  then
    failwith 
    (
      "in " ^ short_string_of_src sr ^ "\n" ^
      "Procedure "^id^" can't reach end\n" ^
      "WORKAROUND: if this is meant to be an infinite loop\n" ^
      "put a dummy label at the end of the procedure"
    )
  ;

  (* if its a function, the end must not be reachable *)
  if in_ret <> `BTYP_void && in_ret <> `BTYP_none
  || !return_count <> 0
  then if !reachable then
    failwith
    (
      "in " ^ short_string_of_src sr ^ "\n" ^
      "Function "^id^" may reach end\n" ^
      "WORKAROUND: if the function finished by \n" ^
      "calling a non-returning procedure\n" ^
      "(such as an error handler)\n"^
      "put a dummy infinite loop at the end like:\n" ^
      "label:> goto label;"
    )
  ;

  (* return with specified return type, if it exists,
     otherwise the calculated one, if it exists
     otherwise report an error
  *)
  if in_ret <> `BTYP_none then
    in_ret,bound_exes
  else if !cal_ret <> `BTYP_none then 
    !cal_ret,bound_exes
  else 
    failwith
    (
      "in " ^ short_string_of_src sr ^ "\n" ^
      "Can't calculate return type of "^id ^"\n" ^
      "WORKAROUND: please specify one explicitly!"
    )


let rec proper_descendant dfns parent =
  match parent with
  | Some parent -> 
    let _,_,parent,entry = Hashtbl.find dfns parent in
    begin match entry with
    | `SYMDEF_interface _ 
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _ 
      -> false
    | _ -> proper_descendant dfns parent 
    end
  | None -> true

let check_type_asserts sym_state env dirs =
  let bt sr t = bind_type sym_state env [] sr t in
  let ctas (e:expr_t) = 
    print_endline ("Type assert " ^ string_of_expr e);
    match e with
    | `AST_apply (sr,(predicate, argument)) ->
       begin match predicate with
       | `AST_name (sr,("eq")) ->
         begin match argument with
         | `AST_tuple (sr,[t1; t2]) ->
            let t1' = bt sr (typecode_of_expr t1)
            and t2' = bt sr (typecode_of_expr t2)
            in if not (type_eq t1' t2')
            then failwith
            (
              "Type assertion failed"
            )
         | _ -> 
           failwith 
           (
             "Type equality expects 2 arguments"
           )
         end
       | _ -> 
         failwith 
         (
           "Can't handle type assertion other than equality yet" 
         )
       end
    | _ -> failwith "Type assertion must be application"
  in
  let ctax e = print_endline ("Type axiom " ^ string_of_expr e) in
  List.iter (function 
    | DIR_typeassert e -> ctas e 
    | DIR_typeaxiom e -> ctax e
    | _ -> ()
  )
  dirs

let bbind sym_state =
  let bbdfns = Hashtbl.create 97 in
  let bexes env id sr exes rt = bind_exes sym_state env id sr exes rt in
  let dummy_sr = ("Generated dummy",0,0,0,0) in
  let cta env dirs = check_type_asserts sym_state env dirs in
  let get_env parent = build_env sym_state [] parent in
  Hashtbl.iter
  (fun i (name, sr,parent, bdcl) -> 
    (*
    print_endline ("binding " ^ name ^ "<" ^ string_of_int i ^ ">");
    *)
  if proper_descendant sym_state.dfns parent
  then begin
    let env = get_env parent in
    let bt t = bind_type sym_state env [] sr t in
    begin match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_interface _
    | `SYMDEF_if_fun _ 
    | `SYMDEF_if_proc _
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _
    | `SYMDEF_module_binding _
    | `SYMDEF_if_type  -> ()

    | `SYMDEF_module (nmap,dirs) ->
       let env = get_env (Some i) in
       cta env dirs

    | `SYMDEF_function (ps,rt,exes,name_map,dirs) -> 
      (* print_endline ("//Binding function " ^ string_of_int i ^ " --> " ^ name);  *)
      (* this is here, so we can fail on an attempt to bind
         `TYP_none .. `BTYP_none should always be constructed
         manually when needed, since `BTYP_none isn't a type
      *)
      let brt = 
        match rt with 
        | `TYP_none -> `BTYP_none 
        | t -> bt t 
      in
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      let env' = get_env (Some i) in
      let cal_ret,bbexes = bexes env' name sr i exes brt in
      let bbdcl = 
        if cal_ret = `BTYP_void then 
          `BBDCL_procedure (bps,bbexes,name_map)
         else
          `BBDCL_function (bps,cal_ret,bbexes,name_map)
      in 
      Hashtbl.add bbdfns i (name,parent,bbdcl);
      cta env' dirs

    | `SYMDEF_parameter t -> 
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `SYMDEF_lazy (e) ->
      let e',rt' = bind_expression sym_state env [] [] e in
      let bbexes = [`BEXE_return (e',rt')] in
      Hashtbl.add bbdfns i 
      (name,parent,`BBDCL_function ([],rt',bbexes,Hashtbl.create 97))


    | `SYMDEF_procedure (ps,exes,name_map,dirs) -> 
      (*
      print_endline ("//Binding procedure " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      (*
      print_endline "Procedure type bound";
      flush stdout;
      *)
      let env' = get_env (Some i) in
      (*
      print_endline "Procedure environment built";
      flush stdout;
      *)
      let _,bbexes = bexes env' name sr i exes `BTYP_void in
      (*
      print_endline "Exes bound";
      flush stdout;
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_procedure (bps,bbexes,name_map))
      ;
      (*
      print_endline "procedure bound";
      *)
      cta env' dirs

    | `SYMDEF_match_check (pat,mvname) ->
      (*
      print_endline ("//Binding match checker " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let name_map = Hashtbl.create 97 in
      let exes = 
        [
        `EXE_return (gen_match_check pat (`AST_name (sr,mvname)))
        ] 
      in
      let _,bbexes = bexes env name sr i exes bool_t in
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_function ([],bool_t,bbexes,name_map));
    | `SYMDEF_dcl dcl -> match dcl with

    (* ugly special handling of DCLs *)

    | `DCL_type -> ()
    | `DCL_type_alias _ -> ()

    | `DCL_val t -> 
      (* print_endline ("//Binding value " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `DCL_var t ->
      (* print_endline ("//Binding variable " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_var (bt t))

    | `DCL_const (t,ct) ->
      (* print_endline ("//Binding constant " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_const (bt t,ct))

    | `DCL_abs ct ->
      (* print_endline ("//Binding abstract type " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_abs ct)

    | `DCL_header ct ->
      (* print_endline ("//Binding header string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_header ct)

    | `DCL_fun (ts,ret,ct) ->
      (* print_endline ("//Binding primitive function " ^ string_of_int i ^ " --> " ^ name);  *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_fun (List.map bt ts,bt ret,ct))

    | `DCL_proc (ts,ct) ->
      (* print_endline ("//Binding primitive procedure " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_proc (List.map bt ts,ct))

    | `DCL_union cs ->
      (* print_endline ("//Binding union " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_union cs')

    | `DCL_struct cs ->
      (* print_endline ("//Binding struct " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_struct cs')

    | `DCL_if_fun _ -> failwith "[bind_entry] Unexpected function decl"
    | `DCL_if_proc _ -> failwith "[bind_entry] Unexpected procedure decl"
    | `DCL_interface _ -> failwith "[bind_entry] Unexpected interface"
    | `DCL_module_binding _ -> failwith "[bind_entry] Unexpected module binding"
    | `DCL_untyped_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_typed_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_function _ -> failwith "[bind_entry] Unexpected function"
    | `DCL_procedure  _ -> failwith "[bind_entry] Unexpected procedure"
    | `DCL_module _ -> failwith "[bind_entry] Unexpected module"
    (*
    | `DCL_match_handler _ -> failwith "[bind_entry] Unexpected match handler"
    *)
    | `DCL_match_check _ -> failwith "[bind_entry] Unexpected match checker"
    | `DCL_lazy _ -> failwith "[bind_entry] Unexpected lazy"
    end
    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ "> COMPLETE");
    flush stdout
    *)
   )
  sym_state.dfns
  ;
  bbdfns

let bind_ifaces sym_state
  (ifaces:
    (iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env sym_state env [] n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | `IFACE_export (sn, cpp_name), parent ->
        let env = build_env sym_state [] parent in
        let index = lookup_sn_in_env sym_state env [] sn in
        `BIFACE_export (index, cpp_name) 
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
;;

try
  let filebase = Sys.argv.(1) in
  let filename = filebase ^ ".flx" in
  print_endline ("Parsing " ^ filename);

  let parse_tree = 
    Flx_parse_ctrl.parse_file 
      filename 
      (Filename.dirname filename)
      []
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "PARSE OK";

  print_endline "----------------------------";
  print_endline "DEBLOCKED:";

  let counter = ref 1 in
  let deblocked = desugar_program "DUMMY" counter parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "----------------------------";

  let dfns = Hashtbl.create 97 in
  let freg = Hashtbl.create 97 in
  let table, exes, ifaces,dirs = 
    build_tables true dfns counter "<top level>" 0 None deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let sym_state = 
      { 
        env_cache = Hashtbl.create 97;
        dfns = dfns; 
        freg = freg; 
        counter = counter; 
      }
    in
    let bbdfns = bbind sym_state in
    let bifaces = bind_ifaces sym_state ifaces in
    print_endline "//Binding complete";
    Hashtbl.iter
    (fun index (name,parent,entry) -> print_endline
      (
        string_of_int index ^ " --> " ^
        string_of_bbdcl dfns entry index
      )
    )
    bbdfns
   
with x -> flush stdout; print_endline "EXCEPTION"; 
  print_endline (Printexc.to_string x)
;;

