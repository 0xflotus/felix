@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
open Flx_ast
open Flx_mtypes2


val bbind:
  sym_state_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  sym_state_t ->
  (range_srcref * iface_t * int option) list ->
  biface_t list 

val cal_children:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (bid_t, bid_t list) Hashtbl.t


@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_ast
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify
open Flx_exceptions
open Flx_bexe
open List
open Flx_generic
open Flx_tpat
open Inria_syntax

let find_param name_map s =
  match Hashtbl.find name_map s with
  | NonFunctionEntry (i) -> i
  | _ -> failwith ("[find_param] Can't find parameter " ^ s )

let print_bvs vs =
  if length vs = 0 then "" else
  "[" ^ catmap "," (fun (s,i) -> s ^ "<"^si i^">") vs^ "]"


let bind_regex' syms env sr be ret_type cls : regular_args_t =
  let irc c = Characters (Inria_cset.singleton (Char.code c)) in
  let rec inr re = match re with 
    | REGEXP_code _ -> assert false
    | REGEXP_name _ -> assert false
    | REGEXP_sentinel -> assert false

    | REGEXP_alt (a,b) -> Alternative (inr a, inr b)
    | REGEXP_seq (a,b) -> Sequence (inr a, inr b)
    | REGEXP_epsilon -> Epsilon
    | REGEXP_aster a -> Repetition (inr a)
    | REGEXP_group (name,a) -> Bind (inr a,name)
    | REGEXP_string s -> 
      if String.length s = 0 then Epsilon
      else let r = ref (irc s.[0]) in
      for i = 1 to String.length s -1 do 
        r := Sequence (!r, irc s.[i])
      done; 
      !r
  in
  let cls = map (fun (e,c) -> bind_regdef syms env [] e, c) cls in
  let lex : (unit, expr_t) Inria_syntax.entry = 
  { 
      name = "dummy"; shortest = false; args=();
      clauses = map (fun (e,c) -> inr e, c) cls
  }
  in
    let aes, aut = Inria_lexgen.make_dfa [lex] in
    failwith "Inria dfa built"
    
let bind_regex syms env sr be ret_type cls : regular_args_t =
  (*
  print_endline "Binding regmatch";
  *) 
  let bd e = bind_regdef syms env [] e in

  (* create a unified regexp using REGEXP_code for expressions *)
  let f (e,c) = REGEXP_seq (e, REGEXP_code c) in
  let re = List.map f cls in
  let alt r1 r2 = REGEXP_alt (r1,r2) in
  let re = List.fold_right alt re REGEXP_sentinel in

  (* do lookups *)
  let re = bd re in

  (* generate transition matrix *)
  let alphabet, nstates, code_table, matrix = Flx_dfa.process_regexp re in
  let alphabet = CharSet.elements alphabet in

  (* bind RHS expressions *)
  let bcode = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i c -> 
    let sr = src_of_expr c in
    let e,t as bt = be c in
    let t = minimise syms.dfns t in
    Hashtbl.add bcode i (e,t);
    if do_unify syms !ret_type t then
      ret_type := varmap_subst syms.varmap !ret_type
    else 
      clierr sr 
      (
        "[bind_regex] Wrong return type,\nexpected : " ^ 
        string_of_btypecode syms.dfns !ret_type ^
        "\nbut we got " ^
        string_of_btypecode syms.dfns t ^ " in\n" ^
        short_string_of_src sr
      )
  )
  code_table
  ;
  alphabet,nstates, bcode,matrix

let rec find_true_parent dfns child parent = 
  match parent with 
  | None -> None
  | Some parent ->
    match Hashtbl.find dfns parent with
    | {id=id; parent=grandparent; symdef=bdcl} ->
      match bdcl with 
      | `SYMDEF_module -> find_true_parent dfns id grandparent
      | `SYMDEF_regmatch _ 
      | `SYMDEF_reglex _ 
      | `SYMDEF_function _ -> Some parent
      | _ -> None
    
let bind_req syms env sr tag =
  lookup_code_in_env syms env sr tag


let bind_reqs bt syms env sr reqs : (bid_t * btypecode_t list) list =
  let add lst i = if mem i lst then lst else i :: lst in
  let br = 
    fold_left 
    (fun lst tag ->
      let entries,ts = bind_req syms env sr tag in
      let ts = map bt ts in
      fold_left (fun lst index -> 
        let ts = adjust_ts syms sr index ts in add lst (index,ts)
      ) lst entries
    ) 
    [] 
    reqs
  in
    br
  
let bbind_sym syms bbdfns i {id=name;sr=sr;parent=parent;vs=local_vs;privmap=name_map;dirs=dirs;symdef=bdcl} =
  let qname = qualified_name_of_index syms.dfns i in
  let true_parent = find_true_parent syms.dfns name parent in
  let bexes env exes rt i tvars = bind_exes syms env sr exes rt name i tvars in
  (*
  print_endline ("Parent is " ^ (match parent with | None -> "none" | Some i -> si i));
  *) 
  begin
    (* let env = build_env syms parent in  *)
    let env = build_env syms (Some i) in 
    let be e = bind_expression syms env e in
    let luqn n = lookup_qn_in_env syms env n in
    let luqn2 n = lookup_qn_in_env2 syms env n in
    let bt t = bind_type syms env sr t in
    let ivs = find_vs syms i in (* this is the full vs list *) 
    let bvs = map (fun (s,i,tp) -> s,i) ivs in
    let btraint = function | Some x -> Some (be x) | None -> None in
    let bind_reqs reqs = bind_reqs bt syms env sr reqs in
    (*
    print_endline ("Binding " ^ name);
    *)
    let bindps (ps,traint) = 
        List.map (fun (s,t) -> 
        let i = find_param name_map s in
        s,(i,bt t)) 
      ps , btraint traint
    in
    match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_module
    | `SYMDEF_typevar _
      -> ()

    | `SYMDEF_function (ps,rt,props,exes) -> 
      let bps = bindps ps in
      let ts = map (fun (s,(i,t)) -> t) (fst bps) in
      let brt = bt rt in
      let brt',bbexes = bexes env exes brt i bvs in
      let bbdcl = 
        match brt' with
        | `BTYP_void ->
          `BBDCL_procedure (props,bvs,bps,bbexes)
        | _ ->
          `BBDCL_function (props,bvs,bps,brt',bbexes)
      in
        Hashtbl.add bbdfns i (name,true_parent,sr,bbdcl);
        begin
          if not (Hashtbl.mem syms.ticache i) then
          let t = fold syms.dfns (`BTYP_function (typeoflist ts,brt')) in
          Hashtbl.add syms.ticache i t
        end
        ;
        let atyp = typeoflist (map (fun (s,(i,t)) -> t) (fst bps)) in
        if syms.compiler_options.print_flag then
        print_endline 
        (
          "//bound function " ^ qname ^ "<"^si i^">" ^
           print_bvs bvs ^":" ^
           sbt syms.dfns (`BTYP_function (atyp,brt'))
        )

    | `SYMDEF_parameter (t) -> 
      begin match parent with 
      | None -> failwith "[bbind_sym] expected parameter to have a parent" 
      | Some ip ->
        match Hashtbl.find syms.dfns ip with
        | {symdef=`SYMDEF_function _} 
        | {symdef=`SYMDEF_regmatch _} 
        | {symdef=`SYMDEF_reglex _} 
          ->
          let t = typeofindex syms i in
          Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_val (bvs,t));
          Hashtbl.add syms.varmap i t;

          if syms.compiler_options.print_flag then
          print_endline ("//bound val " ^ name ^ "<"^si i^">" ^
          print_bvs bvs ^ ":" ^
          sbt syms.dfns t)

        | _ -> failwith "[bbind_sym] expected parameter to have function or functor parent"
      end

    | `SYMDEF_match_check (pat,(mvname,mvindex)) ->
      let t = typeofindex syms mvindex in
      let name_map = Hashtbl.create 97 in
      let exes = 
        [
        sr,`EXE_fun_return (gen_match_check pat (`AST_index (sr,mvname,mvindex)))
        ] 
      in
      let brt',bbexes = bexes env exes flx_bbool i [] in
      if brt' <> flx_bbool
      then 
        failwith 
        (
          "expected boolean return from match checker " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,true_parent,sr,
        `BBDCL_function ([`Inline; `Generated "bbind: match check"],bvs,([],None),flx_bbool,bbexes)
      );
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold syms.dfns (`BTYP_function (`BTYP_tuple[],flx_bbool)) in
        Hashtbl.add syms.ticache i t
      end
      ;

      if syms.compiler_options.print_flag then
      print_endline ("//bound match check " ^ name ^ "<"^si i^">" ^
      print_bvs bvs ^ ":" ^
        sbt syms.dfns (`BTYP_function (`BTYP_tuple[],flx_bbool))
      )
    
    (*
    | `SYMDEF_regexp _ -> ()
    *)

    | `SYMDEF_regmatch (ps,cls) ->
      let bps = bindps ps in
      let ts = map (fun (s,(i,t)) -> t) (fst bps) in
      let ret_type =  ref (snd (be (snd (hd cls)))) in
      let bregex = bind_regex syms env sr be ret_type cls in
      let bbdcl = `BBDCL_regmatch ([],bvs,bps,!ret_type,bregex) in
      Hashtbl.add bbdfns i (name,true_parent,sr,bbdcl)
      ;
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold syms.dfns (`BTYP_function (typeoflist ts,!ret_type)) in
        Hashtbl.add syms.ticache i t
      end
      ;
      if syms.compiler_options.print_flag then
      print_endline ("//bound regmatch " ^ name ^ "<"^si i^">" )

      
    | `SYMDEF_reglex (ps,le,cls) ->
      let bps = bindps ps in
      let ts = map (fun (s,(i,t)) -> t) (fst bps) in
      let ret_type = ref (snd (be (snd (hd cls)))) in
      let bregex = bind_regex syms env sr be ret_type cls in
      let bbdcl = `BBDCL_reglex ([],bvs,bps,le,!ret_type,bregex) in
      Hashtbl.add bbdfns i (name,true_parent,sr,bbdcl)
      ;
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold syms.dfns (`BTYP_function (typeoflist ts,!ret_type)) in
        Hashtbl.add syms.ticache i t
      end
      ;
      if syms.compiler_options.print_flag then
      print_endline ("//bound reglex " ^ name ^ "<"^si i^">" )

    | `SYMDEF_glr (t,(p,exes)) ->
      (*
      print_endline ("Binding nonterm " ^ name ^"<"^ si i ^">");
      *)
      let brt = if t = `TYP_none then `BTYP_var (i,`BTYP_type) else bt t in
      (*
      print_endline ("Specified type " ^ sbt syms.dfns brt);
      *)
      (*
      let brt = `BTYP_var i in (* hack .. *)
      *)

      let bn q = 
        (* we have to check this .. *)
        match luqn2 q with 
        | FunctionEntry [i],[] -> 
          begin match Hashtbl.find syms.dfns i with
          | {symdef=`SYMDEF_glr _ } -> `Nonterm [i]
          | {symdef=`SYMDEF_nonconst_ctor _} -> `Term i
          | _ -> clierr sr "Expected nonterminal or union constructor"
          end
        | FunctionEntry ii,[] -> 
          let i = hd ii in
          begin match Hashtbl.find syms.dfns i with
          | {symdef=`SYMDEF_glr _ } -> `Nonterm ii
          | {symdef=`SYMDEF_nonconst_ctor _} -> 
            clierr sr "Expected unique union constructor (it's overloaded)"
          | _ -> clierr sr "Expected nonterminal or union constructor"
          end
        | NonFunctionEntry i,[] -> `Term i
        | _,ts -> clierr sr "Unexpected type variables"
      in
      let bp p = map (fun (n,q) -> n,bn q) p in
      let p = bp p in
      let brt',bbexes = bexes env exes brt i bvs in
      let bbdcl = `BBDCL_glr ([],bvs,brt',(p, bbexes)) in
      Hashtbl.add bbdfns i (name,true_parent,sr,bbdcl);

      if syms.compiler_options.print_flag then
      print_endline ("//bound glr " ^ name ^ "<"^si i^">" )

    | `SYMDEF_const_ctor (uidx,ut,ctor_idx) ->
      let unit_sum = 
        match Hashtbl.find syms.dfns uidx with
        | {symdef=`SYMDEF_union its} ->
          fold_left 
          (fun v (_,t) -> 
            v && (match t with `AST_void _ -> true | _ -> false) 
          )
          true 
          its
        | _ -> assert false
      in
      let t = typeofindex syms i in
      let ut = bt ut in
      let ct = 
        if unit_sum then si ctor_idx 
        else "_uctor_(" ^ si ctor_idx ^ ",0)"
      in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_const (bvs,t,`Str ct,[]));

      if syms.compiler_options.print_flag then
      print_endline ("//bound const " ^ name ^ "<"^si i^">:" ^
      sbt syms.dfns t)

    | `SYMDEF_nonconst_ctor (uidx,ut,ctor_idx,argt) ->
      let t = typeofindex syms i in
      let argt = bt argt in
      let ut = bt ut in
      let bbdcl = `BBDCL_nonconst_ctor (bvs,uidx,ut,ctor_idx,argt) in
      Hashtbl.add bbdfns i (name,true_parent,sr,bbdcl);

      if syms.compiler_options.print_flag then
      print_endline ("//bound fun " ^ name ^ "<"^si i^">:" ^
      sbt syms.dfns t)

    | `SYMDEF_val (t) -> 
      let t = typeofindex syms i in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_val (bvs,t));

      if syms.compiler_options.print_flag then
      print_endline ("//bound val " ^ name ^ "<"^si i^">" ^
      print_bvs bvs ^ ":" ^
      sbt syms.dfns t)

    | `SYMDEF_var (t) ->
      (*
      print_endline ("Binding variable " ^ name ^"<"^ si i ^">");
      *)
      let t = typeofindex syms i in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_var (bvs, t))
      ;
      if syms.compiler_options.print_flag then
      print_endline ("//bound var " ^ name ^ "<"^si i^">" ^
      print_bvs bvs ^ ":" ^
      sbt syms.dfns t)
    
    | `SYMDEF_const (t,ct,reqs) ->
      let t = typeofindex syms i in
      let reqs = bind_reqs reqs in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_const (bvs,t,ct,reqs));
      if syms.compiler_options.print_flag then
      print_endline ("//bound const " ^ name ^ "<"^si i^">:" ^
      sbt syms.dfns t)


    | `SYMDEF_fun (props,ts,ret,ct,reqs,prec) ->
      let ts = map bt ts in
      let bret = bt ret in
      let reqs = bind_reqs reqs in
      let bbdcl = match bret with
        | `BTYP_void ->
          `BBDCL_proc (props,bvs,ts,ct,reqs)
        | _ ->
          `BBDCL_fun (props,bvs,ts,bret,ct,reqs,prec)
      in
      Hashtbl.add bbdfns i (name,None,sr,bbdcl);
      begin
        if not (Hashtbl.mem syms.ticache i) then
        let t = fold syms.dfns (`BTYP_function (typeoflist ts,bret)) in
        Hashtbl.add syms.ticache i t
      end
      ;
      let atyp = typeoflist ts in
      if syms.compiler_options.print_flag then
      print_endline ("//bound fun " ^ name ^ "<"^si i^">"^
      print_bvs bvs ^ ":" ^
      sbt syms.dfns (`BTYP_function (atyp,bret)))


    | `SYMDEF_union (cs) ->
      (* print_endline ("//Binding union " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_union (bvs,cs'))

    | `SYMDEF_struct (cs) ->
      (* print_endline ("//Binding struct " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_struct (bvs,cs'))

    | `SYMDEF_cstruct (cs) ->
      (* print_endline ("//Binding cstruct " ^ si i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_cstruct (bvs,cs'))

    | `SYMDEF_cclass (cs) -> 
      (* NOTE: At present the code spec is already handled by symtab,
      so there is point propagating it .. the bound members are kept
      to ensure we generate all required types, they don't generate
      any actual code
      *)
      let cs' = List.map (function
        |  `MemberVal (n,t,_) -> `BMemberVal (n, bt t)
        |  `MemberVar (n,t,_) -> `BMemberVar (n, bt t)
        |  `MemberFun (n,t,_) -> `BMemberFun (n, bt t)
        |  `MemberProc (n,t,_) -> `BMemberProc (n, bt t)
        |  `MemberCtor (n,t,_) -> `BMemberCtor (n, bt t)
        ) cs 
      in
      Hashtbl.add bbdfns i (name,true_parent,sr,`BBDCL_cclass (bvs,cs'))

    | `SYMDEF_regdef _ -> ()
    | `SYMDEF_type_alias _ -> ()
    | `SYMDEF_inherit _ -> ()
    | `SYMDEF_inherit_fun _ -> ()

    | `SYMDEF_abs (complete,ct,reqs)->
      (*
      print_endline ("//Binding abstract type " ^ si i ^ " --> " ^ name); 
      *)
      let reqs = bind_reqs reqs in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_abs (bvs,complete,ct,reqs))

    | `SYMDEF_insert (ct,ikind,reqs) ->
      (* print_endline ("//Binding header string " ^ si i ^ " --> " ^ name); 
      *)
      let reqs = bind_reqs reqs in
      Hashtbl.add bbdfns i (name,None,sr,`BBDCL_insert (bvs,ct,ikind,reqs))

    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ si i ^ "> COMPLETE");
    flush stdout
    *)

let bbind_index syms bbdfns i =
  if Hashtbl.mem bbdfns i then ()
  else let entry = Hashtbl.find syms.dfns i in
  bbind_sym syms bbdfns i entry

let cal_children syms bbdfns =
  let child_map = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i (id,parent,sr,entry) ->
    match parent with
    | Some parent ->
      Hashtbl.replace child_map parent
      (i ::
        (
          try Hashtbl.find child_map parent
          with Not_found -> []
        )
      )
    | None -> ()
  )
  bbdfns
  ;
  child_map

let bbind syms = 
  let bbdfns = Hashtbl.create 97 in
  (* loop through all counter values [HACK]
    to get the indices in sequence, AND,
    to ensure any instantiations will be bound,
    (since they're always using the current value
    of syms.counter for an index
  *)
  let i = ref 0 in
  while !i < !(syms.counter) do
    begin 
      let entry = 
        try Some (Hashtbl.find syms.dfns !i)
        with Not_found -> None
      in match entry with
      | Some entry ->
        begin try
          bbind_sym syms bbdfns !i entry
        with Not_found -> failwith ("Binding error index " ^ si !i)
        end
      | None -> ()
    end
    ;
    incr i
  done
  ;
  bbdfns

let bind_ifaces syms 
  (ifaces:
    (range_srcref * iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env syms env n in
  let bound_ifaces = 
    List.map
    (function 
      | sr,`IFACE_export_fun (sn, cpp_name), parent ->
        let env = build_env syms parent in
        let index,ts = lookup_sn_in_env syms env sn in
        if length ts = 0 then
          `BIFACE_export_fun (sr,index, cpp_name) 
        else clierr sr 
        (
          "Can't export generic entity " ^
          string_of_suffixed_name sn
        )
      
      | sr,`IFACE_export_type (typ, cpp_name), parent ->
        let env = build_env syms parent in
        let t = bind_type syms env dummy_sr typ in
        if var_occurs t then
        clierr sr 
        (
          "Can't export generic type " ^
          string_of_btypecode syms.dfns t
        )
        else
          `BIFACE_export_type (sr, t, cpp_name) 
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_flxopt
open Flx_exceptions
open Flx_mtypes1
open Flx_mtypes2
open Flx_use
;;

let print_help () = print_options(); exit(0)
;;
let reverse_return_parity = ref false
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    raise (Exit 0)
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity :=  compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  let include_dirs =  (* (Filename.dirname input_file_name) :: *) compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in
  let deblocked = desugar_program syms module_name parse_tree in

  let root = !(syms.counter) in
  print_endline ("//Top level module '"^module_name^"' has index " ^ si root);

  let table, _, exes, ifaces,dirs = 
    build_tables syms "root" 0 None None root deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let bbdfns = bbind syms in
    let child_map = cal_children syms bbdfns in
    let bifaces = bind_ifaces syms ifaces in
    print_endline "//Binding complete";

    let root_proc = 
      match 
        try Hashtbl.find syms.dfns root 
        with Not_found ->
          failwith 
          (
            "Can't find root module " ^ si root ^
            " in symbol table?"
          )
      with {id=id; sr=sr; parent=parent;vs=vs;pubmap=name_map;symdef=entry} ->
      begin match entry with
        | `SYMDEF_module -> ()
        | _ -> failwith "Expected to find top level module ''"
      end
      ;
      let entry = 
        try Hashtbl.find name_map "_init_" 
        with Not_found ->
          failwith "Can't find name _init_ in top level module's name map"
      in
      let index = match entry with
        | FunctionEntry [x] -> x
        | FunctionEntry [] -> failwith "Couldn't find '_init_'"
        | FunctionEntry _ -> failwith "Too many top level procedures called '_init_'"
        | NonFunctionEntry _ -> failwith "_init_ found but not procedure"
      in 
      if compiler_options.print_flag 
      then print_endline ("//root module's init procedure has index " ^ si index);
      index
    in

    Hashtbl.iter
    (fun index (name,parent,sr,entry) -> print_endline
      (
        si index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns
   
with x -> Flx_terminate.terminate !reverse_return_parity x
;;

