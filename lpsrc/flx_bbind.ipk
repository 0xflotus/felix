@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_bbind.mli")
@select(h)
open Flx_types
val bbind:
  sym_state_t ->
  fully_bound_symbol_table_t

val bind_ifaces:
  sym_state_t ->
  (iface_t * int option) list ->
  biface_t list 

@h = tangler("src/flx_bbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify

let cal_call dfns (p,pt) e =
  match lower pt with
  | `BTYP_function (_, `BTYP_void) -> 
    `BEXE_call ((p,lower pt), e)
  | _ -> 
    failwith ("call non procedure, "^
    string_of_bound_expression dfns (p,pt)
    ^"\ntype=" ^ string_of_btypecode dfns pt)

exception Found of int

let bool_t = `BTYP_sum [`BTYP_tuple[]; `BTYP_tuple []]

let bind_exes syms env exes ret_type id = 
  (*
  print_endline ("bind_exes.. env depth="^ string_of_int (List.length env));
  print_endline "Dumping Source Executables";
  print_endline "--------------------------";
  let soe e = Flx_print.string_of_expr e in
  List.iter 
    (fun x -> print_endline (string_of_exe 1 x))
    exes
  ;
  print_endline ""
  ;

  print_endline "Binding Executables";
  print_endline "-------------------";
  *)
  let ret_type = ref ret_type in
  let be e = bind_expression syms env [] [] 0 [] e in
  let lun sr n = lookup_name_in_env env sr n in
  let luqn n = lookup_qn_in_env syms env [] n in
  let bt sr t = bind_type syms env [] [] sr t in
  let dummy_sr = ("bind exes",0,0,0,0) in
  let return_count = ref 0 in
  let reachable = ref true in

  let bound_exes = 
    List.map
    (fun x -> 
      (*
      print_endline (string_of_exe 1 x);
      *)
      if not !reachable then 
      begin 
        match x with 
        | `EXE_label _ -> ()
        | `EXE_comment _ -> ()
        | `EXE_nop _ -> ()
        | _ -> print_endline ("WARNING: Unreachable code in "^id^": " ^ string_of_exe 1 x);
      end
      ;
      match x with
      | `EXE_comment s ->       `BEXE_comment s
      | `EXE_label s ->         reachable := true; `BEXE_label s
      | `EXE_goto s ->          reachable := false; `BEXE_goto s

      | `EXE_ifgoto (e,s) ->    
        let e',t = be e in
        if t = bool_t
        then `BEXE_ifgoto ((e',t), s)
        else 
          failwith 
          (
            "[bind_exes:ifgoto] Conditional requires bool argument, got " ^
            string_of_btypecode syms.dfns t
          )

      | `EXE_ifnotgoto (e,s) -> 
        let e',t = be e in
        if t = bool_t
        then `BEXE_ifnotgoto ((e',t), s)
        else 
          failwith 
          (
            "[bind_exes:ifnotgoto] Conditional requires bool argument, got " ^
            string_of_btypecode syms.dfns t
          )

      | `EXE_call (`AST_ginst(sr,(#qualified_name_t as qn,ts)), e2) -> (* OVERLOADING *)
        (*
        print_endline "Handling call of generic with qualified name";
        flush stdout;
        *)
        let be2,t2 = be e2 in
        (*
        print_endline "Argument bound";
        flush stdout;
        *)
        let ts = List.map (bt sr) ts in
        let tbe1 =
          lookup_qn_with_sig 
          syms 
          dummy_sr dummy_sr 
          env [] [] 
          qn ts t2 
        in  
          (*
          print_endline "Applying call now";
          flush stdout;
          *)
          cal_call syms.dfns tbe1 (be2,t2)

      | `EXE_call (#suffixed_name_t as sn, e2) -> (* OVERLOADING *)
        (*
        print_endline "Handling call of suffixed name";
        flush stdout;
        *)
        let be2,t2 = be e2 in
        (*
        print_endline "Argument bound";
        flush stdout;
        *)
        let tbe1 =
           match sn with
           | #qualified_name_t as qn ->
             lookup_qn_with_sig 
             syms 
             dummy_sr dummy_sr 
             env [] [] 
             qn [] t2 
           | _ -> be sn
        in  
          (*
          print_endline "Applying call now";
          flush stdout;
          *)
          cal_call syms.dfns tbe1 (be2,t2)

      | `EXE_call (p,e) ->
        let p',pt' = be p and e',et' = be e in
        cal_call syms.dfns (p', pt') (e', et')

      | `EXE_read s ->          
        begin match lun dummy_sr s with
        | NonFunctionEntry (Simple index) -> `BEXE_read index
        | NonFunctionEntry _ -> failwith "not expecting bound entry"
        | FunctionEntry _ -> failwith "Can't read function!"
        end

      | `EXE_return e ->        
        (*
        print_endline "Processsing return";
        *)
        reachable := false;
        incr return_count;
        (*
        print_endline ("Expression is " ^ string_of_expr e);
        *)
        let e',t' = be e in
        (*
          print_endline ("Starting ret type is " ^ string_of_btypecode syms.dfns !ret_type);
          print_endline ("Expression type is   " ^ string_of_btypecode syms.dfns t');
        *)
        if do_unify syms !ret_type t' then begin
          ret_type := varmap_subst syms.varmap !ret_type;
          `BEXE_return (e',lower t')
        end 
        else
          failwith 
          (
            "Wrong return type,\nexpected : " ^ 
            string_of_btypecode syms.dfns !ret_type ^
            "\nbut we got " ^
            string_of_btypecode syms.dfns t'
          )

      | `EXE_nop s ->           `BEXE_nop s 
      | `EXE_code s ->          `BEXE_code s
      | `EXE_noreturn_code s ->  reachable := false; `BEXE_code s

      | `EXE_init (s,e) -> 
        let sr = src_of_expr e in (* HACK! *)
        begin match lun sr s with
        | FunctionEntry _ -> failwith "Can't init function constant"
        | NonFunctionEntry (Simple index) -> 
          let e',rhst = be e in
          let lhst = typeofindex syms [] [] 0 [] index in
          if type_eq lhst rhst
          then `BEXE_init (index, (e',rhst))
          else failwith (
            "LHS["^s^"]("^string_of_btypecode syms.dfns lhst^
            ") of initialisation must have same type as RHS("^
            string_of_btypecode syms.dfns rhst^")"
          )
        | NonFunctionEntry _ -> failwith "Not expecting bound entry"
        end

      | `EXE_regmatch (e,cls) ->  
        (*
        print_endline "Binding regmatch";
        *) 
        reachable := false;
        let e = be e in
        let bd e = bind_regdef syms env [] [] [] e in

        (* create a unified regexp using REGEXP_code for expressions *)
        let f (e,c) = REGEXP_seq (e, REGEXP_code c) in
        let re = List.map f cls in
        let alt r1 r2 = REGEXP_alt (r1,r2) in
        let re = List.fold_right alt re REGEXP_sentinel in

        (* do lookups *)
        let re = bd re in

        (* generate transition matrix *)
        let alphabet, nstates, code_table, matrix = Flx_dfa.process_regexp re in
        let alphabet = CharSet.elements alphabet in

        (* bind RHS expressions *)
        let bcode = Hashtbl.create 97 in
        Hashtbl.iter
        (fun i c -> 
          let _,t as bt = be c in
          Hashtbl.add bcode i bt;
          incr return_count;
          if do_unify syms !ret_type t then
            ret_type := varmap_subst syms.varmap !ret_type
          else 
            failwith 
            (
              "Wrong return type,\nexpected : " ^ 
              string_of_btypecode syms.dfns !ret_type ^
              "\nbut we got " ^
              string_of_btypecode syms.dfns t
            )
        )
        code_table
        ;
        `BEXE_regmatch (e,alphabet,nstates, bcode,matrix)
    )
    exes
  in 
  (*
  print_endline ""
  ;
  List.iter 
    (fun x -> print_endline (string_of_bexe syms.dfns 1 x)) 
    bound_exes
  ;
  print_endline ""
  ;
  print_endline "BINDING COMPLETE"
  ;
  *)

  (* No return statements found: it must be a procedure,
     so unify void [just a comparison with void .. heh!]
  *)
  if !return_count = 0 then
  begin
    if do_unify syms !ret_type `BTYP_void 
    then
      ret_type := varmap_subst syms.varmap !ret_type
    else
      failwith 
      (
        "procedure " ^id^" has non-void return type"
      )
  end
  ;

  begin match !ret_type with
  | `BTYP_void ->
    if not !reachable
    then print_endline ("WARNING: procedure " ^id^" doesn't drop thru end, possible infinit loop")
  | _ ->
    if !reachable 
    then print_endline ("WARNING: function "^id^" drops off end, possible missing return statement");
  end
  ;
  !ret_type,bound_exes

let rec proper_descendant dfns parent =
  match parent with
  | Some parent -> 
    let _,_,parent,entry = Hashtbl.find dfns parent in
    begin match entry with
    | `SYMDEF_interface _ 
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _ 
      -> false
    | _ -> proper_descendant dfns parent 
    end
  | None -> true

 
let bbind_sym syms bbdfns i (name,sr,parent,bdcl) =
  let bexes env exes rt = bind_exes syms env exes rt name in
  let dummy_sr = ("Generated dummy",0,0,0,0) in
  (*
  print_endline ("binding symbol " ^ name);
  *)
  if proper_descendant syms.dfns parent
  then begin
    (*
    print_endline "Building ENV";
    *)
    let env = build_env syms [] parent in 
    (* print_env env; *)
    (*
    print_endline "Building ENV Complete";
    *)
    let bt t = bind_type syms env [] [] sr t in
    let bgt vs t = bind_type_with_tvars syms env [] [] sr t vs in
    (*
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ ">");
    *)
    begin match bdcl with

    (* Pure declarations of functions, modules, and type
       don't generate anything. Variable dcls do, however.
    *)
    | `SYMDEF_interface _
    | `SYMDEF_if_fun _ 
    | `SYMDEF_if_proc _
    | `SYMDEF_module _
    | `SYMDEF_typed_functor _
    | `SYMDEF_untyped_functor _
    | `SYMDEF_module_binding _
    | `SYMDEF_if_type  -> ()

    | `SYMDEF_function (ps,rt,exes,name_map,dirs) -> 
      (*
      print_endline ("//Binding function " ^ string_of_int i ^ " --> " ^ name); 
      print_endline ("given type is " ^ string_of_typecode rt);
      print_endline ("exes are: " ^ (String.concat "\n  " (List.map (string_of_exe 1) exes)));
      *)
      let brt = bt rt in
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      let env' = build_env syms [] (Some i) in
      let brt',bbexes = bexes env' exes brt in
      (*
      print_endline ("return type is " ^ string_of_btypecode syms.dfns brt');
      *)
      let bbdcl = 
        match brt' with
        | `BTYP_void ->
          `BBDCL_procedure (bps,bbexes,name_map)
        | _ ->
          `BBDCL_function (bps,brt',bbexes,name_map)
      in
        Hashtbl.add bbdfns i (name,parent,bbdcl)

    | `SYMDEF_parameter t -> 
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `SYMDEF_lazy (e) ->
      let e',rt' = bind_expression syms env [] [] 0 [] e in
      let bbexes = [`BEXE_return (e',rt')] in
      Hashtbl.add bbdfns i 
      (name,parent,`BBDCL_function ([],rt',bbexes,Hashtbl.create 97))



    | `SYMDEF_procedure (ps,exes,name_map,dirs) -> 
      (*
      print_endline ("//Binding procedure " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let bps = List.map (fun (name,t) -> (name, bt t)) ps in
      (*
      print_endline "Procedure type bound";
      flush stdout;
      *)
      let env' = build_env syms [] (Some i) in
      (*
      print_endline "Procedure environment built";
      flush stdout;
      *)
      let brt',bbexes = bexes env' exes `BTYP_void in
      (*
      print_endline "Exes bound";
      flush stdout;
      *)
      if brt' <> `BTYP_void
      then 
        failwith 
        (
          "expected void return from procedure " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,parent,`BBDCL_procedure (bps,bbexes,name_map))
      ;
      (*
      print_endline "procedure bound";
      *)

    | `SYMDEF_match_check (pat,mvindex) ->
      (*
      print_endline ("//Binding match checker " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let t = typeofindex syms [] [] 0 [] mvindex in
      let name_map = Hashtbl.create 97 in
      let arg,sr = match Hashtbl.find syms.dfns mvindex with id,sr,_,_ -> id,sr in
      let exes = 
        [
        `EXE_return (gen_match_check pat (`AST_name (sr,arg)))
        ] 
      in
      let brt',bbexes = bexes env exes bool_t in
      if brt' <> bool_t
      then 
        failwith 
        (
          "expected boolean return from match checker " ^ name ^ " in\n" ^
          short_string_of_src sr
        )
      ;
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_function ([],bool_t,bbexes,name_map));
    
    | `SYMDEF_val t -> 
      (*
      print_endline ("//Binding value " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_val (bt t))

    | `SYMDEF_var t ->
      (* print_endline ("//Binding variable " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_var (bt t))

    | `SYMDEF_dcl dcl -> match dcl with

    (* ugly special handling of DCLs *)

    | `DCL_type -> ()

    | `DCL_regdef _ -> ()
    | `DCL_type_alias _ -> ()


    | `DCL_const (t,ct) ->
      (* print_endline ("//Binding constant " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_const (bt t,ct))

    | `DCL_abs (vs,ct) ->
      (*
      print_endline ("//Binding abstract type " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_abs (vs,ct))

    | `DCL_header ct ->
      (* print_endline ("//Binding header string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_header ct)

    | `DCL_body ct ->
      (* print_endline ("//Binding body string " ^ string_of_int i ^ " --> " ^ name); 
      *)
      Hashtbl.add bbdfns i (name,parent,`BBDCL_body ct)

    | `DCL_fun (vs,ts,ret,ct) ->
      (*
      print_endline ("//Binding primitive function " ^ string_of_int i ^ " --> " ^ name);
      *)
      let tvars : (string * int) list= 
        List.map
        (fun s -> 
          let n = !(syms.counter) in 
          incr (syms.counter);
          s,n
        )
        vs
      in
      let tv2 = List.map (fun (s,i) -> s,`BTYP_var i) tvars in
      let params : btypecode_t list = List.map (bgt tv2 ) ts in
      Hashtbl.add bbdfns i (name,parent,
        `BBDCL_fun (tvars, params,bgt tv2 ret,ct)
      )

    | `DCL_proc (vs,ts,ct) ->
      (*
      print_endline ("//Binding primitive procedure " ^ string_of_int i ^ " --> " ^ name);
      *)
      let tvars : (string * int) list= 
        List.map
        (fun s -> 
          let n = !(syms.counter) in 
          incr (syms.counter);
          s,n
        )
        vs
      in
      let tv2 = List.map (fun (s,i) -> s,`BTYP_var i) tvars in
      let params : btypecode_t list = List.map (bgt tv2) ts in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_proc (tvars,params,ct))

    | `DCL_union cs ->
      (* print_endline ("//Binding union " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_union cs')

    | `DCL_struct cs ->
      (* print_endline ("//Binding struct " ^ string_of_int i ^ " --> " ^ name); 
      *)
      let cs' = List.map (fun (n,t) -> n, bt t) cs in
      Hashtbl.add bbdfns i (name,parent,`BBDCL_struct cs')

    | `DCL_val _ -> failwith "[bind_entry] Unexpected val decl"
    | `DCL_var _ -> failwith "[bind_entry] Unexpected var decl"
    | `DCL_if_fun _ -> failwith "[bind_entry] Unexpected function decl"
    | `DCL_if_proc _ -> failwith "[bind_entry] Unexpected procedure decl"
    | `DCL_interface _ -> failwith "[bind_entry] Unexpected interface"
    | `DCL_module_binding _ -> failwith "[bind_entry] Unexpected module binding"
    | `DCL_untyped_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_typed_functor _ -> failwith "[bind_entry] Unexpected functor"
    | `DCL_function _ -> failwith "[bind_entry] Unexpected function"
    | `DCL_procedure  _ -> failwith "[bind_entry] Unexpected procedure"
    | `DCL_module _ -> failwith "[bind_entry] Unexpected module"
    | `DCL_match_handler _ -> failwith "[bind_entry] Unexpected match handler"
    | `DCL_match_check _ -> failwith "[bind_entry] Unexpected match checker"
    | `DCL_lazy _ -> failwith "[bind_entry] Unexpected lazy"
    | `DCL_regmatch _ -> failwith "[bind_entry] Unexpected regmatch"
    end
    end
    (*
    ;
    print_endline ("BINDING " ^ name ^ "<" ^ string_of_int i ^ "> COMPLETE");
    flush stdout
    *)

(*
let bbind_index syms bbdfns i =
  if Hashtbl.mem bbdfns i then ()
  else let entry = Hashtbl.find syms.dfns i in
  bbind_sym syms bbdfns i entry
*) 

let bbind syms = 
  let bbdfns = Hashtbl.create 97 in
  Hashtbl.iter 
    (bbind_sym syms bbdfns)
    syms.dfns
  ;
  bbdfns

let bind_ifaces syms 
  (ifaces:
    (iface_t * int option) list
  )
= 
  let luqn env n = lookup_qn_in_env syms env [] n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | `IFACE_export (sn, cpp_name), parent ->
        let env = build_env syms [] parent in
        let index = lookup_sn_in_env syms env [] sn in
        `BIFACE_export (index, cpp_name) 
     )
     ifaces
   in bound_ifaces


@h = tangler("src/flxb.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_bbind
open Flx_print
open Flx_types
open Flx_symtab
open Flx_getopt
open Flx_version
;;

let print_help () =
  print_endline "options:";
  print_endline "  -h, --help : print this help";
  print_endline "  --version: print version info";
  print_endline "  -v, --verbose: print symbol table";
  print_endline "  -q, --quiet: no stdout";
  print_endline "  -Idir, --include=dir : append dir to include path";
  exit(0)
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let options = get_options Sys.argv in
  let include_dirs = ref [] in
  let print_flag = ref false in
  List.iter (fun (key,value) ->
    if key = "include" || key = "I"
    then include_dirs := !include_dirs @ [value]

    else if key = "verbose" || key = "v"
    then print_flag := true

    else if key = "help" || key = "h"
    then print_help ()

    else if key = "version" 
    then (print_endline ("Felix Version " ^ version_string))
  )
  options
  ;
  if !print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    !include_dirs;
    print_endline ""
  end
  ;

  let filebase = Sys.argv.(argc-1) in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  print_endline ("Parsing " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      !include_dirs 
  in

  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "PARSE OK";

  print_endline "----------------------------";
  print_endline "DEBLOCKED:";

  let syms = 
    { 
      registry = Hashtbl.create 97;
      counter = ref 1; 
      freg = Hashtbl.create 97;
      dfns = Hashtbl.create 97 ;
      varmap = Hashtbl.create 97;
      ticache = Hashtbl.create 97;
      env_cache = Hashtbl.create 97;
      prim_inst = Hashtbl.create 97;
      rev_prim_inst = Hashtbl.create 97;
      instantiated_types = Hashtbl.create 97;
    } 
  in
  let deblocked = desugar_program "DUMMY" (syms.counter) parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "----------------------------";

  let table, exes, ifaces,dirs = 
    build_tables true syms.dfns syms.counter "<top level>" 0 None deblocked 
  in
    print_endline "//BINDING EXECUTABLE CODE";
    print_endline "//-----------------------";
    let bbdfns = bbind syms in
    let bifaces = bind_ifaces syms ifaces in
    print_endline "//Binding complete";
    Hashtbl.iter
    (fun index (name,parent,entry) -> print_endline
      (
        string_of_int index ^ " --> " ^
        string_of_bbdcl syms.dfns entry index
      )
    )
    bbdfns
   
with x -> flush stdout; print_endline "EXCEPTION"; 
  print_endline (Printexc.to_string x)
;;

