@head(1,"Run time driver support library")

@execfile('config'+os.sep+'flx_data.py')

This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@select(tangler('spkgs/flx.py'))
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','flx_gc','flx_pthread','demux','faio','flx_stdlib']
@doc()

@select(tangler('spkgs/flx_async.py'))
cpp_cpps = ['rtl/flx_async']
provides_lib = "libflx_async"
pkg_requires = ['faio','demux','flx_pthread','flx_rtl','flx_gc']
lib_requires = ['libfaio','libdemux','libflx_pthread','libflx','libflx_gc']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "ASYNC"
@doc()

@select(tangler('spkgs/flx_rtl.py'))
RTL_CPPS = [
  "rtl/flx_rtl",
  "rtl/flx_dynlink",
  "rtl/flx_sync",
  "rtl/flx_eh",
  "rtl/flx_i18n",
  "rtl/flx_ioutil",
  "rtl/flx_strutil",
  "rtl/flx_main",
]

cpp_cpps = RTL_CPPS
provides_lib = "libflx"
lib_requires = ['libflx_gc']
pkg_requires = ['flx_gc']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "RTL"
weaver_directory = 'doc/rtl/flx_rtl/'
@doc()

@select(tangler('spkgs/flx_drivers.py'))
DRIVERS = [
  ('static','rtl/flx_run','',[]),
  ('dynamic','rtl/flx_run','bin/flx_run',[]),
  ('static','test/drivers/flx_perf_drv1','',[]),
  ('dynamic','test/drivers/flx_perf_drv1','test/drivers/flx_perf_drv1',[]),
  ('static','test/drivers/mickey_mouse','',[]),
  ('dynamic','test/drivers/mickey_mouse','bin/mickey_mouse',[]),
]

DRLIBS = [
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  ]

drivers = DRIVERS
drivers_require_libs = DRLIBS
pkg_requires = ['flx_rtl','flx_pthread','flx_gc']
lib_requires = ['libdemux','libflx_pthread','libflx']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('spkgs/flx_async_drivers.py'))
DRIVERS = [
  ('static','rtl/flx_arun','',[]),
  ('dynamic','rtl/flx_arun','bin/flx_arun',[]),
]

DRLIBS = [
  'libflx_async',
  'libfaio',
  'libdemux',
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  ]

drivers = DRIVERS
drivers_require_libs = DRLIBS
pkg_requires = ['flx_gc','flx_rtl','flx_pthread','flx_async','demux','faio']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('config/flx.fpc', 'data'))
Name: flx
Description: Felix core runtime support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_static")
 else:
   tangle("provides_dlib: -lflx_dynamic")
   tangle("provides_slib: -lflx_static")
Requires: flx_gc
@doc()

@select(tangler('config/flx_arun.fpc', 'data'))
Name: flx_arun
Description: Felix standard driver, async support
Version: $Id$
Requires: flx_async faio demux flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_run.fpc', 'data'))
Name: flx_run
Description: Felix standard driver, no async support
Version: $Id$
Requires: flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_async.fpc', 'data'))
Name: flx_async
Description: Async hook
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_async_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_async_static")
 else:
   tangle("provides_dlib: -lflx_async_dynamic")
   tangle("provides_slib: -lflx_async_static")

Requires: faio demux flx_pthread flx flx_gc
@doc()

@select(tangler("rtl/flx_meta.hpp"))
#ifndef __FLX_META_H__
#define __FLX_META_H__
// taken from BOOST
@if HAVE_INCLASS_MEMBER_INITIALIZATION:
  tangle('#define FLX_HAVE_INCLASS_MEMBER_INITIALIZATION 1')
 else:
  tangle('#define FLX_HAVE_INCLASS_MEMBER_INITIALIZATION 0')

#if FLX_HAVE_INCLASS_MEMBER_INITIALIZATION
#  define FLX_STATIC_CONSTANT(type, assignment) static const type assignment
#else
#  define FLX_STATIC_CONSTANT(type, assignment) enum { assignment }
#endif

#include <cstddef>

template <std::size_t> struct type_with_alignment;
@for k in flx_aligns.keys():
  t = flx_aligns[k]
  tangle('template <> struct type_with_alignment<'+str(k)+'>{ typedef '+t+' type; };')

template <typename T> struct alignment_of;

template <typename T>
struct alignment_of_hack
{
  char c;
  T t;
  alignment_of_hack();
};

template <unsigned A, unsigned S>
struct alignment_logic
{
  FLX_STATIC_CONSTANT(std::size_t, value = A < S ? A : S);
};

template< typename T >
struct alignment_of
{
  FLX_STATIC_CONSTANT(std::size_t, value =
    (alignment_logic<
      sizeof(alignment_of_hack<T>) - sizeof(T),
      sizeof(T)
    >::value));
};

template<std::size_t L, std::size_t A> 
struct aligned_storage
{
  union type
  {
    unsigned char data_[ L ];
    typename type_with_alignment<A>::type align_;
  };
};

template<typename T>
struct store_of 
{
  typedef typename aligned_storage<sizeof(T), alignment_of<T>::value>::type type;
};

// convert an rvalue to an lvalue
template<typename T> 
T const &lvalue(T const &x) 
{ 
  return x; 
}

// this reinterpret cast works with rvalues too
template<typename T, typename U>
T &reinterpret(U const &x) {
  return reinterpret_cast<T&>(const_cast<U&>(x));
}
#endif
@doc()

@select(tangler("rtl/flx_host_config.hpp"))
#ifndef __FLX_HOST_CONFIG_H__
#define __FLX_HOST_CONFIG_H__

@if HOST_CXX.options.WIN32:
  tangle('#define FLX_WIN32 1')
 else:
  tangle('#define FLX_WIN32 0')

@if HOST_CXX.options.HAVE_BOOL:
  tangle('#define FLX_HAVE_BOOL 1')
 else:
  tangle('#define FLX_HAVE_BOOL 0')

@if HOST_CXX.options.HAVE_LONGLONG:
  tangle('#define FLX_HAVE_LONGLONG 1')
 else:
  tangle('#define FLX_HAVE_LONGLONG 0')

@if HOST_CXX.options.HAVE_LONGDOUBLE:
  tangle('#define FLX_HAVE_LONGDOUBLE 1')
 else:
  tangle('#define FLX_HAVE_LONGDOUBLE 0')

#if !defined(FLX_STATIC_LINK) && FLX_WIN32
#define FLX_EXPORT __declspec(dllexport)
#define FLX_IMPORT __declspec(dllimport)
#else
#define FLX_EXPORT
#define FLX_IMPORT
#endif


@def cal_raw_address():
  if HOST_CXX.options.SIZEOF_INT == HOST_CXX.options.SIZEOF_VOIDP: return "unsigned"
  if HOST_CXX.options.SIZEOF_LONG == HOST_CXX.options.SIZEOF_VOIDP: return "unsigned long"
  if HOST_CXX.options.SIZEOF_LONGLONG == HOST_CXX.options.SIZEOF_VOIDP: return "unsigned long long"
  raise "Cannot find an int the size of a void pointer"

@tangle("#define FLX_RAWADDRESS "+cal_raw_address())
@tangle('#define FLX_MAX_ALIGN '+str(HOST_CXX.options.MAX_ALIGN))

#if FLX_WIN32
#define _WIN32_WINNT 0x500 // Require Windows NT5 (2K, XP, 2K3)
#endif


#endif

@select(tangler("rtl/flx_rtl_config.hpp"))
#ifndef __FLX_RTL_CONFIG_H__
#define __FLX_RTL_CONFIG_H__

@if HAVE_VSNPRINTF:
  tangle('#define FLX_HAVE_VSNPRINTF 1')
 else:
  tangle('#define FLX_HAVE_VSNPRINTF 0')

@if TARGET_CXX.options.HAVE_BOOL:
  tangle('#define FLX_HAVE_BOOL 1')
 else:
  tangle('#define FLX_HAVE_BOOL 0')

@if HAVE_LONGLONG:
  tangle('#define FLX_HAVE_LONGLONG 1')
 else:
  tangle('#define FLX_HAVE_LONGLONG 0')

@if HAVE_LONGDOUBLE:
  tangle('#define FLX_HAVE_LONGDOUBLE 1')
 else:
  tangle('#define FLX_HAVE_LONGDOUBLE 0')

@if HAVE_ISNAN_IN_IEEEFP:
  tangle('#define FLX_HAVE_ISNAN_IN_IEEEFP 1')
 else:
  tangle('#define FLX_HAVE_ISNAN_IN_IEEEFP 0')

@if HAVE_GNU:
  tangle('#define FLX_HAVE_GNU 1')
 else:
  tangle('#define FLX_HAVE_GNU 0')

@if HAVE_GNU_X86:
  tangle('#define FLX_HAVE_GNU_X86 1')
 else:
  tangle('#define FLX_HAVE_GNU_X86 0')

@if HAVE_GNU_X86_64:
  tangle('#define FLX_HAVE_GNU_X86_64 1')
 else:
  tangle('#define FLX_HAVE_GNU_X86_64 0')

@if HAVE_GNU_BUILTIN_EXPECT:
  # only use these with proper predicates!
  tangle('#define FLX_UNLIKELY(x) __builtin_expect(long(x),0)')
  tangle('#define FLX_LIKELY(x) !__builtin_expect(!long(x),0)')
 else:
  tangle('#define FLX_UNLIKELY(x) x')
  tangle('#define FLX_LIKELY(x) x')

@if HAVE_CGOTO:
  tangle("#define FLX_HAVE_CGOTO 1")
 else:
  tangle("#define FLX_HAVE_CGOTO 0")

@if USE_REGPARM3:
  tangle("#define FLX_USE_REGPARM3 1")
 else:
  tangle("#define FLX_USE_REGPARM3 0")
  
@if HAVE_ASM_LABELS:
  tangle("#define FLX_HAVE_ASM_LABELS 1")
 else:
  tangle("#define FLX_HAVE_ASM_LABELS 0")

@if HAVE_DLOPEN:
  tangle("#define FLX_HAVE_DLOPEN 1")
 else:
  tangle("#define FLX_HAVE_DLOPEN 0")

@if WIN32:
  tangle('#define FLX_WIN32 1')
 else:
  tangle('#define FLX_WIN32 0')

@if MACOSX:
  tangle("#define FLX_MACOSX 1")
 else:
  tangle("#define FLX_MACOSX 0")

@if LINUX:
  tangle("#define FLX_LINUX 1")
 else:
  tangle("#define FLX_LINUX 0")

@if WIN32:
  tangle("#define FLX_WIN32 1")
 else:
  tangle("#define FLX_WIN32 0")

@if WIN64:
  tangle("#define FLX_WIN64 1")
 else:
  tangle("#define FLX_WIN64 0")

@if CYGWIN:
  tangle("#define FLX_CYGWIN 1")
 else:
  tangle("#define FLX_CYGWIN 0")

@if POSIX:
  tangle("#define FLX_POSIX 1")
 else:
  tangle("#define FLX_POSIX 0")

@if SOLARIS:
  tangle("#define FLX_SOLARIS 1")
 else:
  tangle("#define FLX_SOLARIS 0")

@if HAVE_MSVC:
  tangle("#define FLX_HAVE_MSVC 1")
 else:
  tangle("#define FLX_HAVE_MSVC 0")

@if HAVE_KQUEUE_DEMUXER:
  tangle("#define FLX_HAVE_KQUEUE_DEMUXER 1")
 else:
  tangle("#define FLX_HAVE_KQUEUE_DEMUXER 0")

@if HAVE_POLL:
  tangle("#define FLX_HAVE_POLL 1")
 else:
  tangle("#define FLX_HAVE_POLL 0")

@if HAVE_EPOLL:
  tangle("#define FLX_HAVE_EPOLL 1")
 else:
  tangle("#define FLX_HAVE_EPOLL 0")

@if HAVE_EVTPORTS:
  tangle("#define FLX_HAVE_EVTPORTS 1")
 else:
  tangle("#define FLX_HAVE_EVTPORTS 0")

//
#if FLX_HAVE_CGOTO && FLX_HAVE_ASM_LABELS
#define FLX_CGOTO 1
#else
#define FLX_CGOTO 0
#endif

#if FLX_WIN32
#define _WIN32_WINNT 0x0600 // Require Windows NT5 (2K, XP, 2K3)
#define WINVER 0x0600 // Require Windows NT5 (2K, XP, 2K3)
// vs windows.h just LOVES to include winsock version 1 headers by default.
// that's bad for everyone, so quit it.
#define _WINSOCKAPI_
#endif


#if !defined(FLX_STATIC_LINK) && FLX_WIN32
#define FLX_EXPORT __declspec(dllexport)
#define FLX_IMPORT __declspec(dllimport)
#else
#define FLX_EXPORT
#define FLX_IMPORT
#endif


#ifdef BUILD_RTL
#define RTL_EXTERN FLX_EXPORT
#else
#define RTL_EXTERN FLX_IMPORT
#endif

#if FLX_MACOSX && !FLX_HAVE_DLOPEN
#define FLX_MACOSX_NODLCOMPAT 1
#else
#define FLX_MACOSX_NODLCOMPAT 0
#endif

#if FLX_HAVE_GNU
#define FLX_ALWAYS_INLINE __attribute__ ((always_inline))
#define FLX_NOINLINE __attribute__ ((noinline))
#define FLX_CONST __attribute__ ((const))
#define FLX_PURE __attribute__ ((pure))
#define FLX_GXX_PARSER_HACK (void)0,
#define FLX_UNUSED __attribute__((unused))
#else
#define FLX_ALWAYS_INLINE
#define FLX_NOINLINE 
#define FLX_CONST
#define FLX_PURE 
#define FLX_GXX_PARSER_HACK
#define FLX_UNUSED
#endif

@def cal_raw_address():
  if SIZEOF_INT == SIZEOF_VOIDP: return "unsigned"
  if SIZEOF_LONG == SIZEOF_VOIDP: return "unsigned long"
  if SIZEOF_LONGLONG == SIZEOF_VOIDP: return "unsigned long long"
  raise "Cannot find an int the size of a void pointer"

@tangle("#define FLX_RAWADDRESS "+cal_raw_address())
@tangle('#define FLX_MAX_ALIGN '+str(MAX_ALIGN))
#endif
@doc()

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@select(tangler("rtl/flx_rtl.hpp"))
#ifndef __FLX_RTL_H__
#define __FLX_RTL_H__
#include "flx_rtl_config.hpp"
#include "flx_meta.hpp"
#include "flx_gc.hpp"
#include <string>
#include <functional>

#if FLX_PTF_STATIC_STRUCT
#define PTF ptf.
#elif FLX_PTF_STATIC_POINTER
#define PTF ptf->
#else
#define PTF ptf->
#endif

// for declarations in header file 
#if FLX_PTF_STATIC_STRUCT
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t ptf;
#elif FLX_PTF_STATIC_POINTER
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t *ptf;
#else
#define FLX_FMEM_DECL thread_frame_t *ptf;
#define FLX_FPAR_DECL_ONLY thread_frame_t *_ptf
#define FLX_FPAR_DECL thread_frame_t *_ptf,
#define FLX_APAR_DECL_ONLY thread_frame_t *ptf
#define FLX_APAR_DECL thread_frame_t *ptf,
#define FLX_DCL_THREAD_FRAME
#endif

#if FLX_CGOTO
  #define FLX_PC_DECL void *pc;
#else
  #define FLX_PC_DECL int pc;
#endif


namespace flx { namespace rtl {

// ********************************************************
// Felix system classes
// ********************************************************

struct RTL_EXTERN con_t;     // continuation
struct RTL_EXTERN thread_t; // f-thread
struct RTL_EXTERN _ref_;     // pointer/reference
struct RTL_EXTERN _uctor_;   // union constructor
struct RTL_EXTERN schannel_t;   // synchronous channel type
struct RTL_EXTERN slist_t;   // singly linked list of void*
struct RTL_EXTERN _root_ptr_t;   // singly linked list of void*

struct RTL_EXTERN unit {};   // unit 
  // INLINE DEFINITION, PROBLEMATIC!!

// ********************************************************
// Shape (RTTI) objects for system classes 
// con_t is only an abstract base, so has no fixed shape
// shapes for instance types generated by Felix compiler
// we provide a shape for C 'int' type as well
// ********************************************************

RTL_EXTERN extern flx::gc::generic::gc_shape_t _fthread_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t schannel_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _ref_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _uctor_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _int_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t unit_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t slist_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _root_ptr_ptr_map;

// ********************************************************
// Standard C++ Exceptions
// ********************************************************

struct RTL_EXTERN flx_exception_t;
struct RTL_EXTERN flx_exec_failure_t;
struct RTL_EXTERN flx_range_srcref_t;
struct RTL_EXTERN flx_match_failure_t;
struct RTL_EXTERN flx_assert_failure_t;
struct RTL_EXTERN flx_assert2_failure_t;
struct RTL_EXTERN flx_switch_failure_t;
// ********************************************************
/// CONTINUATION.
// ********************************************************

struct RTL_EXTERN con_t ///< abstract base for mutable continuations
{
  FLX_PC_DECL               ///< interior program counter
  _uctor_ *p_svc;           ///< pointer to service request

  con_t();                  ///< initialise pc, p_svc to 0
  virtual con_t *resume()=0;///< method to perform a computational step
  virtual ~con_t();
  con_t * _caller;          ///< callers continuation (return address)
};

// ********************************************************
/// SLIST. singly linked lists: SHARABLE and COPYABLE
/// SLIST manages pointers to memory managed by the collector
// ********************************************************

struct RTL_EXTERN slist_t {
  gc::generic::collector_t *gc;
  struct slist_node_t *head;

  slist_t (gc::generic::collector_t *); ///< create empty list
  slist_t (slist_t const &);            ///< shallow copy

  void push(void *data);                ///< push a gc pointer
  void *pop();                          ///< pop a gc pointer
  bool isempty()const;
};

// ********************************************************
/// FTHREAD. Felix threads
// ********************************************************

struct RTL_EXTERN fthread_t // fthread abstraction
{
  con_t *cc;                    ///< current continuation

  fthread_t();                  ///< dead thread, suitable for assignment
  fthread_t(con_t*);            ///< make thread from a continuation
  _uctor_ *run();               ///< run until dead or driver service request
  void kill();                  ///< kill by detaching the continuation
  _uctor_ *get_svc()const;      ///< get current service request of waiting thread
private: // uncopyable
  fthread_t(fthread_t const&); 
  void operator=(fthread_t const&);
};

// ********************************************************
/// SCHANNEL. Synchronous channels
// ********************************************************

struct RTL_EXTERN schannel_t 
{
  slist_t *waiting_to_read;             ///< fthreads waiting for a writer
  slist_t *waiting_to_write;            ///< fthreads waiting for a reader
  schannel_t(gc::generic::collector_t*);
  void push_reader(fthread_t *);        ///< add a reader
  fthread_t *pop_reader();              ///< pop a reader, NULL if none
  void push_writer(fthread_t *);        ///< add a writer
  fthread_t *pop_writer();              ///< pop a writer, NULL if none
private: // uncopyable
  schannel_t(schannel_t const&); 
  void operator= (schannel_t const&); 
};

// ********************************************************
/// REFERENCE. Felix pointer type
/// note: non-polymorphic, so ctor can be inline
/// This type is used to represent pointers to variables.
/// It has two components: a frame pointer and offset.
/// A whole frame is refered to by setting the offset to 0.
/// A non-collectable pointer is refered to by setting the frame to 0
/// References are first class values: they can copied, assigned,
/// and default constructed. Holding a reference in a location
/// known to the gc ensures the target variable is not collected:
/// Such references cannot dangle.
/// The frame/offset representation was chosen since it fits
/// well with a copying collector: the price is that finding
/// the interior pointer requires adding the offset to the frame
/// pointer. Note that 'frame' points to the CLIENTDATA address
/// of a frame where user data starts: this is not the lowest
/// machine address of the frame's allocated memory or FRAME
/// address, despite the name.
// ********************************************************

struct RTL_EXTERN _ref_
{
  void *frame;      ///< Heap frame pointer
  std::ptrdiff_t offset;   ///< Client Data offset

  _ref_() : frame(0),offset(0) {} ///< NULL reference
  _ref_(void *f, void *d): 
    frame(f), offset((unsigned char*)d-(unsigned char*)f) {} 
      ///< init from interior pointer d of a collectable frame f
  
  _ref_(void *f, std::ptrdiff_t d): 
    frame(f), offset(d) {} ///< init from collectable frame f and offset d

  _ref_(_ref_ const& r) : frame(r.frame), offset(r.offset) {} 
    ///< copy constructor

  void operator = (_ref_ const& r); ///< assignment operator

  void *get_data()const { return (unsigned char*)frame + offset; } 
    ///< get interior pointer
    
  void set_data(void *p) 
    { offset = (unsigned char*)p - (unsigned char*)frame; } 
    ///< set interior pointer into same frame

  void set(void *f, void *p) 
  { frame = f; offset = (unsigned char*)p - (unsigned char*)f; } ///< set from frame f and interior pointer
};


// ********************************************************
/// VARIANTS. Felix union type
/// note: non-polymorphic, so ctor can be inline
// ********************************************************

struct RTL_EXTERN _uctor_
{
  int variant;  ///< Variant code
  void *data;   ///< Heap variant constructor data
  _uctor_() : variant(-1), data(0) {}
  _uctor_(int i, void *d) : variant(i), data(d) {}
  _uctor_(int *a, _uctor_ x) : variant(a[x.variant]), data(x.data) {}
};

// ********************************************************
/// ROOT POINTER.
/// Use to chain pseudo roots together. Generally scannable
/// but not collectable. 
// ********************************************************

struct RTL_EXTERN _root_ptr_t
{
  _root_ptr_t();
  _root_ptr_t(void *x);
  _root_ptr_t(_root_ptr_t const&);
  void operator=(_root_ptr_t const&);
  ~_root_ptr_t();

  _root_ptr_t *next;
  _root_ptr_t *prev;
  void *data;

private:
  void insert_after (_root_ptr_t*);
  void erase();
};

// INLINE! All casts
template<class T>
struct root_ptr_t : _root_ptr_t {
  root_ptr_t(){}
  root_ptr_t(root_ptr_t<T> const&){}
  root_ptr_t<T>& operator=(root_ptr_t<T> const &a){
    return reinterpret_cast<root_ptr_t<T>&>(_root_ptr_t::operator=(a));
  }
 ~root_ptr_t(){}

  root_ptr_t(T const *a) : _root_ptr_t (const_cast<T*>(a)) {}
  
  T *operator->() { return (T*)data; }
  T const *operator->() const { return (T const*)data; }
  T &operator*() { return *(T*)data; }
  T const &operator*() const { return *(T const*)data; }
};

template<class T>
bool operator == (root_ptr_t<T> a, root_ptr_t<T> b)
{
  return a-> data == b->data;
}

template<class T>
bool operator != (root_ptr_t<T> a, root_ptr_t<T> b)
{
  return a-> data != b->data;
}

template<class T>
bool operator < (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::less<void const*>()(a-> data, b->data);
}

template<class T>
bool operator <= (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::less_equal<void const*>()(a-> data, b->data);
}

template<class T>
bool operator > (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::greater<void const*>()(a-> data, b->data);
}

template<class T>
bool operator >= (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::greater_equal<void const*>()(a-> data, b->data);
}


// ********************************************************
/// EXCEPTION: Felix exception base abstraction.
/// Mainly used to convert catches into subroutine
/// calls which then dispatch on RTTI manually.
// ********************************************************

struct RTL_EXTERN flx_exception_t {
  virtual ~flx_exception_t()=0;
};

// ********************************************************
/// EXCEPTION: EXEC protocol failure.
/// Thrown when trying to run a dead procedure
// ********************************************************

struct RTL_EXTERN flx_exec_failure_t : flx_exception_t {
  std::string filename;  ///< dll filename
  std::string operation; ///< faulty operation
  std::string what;      ///< error description
  flx_exec_failure_t(std::string f, std::string o, std::string w);
  virtual ~flx_exec_failure_t();
};

// ********************************************************
/// SOURCE REFERENCE: to track places in user source code.
// ********************************************************

struct RTL_EXTERN flx_range_srcref_t {
  char *filename;  ///< source file name
  int startline;   ///< first line (1 origin)
  int startcol;    ///< first column (1 origin)
  int endline;     ///< last line
  int endcol;      ///< last column
  flx_range_srcref_t(char *f,int sl, int sc, int el, int ec);
  flx_range_srcref_t();
};

// ********************************************************
/// EXCEPTION: MATCH failure.
/// Thrown when no match cases match the argument of a match,
/// regmatch, or reglex
// ********************************************************

struct RTL_EXTERN flx_match_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char *cxx_srcfile;          ///< C++ file name
  int cxx_srcline;            ///< C++ line number
  flx_match_failure_t(flx_range_srcref_t ff, char *cf, int cl);
  virtual ~flx_match_failure_t();
};

// ********************************************************
/// EXCEPTION: ASSERT failure.
/// Thrown when user assertion fails
// ********************************************************

struct RTL_EXTERN flx_assert_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char *cxx_srcfile;          ///< C++ file
  int cxx_srcline;            ///< __LINE__ macro
  flx_assert_failure_t(flx_range_srcref_t ff, char *cf, int cl);
  virtual ~flx_assert_failure_t();
};

struct RTL_EXTERN flx_assert2_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  flx_range_srcref_t flx_loc2; ///< second location in Felix file
  char *cxx_srcfile;          ///< C++ file
  int cxx_srcline;            ///< __LINE__ macro
  flx_assert2_failure_t(flx_range_srcref_t ff, flx_range_srcref_t ff2, char *cf, int cl);
  virtual ~flx_assert2_failure_t();
};

// ********************************************************
/// EXCEPTION: RANGE failure.
/// Thrown when a range check fails
// ********************************************************

struct RTL_EXTERN flx_range_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char *cxx_srcfile;          ///< C++ file
  int cxx_srcline;            ///< __LINE__ macro
  flx_range_failure_t(flx_range_srcref_t ff, char *cf, int cl);
  virtual ~flx_range_failure_t();
};

RTL_EXTERN long range_check (long l, long x, long h, flx_range_srcref_t sref, char *cf, int cl);


// ********************************************************
/// EXCEPTION: SWITCH failure. this is a system failure!
// ********************************************************

struct RTL_EXTERN flx_switch_failure_t : flx_exception_t {
  virtual ~flx_switch_failure_t();
};


// ********************************************************
// SERVICE REQUEST CODE
// THESE VALUES MUST SYNCH WITH THE STANDARD LIBRARY
// ********************************************************

enum svc_t               // what the dispatch should do
{                        // when the resume callback returns
  svc_yield = 0,
  svc_get_fthread=1,
  svc_read=2,
  svc_general=3,         // temporary hack by RF
  svc_reserved=4,
  svc_spawn_pthread=5,
  svc_spawn_detached=6,
  svc_sread=7,           // synchronous read
  svc_swrite=8,          // synchronous write
  svc_kill=9,           // kill fthread
  svc_compact=10,        // run compactor
  svc_collect=11,        // run collector
  svc_collect_and_compact=12,        // run collector and compactor
  svc_end
};

struct readreq_t {
  schannel_t *chan;
  _ref_ variable;
};

}} // namespaces

#define FLX_MATCH_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_match_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

#define FLX_ASSERT_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_assert_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

#define FLX_ASSERT2_FAILURE(f,sl,sc,el,ec,f2,sl2,sc2,el2,ec2) \
  throw flx::rtl::flx_assert2_failure_t (\
    flx_range_srcref_t(f,sl,sc,el,ec),\
    flx_range_srcref_t(f2,sl2,sc2,el2,sc2),\
    __FILE__,__LINE__)

#define FLX_RANGE_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_range_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

// for generated code in body file
#define INIT_PC pc=0;
    ///< interior program counter

#if FLX_CGOTO
  #define FLX_START_SWITCH if(pc)goto *pc;
  #define FLX_SET_PC(x) pc=&&case_##x;
  #define FLX_CASE_LABEL(x) case_##x:;
  #define FLX_DECLARE_LABEL(n,i,x) \
    extern void f##i##_##n##_##x(void) __asm__("l"#i"_"#n"_"#x);
  #define FLX_LABEL(n,i,x) x:\
    __asm__(".global l"#i"_"#n"_"#x);\
    __asm__("l"#i"_"#n"_"#x":");\
    __asm__(""::"g"(&&x));
  #define FLX_FARTARGET(n,i,x) (void*)&f##i##_##n##_##x
  #define FLX_END_SWITCH
#else
  #define FLX_START_SWITCH switch(pc){case 0:;
  #define FLX_SET_PC(x) pc=x;
  #define FLX_CASE_LABEL(x) case x:;
  #define FLX_DECLARE_LABEL(n,i,x)
  #define FLX_LABEL(n,i,x) case n: x:;
  #define FLX_FARTARGET(n,i,x) n
  #define FLX_END_SWITCH default: throw flx_switch_failure_t(); }
#endif

#define FLX_RETURN \
{ \
  con_t *tmp = _caller; \
  _caller = 0; \
  return tmp; \
}

#define FLX_NEWP(x) new(*PTF gc,x##_ptr_map)x

#define FLX_FINALISER(x) \
static void x##_finaliser(collector_t *, void *p){\
  ((x*)p)->~x();\
}

#if FLX_USE_REGPARM3 && FLX_HAVE_GNU_X86
#define FLX_REGPARM __attribute__((regparm(3)))
#else
#define FLX_REGPARM
#endif

#if FLX_PTF_STATIC_STRUCT
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define FLX_APAR_PASS_ONLY
#define FLX_APAR_PASS
#define _PTF _ptf.
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT_PTF(x)
#define FLX_DEF_THREAD_FRAME thread_frame_t ptf;
#elif FLX_PTF_STATIC_POINTER
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define FLX_APAR_PASS_ONLY
#define FLX_APAR_PASS
#define _PTF _ptf->
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT
#define FLX_DEF_THREAD_FRAME thread_frame_t *ptf=0;
#else
#define FLX_FMEM_INIT_ONLY : ptf(_ptf)
#define FLX_FMEM_INIT : ptf(_ptf),
#define FLX_FPAR_PASS_ONLY ptf
#define FLX_FPAR_PASS ptf,
#define FLX_APAR_PASS_ONLY _ptf
#define FLX_APAR_PASS _ptf,
#define _PTF _ptf->
#define _PTFV _ptf
#define FLX_PASS_PTF 1
#define FLX_EAT_PTF(x) x
#define FLX_DEF_THREAD_FRAME
#endif

#if FLX_PTF_STATIC_STRUCT
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  ptf.gc = gc;\
  return &ptf;\
}
#elif FLX_PTF_STATIC_POINTER
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  mname::thread_frame_t *p = new(*gc,mname::thread_frame_t_ptr_map) mname::thread_frame_t(gc);\
  ptf = p;\
  return p;\
}
#else
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" FLX_EXPORT mname::thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  mname::thread_frame_t *p = new(*gc,mname::thread_frame_t_ptr_map) mname::thread_frame_t(gc);\
  return p;\
}
#endif

#if FLX_PTF_STATIC_STRUCT
#define FLX_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,mname::x##_ptr_map) \
    mname::x()) ->call(0);\
}
#elif FLX_PTF_STATIC_POINTER
#define FLX_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,mname::x##_ptr_map) \
    mname::x()) ->call(0);\
}
#else 
#define FLX_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,mname::x##_ptr_map) \
    mname::x(ptf)) ->call(0);\
}
#endif

#if FLX_PTF_STATIC_STRUCT
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x().stack_call();\
  return 0;\
}
#elif FLX_PTF_STATIC_POINTER
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x().stack_call();\
  return 0;\
}
#else 
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x(ptf).stack_call();\
  return 0;\
}
#endif

#if FLX_PTF_STATIC_STRUCT
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x();\
  return 0;\
}
#elif FLX_PTF_STATIC_POINTER
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x();\
  return 0;\
}
#else 
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x(ptf);\
  return 0;\
}
#endif

#endif
@doc()

@select(tangler("rtl/flx_rtl.cpp"))
#include "flx_rtl.hpp"
#include <cstdio>
#include <cassert>

namespace flx { namespace rtl {

// ********************************************************
// con_t implementation
// ********************************************************

con_t::con_t() : pc(0), p_svc(0), _caller(0) { 
#if FLX_DEBUG_CONT
 fprintf(stderr,"Constructing %p\n",this);
#endif
}
con_t::~con_t(){
#if FLX_DEBUG_CONT
  fprintf(stderr,"Destroying %p\n",this);
#endif
}

// ********************************************************
// slist implementation
// ********************************************************

// PRIVATE to the slist_t class!
struct slist_node_t {
  slist_node_t *next;
  void *data;
  slist_node_t(slist_node_t *n, void *d) : next(n), data(d) {}
};

//OFFSETS for slist_node_t
static std::size_t slist_node_offsets[2]={
    offsetof(slist_node_t,next),
    offsetof(slist_node_t,data)
};

flx::gc::generic::gc_shape_t slist_node_ptr_map(
  NULL,
  "slist_node_t",
  1,sizeof(slist_node_t),
  0, // no finaliser,
  2,
  slist_node_offsets
);


slist_t::slist_t(gc::generic::collector_t *_gc) : gc (_gc), head(0) {}
slist_t::slist_t(slist_t const &r) : gc (r.gc), head(r.head) {}

bool slist_t::isempty()const { return head == 0; }

void slist_t::push(void *data) 
{
  head = new(*gc,slist_node_ptr_map) slist_node_t(head,data);
}

// note: never fails, return NULL pointer if the list is empty
void *slist_t::pop()
{
  if(head) { 
    void *data = head->data; 
    head=head->next; 
    return data; 
  }
  else return 0;
}

//OFFSETS for slist_t
static std::size_t slist_offsets[1]={
    offsetof(slist_t,head)
};

flx::gc::generic::gc_shape_t slist_ptr_map(
  &slist_node_ptr_map,
  "slist_t",
  1,sizeof(slist_t),
  0, // no finaliser
  1,
  slist_offsets
);

// ********************************************************
// _root_ptr_t implementation
// ********************************************************

_root_ptr_t::_root_ptr_t() : next(0), prev(0), data(0) {}
_root_ptr_t::_root_ptr_t(void *x) : next(0), prev(0), data(x) {}
_root_ptr_t::~_root_ptr_t() { erase(); }

void _root_ptr_t::insert_after(_root_ptr_t *a) {
  prev = a;
  next = prev->next;
  prev->next = this;
  if(next)next->prev = this;
  data = next->data;
}

_root_ptr_t::_root_ptr_t(_root_ptr_t const &a) {
  insert_after(const_cast<_root_ptr_t*>(&a));
}

void _root_ptr_t::operator=(_root_ptr_t const &a) {
  if (&a != this)
  {
    erase(); 
    insert_after(const_cast<_root_ptr_t*>(&a));
  }
}

//OFFSETS for root_ptr_t
static std::size_t _root_ptr_offsets[3]={
    offsetof(_root_ptr_t,next),
    offsetof(_root_ptr_t,prev),
    offsetof(_root_ptr_t,data)
};

flx::gc::generic::gc_shape_t _root_ptr_ptr_map(
  &slist_ptr_map,
  "_root_ptr_t",
  1,sizeof(_root_ptr_t),
  0, // no finaliser
  1,
  _root_ptr_offsets
);

void _root_ptr_t::erase() {
  next->prev = prev;
  prev->next = next;
  next = 0; prev = 0;
  data = 0;
}

// ********************************************************
// fthread_t implementation
// ********************************************************

fthread_t::fthread_t() : cc(0) {}
fthread_t::fthread_t(con_t *a) : cc(a) {}

// uncopyable object but implementation needed for linker
fthread_t::fthread_t(fthread_t const&){ assert(false); }
void fthread_t::operator=(fthread_t const&){ assert(false); }

void fthread_t::kill() { cc = 0; }

_uctor_ *fthread_t::get_svc()const { return cc?cc->p_svc:0; }

_uctor_ *fthread_t::run() {
  if(!cc) return 0; // dead
restep:
  cc->p_svc = 0;
step:  
  //fprintf(stderr,"cc=%p->",cc);
  try { cc = cc->resume(); }
  catch (con_t *x) { cc = x; }

  //fprintf(stderr,"->%p\n",cc);
  if(!cc) return 0; // died

  if(cc->p_svc)
  {
    switch(cc->p_svc->variant)
    {
      case svc_get_fthread: 
        **(fthread_t***)(cc->p_svc->data) = this;
        goto restep;      // handled
        
      //case svc_yield: 
      //  goto restep;

      // we don't know what to do with the request,
      // so pass the buck to the driver
      default:
        return cc->p_svc;
    }
  }
  goto step;
}


//OFFSETS for fthread_t
static std::size_t _fthread_offsets[1]={
    offsetof(fthread_t,cc)
};

flx::gc::generic::gc_shape_t _fthread_ptr_map(
  &_root_ptr_ptr_map,
  "fthread_t",
  1,sizeof(fthread_t),
  0,
  1,
  _fthread_offsets,
  gc::generic::gc_flags_immobile
);

// ********************************************************
// schannel_t implementation
// ********************************************************

schannel_t::schannel_t (gc::generic::collector_t *gc) : 
  waiting_to_read(0), waiting_to_write(0) 
{
  waiting_to_read = new (*gc, slist_ptr_map) slist_t(gc);
  waiting_to_write = new (*gc, slist_ptr_map) slist_t(gc);
}

// uncopyable object but implementation needed for linker
schannel_t::schannel_t(schannel_t const&) { assert(false); }
void schannel_t::operator=(schannel_t const&) { assert(false); }

void schannel_t::push_reader(fthread_t *r)
{
  waiting_to_read->push(r);
}

void schannel_t::push_writer(fthread_t *w)
{
  waiting_to_write->push(w);
}

fthread_t *schannel_t::pop_reader()
{
  return (fthread_t*)waiting_to_read->pop();
}

fthread_t *schannel_t::pop_writer()
{
  return (fthread_t*)waiting_to_write->pop();
}

//OFFSETS for schannel_t
static std::size_t schannel_offsets[2]={
    offsetof(schannel_t,waiting_to_read),
    offsetof(schannel_t,waiting_to_write)
};

flx::gc::generic::gc_shape_t schannel_ptr_map(
  &_fthread_ptr_map,
  "schannel_t",
  1,sizeof(schannel_t),
  0, // no finaliser
  2,
  schannel_offsets
);

// ********************************************************
// _ref_ implementation
// ********************************************************

void _ref_::operator = (_ref_ const& r)
{
  if (frame != r.frame || offset != r.offset)
  {
    frame = r.frame;
    offset = r.offset;
  }
}

//OFFSETS for _ref_
static std::size_t _ref_offsets[1]={
    offsetof(_ref_,frame)
};

flx::gc::generic::gc_shape_t _ref_ptr_map(
  &schannel_ptr_map,
  "_ref_",
  1,sizeof(_ref_),
  0, // no finaliser
  1,
  _ref_offsets
);

// ********************************************************
// _uctor_ implementation
// ********************************************************

//OFFSETS for _uctor_
static std::size_t _uctor_offsets[1]= { 
  offsetof(_uctor_,data) 
};

flx::gc::generic::gc_shape_t _uctor_ptr_map (
  &_ref_ptr_map,
  "_uctor_",
  1,
  sizeof(_uctor_),
  0,
  1,
  _uctor_offsets
);

// ********************************************************
// int implementation
// ********************************************************

flx::gc::generic::gc_shape_t _int_ptr_map (
  &_uctor_ptr_map,
  "int",
  1,
  sizeof(int),
  0,
  0,
  0
);

// ********************************************************
// unit implementation
// ********************************************************

flx::gc::generic::gc_shape_t unit_ptr_map (
  &_int_ptr_map,
  "unit",
  1,
  sizeof(unit),
  0,
  0,
  0
);
                                                                                
// ********************************************************
// standard exceptions -- implementation
// ********************************************************
flx_exception_t::~flx_exception_t(){}

flx_exec_failure_t::flx_exec_failure_t(std::string f, std::string o, std::string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_exec_failure_t::~flx_exec_failure_t(){}

flx_range_srcref_t::flx_range_srcref_t() : 
    filename(""),startline(0),startcol(0),endline(0),endcol(0){}
flx_range_srcref_t::flx_range_srcref_t(char *f,int sl, int sc, int el, int ec) :
    filename(f),startline(sl),startcol(sc),endline(el),endcol(ec){}

flx_match_failure_t::flx_match_failure_t(flx_range_srcref_t ff, char *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_match_failure_t::~flx_match_failure_t(){}

flx_assert_failure_t::flx_assert_failure_t(flx_range_srcref_t ff, char *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_assert_failure_t::~flx_assert_failure_t(){}

flx_assert2_failure_t::flx_assert2_failure_t(flx_range_srcref_t ff, flx_range_srcref_t ff2, char *cf, int cl) :
   flx_loc(ff), flx_loc2(ff2), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_assert2_failure_t::~flx_assert2_failure_t(){}

flx_range_failure_t::flx_range_failure_t(flx_range_srcref_t ff, char *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_range_failure_t::~flx_range_failure_t(){}

flx_switch_failure_t::~flx_switch_failure_t(){}

long range_check (long l, long x, long h, flx_range_srcref_t sref, char *cf, int cl) 
{
  if (x>=l && x<h) return x;
  throw flx::rtl::flx_range_failure_t (sref,cf,cl);
}


}}
@doc()

@head(2,"Unix Dynamic linker")
This is a Unix specific module, which uses dlopen
and friends to dynamically attach a shared file
representing a felix top level module to an 
application, and extract the standard 
symbols from it.

@p()
The link routine links the following symbols,
which must be present in all felix libraries.

@begin_displayed_code()
  create_thread_frame
  start
@end_displayed_code()

The unlink routine is called to unlink the library.
@p()

Note that felix never generates variables of static,
storage class, however felix has no control over
used C/C++ code embedded in Felix library modules.
DO NOT use static storage class for variables,
or even constants which require dynamic initialisation.

@select(tangler("rtl/flx_dynlink.hpp"))
#ifndef __FLX_DYNLINK_H__
#define __FLX_DYNLINK_H__
#ifndef FLX_RTL
#include "flx_rtl.hpp"
#include "flx_gc.hpp"
#endif
#include <string>
using namespace std;

// define dynamic library loader stuff, even for static linkage
#if FLX_WIN32
  #include <windows.h>
  typedef HMODULE LIBHANDLE;
  #define FLX_SET_NOLIBRARY(lib) lib=NULL
  #define FLX_CHECK_NOLIBRARY(lib) (lib==NULL)
  #define FLX_LIB_EXTENSION ".DLL"
  #define FLX_DLSYM(x,y) (void*)GetProcAddress(x,#y) 
  #define FLX_SDLSYM(x,y) (void*)GetProcAddress(x,y) 
#elif FLX_MACOSX_NODLCOMPAT
  #include <mach-o/dyld.h>
  typedef NSModule LIBHANDLE;
  #define FLX_SET_NOLIBRARY(lib) lib=NULL
  #define FLX_CHECK_NOLIBRARY(lib) (lib==NULL)
  #define FLX_LIB_EXTENSION ".dylib"
  #define FLX_DLSYM(x, y) flx::rtl::getmachosym(x,"_"#y)
  #define FLX_SDLSYM(x, y) flx::rtl::getmachosym(x,(string("_")+string(y)).data())
#else
  // UNIX, recent OSX
  typedef void *LIBHANDLE;
  #define FLX_SET_NOLIBRARY(lib) lib=NULL
  #define FLX_CHECK_NOLIBRARY(lib) (lib==NULL)
  #if FLX_CYGWIN
    #define FLX_LIB_EXTENSION ".dll"
  #elif FLX_MACOSX
    #define FLX_LIB_EXTENSION ".dylib"
  #else
    #define FLX_LIB_EXTENSION ".so"
  #endif
  #include <dlfcn.h>
  #define FLX_DLSYM(x,y) dlsym(x,#y)
  #define FLX_SDLSYM(x,y) dlsym(x,y)
#endif

#ifndef FLX_STATIC_LINK
  #define DLSYM(x,y) FLX_DLSYM(x,y)
  #define SDLSYM(x,y) FLX_SDLSYM(x,y)
#else
  #define DLSYM(x,y) (void*)&y
  #define SDLSYM(x,y) (throw flx::rtl::link_failure_t("<static link>",y,"dlsym with static link requires name not string")
#endif

// Utilities to make dynamic linkage and
// initialisation of Felix modules easier
//
// We provide a standard exception to report
// link failure (missing symbol).
//
// We provide a class flx_dynlink_t which
// opens a Felix shared library given a filename,
// and links the mandatory symbols
// The user may derive from this class to add
// linkage for extra symbols
//
// We provide a class flx_libinit_t which
// initialises and terminates a Felix module
// The user may derive from this class to add
// extra initialisation or termination processing.
//
// [Note: the virtuals are *deliberately* private. 
// Be sure to make your overrides private too,
// so they cannot be called:
// they're dispatched automatically by wrappers
// defined in the base]

// must be at global scope, because the users' is
struct thread_frame_t;

namespace flx { namespace rtl {

struct RTL_EXTERN flx_link_failure_t;
struct RTL_EXTERN flx_dynlink_t;
struct RTL_EXTERN flx_libinit_t;

/// Dynamic linkage failure.

struct RTL_EXTERN flx_link_failure_t : flx_exception_t {
  string filename;
  string operation;
  string what;
  flx_link_failure_t(string f, string o, string w);
  virtual ~flx_link_failure_t();
};

RTL_EXTERN LIBHANDLE
flx_load_library(char const *fname);

RTL_EXTERN LIBHANDLE
flx_load_module(char const *fname);

/// frame creators.

typedef thread_frame_t *(*thread_frame_creator_t)
(
  flx::gc::generic::collector_t*
);

/// library initialisation routine.

typedef con_t *(*start_t)
(
  thread_frame_t*,
  int,
  char **,
  FILE*,
  FILE*,
  FILE*
  
);

typedef con_t *(*main_t)(thread_frame_t*);

/// dynamic object loader.

struct RTL_EXTERN flx_dynlink_t
{
  // data
  LIBHANDLE library;
  string filename;
  thread_frame_creator_t thread_frame_creator;
  start_t start_sym;
  main_t main_sym;
  long refcnt;

  // routines
  void link(char const *filename) throw(flx_link_failure_t);
  void unlink();
  virtual ~flx_dynlink_t();
  flx_dynlink_t();

private:
  // the user should override this procedure to
  // link any extra symbols.
  // on error, throw a flx_link_failure_t,
  // otherwise your exception will be dishonoured
  // and a generic link_failure_t thrown anyhow

  flx_dynlink_t(flx_dynlink_t const&); // uncopyable
  void operator=(flx_dynlink_t const&); // uncopyable
  virtual void usr_link();
    // called after mandatory symbols are linked
};

/// Thread Frame Initialisation.

struct RTL_EXTERN flx_libinit_t 
{
  thread_frame_t *thread_frame;
  con_t *start_proc;
  con_t *main_proc;
  flx_dynlink_t *lib;
  flx::gc::generic::collector_t *collector;
  void create
  (
    flx_dynlink_t *lib_a, 
    flx::gc::generic::collector_t *collector_a,
    main_t main_sym,
    int argc,
    char **argv,
    FILE *stdin_,
    FILE *stdout_,
    FILE *stderr_
  );

  void destroy ();

  con_t *bind_proc(void *fn, void *data);
  virtual ~flx_libinit_t();
  flx_libinit_t();
  
private:
  flx_libinit_t(flx_libinit_t const&);
  void operator=(flx_libinit_t const&);
  // the user can override these procedures
  // to perform any additional initialisation
  // and termination required.
  
  virtual void usr_create(); 
    // called after standard init completes
    
  virtual void usr_destroy(); 
    // called before standard destroy starts
};

#if FLX_MACOSX_NODLCOMPAT
void* getmachosym(LIBHANDLE, const char*);
#endif

}} // namespaces
#endif
@doc()

@select(tangler("rtl/flx_dynlink.cpp"))
#include "flx_dynlink.hpp"
#include <cstring>
#include <cstdlib>

#ifdef FLX_STATIC_LINK
extern "C" void *create_thread_frame;
extern "C" void *flx_start;
extern "C" void *flx_main;
#endif

namespace flx { namespace rtl {

#if FLX_MACOSX_NODLCOMPAT
void*
getmachosym(NSModule library, const char* symname)
{
    NSSymbol    sym = NSLookupSymbolInModule(library, symname);
    if(sym)
        return NSAddressOfSymbol(sym);
    return 0;
}

#endif

flx_link_failure_t::flx_link_failure_t(string f, string o, string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_link_failure_t::~flx_link_failure_t(){}

flx_dynlink_t::~flx_dynlink_t() {}
flx_dynlink_t::flx_dynlink_t(flx_dynlink_t const&) {} // no copy hack
void flx_dynlink_t::operator=(flx_dynlink_t const&) {} // no copy hack
 
flx_dynlink_t::flx_dynlink_t() :
  library(0),
  filename(""), 
  thread_frame_creator(NULL),
  start_sym(NULL),
  main_sym(NULL),
  refcnt(0)
{}

LIBHANDLE
flx_load_library(char const *filename)
{
  LIBHANDLE library;
  FLX_SET_NOLIBRARY(library);

#ifndef FLX_STATIC_LINK
//#if FLX_WIN32 || FLX_CYGWIN
#if FLX_WIN32
  // stop windows showing err dialogues, ignoring error code.
  (void)SetErrorMode(SEM_NOOPENFILEERRORBOX);  
  library = LoadLibrary(filename);
  if(FLX_CHECK_NOLIBRARY(library)) 
    throw flx_link_failure_t(filename,"LoadLibrary","Cannot find dll");
#else
  #if FLX_MACOSX_NODLCOMPAT
    NSObjectFileImage            bndl_img;
    NSObjectFileImageReturnCode  res;

    res = NSCreateObjectFileImageFromFile(filename, &bndl_img);

    if(NSObjectFileImageSuccess != res)
      throw flx_link_failure_t(filename, "NSCreateObjectFileImageFromFile",
              "failure to open library");

    // don't merge globals with loader's, load programmatically
    // return on error allows us to continue without being terminated

    unsigned long                link_flags;
    link_flags = NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR;
    library = NSLinkModule(bndl_img, filename, link_flags);

    // even if link failed, we do this
    NSDestroyObjectFileImage(bndl_img);

    // more info can be gleaned about link errors from NSLinkEditError
    if(FLX_CHECK_NOLIBRARY(library))
      throw flx_link_failure_t(filename, "NSLinkModule", "failed to link");

  #else
    library = dlopen(filename,RTLD_NOW);
    if(FLX_CHECK_NOLIBRARY(library))
      throw flx_link_failure_t(filename,"dlopen",dlerror());
  #endif
#endif
#endif
  return library;
}

LIBHANDLE
flx_load_module(char const *fname)
{
  int n = std::strlen(fname)+strlen(FLX_LIB_EXTENSION)+1;
  char *f = (char*)std::malloc(n);
  std::strcpy(f,fname);
  std::strcat(f,FLX_LIB_EXTENSION);
  LIBHANDLE lib = flx_load_library(f);
  std::free(f);
  return lib;
}

void flx_dynlink_t::link(char const *fname) throw(flx_link_failure_t)
{
  filename=fname;
  library = flx_load_library(fname);
  //fprintf(stderr,"File %s dlopened at %p ok\n",fname,library);

  thread_frame_creator = (thread_frame_creator_t)
    DLSYM(library,create_thread_frame);
  if(!thread_frame_creator) 
    throw flx_link_failure_t(filename,"dlsym","create_thread_frame");

  //fprintf(stderr,"Thread frame creator found at %p\n",thread_frame_creator);

  start_sym = (start_t)DLSYM(library,flx_start);
  if(!start_sym) 
    throw flx_link_failure_t(filename,"dlsym","flx_start");

  main_sym = (main_t)DLSYM(library,flx_main);

  //fprintf(stderr,"Start symbol found at %p\n",start_sym);
  //fprintf(stderr,"main symbol found at %p\n",main_sym);
  
  refcnt = 1L;

  //fprintf(stderr,"Set refcnt to 1\n");
  try { usr_link(); }
  catch (flx_link_failure_t &) { throw; }
  catch (...) { 
    throw flx_link_failure_t
    (
      filename,
      "usr_link()",
      "Unknown user exception"
    );
  }
}

void flx_dynlink_t::unlink()
{
  --refcnt;
  if(refcnt == 0) {
    //fprintf(stderr,"closing library\n");
#ifndef FLX_STATIC_LINK
//#if FLX_WIN32 || FLX_CYGWIN
#if FLX_WIN32
    FreeLibrary(library);
#else
  #if FLX_MACOSX_NODLCOMPAT
    NSUnLinkModule(library, NSUNLINKMODULE_OPTION_NONE);
  #else
    dlclose(library);
  #endif
#endif
#endif
  }
}

void flx_dynlink_t::usr_link(){}

flx_libinit_t::~flx_libinit_t(){}
flx_libinit_t::flx_libinit_t() :
  thread_frame (NULL),
  start_proc (NULL),
  main_proc (NULL),
  lib (NULL),
  collector(NULL) 
{}

flx_libinit_t::flx_libinit_t(flx_libinit_t const&){}
void flx_libinit_t::operator=(flx_libinit_t const&){}

void flx_libinit_t::create
(
  flx_dynlink_t *lib_a, 
  flx::gc::generic::collector_t *collector_a,
  main_t main_sym,
  int argc,
  char **argv,
  FILE *stdin_,
  FILE *stdout_,
  FILE *stderr_
)
{
  lib = lib_a;
  collector = collector_a;
  thread_frame = lib->thread_frame_creator(
    collector 
  );
  //fprintf(stderr,"Incrementing refcnt\n");
  ++lib->refcnt;
  collector->add_root(thread_frame);
  start_proc = lib->start_sym(thread_frame, argc, argv, stdin_,stdout_,stderr_);
  main_proc = main_sym?main_sym(thread_frame):0;
  usr_create();
}

void flx_libinit_t::usr_create(){}

void flx_libinit_t::destroy () {
  usr_destroy();
  collector->remove_root(thread_frame);
  //fprintf(stderr,"Decrementing refcnt\n");
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
  --lib->refcnt;
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
}

void flx_libinit_t::usr_destroy (){}

con_t *flx_libinit_t::bind_proc(void *fn, void *data) {
  typedef con_t *(*binder_t)(void *,void*);
  return ((binder_t)fn)(thread_frame,data);
}

}} // namespaces
@doc()

@select(tangler("rtl/flx_sync.hpp"))
#ifndef __FLX_SYNC_H__
#define __FLX_SYNC_H__

#include "flx_gc.hpp"
#include "flx_dynlink.hpp"
#include "flx_rtl.hpp"
#include <list>

namespace flx { namespace run {

enum fstate_t { terminated, blocked, delegated };
enum fpc_t { next_fthread_pos, next_request_pos };

RTL_EXTERN char const * get_fstate_desc(fstate_t);
RTL_EXTERN char const * get_fpc_desc(fpc_t);

struct RTL_EXTERN gc_profile_t {
  bool debug_allocations;
  bool debug_collections; 
  unsigned long compact; 
  unsigned long gc_freq;
  unsigned long gc_counter;
  unsigned long collections;
  bool finalise;
  flx::gc::generic::collector_t *collector;

  gc_profile_t (
    bool debug_allocations_, 
    bool debug_collections_, 
    unsigned long compact_, 
    unsigned long gc_freq_,
    bool finalise_,
    flx::gc::generic::collector_t *collector
  );
  ~gc_profile_t();
};

struct RTL_EXTERN sync_state_t {
  bool debug_driver;
  gc_profile_t *gcp;
  std::list<flx::rtl::fthread_t*> *active;
  flx::rtl::fthread_t *ft;
  flx::rtl::_uctor_ *request;
  fpc_t pc;
  fstate_t fs;
  sync_state_t (
    bool debug_driver_,
    gc_profile_t *gcp_,
    std::list<flx::rtl::fthread_t*> *active_
  );
  void frun();
};

}}

#endif
@doc()

@select(tangler("rtl/flx_sync.cpp"))
#include "flx_sync.hpp"
using namespace flx::rtl;

namespace flx { namespace run {

RTL_EXTERN char const *get_fstate_desc(fstate_t fs)
{
  switch(fs)
  {
    case terminated: return "terminated";
    case blocked: return "blocked";
    case delegated: return "delegated";
    default: return "Illegal fstate_t";
  }
}

RTL_EXTERN char const *get_fpc_desc(fpc_t fpc)
{
  switch(fpc)
  {
    case next_fthread_pos: return "Next fthread pos";
    case next_request_pos: return "Next request pos";
    default: return "Illegal fpc_t";
  }
}


gc_profile_t::gc_profile_t (
  bool debug_allocations_, 
  bool debug_collections_, 
  unsigned long compact_, 
  unsigned long gc_freq_,
  bool finalise_,
  flx::gc::generic::collector_t *collector_
) :
  debug_allocations(debug_allocations_),
  debug_collections(debug_collections_),
  compact(compact_),
  gc_freq(gc_freq_),
  gc_counter(0),
  collections(0),
  finalise(finalise_),
  collector(collector_)
{
}

gc_profile_t::~gc_profile_t() { }

sync_state_t::sync_state_t (
  bool debug_driver_,
  gc_profile_t *gcp_,
  std::list<fthread_t*> *active_
) : 
  debug_driver(debug_driver_),
  gcp(gcp_),
  active(active_),
  pc(next_fthread_pos)
{}

void sync_state_t::frun()
{
  // local copies are faster
  flx::gc::generic::collector_t *collector = gcp->collector;

  // dispatch
  if (pc == next_request_pos) goto next_request;
  if (pc == next_fthread_pos) goto next_fthread;
  fprintf(stderr,"BUG -- unreachable code in frun\n");
  abort();

next_fthread:
  if (active->size() == 0) {
    fs = blocked; 
    pc = next_fthread_pos;
    return; 
  }
  ft = active->front();
  active->pop_front();

next_request:
  request = ft->run();
  if(request != 0) goto check_collect;

forget_fthread:
  if(debug_driver)fprintf(stderr,"unrooting fthread %p\n",ft);
  collector->remove_root(ft);
  goto next_fthread;

delegate:
  pc = next_request_pos;
  fs = delegated;
  return;

check_collect:  
  //gcp->gc_counter++;
  //if(gcp->gc_counter == gcp->gc_freq)
  //{
  //  gcp->gc_counter = 0;
  //  gcp->collections++;
  //  unsigned long n = collector->collect();
  //  if(gcp->compact) collector->compact(true);
  //  if(gcp->debug_collections)fprintf(stderr,"collected %ld objects\n",n);
  //}
    
  switch(request->variant)
  {
    case svc_yield: 
    {
      if(debug_driver)fprintf(stderr,"yield");
      active->push_back(ft);
    }
    goto next_fthread;

    case svc_spawn_detached:
    {
      fthread_t *ftx = *(fthread_t**)request->data;
      if(debug_driver)fprintf(stderr,"Spawn thread %p\n",ftx);
      collector->add_root(ftx);
      active->push_front(ftx);
    }
    goto next_request;

    case svc_sread:
    {
      readreq_t * pr = (readreq_t*)request->data;
      schannel_t *chan = pr->chan;
      if(debug_driver)fprintf(stderr,"Request to read on channel %p\n",chan);
    svc_read_next:
      {
        fthread_t *writer= chan->pop_writer();
        if(writer == 0) goto svc_read_none;       // no writers
        if(writer->cc == 0) goto svc_read_next;   // killed
        {
          readreq_t * pr = (readreq_t*)request->data;
          readreq_t * pw = (readreq_t*)writer->get_svc()->data;
          if(debug_driver)fprintf(stderr,"Writer @%p=%p, read into %p\n", pw->variable.get_data(),*(void**)pw->variable.get_data(), pr->variable.get_data());
          *(void**)pr->variable.get_data() = *(void**)pw->variable.get_data();
          active->push_front(writer);
          collector->add_root(writer);
        }
      }
      goto next_request;

    svc_read_none:
      if(debug_driver)fprintf(stderr,"No writers on channel %p: BLOCKING\n",chan);
      chan->push_reader(ft);
    }
    goto forget_fthread;

    case svc_swrite:
    {
      readreq_t * pr = (readreq_t*)request->data;
      schannel_t *chan = pr->chan;
      if(debug_driver)fprintf(stderr,"Request to write on channel %p\n",chan);
    svc_write_next:
      {
        fthread_t *reader= chan->pop_reader();
        if(reader == 0) goto svc_write_none;     // no readers
        if(reader->cc == 0) goto svc_write_next; // killed
        {
          readreq_t * pw = (readreq_t*)request->data;
          readreq_t * pr = (readreq_t*)reader->get_svc()->data;
          if(debug_driver)fprintf(stderr,"Writer @%p=%p, read into %p\n", pw->variable.get_data(),*(void**)pw->variable.get_data(), pr->variable.get_data());
          *(void**)pr->variable.get_data() = *(void**)pw->variable.get_data();
          active->push_front(reader);
          collector->add_root(reader);
        }
      }
      goto next_request;

    svc_write_none:
      if(debug_driver)fprintf(stderr,"No readers on channel %p: BLOCKING\n",chan);
      chan->push_writer(ft);
    }
    goto forget_fthread;
    
    case svc_kill:
    {
      fthread_t *ftx = *(fthread_t**)request->data;
      if(debug_driver)fprintf(stderr,"Request to kill fthread %p\n",ftx);
      ftx -> kill();
    }
    goto next_request;

    default:  goto delegate;
  } 
  fprintf(stderr,"BUG unreachable code executed\n");
  abort();
}

}}
@doc()

@head(2,'Universal Program Driver')
This driver runs stand alone Felix programs.
It invokes the library routine 'start'.
No messages are dispatched, the Felix
program must not read any messages.

@p()
For statically linked programs,
command line arguments are passed directly,
the debugging switch isn't supported.

@p()
For dynamically loaded programs, the name of the
driver and optional --debug switch given before the
shared library name are not passed.

@select(tangler('rtl/flx_async.hpp','hpp'))
#ifndef __FLX_ASYNC_H__
#define __FLX_ASYNC_H__
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"

#ifdef BUILD_ASYNC
#define ASYNC_EXTERN FLX_EXPORT
#else
#define ASYNC_EXTERN FLX_IMPORT
#endif

// GLOBAL NAMESPACE!

class ASYNC_EXTERN async_hooker {
public:
  virtual flx::rtl::fthread_t *dequeue()=0;
  virtual bool handle_request(void *data, flx::rtl::fthread_t *ss)=0;
  virtual ~async_hooker();
};

typedef 
async_hooker *
create_async_hooker_t
(
  int n0,   // bound on resumable thread queue
  int n1,   // bound on general input job queue
  int m1,   // number of threads in job pool
  int n2,   // bound on async fileio job queue
  int m2    // number of threads doing async fileio
);

extern "C" {
ASYNC_EXTERN async_hooker *
create_async_hooker
(
  int n0,   // bound on resumable thread queue
  int n1,   // bound on general input job queue
  int m1,   // number of threads in job pool
  int n2,   // bound on async fileio job queue
  int m2    // number of threads doing async fileio
);
}

#endif
@doc()

@select(tangler('rtl/flx_async.cpp','cpp'))
#include "flx_async.hpp"
#include "pthread_sleep_queue.hpp"
#include "flx_rtl.hpp"
#include "demux_demuxer.hpp"
#include "faio_drv.hpp"

using namespace flx::rtl;
using namespace flx::demux;
using namespace flx::faio;
using namespace flx::pthread;


class async_hooker_impl : public async_hooker {
  virtual flx::faio::flx_drv *get_driver()=0;
  virtual flx::demux::demuxer *get_demuxer()=0;
public:
  bool handle_request(void *data,fthread_t *ss);
  ~async_hooker_impl();
};


#if FLX_WIN32
 #include "demux_iocp_demuxer.hpp"
 #include "faio_wdrv.hpp"
 typedef flx::demux::iocp_demuxer flx_demuxer;
#elif FLX_HAVE_KQUEUE_DEMUXER
 #include "demux_kqueue_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::kqueue_demuxer flx_demuxer;
#elif FLX_HAVE_EVTPORTS
 #include "demux_evtport_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::evtport_demuxer flx_demuxer;
#elif FLX_HAVE_EPOLL
 #include "demux_epoll_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::epoll_demuxer flx_demuxer;
#elif FLX_HAVE_POLL
 // NB!: on osx 10.3 poll exists, but is a poor cousin emulation layer on
 // top of select. however, 10.3 has kqueues (above), so should be ok...
 #include "demux_ts_poll_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::ts_poll_demuxer flx_demuxer;
#else
 #include "demux_ts_select_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::ts_select_demuxer flx_demuxer;  // thread safe!
#endif

#include "faio_asyncio.hpp"

async_hooker::~async_hooker(){ 
 //fprintf(stderr,"Deleted async_hooker\n"); 
}

async_hooker_impl::~async_hooker_impl(){ 
  //fprintf(stderr,"Deleted async_hooker_impl\n"); 
}

bool async_hooker_impl::handle_request(void *data,fthread_t *ft)
{
  flx::faio::flx_driver_request_base* dreq = 
        (flx::faio::flx_driver_request_base*)data
  ;

  //fprintf(stderr,"Request object at %p\n",dreq);
  // RF hates the flag this function returns .. might
  // mask a race condition, get rid of it

  bool result =dreq->start_async_op(
   *get_demuxer(), 
   get_driver(), 
  ft)
  ;
  return result;
}

class proto_async : public async_hooker_impl
{
   flx_demuxer demux;

    sleep_queue_t async_active;
    flx_thread_t ethread;

#if FLX_WIN32
    wflx_drv driver;
#else
    pflx_drv driver;
#endif
    static void pthread_thread(void* udat);

public:
   proto_async(int n0, int n1, int m1, int n2, int m2) : 
     async_active(n0), driver(async_active,n1,m1,n2,m2) 
   {
     // start waiting thread. note that we only have ONE event waiting thread.
     // that's currently important for clean takedowns
     if(ethread.init(pthread_thread, &demux) == -1) 
     {
       fprintf(stderr,"Proto_async thread init failure\n");
       exit(1);
     }
   }

  ~proto_async(){ 
    //fprintf(stderr,"Deleting proto async\n"); 
  }
  flx_drv *get_driver() { return &driver; }
  demuxer *get_demuxer(){ return &demux; }
  fthread_t* dequeue() 
  { 
    return (fthread_t*)async_active.dequeue(); 
  }
};

void
proto_async::pthread_thread(void* udat)
{
    demuxer*    d = (demuxer*)udat;

    while(1)
    {
        //fprintf(stderr, "ETHREAD ABOUT TO WAIT\n");
        d->wait();          // this does it
        //fprintf(stderr, "ETHREAD CHECKING QUIT FLAG\n");
        demux_quit_flag* f = d->get_quit_flag();
        if(f)
        {
          // got a quit flag - this is the very last thing we do before
          // exiting. don't use the demuxer after this as it's probably been
          // destructed.
          //fprintf(stderr, "ETHREAD GOT QUIT FLAG, SIGNALLING AND EXITING\n");
          f->signal_true();
          // in the case of a system takedown there's no guarantee that
          // anything after the signal_finish will be run at all, so this
          // is not a good place to put anything important.
          break;  // outta here
        }
    }
    //fprintf(stderr, "ETHREAD EXITING\n");
    // fprintf(stderr, "proto_async was asked to quit...\n");
}

async_hooker *create_async_hooker(int n0,int n1,int m1,int n2,int m2) {
  return new proto_async(n0,n1,m1,n2,m2);
}
@doc()

@select(tangler('rtl/flx_eh.hpp'))
#ifndef __FLX_EH_H__
#define __FLX_EH_H__
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"

namespace flx { namespace rtl {
void RTL_EXTERN print_loc(FILE *ef,flx::rtl::flx_range_srcref_t x,char *cf, int cl);
int RTL_EXTERN std_exception_handler (std::exception *e);
int RTL_EXTERN flx_exception_handler (flx::rtl::flx_exception_t *e);
}}

#endif

@select(tangler('rtl/flx_eh.cpp'))
#include <stdio.h>
#include "flx_rtl.hpp"
#include "flx_dynlink.hpp"
#include "flx_eh.hpp"
using namespace flx::rtl;

void flx::rtl::print_loc(FILE *ef,flx_range_srcref_t x,char *cf, int cl)
{
  fprintf(ef,"Felix location: %s %d[%d]-%d[%d]\n",
    x.filename,
    x.startline,
    x.startcol,
    x.endline,
    x.endcol
  );
  fprintf(ef,"C++ location  : %s %d\n", cf, cl);
}


int flx::rtl::std_exception_handler (std::exception *e)
{
  fprintf(stderr,"C++ STANDARD EXCEPTION %s\n",e->what());
  return 4;
}

int flx::rtl::flx_exception_handler (flx_exception_t *e)
{
  if (flx_link_failure_t *x = dynamic_cast<flx_link_failure_t*>(e))
  {
    fprintf(stderr,"Dynamic linkage error\n");
    fprintf(stderr,"filename: %s\n",x->filename.data());
    fprintf(stderr,"operation: %s\n",x->operation.data());
    fprintf(stderr,"what: %s\n",x->what.data());
    return 2;
  }
  else
  if (flx_exec_failure_t *x = dynamic_cast<flx_exec_failure_t*>(e))
  {
    fprintf(stderr,"Execution error\n");
    fprintf(stderr,"filename: %s\n",x->filename.data());
    fprintf(stderr,"operation: %s\n",x->operation.data());
    fprintf(stderr,"what: %s\n",x->what.data());
    return 3;
  }
  else
  if (flx_assert_failure_t *x = dynamic_cast<flx_assert_failure_t*>(e))
  {
    fprintf(stderr,"Assertion Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  if (flx_assert2_failure_t *x = dynamic_cast<flx_assert2_failure_t*>(e))
  {
    fprintf(stderr,"Assertion2 Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    print_loc(stderr,x->flx_loc2,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  if (flx_match_failure_t *x = dynamic_cast<flx_match_failure_t*>(e))
  {
    fprintf(stderr,"Match Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  if (flx_range_failure_t *x = dynamic_cast<flx_range_failure_t*>(e))
  {
    fprintf(stderr,"Range Check Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  {
    fprintf(stderr,"Unknown EXCEPTION!\n");
    return 5;
  }
}
@doc()

@select(tangler('rtl/flx_run.include','cpp'))
#include <cstdlib>
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <cstring>
#include <cassert>

#include <string>
//#include <unistd.h>
#include "flx_rtl.hpp"

#include "flx_async.hpp"

#include "flx_ts_collector.hpp"
#include "flx_dynlink.hpp"
#include "flx_sync.hpp"
#include "pthread_thread.hpp"
#include "pthread_counter.hpp"
#include "flx_eh.hpp"

using namespace std;
using namespace flx::rtl;
using namespace flx::pthread;
using namespace flx::run;

#if FLX_HAVE_GNU_X86
register void *sp __asm__("esp");
#elif FLX_HAVE_GNU_X86_64
register void *sp __asm__("rsp");
#else
static void *sp = 0;
#endif

// non async drivers aren't don't depend on faio<-demux<-winsock
// and so aren't linked with mswsock and ws2_32
#if FLX_WIN32 && FLX_SUPPORT_ASYNC
  #include "demux_iocp_demuxer.hpp"
  // needed to perform win socket io (calls WSAInit). Must happen
  // before iocp_demuxer is instantiated and (I assume) happen
  // only once.
  // JS: No, it can be called any number of times, provided
  // the destructor WSACleanup is called same number of times
  // Use of this RAII object ensures WSAinit/Cleanup calls balance.
  // RF: Still has to happen before any socket calls. Putting it in
  // the async object which is created on command is already too late.
  // If that's a problem then any socket creation calls would have to
  // gratuitously make async calls.
  flx::demux::winsock_initer wsinit;
#endif


int do_final_cleanup(
  bool debug_driver, 
  gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
);

class thread_control_t
{
    unsigned int thread_counter;
    bool do_world_stop;
    flx_condv_t stop_guard;
    flx_mutex_t stop_mutex;
public: 
    thread_control_t () : do_world_stop(false), thread_counter(0) 
    {
      //fprintf(stderr,"INITIALISING THREAD CONTROL OBJECT\n");
    }

    int thread_count() {
      flx_mutex_locker_t m(stop_mutex);
      return thread_counter;
    }

    void add_thread() {
      flx_mutex_locker_t m(stop_mutex);
      //fprintf(stderr, "Adding thread\n");
      ++thread_counter; 
      stop_guard.broadcast();
    }
    void remove_thread() { 
      flx_mutex_locker_t m(stop_mutex);
      //fprintf(stderr, "Removing thread\n");
      --thread_counter; 
      stop_guard.broadcast();
    }

    // stop the world!
    bool world_stop() {
      flx_mutex_locker_t m(stop_mutex);
      //fprintf(stderr,"Stopping world\n");
      if (do_world_stop) return false; // race! Someone else beat us
      do_world_stop = true;
      --thread_counter;
      while(thread_counter>0) stop_guard.wait(&stop_mutex);
      //fprintf(stderr,"World STOPPED\n");
      return true; // we stopped the world
    }

    // used by mainline to wait for other threads to die
    void join_all() 
    {
      flx_mutex_locker_t m(stop_mutex);
      while(do_world_stop || thread_counter>0) stop_guard.wait(&stop_mutex);
      //fprintf(stderr,"World restarted: do_world_stop=%d, Yield thread count now %d\n",do_world_stop,thread_counter);
    }

    // restart the world
    void world_start() {
      flx_mutex_locker_t m(stop_mutex);
      //fprintf(stderr,"Restarting world\n");
      ++thread_counter;
      do_world_stop = false;
      stop_guard.broadcast();
    }

   void yield() {
      flx_mutex_locker_t m(stop_mutex);
      if (do_world_stop)
      {
        //fprintf(stderr,"Yield found world stop!\n");
        --thread_counter;
        //fprintf(stderr,"Yield thread count now %d\n",thread_counter);
        stop_guard.broadcast();
        while(do_world_stop) stop_guard.wait(&stop_mutex);
        ++thread_counter;
        //fprintf(stderr,"World restarted: do_world_stop=%d, Yield thread count now %d\n",do_world_stop,thread_counter);
      }
   }
};


struct doflx_data 
{
  bool debug_driver;
  gc_profile_t *gcp;
  std::list<fthread_t*> *active;
  thread_control_t *thread_control;
  doflx_data(bool d, gc_profile_t *g, std::list<fthread_t*> *a, thread_control_t *tc)
   : debug_driver(d), gcp(g), active(a), thread_control(tc) {}
};

static
create_async_hooker_t *ptr_create_async_hooker = NULL;

void doflx (void *data) {
  doflx_data *d = (doflx_data*)data;
  bool debug_driver = d->debug_driver;
  gc_profile_t *gcp = d-> gcp;
  std::list<fthread_t*> *active = d->active;
  thread_control_t *thread_control=d->thread_control;
  delete d;

  unsigned long async_count = 0;
  async_hooker* async = NULL;

  try 
  {
    sync_state_t ss(debug_driver, gcp, active);

  process_active:
    if(debug_driver)fprintf(stderr,"Process active ..");

    if(debug_driver)
      fprintf(stderr,"Before running: Sync state is %s/%s\n",
        get_fstate_desc(ss.fs),get_fpc_desc(ss.pc));

    ss.frun();

    if(debug_driver)
      fprintf(stderr,"After running: Sync state is %s/%s\n",
        get_fstate_desc(ss.fs),get_fpc_desc(ss.pc));

    if (ss.fs == terminated) goto cleanup;

    //fprintf(stderr, "Thread yielding ..");
    thread_control->yield();
    //fprintf(stderr, "..Thread resuming!\n");

    if (ss.fs == blocked) goto do_async;

    if (ss.fs == delegated) 
    switch (ss.request->variant)
    {
      case svc_compact:
      {
        // requires fthreads to be immobile
        if(debug_driver)fprintf(stderr,"svc compact\n");
        gcp->collector->compact(false);
      }
      goto process_active;

      case svc_collect:
      {
        // requires fthreads to be immobile
        if(debug_driver)fprintf(stderr,"svc collect\n");
        if (thread_control->world_stop())
        {
          if(debug_driver)fprintf(stderr,"ACTUALLY COLLECTING\n");
          gcp->collector->collect();
          thread_control->world_start();
        }
        else {
          if(debug_driver)fprintf(stderr,"RACE: someone else is collecting, just yield\n");
          thread_control->yield();
        }
      }
      goto process_active;

      case svc_collect_and_compact:
      {
        // requires fthreads to be immobile
        if(debug_driver)fprintf(stderr,"svc collect and compact\n");
        if (thread_control->world_stop())
        {
          gcp->collector->collect();
          gcp->collector->compact(true);
          thread_control->world_start();
        }
        else thread_control->yield();
      }
      goto process_active;

      case svc_spawn_pthread:
      {
        fthread_t *ftx = *(fthread_t**)ss.request->data;
        if(debug_driver)fprintf(stderr,"Spawn pthread %p\n",ftx);
        gcp->collector->add_root(ftx);
        std::list<fthread_t*> *pactive =new std::list<fthread_t*>;
        pactive->push_front(ftx);
        void *data = new doflx_data(debug_driver, gcp, pactive, thread_control);
        flx_detached_thread_t dummy;
        if(debug_driver)fprintf(stderr,"Starting new pthread, thread counter= %ld\n",thread_control->thread_count());
        thread_control->add_thread();
        dummy.init( doflx,data);
      }
      goto process_active;

      case svc_general:
      {
        if(debug_driver)
          fprintf(stderr,"svc_general from fthread=%p\n",ss.ft);
        if( !async )
        {
          if (ptr_create_async_hooker == NULL)
          {
#if !FLX_SUPPORT_ASYNC
             ptr_create_async_hooker = 0;
#else
             ptr_create_async_hooker = create_async_hooker;
  #ifndef FLX_STATIC_LINK
             LIBHANDLE async_lib = flx_load_module("libflx_async_dynamic");
             if (async_lib == NULL)
             {
               fprintf(stderr,"Unable to find module 'libflx_async_dynamic'\n");
               exit(1);
             }
             // debug only ..
             else { 
               if(debug_driver) 
                 fprintf(stderr, "module 'libflx_async_dynamic' loaded!\n"); 
             }
             ptr_create_async_hooker = (create_async_hooker_t*)
               DLSYM(async_lib,create_async_hooker)
             ;
             if (ptr_create_async_hooker == NULL)
             {
               fprintf(stderr,"Unable to find symbol 'create_async_hooker' in module 'libflx_async_dynamic'\n");
               exit(1);
             }
             // debug only
             else {
               if(debug_driver)
                 fprintf(stderr, "found 'create_async_hooker'!\n"); 
             }
  #endif          
#endif
          }
          if (ptr_create_async_hooker == NULL)
          {
            fprintf(stderr,"Unable to initialise async I/O system: terminating\n");
            exit(1);
          }
          async = (*ptr_create_async_hooker)(
            20000, // bound on resumable thread queue
            50,    // bound on general input job queue
            2,     // number of threads in job pool
            50,    // bound on async fileio job queue
            1      // number of threads doing async fileio
          );
        }
        ++async_count;
        void *dreq =  (((_ref_*)(ss.request->data))->get_data());

        //fprintf(stderr,"Request object at %p\n",dreq);
        // RF hates the flag this function returns .. might
        // mask a race condition, get rid of it
        if(!async->handle_request(dreq, ss.ft))
        {
          ss.pc = next_fthread_pos;
        } 
        else {
          --async_count;
          ss.pc = next_request_pos;
        }
      }
      goto process_active;

      default:
        fprintf(stderr,"Unknown service request code 0x%4x\n",ss.request->variant);
        abort();
    }
    fprintf(stderr,"Unknown frun return status 0x%4x\n",ss.fs);
    abort();

  do_async:
    // ran out of active threads - are there any in the async queue?
    if(debug_driver){
      fprintf(stderr, "out of active synchronous threads, trying async, count=%ld\n",async_count);
    }

    if(async && async_count > 0){
      // STILL A ROOT
      fthread_t* ftp = async->dequeue();
      if(debug_driver)
        fprintf(stderr,"Async Retrieving fthread %p\n",ftp);
      active->push_front(ftp);
      --async_count;
      ss.pc = next_fthread_pos;
      goto process_active;
    }

    if(debug_driver)fprintf(stderr,"Out of jobs\n");
  cleanup:;
  }
  catch (flx_exception_t &x) { flx_exception_handler (&x); }
  catch (std::exception &x) { std_exception_handler (&x); }
  catch (...) { fprintf(stderr,"Unknown exception in thread!\n"); }

  try
  {
    if(debug_driver)fprintf(stderr,"Terminating Felix subsystem\n");
    delete async;
    delete active;
  }
  catch (...) { fprintf(stderr,"Unknown exception deleting async!\n"); }

  // if this fails the whole system is corrupted
  thread_control->remove_thread();
}

// RUN A FELIX INSTANCE IN THE CURRENT PTHREAD
//
// CURRENTLY ONLY CALLED ONCE IN MAIN THREAD

int run_felix_pthread(
  bool debug_driver, 
  gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
)
{    
   flx::gc::generic::collector_t *collector = gcp->collector;
   std::list<fthread_t*> *active =new std::list<fthread_t*>;

  fthread_t *flx_main = NULL;
  {
    con_t *top = instance->main_proc;
    if(top)
    {
      flx_main = new (*collector,_fthread_ptr_map) fthread_t(top);
      collector->add_root(flx_main);
      active->push_front(flx_main);
    }
  }

  {
    con_t *top = instance->start_proc;
    fthread_t *ft = new (*collector,_fthread_ptr_map) fthread_t(top);
    collector->add_root(ft);
    active->push_front(ft);
  }

  {
    thread_control_t thread_control;
    thread_control.add_thread();
    
    doflx(new doflx_data(debug_driver, gcp, active, &thread_control)); // deletes active for us!
  
    if(debug_driver)fprintf(stderr,"MAIN THREAD FINISHED: waiting for other threads\n");
    thread_control.join_all();
    if(debug_driver)fprintf(stderr,"ALL THREADS DEAD: mainline cleanup!\n");

    if(debug_driver){
      unsigned long uncollected = collector->get_allocation_count();
      unsigned long roots = collector->get_root_count();
      fprintf(stderr,
        "program finished, %ld collections, %ld uncollected objects, roots %ld\n",
        gcp->collections,uncollected,roots);
    }
  }

  if(gcp->finalise)
    do_final_cleanup(debug_driver, gcp, library, instance);
  return 0;
}

// terminates process! 
// Not called by default (let the OS clean up)
// 
// NEEDS TO BE SPLIT UP so that destroying
// a program instance is separated from unloading
// the library

int do_final_cleanup(
  bool debug_driver, 
  gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
)
{
  flx::gc::generic::collector_t *collector = gcp->collector;

  // garbage collect application objects
  {
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Finalisation: pass 1 Data collection starts ..\n");
    unsigned long n = collector->collect();
    unsigned long a = collector->get_allocation_count();
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"flx_run collected %ld objects, %ld left\n",n,a);
  }

  // Destroy program instance/ thread frame object

  if(debug_driver)
    fprintf(stderr,"Destroying program instance\n");
  instance->destroy();

  // garbage collect system objects

  {
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Finalisation: pass 2 Final collection starts ..\n");
    unsigned long n = collector->collect();
    unsigned long a = collector->get_allocation_count();
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Collected %ld objects, %ld left (should be 0)\n",n,a);
    if(a!=0){
      fprintf(stderr,"flx_run %ld uncollected objects, should be zero!!\n",a);
      return 5;
    }
  }

  // dump the DLL

  if(debug_driver)
    fprintf(stderr,"Libref cnt = %ld\n",library->refcnt);
  if(library->refcnt >0)
  {
    if(debug_driver)
      fprintf(stderr,"flx_run %p library still referenced %ld times\n",
        library->library,library->refcnt
      );
  }
  if(debug_driver)
    fprintf(stderr,"Unlinking library ..\n");
  library->unlink();
  return 0;
}

// MAINLINE, ONLY DONE ONCE
int run_felix(
  bool debug_driver, 
  gc_profile_t *gcp,
  char *filename, 
  int flx_argc, 
  char **flx_argv
)
{
  try 
  {
    if(debug_driver)
      fprintf(stderr,"flx_run driver begins %s\n",flx_argv[0]);
    flx_dynlink_t library;
    flx_libinit_t instance;
    library.link(filename);

    flx::gc::generic::collector_t *collector = gcp->collector;

    instance.create(&library, collector,library.main_sym,flx_argc,flx_argv,stdin,stdout,stderr);

    if(debug_driver){
      fprintf(stderr,"loaded library %s at %p\n",filename,library.library);
      fprintf(stderr,"thread frame at %p\n",instance.thread_frame);
      fprintf(stderr,"initial continuation at %p\n",instance.start_proc);
      fprintf(stderr,"main continuation at %p\n",instance.main_proc);
    } 
    run_felix_pthread(debug_driver,gcp,&library,&instance);

    if(gcp->finalise)
    {
      if(library.refcnt >0)
      {
        fprintf(stderr,"flx_run %p library still referenced %ld times?!\n",library.library,library.refcnt);
        return 6;
      }
      if(debug_driver)
        fprintf(stderr,"flx_run driver ends with finalisation complete\n");
    }
    else 
    {
      if(debug_driver || gcp->debug_collections)
      {
        unsigned long a = collector->get_allocation_count();
        fprintf(stderr,"flx_run driver ends with finalisation skipped, %ld uncollected objects\n",a);
      }
    }
  }
  catch (flx_exception_t &x)
  {
    return flx_exception_handler(&x);
  }
  catch (...)
  {
    fprintf(stderr,"flx_run driver ends with unknown EXCEPTION\n");
    return 4;
  }
  return 0;
}
  
int main(int argc, char** argv)
{
#ifndef FLX_STATIC_LINK  
  bool static_link = false;
  if (argc<2) 
  {
    printf("usage: flx_run [--debug] dll_filename options ..\n");
    printf("  environment variables:\n");
    printf("  FLX_DEBUG               # enable debugging traces (default off)\n");
    printf("  FLX_DEBUG_ALLOCATIONS   # enable debugging allocator (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_COLLECTIONS   # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_DRIVER        # enable debugging driver (default FLX_DEBUG)\n");
    printf("  FLX_FINALISE            # whether to cleanup on termination (default NO)\n");
    printf("  FLX_COMPACT=n           # size of compaction arena, 0 to disable (default)\n");
    printf("  FLX_GC_FREQ=n           # how often to call garbage collector (default 1000)\n");
    return 1;
  }
  char *filename = argv[1];
  char **flx_argv = argv+1;
  int flx_argc = argc-1;
  bool debug = (argc > 1) && (strcmp(argv[1],"--debug")==0);
  if(debug)
  {
    if(argc<3)
    {
      printf("usage: flx_run [--debug] dll_filename options ..\n");
      return 1;
    }
    filename = argv[2];
    --flx_argc;
    ++flx_argv;
  }
#else
  bool static_link = true;
  char *filename = argv[0];
  char **flx_argv = argv;
  int flx_argc = argc;
  bool debug = false;

//  printf("Statically linked Felix program running\n");
#endif
  char *debug_env = std::getenv("FLX_DEBUG");
  debug = debug || debug_env != 0;
  if(debug)
  {
    fprintf(stderr,"[FLX_DEBUG] Debug enabled for %s link program\n",static_link?"static":"dynamic");
  }

  bool debug_allocations = debug || std::getenv("FLX_DEBUG_ALLOCATIONS") !=0;
  if(debug_allocations)
  {
    fprintf(stderr,"[FLX_DEBUG_ALLOCATIONS] Allocation debug enabled\n");
  }

  bool debug_collections = debug || std::getenv("FLX_DEBUG_COLLECTIONS") !=0;
  if(debug_collections)
  {
    fprintf(stderr,"[FLX_DEBUG_COLLECTIONS] Collection debug enabled\n");
  }


  bool debug_driver = debug || std::getenv("FLX_DEBUG_DRIVER") !=0;
  if(debug_driver)
  {
    fprintf(stderr,"[FLX_DEBUG_DRIVER] Driver debug enabled\n");
  }


  char *finalise_env= std::getenv("FLX_FINALISE");
  bool finalise = finalise_env != 0;

  if(debug) 
    fprintf(stderr,"[FLX_FINALISE] Finalisation %s\n",finalise? "Enabled" : "Disabled");

  char *compact_env= std::getenv("FLX_COMPACT");
  unsigned long compact = compact_env?atol(compact_env):0;
  if(debug)
  {
    if(compact)
      fprintf(stderr,"[FLX_COMPACT] Compacting with arena minimum size = %ldK\n",compact);
    else
      fprintf(stderr,"[FLX_COMPACT] Compaction initially OFF\n");
  }
  compact = compact * 1024;

  char *gc_freq_env= std::getenv("FLX_GC_FREQ");
  unsigned long gc_freq = gc_freq_env?atol(gc_freq_env):1000;
  if (gc_freq < 1) gc_freq = 1;
  if(debug)
    fprintf(stderr,"[FLX_GC_FREQ] call gc every %lu iterations\n",gc_freq);

#if FLX_HAVE_GNU
    if(debug)fprintf(stderr, "Compiled by g++\n");
    static void *init_sp = sp;
    static void *init_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *init_ret = __builtin_return_address(0);
    if(debug)fprintf(stderr, "Stack pointer = %p, frame=%p, return=%p\n",sp,init_fframe,init_ret);
#endif
  if(debug)
    for(int i=0; i<flx_argc; ++i) 
    fprintf(stderr,"flx_argv[%d]->%s\n",i,flx_argv[i]);
    
  flx::gc::generic::allocator_t *allocator = 
    new flx::gc::collector::malloc_free()
  ;
  allocator->set_debug(debug_allocations);

  flx::gc::collector::flx_collector_t *collector =
    new flx::gc::collector::flx_ts_collector_t(allocator)
  ;
  collector->set_debug(debug_collections);
  if(compact)
  {
    collector->set_min_arena_size(compact);
    collector->compact(false);
  }


  gc_profile_t *gcp = new gc_profile_t(
    debug_allocations, 
    debug_collections, 
    compact, 
    gc_freq,
    finalise,
    collector
  );
  run_felix(
    debug_driver,
    gcp,
    filename,flx_argc,flx_argv
  );

  delete gcp;
  delete collector;
  delete allocator;

#if FLX_HAVE_GNU
    // check the frame pointer isn't corrupted
    static void *fin_sp = sp;
    static void *fin_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *fin_ret = __builtin_return_address(0);
    if (init_sp != fin_sp ) {
      fprintf(stderr,"g++: STACK POINTER ERROR %p != %p\n",init_sp,fin_sp);
    }
// I have to comment this out, because it only applies if the
// gcc compiler is using the frame pointer.. it doesn't if you
// say -fomit-frame-pointer, for example .. I don't know if there
// is a way to tell inside the code ..
#if 0
    if (init_fframe != fin_fframe) {
      fprintf(stderr,"g++: FRAME POINTER ERROR %p != %p\n",init_fframe,fin_fframe);
    }
#endif
    else if (init_ret != fin_ret) {
      fprintf(stderr,"g++: RETURN ADDRESS ERROR %p != %p\n",init_ret,fin_ret);
    }
#endif
  if(debug)fprintf(stderr,"flx_run driver ends OK\n");
  return 0;
}
@doc()

@select(tangler('rtl/flx_run.cxx','cpp'))
#define FLX_SUPPORT_ASYNC 0

#include "flx_run.include"
@doc()

@select(tangler('rtl/flx_arun.cxx','cpp'))
#define FLX_SUPPORT_ASYNC 1

#include "flx_run.include"
@doc()

@select(tangler('rtl/flx_main.cpp','cpp'))
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"
// THIS IS A DO NOTHING MAINLINE FOR USE WHEN STATICALLY LINKING
extern "C" flx::rtl::con_t *flx_main( void *p){ return 0; }
@doc()

@select(tangler('test/drivers/mickey_mouse.cxx','cpp'))
#include <stdio.h>
#include "flx_rtl.hpp"
#include "flx_collector.hpp"
#include "flx_dynlink.hpp"

using namespace std;
using namespace flx;

int main(int argc, char** argv)
{
  rtl::flx_dynlink_t library;
  rtl::flx_libinit_t instance;
  library.link(argc>1?argv[1]:"<static>");
  gc::collector::malloc_free allocator;
  gc::collector::flx_collector_t collector(&allocator);
  instance.create(&library, &collector,library.main_sym,argc,argv,stdin,stdout,stderr);
  rtl::con_t *top = instance.start_proc;
  while( top ) top = top->resume();
  return 0;
}
@doc()

@select(tangler('rtl/flx_i18n.hpp'))
#ifndef __FLX_I18N_H__
#define __FLX_I18N_H__
#include <string>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace i18n {
   RTL_EXTERN std::string utf8(unsigned long);
}}}
#endif
@doc()

@select(tangler('rtl/flx_i18n.cpp'))
#include "flx_i18n.hpp"
namespace flx { namespace rtl { namespace i18n {
  std::string utf8(unsigned long i) 
  {
    char s[6];
    if (i < 0x80UL ) 
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL ) 
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL ) 
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL ) 
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL ) 
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else 
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}}
@doc()

@select(tangler('rtl/flx_ioutil.hpp'))
#ifndef FLX_IOUTIL
#define FLX_IOUTIL
#include <string>
#include <cstdio>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace ioutil {
  RTL_EXTERN std::string load_file (std::FILE *);
  RTL_EXTERN std::string load_file (std::string);
  RTL_EXTERN std::string readln(std::FILE*);
  RTL_EXTERN void write (std::FILE *, std::string);
  RTL_EXTERN void writeln (std::FILE *, std::string);
}}}
#endif
@doc()

@select(tangler('rtl/flx_ioutil.cpp'))
#include <cstdio>
#include <string>
#include "flx_ioutil.hpp"
namespace flx { namespace rtl { namespace ioutil {
  using namespace std;

  string load_file (FILE *fi)
  {
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  string load_file (string f)
  {
    char const *fname = f.data();
    FILE *fi = fopen(fname,"rt");
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  // includes newline if present
  // null string indicates end of file
  string readln (FILE *fi)
  {
    if(fi)
    {
      string x = "";
      char buffer[513];
      buffer[512]='\0';
      int n;
      while 
      ( 
        !(
          (n=x.size()) && 
          x[n-1]=='\n'
        ) 
        &&
        fgets(buffer,512,fi)
      )
        x = x + string(buffer);
      return x;
    }
    else return "";
  }

  void write (FILE *fi, string s)
  {
    fwrite(s.data(),s.size(),1,fi);
  }

  void writeln (FILE *fi, string s)
  {
    static char *eol = "\n";
    static int n = 0;
    if(n==0)n=strlen(eol);
    fwrite(s.data(),s.size(),1,fi);
    fwrite(eol,n,1,fi);
  }

}}}
@doc()

@select(tangler('rtl/flx_strutil.hpp'))
#include <string>
#include <sstream>
#include <stdarg.h>

#include "flx_rtl_config.hpp"

//RF: was only to commented out to fix macosx problem,
//but lets see what happens to all the other builds.
//#ifndef MACOSX
//template class RTL_EXTERN std::basic_string<char>;
//#endif

namespace flx { namespace rtl { namespace strutil {
  using namespace std;
  template<class T>
  basic_string<T> mul(basic_string<T> s, int n) {
    basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  basic_string<T> substr(basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }

  template<class T>
  T subscript(basic_string<T> const &s, int i)
  {
    int n = s.size();
    if(i<0)  i=i+n;
    return i<0 || i >= n ? T(0) : s[i];
  }

  template<class T>
  string str(T const &t) {
    std::ostringstream x;
    x << t;
    return x.str();
  }

  RTL_EXTERN string atostr(char const *a);
  RTL_EXTERN string ltrim(string const &x);
  RTL_EXTERN string rtrim(string const &x);
  RTL_EXTERN string flx_asprintf(char *fmt,...);

}}}
@doc()

@select(tangler('rtl/flx_strutil.cpp'))
#include "flx_strutil.hpp"

namespace flx { namespace rtl { namespace strutil {

  string atostr(char const *a) {
    if(a) return a;
    else return "";
  }

 string ltrim(string const &x) {
   int n = x.size();
   int i;
   for(i = 0; i < n; ++i)
     if(x[i]>' ')break;
   return x.substr(i,n-i);
 }

 string rtrim(string const &x) {
   int n = x.size();
   int i;
   for(i = n; i > 0; --i)
     if(x[i-1]>' ')break;
   return x.substr(0,i);
 }

#ifdef HAVE_VSNPRINTF  
  string flx_asprintf(char *fmt,...){
    va_list ap;
    va_start(ap,fmt);
    int n = vsnprintf(NULL,0,fmt,ap);
    va_end(ap);
    char *res = (char*)malloc(n+1);
    va_start(ap,fmt);
    vsnprintf(res,n+1,fmt,ap);
    va_end(ap);
    string s = string(res);
    free(res);
    return s;
  }
#else
  // THIS IS UNSAFE .. but Windows sucks.
  // It documents vsnprintf .. but doesn't provide it
  string flx_asprintf(char *fmt,...){
    va_list ap;
    int n = 1000;
    char *res = (char*)malloc(n+1);
    va_start(ap,fmt);
    vsprintf(res,fmt,ap);
    va_end(ap);
    string s = string(res);
    free(res);
    return s;
  }
#endif

}}}
@doc()
