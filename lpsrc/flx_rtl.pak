@head(1,"Run time driver support library")

@execfile('config'+os.sep+'flx_data.py')

This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@select(tangler('spkgs/flx_exceptions.py'))
cpp_cpps = [
  "rtl/flx_exceptions",
]

rtl_interfaces = [
  'rtl/flx_exceptions_config.hpp',
  'rtl/flx_exceptions.hpp',
]

pkg_requires = ['flx_rtl_config']
provides_lib = "libflx_exceptions"
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "FLX_EXCEPTIONS"
weaver_directory = 'doc/rtl/flx_exceptions/'
@doc()

@select(tangler('spkgs/flx_rtl.py'))
RTL_CPPS = [
  "rtl/flx_rtl",
  "rtl/flx_dynlink",
  "rtl/flx_sync",
  "rtl/flx_eh",
  "rtl/flx_i18n",
  "rtl/flx_ioutil",
  "rtl/flx_strutil",
  "rtl/flx_executil",
  "rtl/flx_main",
]

RTL_INTERFACES = [
  "rtl/flx_rtl.hpp",
	'rtl/flx_compiler_support_headers.hpp',
	'rtl/flx_compiler_support_bodies.hpp',
  'rtl/flx_dynlink.hpp',
	'rtl/flx_i18n.hpp',
	'rtl/flx_ioutil.hpp',
	'rtl/flx_strutil.hpp',
	'rtl/flx_executil.hpp',
]

cpp_cpps = RTL_CPPS
rtl_interfaces = RTL_INTERFACES
provides_lib = "libflx"
lib_requires = ['libflx_exceptions','libflx_gc','libflx_judy','libflx_pthread']
pkg_requires = ['flx_exceptions','flx_gc','flx_pthread']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "RTL"
weaver_directory = 'doc/rtl/flx_rtl/'
xfiles = []

@doc()

@select(tangler('spkgs/flx.py'))
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','flx_gc','flx_pthread','demux','faio','flx_stdlib']
@doc()

@select(tangler('spkgs/flx_async.py'))
cpp_cpps = ['rtl/flx_async']
provides_lib = "libflx_async"
pkg_requires = ['faio','demux','flx_pthread','flx_rtl','flx_gc']
lib_requires = ['libfaio','libdemux','libflx_pthread','libflx','libflx_gc','libflx_judy', 'libflx_exceptions']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "ASYNC"
@doc()

@select(tangler('spkgs/flx_drivers.py'))
STATIC_DRIVERS = [
  ('rtl/flx_run', 'lib'),
  ('test/drivers/flx_perf_drv1', ''),
  ('test/drivers/mickey_mouse', ''),
]

DYNAMIC_DRIVERS = [
  ('rtl/flx_run','bin/flx_run'),
  ('test/drivers/flx_perf_drv1','test/drivers/flx_perf_drv1'),
  ('test/drivers/mickey_mouse','bin/mickey_mouse'),
]

DRLIBS = [
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  'libflx_judy',
  ]

static_drivers = STATIC_DRIVERS
dynamic_drivers = DYNAMIC_DRIVERS
drivers_require_libs = DRLIBS
pkg_requires = ['flx_rtl','flx_pthread','flx_gc', 'flx_exceptions']
lib_requires = ['libdemux','libflx_pthread','libflx','libflx_judy', 'libflx_exceptions']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('spkgs/flx_async_drivers.py'))
STATIC_DRIVERS = [
  ('rtl/flx_arun',''),
]

DYNAMIC_DRIVERS = [
  ('rtl/flx_arun','bin/flx_arun'),
]

DRLIBS = [
  'libflx_async',
  'libfaio',
  'libdemux',
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  'libflx_judy',
  'libflx_exceptions',
  ]

static_drivers = STATIC_DRIVERS
dynamic_drivers = DYNAMIC_DRIVERS
drivers_require_libs = DRLIBS
pkg_requires = ['flx_gc','flx_rtl','flx_pthread','flx_async','demux','faio']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('config/flx_exceptions.fpc', 'data'))
Name: flx
Description: Felix exceptions 
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_exceptions_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_exceptions_static")
 else:
   tangle("provides_dlib: -lflx_exceptions_dynamic")
   tangle("provides_slib: -lflx_exceptions_static")
@doc()

@select(tangler('config/flx.fpc', 'data'))
Name: flx
Description: Felix core runtime support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_static")
 else:
   tangle("provides_dlib: -lflx_dynamic")
   tangle("provides_slib: -lflx_static")
Requires: flx_gc flx_exceptions
@doc()

@select(tangler('config/flx_arun.fpc', 'data'))
Name: flx_arun
Description: Felix standard driver, async support
Version: $Id$
Requires: flx_async faio demux flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_run.fpc', 'data'))
Name: flx_run
Description: Felix standard driver, no async support
Version: $Id$
Requires: flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_async.fpc', 'data'))
Name: flx_async
Description: Async hook
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_async_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_async_static")
 else:
   tangle("provides_dlib: -lflx_async_dynamic")
   tangle("provides_slib: -lflx_async_static")

Requires: faio demux flx_pthread flx flx_gc
@doc()

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@h=tangler('rtl/flx_exceptions_config.hpp')
@select(h)
#ifndef __FLX_EXCEPTIONS_CONFIG_H__
#define __FLX_EXCEPTIONS_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FLX_EXCEPTIONS
#define FLX_EXCEPTIONS_EXTERN FLX_EXPORT
#else
#define FLX_EXCEPTIONS_EXTERN FLX_IMPORT
#endif
#endif

@select(tangler("rtl/flx_exceptions.hpp"))
#ifndef __FLX_EXCEPTIONS_HPP__
#define __FLX_EXCEPTIONS_HPP__
#include "flx_exceptions_config.hpp"
#include <string>

namespace flx { namespace rtl {
// ********************************************************
// Standard C++ Exceptions
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_exception_t;
struct FLX_EXCEPTIONS_EXTERN flx_out_of_memory_t;
struct FLX_EXCEPTIONS_EXTERN flx_exec_failure_t;
struct FLX_EXCEPTIONS_EXTERN flx_range_srcref_t;
struct FLX_EXCEPTIONS_EXTERN flx_match_failure_t;
struct FLX_EXCEPTIONS_EXTERN flx_assert_failure_t;
struct FLX_EXCEPTIONS_EXTERN flx_assert2_failure_t;
struct FLX_EXCEPTIONS_EXTERN flx_switch_failure_t;

// ********************************************************
/// EXCEPTION: Felix exception base abstraction.
/// Mainly used to convert catches into subroutine
/// calls which then dispatch on RTTI manually.
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_exception_t {
  virtual ~flx_exception_t()=0;
};

// ********************************************************
/// EXCEPTION: Out of Memory.
/// Thrown when out of memory or memory bound exceeded.
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_out_of_memory_t : flx_exception_t {
  flx_out_of_memory_t();
  virtual ~flx_out_of_memory_t();
};

// ********************************************************
/// EXCEPTION: EXEC protocol failure.
/// Thrown when trying to run a dead procedure
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_exec_failure_t : flx_exception_t {
  std::string filename;  ///< dll filename
  std::string operation; ///< faulty operation
  std::string what;      ///< error description
  flx_exec_failure_t(std::string f, std::string o, std::string w);
  virtual ~flx_exec_failure_t();
};

// ********************************************************
/// SOURCE REFERENCE: to track places in user source code.
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_range_srcref_t {
  char const *filename;  ///< source file name
  int startline;   ///< first line (1 origin)
  int startcol;    ///< first column (1 origin)
  int endline;     ///< last line
  int endcol;      ///< last column
  flx_range_srcref_t(char const *f,int sl, int sc, int el, int ec);
  flx_range_srcref_t();
};

// ********************************************************
/// EXCEPTION: HALT.
/// Thrown by halt command
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_halt_t : flx_exception_t {
  std::string reason;         ///< halt argument
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char const *cxx_srcfile;          ///< C++ file name
  int cxx_srcline;            ///< C++ line number
  flx_halt_t(flx_range_srcref_t ff, char const *cf, int cl, std::string reason);
  virtual ~flx_halt_t();
};

// ********************************************************
/// EXCEPTION: MATCH failure.
/// Thrown when no match cases match the argument of a match,
/// regmatch, or reglex
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_match_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char const *cxx_srcfile;          ///< C++ file name
  int cxx_srcline;            ///< C++ line number
  flx_match_failure_t(flx_range_srcref_t ff, char const *cf, int cl);
  virtual ~flx_match_failure_t();
};

// ********************************************************
/// EXCEPTION: ASSERT failure.
/// Thrown when user assertion fails
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_assert_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char const *cxx_srcfile;          ///< C++ file
  int cxx_srcline;            ///< __LINE__ macro
  flx_assert_failure_t(flx_range_srcref_t ff, char const *cf, int cl);
  virtual ~flx_assert_failure_t();
};

struct FLX_EXCEPTIONS_EXTERN flx_assert2_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  flx_range_srcref_t flx_loc2; ///< second location in Felix file
  char const *cxx_srcfile;          ///< C++ file
  int cxx_srcline;            ///< __LINE__ macro
  flx_assert2_failure_t(flx_range_srcref_t ff, flx_range_srcref_t ff2, char const *cf, int cl);
  virtual ~flx_assert2_failure_t();
};

// ********************************************************
/// EXCEPTION: RANGE failure.
/// Thrown when a range check fails
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_range_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char const *cxx_srcfile;          ///< C++ file
  int cxx_srcline;            ///< __LINE__ macro
  flx_range_failure_t(flx_range_srcref_t ff, char const *cf, int cl);
  virtual ~flx_range_failure_t();
};

FLX_EXCEPTIONS_EXTERN long range_check (long l, long x, long h, flx_range_srcref_t sref, char const *cf, int cl);
FLX_EXCEPTIONS_EXTERN void print_loc(FILE *ef,flx_range_srcref_t x,char const *cf, int cl);


// ********************************************************
/// EXCEPTION: SWITCH failure. this is a system failure!
// ********************************************************

struct FLX_EXCEPTIONS_EXTERN flx_switch_failure_t : flx_exception_t {
  virtual ~flx_switch_failure_t();
};
}}
#endif

@select(tangler("rtl/flx_exceptions.cpp"))
#include "flx_exceptions.hpp"

namespace flx { namespace rtl {
// ********************************************************
// standard exceptions -- implementation
// ********************************************************
flx_exception_t::~flx_exception_t(){}

flx_exec_failure_t::flx_exec_failure_t(std::string f, std::string o, std::string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_out_of_memory_t::flx_out_of_memory_t(){}
flx_out_of_memory_t::~flx_out_of_memory_t(){}
flx_exec_failure_t::~flx_exec_failure_t(){}

flx_range_srcref_t::flx_range_srcref_t() : 
    filename(""),startline(0),startcol(0),endline(0),endcol(0){}
flx_range_srcref_t::flx_range_srcref_t(char const *f,int sl, int sc, int el, int ec) :
    filename(f),startline(sl),startcol(sc),endline(el),endcol(ec){}

flx_halt_t::flx_halt_t(flx_range_srcref_t ff, char const *cf, int cl, std::string r) :
   reason(r), flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_halt_t::~flx_halt_t(){}

flx_match_failure_t::flx_match_failure_t(flx_range_srcref_t ff, char const *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_match_failure_t::~flx_match_failure_t(){}

flx_assert_failure_t::flx_assert_failure_t(flx_range_srcref_t ff, char const *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_assert_failure_t::~flx_assert_failure_t(){}

flx_assert2_failure_t::flx_assert2_failure_t(flx_range_srcref_t ff, flx_range_srcref_t ff2, char const *cf, int cl) :
   flx_loc(ff), flx_loc2(ff2), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_assert2_failure_t::~flx_assert2_failure_t(){}

flx_range_failure_t::flx_range_failure_t(flx_range_srcref_t ff, char const *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_range_failure_t::~flx_range_failure_t(){}

flx_switch_failure_t::~flx_switch_failure_t(){}

long range_check (long l, long x, long h, flx_range_srcref_t sref, char const *cf, int cl) 
{
  if (x>=l && x<h) return x;
  throw flx::rtl::flx_range_failure_t (sref,cf,cl);
}

void print_loc(FILE *ef,flx_range_srcref_t x,char const *cf, int cl)
{
  fprintf(ef,"Felix location: %s %d[%d]-%d[%d]\n",
    x.filename,
    x.startline,
    x.startcol,
    x.endline,
    x.endcol
  );
  fprintf(ef,"C++ location  : %s %d\n", cf, cl);
}

}}

@select(tangler("rtl/flx_compiler_support_headers.hpp"))
#ifndef __FLX_COMPILER_SUPPORT_HEADERS_H__
#define __FLX_COMPILER_SUPPORT_HEADERS_H__
#include "flx_rtl_config.hpp"
#if defined(FLX_PTF_STATIC_STRUCT) && defined(FLX_PTF_STATIC_PTR)
#error defined(FLX_PTF_STATIC_STRUCT) && defined(FLX_PTF_STATIC_PTR)
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define PTF ptf.
#define FLX_POINTER_TO_THREAD_FRAME (&ptf)
#elif defined(FLX_PTF_STATIC_POINTER)
#define PTF ptf->
#define FLX_POINTER_TO_THREAD_FRAME ptf
#else
#define PTF ptf->
#define FLX_POINTER_TO_THREAD_FRAME ptf
#endif

// for declarations in header file 
#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t ptf;
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t *ptf;
#else
#define FLX_FMEM_DECL thread_frame_t *ptf;
#define FLX_FPAR_DECL_ONLY thread_frame_t *_ptf
#define FLX_FPAR_DECL thread_frame_t *_ptf,
#define FLX_APAR_DECL_ONLY thread_frame_t *ptf
#define FLX_APAR_DECL thread_frame_t *ptf,
#define FLX_DCL_THREAD_FRAME
#endif

#if FLX_CGOTO
  #define FLX_PC_DECL void *pc;
#else
  #define FLX_PC_DECL int pc;
#endif

#endif

@select(tangler("rtl/flx_compiler_support_bodies.hpp"))
#ifndef __FLX_COMPILER_SUPPORT_BODIES_H__
#define __FLX_COMPILER_SUPPORT_BODIES_H__
#include "flx_compiler_support_headers.hpp"


#define FLX_SAVE_REGS \
  jmp_buf reg_save_on_stack; \
  setjmp (reg_save_on_stack)


#define FLX_EXEC_FAILURE(f,op,what) \
  throw flx::rtl::flx_exec_failure_t (f,op,what)

#define FLX_HALT(f,sl,sc,el,ec,s) \
  throw flx::rtl::flx_halt_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__,s)

// note call should be trace(&v,...) however that requires
// compiler support to make a trace record for each tracepoint
// so we use NULL for now

#ifdef FLX_ENABLE_TRACE
#define FLX_TRACE(v,f,sl,sc,el,ec,s) \
  flx::rtl::flx_trace (NULL,flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__,s)
#else
#define FLX_TRACE(v,f,sl,sc,el,ec,s)
#endif

#define FLX_MATCH_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_match_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

#define FLX_ASSERT_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_assert_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

#define FLX_ASSERT2_FAILURE(f,sl,sc,el,ec,f2,sl2,sc2,el2,ec2) \
  throw flx::rtl::flx_assert2_failure_t (\
    flx_range_srcref_t(f,sl,sc,el,ec),\
    flx_range_srcref_t(f2,sl2,sc2,el2,sc2),\
    __FILE__,__LINE__)

#define FLX_RANGE_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_range_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

// for generated code in body file
#define INIT_PC pc=0;
    ///< interior program counter

#if FLX_CGOTO
  #define FLX_START_SWITCH if(pc)goto *pc;
  #define FLX_SET_PC(x) pc=&&case_##x;
  #define FLX_CASE_LABEL(x) case_##x:;
  #define FLX_DECLARE_LABEL(n,i,x) \
    extern void f##i##_##n##_##x(void) __asm__("l"#i"_"#n"_"#x);
  #define FLX_LABEL(n,i,x) x:\
    __asm__(".global l"#i"_"#n"_"#x);\
    __asm__("l"#i"_"#n"_"#x":");\
    __asm__(""::"g"(&&x));
  #define FLX_FARTARGET(n,i,x) (void*)&f##i##_##n##_##x
  #define FLX_END_SWITCH
#else
  #define FLX_START_SWITCH switch(pc){case 0:;
  #define FLX_SET_PC(x) pc=x;
  #define FLX_CASE_LABEL(x) case x:;
  #define FLX_DECLARE_LABEL(n,i,x)
  #define FLX_LABEL(n,i,x) case n: x:;
  #define FLX_FARTARGET(n,i,x) n
  #define FLX_END_SWITCH default: throw flx_switch_failure_t(); }
#endif

#define FLX_RETURN \
{ \
  con_t *tmp = _caller; \
  _caller = 0; \
  return tmp; \
}

#define FLX_NEWP(x) new(*PTF gcp,x##_ptr_map,true)x

#define FLX_FINALISER(x) \
static void x##_finaliser(collector_t *, void *p){\
  ((x*)p)->~x();\
}

#if FLX_USE_REGPARM3 && FLX_HAVE_GNU_X86
#define FLX_REGPARM __attribute__((regparm(3)))
#else
#define FLX_REGPARM
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define FLX_APAR_PASS_ONLY
#define FLX_APAR_PASS
#define _PTF _ptf.
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT_PTF(x)
#define FLX_DEF_THREAD_FRAME thread_frame_t ptf;
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define FLX_APAR_PASS_ONLY
#define FLX_APAR_PASS
#define _PTF _ptf->
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT_PTF(x)
#define FLX_DEF_THREAD_FRAME thread_frame_t *ptf=0;
#else
#define FLX_FMEM_INIT_ONLY : ptf(_ptf)
#define FLX_FMEM_INIT : ptf(_ptf),
#define FLX_FPAR_PASS_ONLY ptf
#define FLX_FPAR_PASS ptf,
#define FLX_APAR_PASS_ONLY _ptf
#define FLX_APAR_PASS _ptf,
#define _PTF _ptf->
#define _PTFV _ptf
#define FLX_PASS_PTF 1
#define FLX_EAT_PTF(x) x
#define FLX_DEF_THREAD_FRAME
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" thread_frame_t *create_thread_frame(\
  gc_profile_t *gcp\
) {\
  ptf.gcp = gcp;\
  return &ptf;\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" thread_frame_t *create_thread_frame(\
  gc_profile_t *gcp\
) {\
  mname::thread_frame_t *p = new(*gcp,mname::thread_frame_t_ptr_map,false) mname::thread_frame_t();\
  p->gcp = gcp;\
  ptf = p;\
  return p;\
}
#else
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" FLX_EXPORT mname::thread_frame_t *create_thread_frame(\
  gc_profile_t *gcp\
) {\
  mname::thread_frame_t *p = new(*gcp,mname::thread_frame_t_ptr_map,false) mname::thread_frame_t();\
  p->gcp = gcp;\
  return p;\
}
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gcp,mname::x##_ptr_map,false) \
    mname::x()) ->call(0);\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gcp,mname::x##_ptr_map,false) \
    mname::x()) ->call(0);\
}
#else 
#define FLX_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gcp,mname::x##_ptr_map,false) \
    mname::x(ptf)) ->call(0);\
}
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x().stack_call();\
  return 0;\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x().stack_call();\
  return 0;\
}
#else 
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x(ptf).stack_call();\
  return 0;\
}
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x();\
  return 0;\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x();\
  return 0;\
}
#else 
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x(ptf);\
  return 0;\
}
#endif

#endif

@select(tangler("rtl/flx_rtl.hpp"))
#ifndef __FLX_RTL_H__
#define __FLX_RTL_H__

#include "flx_rtl_config.hpp"
#include "flx_meta.hpp"
#include "flx_exceptions.hpp"
#include "flx_gc.hpp"

// temporary compatibility hack
#include "flx_compiler_support_headers.hpp"
#include "flx_compiler_support_bodies.hpp"

#include <string>
#include <functional>

namespace flx { namespace rtl {

// ********************************************************
// Felix system classes
// ********************************************************

struct RTL_EXTERN con_t;     // continuation
struct RTL_EXTERN thread_t; // f-thread
//struct RTL_EXTERN _ref_;     // pointer/reference
struct RTL_EXTERN _uctor_;   // union constructor
struct RTL_EXTERN schannel_t;   // synchronous channel type
struct RTL_EXTERN slist_t;   // singly linked list of void*
struct RTL_EXTERN _root_ptr_t;   // singly linked list of void*

struct RTL_EXTERN unit {};   // unit 
  // INLINE DEFINITION, PROBLEMATIC!!

// ********************************************************
// Shape (RTTI) objects for system classes 
// con_t is only an abstract base, so has no fixed shape
// shapes for instance types generated by Felix compiler
// we provide a shape for C 'int' type as well
// ********************************************************

RTL_EXTERN extern flx::gc::generic::gc_shape_t _fthread_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t schannel_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _ref_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _uctor_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _int_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t unit_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t slist_ptr_map;
RTL_EXTERN extern flx::gc::generic::gc_shape_t _root_ptr_ptr_map;

// ********************************************************
/// CONTINUATION.
// ********************************************************

struct RTL_EXTERN con_t ///< abstract base for mutable continuations
{
  FLX_PC_DECL               ///< interior program counter
  _uctor_ *p_svc;           ///< pointer to service request

  con_t();                  ///< initialise pc, p_svc to 0
  virtual con_t *resume()=0;///< method to perform a computational step
  virtual ~con_t();
  con_t * _caller;          ///< callers continuation (return address)
};

// ********************************************************
/// SLIST. singly linked lists: SHARABLE and COPYABLE
/// SLIST manages pointers to memory managed by the collector
// ********************************************************

struct RTL_EXTERN slist_t {
  gc::generic::gc_profile_t *gcp;
  struct slist_node_t *head;

  slist_t (gc::generic::gc_profile_t*); ///< create empty list
  slist_t (slist_t const &);            ///< shallow copy

  void push(void *data);                ///< push a gc pointer
  void *pop();                          ///< pop a gc pointer
  bool isempty()const;
};

// ********************************************************
/// FTHREAD. Felix threads
// ********************************************************

struct RTL_EXTERN fthread_t // fthread abstraction
{
  con_t *cc;                    ///< current continuation

  fthread_t();                  ///< dead thread, suitable for assignment
  fthread_t(con_t*);            ///< make thread from a continuation
  _uctor_ *run();               ///< run until dead or driver service request
  void kill();                  ///< kill by detaching the continuation
  _uctor_ *get_svc()const;      ///< get current service request of waiting thread
private: // uncopyable
  fthread_t(fthread_t const&); 
  void operator=(fthread_t const&);
};

// ********************************************************
/// SCHANNEL. Synchronous channels
// ********************************************************

struct RTL_EXTERN schannel_t 
{
  slist_t *waiting_to_read;             ///< fthreads waiting for a writer
  slist_t *waiting_to_write;            ///< fthreads waiting for a reader
  schannel_t(gc::generic::gc_profile_t*);
  void push_reader(fthread_t *);        ///< add a reader
  fthread_t *pop_reader();              ///< pop a reader, NULL if none
  void push_writer(fthread_t *);        ///< add a writer
  fthread_t *pop_writer();              ///< pop a writer, NULL if none
private: // uncopyable
  schannel_t(schannel_t const&); 
  void operator= (schannel_t const&); 
};

// ********************************************************
/// VARIANTS. Felix union type
/// note: non-polymorphic, so ctor can be inline
// ********************************************************

struct RTL_EXTERN _uctor_
{
  int variant;  ///< Variant code
  void *data;   ///< Heap variant constructor data
  _uctor_() : variant(-1), data(0) {}
  _uctor_(int i, void *d) : variant(i), data(d) {}
  _uctor_(int *a, _uctor_ x) : variant(a[x.variant]), data(x.data) {}
};

// ********************************************************
/// ROOT POINTER.
/// Use to chain pseudo roots together. Generally scannable
/// but not collectable. 
// ********************************************************

struct RTL_EXTERN _root_ptr_t
{
  _root_ptr_t();
  _root_ptr_t(void *x);
  _root_ptr_t(_root_ptr_t const&);
  void operator=(_root_ptr_t const&);
  ~_root_ptr_t();

  _root_ptr_t *next;
  _root_ptr_t *prev;
  void *data;

private:
  void insert_after (_root_ptr_t*);
  void erase();
};

// INLINE! All casts
template<class T>
struct root_ptr_t : _root_ptr_t {
  root_ptr_t(){}
  root_ptr_t(root_ptr_t<T> const&){}
  root_ptr_t<T>& operator=(root_ptr_t<T> const &a){
    return reinterpret_cast<root_ptr_t<T>&>(_root_ptr_t::operator=(a));
  }
 ~root_ptr_t(){}

  root_ptr_t(T const *a) : _root_ptr_t (const_cast<T*>(a)) {}
  
  T *operator->() { return (T*)data; }
  T const *operator->() const { return (T const*)data; }
  T &operator*() { return *(T*)data; }
  T const &operator*() const { return *(T const*)data; }
};

template<class T>
bool operator == (root_ptr_t<T> a, root_ptr_t<T> b)
{
  return a-> data == b->data;
}

template<class T>
bool operator != (root_ptr_t<T> a, root_ptr_t<T> b)
{
  return a-> data != b->data;
}

template<class T>
bool operator < (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::less<void const*>()(a-> data, b->data);
}

template<class T>
bool operator <= (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::less_equal<void const*>()(a-> data, b->data);
}

template<class T>
bool operator > (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::greater<void const*>()(a-> data, b->data);
}

template<class T>
bool operator >= (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::greater_equal<void const*>()(a-> data, b->data);
}



// ********************************************************
// SERVICE REQUEST CODE
// THESE VALUES MUST SYNCH WITH THE STANDARD LIBRARY
// ********************************************************

enum svc_t               // what the dispatch should do
{                        // when the resume callback returns
  svc_yield = 0,
  svc_get_fthread=1,
  svc_read=2,
  svc_general=3,         // temporary hack by RF
  svc_reserved=4,
  svc_spawn_pthread=5,
  svc_spawn_detached=6,
  svc_sread=7,           // synchronous read
  svc_swrite=8,          // synchronous write
  svc_kill=9,           // kill fthread
  svc_collect=10,        // run collector
  svc_end
};

struct readreq_t {
  schannel_t *chan;
  void *variable;
};

struct flx_trace_t 
{
  unsigned long count;
  int enable_trace;
};

extern RTL_EXTERN int flx_enable_trace;

RTL_EXTERN void flx_trace(flx_trace_t* tr,flx_range_srcref_t sr, char const *file, int line, char const *msg);

}} // namespaces

#endif
@doc()

@select(tangler("rtl/flx_rtl.cpp"))
#include "flx_rtl.hpp"
#include <cstdio>
#include <cassert>
#include "flx_exceptions.hpp"

namespace flx { namespace rtl {

// ********************************************************
// con_t implementation
// ********************************************************

con_t::con_t() : pc(0), p_svc(0), _caller(0) { 
#if FLX_DEBUG_CONT
 fprintf(stderr,"Constructing %p\n",this);
#endif
}
con_t::~con_t(){
#if FLX_DEBUG_CONT
  fprintf(stderr,"Destroying %p\n",this);
#endif
}

// ********************************************************
// slist implementation
// ********************************************************

// PRIVATE to the slist_t class!
struct slist_node_t {
  slist_node_t *next;
  void *data;
  slist_node_t(slist_node_t *n, void *d) : next(n), data(d) {}
};

//OFFSETS for slist_node_t
static std::size_t slist_node_offsets[2]={
    offsetof(slist_node_t,next),
    offsetof(slist_node_t,data)
};

flx::gc::generic::gc_shape_t slist_node_ptr_map = {
  NULL,
  "slist_node_t",
  1,sizeof(slist_node_t),
  0, // no finaliser,
  2,
  slist_node_offsets,
  gc::generic::gc_flags_default
};


slist_t::slist_t(gc::generic::gc_profile_t *_gcp) : gcp (_gcp), head(0) {}
slist_t::slist_t(slist_t const &r) : gcp (r.gcp), head(r.head) {}

bool slist_t::isempty()const { return head == 0; }

void slist_t::push(void *data) 
{
  head = new(*gcp,slist_node_ptr_map,true) slist_node_t(head,data);
}

// note: never fails, return NULL pointer if the list is empty
void *slist_t::pop()
{
  if(head) { 
    void *data = head->data; 
    head=head->next; 
    return data; 
  }
  else return 0;
}

//OFFSETS for slist_t
static std::size_t slist_offsets[1]={
    offsetof(slist_t,head)
};

flx::gc::generic::gc_shape_t slist_ptr_map = {
  &slist_node_ptr_map,
  "slist_t",
  1,sizeof(slist_t),
  0, // no finaliser
  1,
  slist_offsets,
  gc::generic::gc_flags_default
};

// ********************************************************
// _root_ptr_t implementation
// ********************************************************

_root_ptr_t::_root_ptr_t() : next(0), prev(0), data(0) {}
_root_ptr_t::_root_ptr_t(void *x) : next(0), prev(0), data(x) {}
_root_ptr_t::~_root_ptr_t() { erase(); }

void _root_ptr_t::insert_after(_root_ptr_t *a) {
  prev = a;
  next = prev->next;
  prev->next = this;
  if(next)next->prev = this;
  data = next->data;
}

_root_ptr_t::_root_ptr_t(_root_ptr_t const &a) {
  insert_after(const_cast<_root_ptr_t*>(&a));
}

void _root_ptr_t::operator=(_root_ptr_t const &a) {
  if (&a != this)
  {
    erase(); 
    insert_after(const_cast<_root_ptr_t*>(&a));
  }
}

//OFFSETS for root_ptr_t
static std::size_t _root_ptr_offsets[3]={
    offsetof(_root_ptr_t,next),
    offsetof(_root_ptr_t,prev),
    offsetof(_root_ptr_t,data)
};

flx::gc::generic::gc_shape_t _root_ptr_ptr_map = {
  &slist_ptr_map,
  "_root_ptr_t",
  1,sizeof(_root_ptr_t),
  0, // no finaliser
  1,
  _root_ptr_offsets,
  gc::generic::gc_flags_default
};

void _root_ptr_t::erase() {
  next->prev = prev;
  prev->next = next;
  next = 0; prev = 0;
  data = 0;
}

// ********************************************************
// fthread_t implementation
// ********************************************************

fthread_t::fthread_t() : cc(0) {}
fthread_t::fthread_t(con_t *a) : cc(a) {}

// uncopyable object but implementation needed for linker
fthread_t::fthread_t(fthread_t const&){ assert(false); }
void fthread_t::operator=(fthread_t const&){ assert(false); }

void fthread_t::kill() { cc = 0; }

_uctor_ *fthread_t::get_svc()const { return cc?cc->p_svc:0; }

_uctor_ *fthread_t::run() {
  if(!cc) return 0; // dead
restep:
  cc->p_svc = 0;
step:  
  //fprintf(stderr,"cc=%p->",cc);
  try { cc = cc->resume(); }
  catch (con_t *x) { cc = x; }

  //fprintf(stderr,"->%p\n",cc);
  if(!cc) return 0; // died

  if(cc->p_svc)
  {
    switch(cc->p_svc->variant)
    {
      case svc_get_fthread: 
        **(fthread_t***)(cc->p_svc->data) = this;
        goto restep;      // handled
        
      //case svc_yield: 
      //  goto restep;

      // we don't know what to do with the request,
      // so pass the buck to the driver
      default:
        return cc->p_svc;
    }
  }
  goto step;
}


//OFFSETS for fthread_t
static std::size_t _fthread_offsets[1]={
    offsetof(fthread_t,cc)
};

flx::gc::generic::gc_shape_t _fthread_ptr_map = {
  &_root_ptr_ptr_map,
  "fthread_t",
  1,sizeof(fthread_t),
  0,
  1,
  _fthread_offsets,
  gc::generic::gc_flags_immobile
};

// ********************************************************
// schannel_t implementation
// ********************************************************

schannel_t::schannel_t (gc::generic::gc_profile_t *gcp) : 
  waiting_to_read(0), waiting_to_write(0) 
{
  waiting_to_read = new (*gcp, slist_ptr_map,false) slist_t(gcp);
  waiting_to_write = new (*gcp, slist_ptr_map,false) slist_t(gcp);
}

// uncopyable object but implementation needed for linker
schannel_t::schannel_t(schannel_t const&) { assert(false); }
void schannel_t::operator=(schannel_t const&) { assert(false); }

void schannel_t::push_reader(fthread_t *r)
{
  waiting_to_read->push(r);
}

void schannel_t::push_writer(fthread_t *w)
{
  waiting_to_write->push(w);
}

fthread_t *schannel_t::pop_reader()
{
  return (fthread_t*)waiting_to_read->pop();
}

fthread_t *schannel_t::pop_writer()
{
  return (fthread_t*)waiting_to_write->pop();
}

//OFFSETS for schannel_t
static std::size_t schannel_offsets[2]={
    offsetof(schannel_t,waiting_to_read),
    offsetof(schannel_t,waiting_to_write)
};

flx::gc::generic::gc_shape_t schannel_ptr_map = {
  &_fthread_ptr_map,
  "schannel_t",
  1,sizeof(schannel_t),
  0, // no finaliser
  2,
  schannel_offsets,
  gc::generic::gc_flags_default
};

// ********************************************************
// _ref_ implementation
// ********************************************************

/*
void _ref_::operator = (_ref_ const& r)
{
  if (frame != r.frame || offset != r.offset)
  {
    frame = r.frame;
    offset = r.offset;
  }
}
*/

//OFFSETS for _ref_
static std::size_t _ref_offsets[1]={
  0
};

flx::gc::generic::gc_shape_t _ref_ptr_map = {
  &schannel_ptr_map,
  "void*",
  1,sizeof(void*),
  0, // no finaliser
  1,
  _ref_offsets,
  gc::generic::gc_flags_default
};

// ********************************************************
// _uctor_ implementation
// ********************************************************

//OFFSETS for _uctor_
static std::size_t _uctor_offsets[1]= { 
  offsetof(_uctor_,data) 
};

flx::gc::generic::gc_shape_t _uctor_ptr_map = {
  &_ref_ptr_map,
  "_uctor_",
  1,
  sizeof(_uctor_),
  0,
  1,
  _uctor_offsets,
  gc::generic::gc_flags_default
};

// ********************************************************
// int implementation
// ********************************************************

flx::gc::generic::gc_shape_t _int_ptr_map = {
  &_uctor_ptr_map,
  "int",
  1,
  sizeof(int),
  0,
  0,
  0,
  gc::generic::gc_flags_default
};

// ********************************************************
// unit implementation
// ********************************************************

flx::gc::generic::gc_shape_t unit_ptr_map = {
  &_int_ptr_map,
  "unit",
  1,
  sizeof(unit),
  0,
  0,
  0,
  gc::generic::gc_flags_default
};
                                                                                
int flx_enable_trace=1;
unsigned long flx_global_trace_count=0uL;

void flx_trace(flx_trace_t* tr,flx_range_srcref_t sr, char const *file, int line, char const *msg)
{
  if(!flx_enable_trace)return;
  flx_global_trace_count++;
  if(tr)
  {
    tr->count++;
    if(tr->enable_trace) 
    {
      fprintf(stderr,"%ld : %s\n",tr->count,msg);
      print_loc(stderr,sr,file,line);
    }
  }
  else
  {
    fprintf(stderr,"%ld : %s\n",flx_global_trace_count,msg);
    print_loc(stderr,sr,file,line);
  }
}


}}
@doc()

@head(2,"Unix Dynamic linker")
This is a Unix specific module, which uses dlopen
and friends to dynamically attach a shared file
representing a felix top level module to an 
application, and extract the standard 
symbols from it.

@p()
The link routine links the following symbols,
which must be present in all felix libraries.

@begin_displayed_code()
  create_thread_frame
  start
@end_displayed_code()

The unlink routine is called to unlink the library.
@p()

Note that felix never generates variables of static,
storage class, however felix has no control over
used C/C++ code embedded in Felix library modules.
DO NOT use static storage class for variables,
or even constants which require dynamic initialisation.

@select(tangler("rtl/flx_dynlink.hpp"))
#ifndef __FLX_DYNLINK_H__
#define __FLX_DYNLINK_H__
#ifndef FLX_RTL
#include "flx_rtl.hpp"
#include "flx_gc.hpp"
#endif
#include <string>
using namespace std;

// define dynamic library loader stuff, even for static linkage
#if FLX_WIN32
  #include <windows.h>
  typedef HMODULE LIBHANDLE;
  #define FLX_SET_NOLIBRARY(lib) lib=NULL
  #define FLX_CHECK_NOLIBRARY(lib) (lib==NULL)
  #define FLX_LIB_EXTENSION ".DLL"
  #define FLX_DLSYM(x,y) (void*)GetProcAddress(x,#y) 
  #define FLX_SDLSYM(x,y) (void*)GetProcAddress(x,y) 
#elif FLX_MACOSX_NODLCOMPAT
  #include <sys/stat.h>
  #include <mach-o/dyld.h>
  typedef NSModule LIBHANDLE;
  #define FLX_SET_NOLIBRARY(lib) lib=NULL
  #define FLX_CHECK_NOLIBRARY(lib) (lib==NULL)
  // using .so = bundle = programmatically loadable, unbreaks the 10.2 build
  // I'm not sure why the 10.3 and upwards versions of flx_load_module 
  // work with .dylib, they really shouldn't shouldn't.
  // #define FLX_LIB_EXTENSION ".dylib"
  #define FLX_LIB_EXTENSION ".so"
  #define FLX_DLSYM(x, y) flx::rtl::getmachosym(x,"_"#y)
  #define FLX_SDLSYM(x, y) flx::rtl::getmachosym(x,(string("_")+string(y)).data())
#else
  // UNIX, recent OSX
  typedef void *LIBHANDLE;
  #define FLX_SET_NOLIBRARY(lib) lib=NULL
  #define FLX_CHECK_NOLIBRARY(lib) (lib==NULL)
  #if FLX_CYGWIN
    #define FLX_LIB_EXTENSION ".dll"
  #elif FLX_MACOSX
    // this should never have worked. dylibs can't be programmatically
    // loaded. perhaps 10.3 and above removed the bundle/dylib distinction.
    // #define FLX_LIB_EXTENSION ".dylib"
    #define FLX_LIB_EXTENSION ".so"
  #else
    #define FLX_LIB_EXTENSION ".so"
  #endif
  #include <dlfcn.h>
  #define FLX_DLSYM(x,y) dlsym(x,#y)
  #define FLX_SDLSYM(x,y) dlsym(x,y)
#endif

#ifndef FLX_STATIC_LINK
  #define DLSYM(x,y) FLX_DLSYM(x,y)
  #define SDLSYM(x,y) FLX_SDLSYM(x,y)
#else
  #define DLSYM(x,y) (void*)&y
  #define SDLSYM(x,y) (throw flx::rtl::link_failure_t("<static link>",y,"dlsym with static link requires name not string")
#endif

// Utilities to make dynamic linkage and
// initialisation of Felix modules easier
//
// We provide a standard exception to report
// link failure (missing symbol).
//
// We provide a class flx_dynlink_t which
// opens a Felix shared library given a filename,
// and links the mandatory symbols
// The user may derive from this class to add
// linkage for extra symbols
//
// We provide a class flx_libinit_t which
// initialises and terminates a Felix module
// The user may derive from this class to add
// extra initialisation or termination processing.
//
// [Note: the virtuals are *deliberately* private. 
// Be sure to make your overrides private too,
// so they cannot be called:
// they're dispatched automatically by wrappers
// defined in the base]

// must be at global scope, because the users' is
struct thread_frame_t;

namespace flx { namespace rtl {

struct RTL_EXTERN flx_link_failure_t;
struct RTL_EXTERN flx_dynlink_t;
struct RTL_EXTERN flx_libinit_t;

/// Dynamic linkage failure.

struct RTL_EXTERN flx_link_failure_t : flx_exception_t {
  string filename;
  string operation;
  string what;
  flx_link_failure_t(string f, string o, string w);
  virtual ~flx_link_failure_t();
};

RTL_EXTERN LIBHANDLE
flx_load_library(const std::string& filename);

RTL_EXTERN LIBHANDLE
flx_load_module(const std::string& filename);

/// frame creators.

typedef thread_frame_t *(*thread_frame_creator_t)
(
  flx::gc::generic::gc_profile_t*
);

/// library initialisation routine.

typedef con_t *(*start_t)
(
  thread_frame_t*,
  int,
  char **,
  FILE*,
  FILE*,
  FILE*
  
);

typedef con_t *(*main_t)(thread_frame_t*);

/// dynamic object loader.

struct RTL_EXTERN flx_dynlink_t
{
  // data
  LIBHANDLE library;
  string filename;
  thread_frame_creator_t thread_frame_creator;
  start_t start_sym;
  main_t main_sym;
  long refcnt;

  // routines
  void link(const std::string& filename) throw(flx_link_failure_t);
  void unlink();
  virtual ~flx_dynlink_t();
  flx_dynlink_t();

private:
  // the user should override this procedure to
  // link any extra symbols.
  // on error, throw a flx_link_failure_t,
  // otherwise your exception will be dishonoured
  // and a generic link_failure_t thrown anyhow

  flx_dynlink_t(flx_dynlink_t const&); // uncopyable
  void operator=(flx_dynlink_t const&); // uncopyable
  virtual void usr_link();
    // called after mandatory symbols are linked
};

/// Thread Frame Initialisation.

struct RTL_EXTERN flx_libinit_t 
{
  thread_frame_t *thread_frame;
  con_t *start_proc;
  con_t *main_proc;
  flx_dynlink_t *lib;
  flx::gc::generic::gc_profile_t *gcp;
  void create
  (
    flx_dynlink_t *lib_a, 
    flx::gc::generic::gc_profile_t *gcp_a,
    main_t main_sym,
    int argc,
    char **argv,
    FILE *stdin_,
    FILE *stdout_,
    FILE *stderr_
  );

  void destroy ();

  con_t *bind_proc(void *fn, void *data);
  virtual ~flx_libinit_t();
  flx_libinit_t();
  
private:
  flx_libinit_t(flx_libinit_t const&);
  void operator=(flx_libinit_t const&);
  // the user can override these procedures
  // to perform any additional initialisation
  // and termination required.
  
  virtual void usr_create(); 
    // called after standard init completes
    
  virtual void usr_destroy(); 
    // called before standard destroy starts
};

#if FLX_MACOSX_NODLCOMPAT
void* getmachosym(LIBHANDLE, const char*);
#endif

}} // namespaces
#endif
@doc()

@select(tangler("rtl/flx_dynlink.cpp"))
#include "flx_dynlink.hpp"
#include <cstring>
#include <cstdlib>

#ifdef FLX_STATIC_LINK
extern "C" void *create_thread_frame;
extern "C" void *flx_start;
extern "C" void *flx_main;
#endif

namespace flx { namespace rtl {

#if FLX_MACOSX_NODLCOMPAT
void*
getmachosym(NSModule library, const char* symname)
{
    NSSymbol    sym = NSLookupSymbolInModule(library, symname);
    if(sym)
        return NSAddressOfSymbol(sym);
    return 0;
}

#endif

flx_link_failure_t::flx_link_failure_t(string f, string o, string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_link_failure_t::~flx_link_failure_t(){}

flx_dynlink_t::~flx_dynlink_t() {}
flx_dynlink_t::flx_dynlink_t(flx_dynlink_t const&) {} // no copy hack
void flx_dynlink_t::operator=(flx_dynlink_t const&) {} // no copy hack
 
flx_dynlink_t::flx_dynlink_t() :
  library(0),
  filename(""), 
  thread_frame_creator(NULL),
  start_sym(NULL),
  main_sym(NULL),
  refcnt(0)
{}

LIBHANDLE
flx_load_library(const std::string& filename)
{
  LIBHANDLE library;
  FLX_SET_NOLIBRARY(library);

#ifndef FLX_STATIC_LINK
//#if FLX_WIN32 || FLX_CYGWIN
#if FLX_WIN32
  // stop windows showing err dialogues, ignoring error code.
  (void)SetErrorMode(SEM_NOOPENFILEERRORBOX);  
  library = LoadLibrary(filename.c_str());
  if(FLX_CHECK_NOLIBRARY(library)) 
    throw flx_link_failure_t(filename,"LoadLibrary","Cannot find dll");
#else
  #if FLX_MACOSX_NODLCOMPAT
    NSObjectFileImage            bndl_img;
    NSObjectFileImageReturnCode  res;

    string s_filename(filename);
    struct stat st;

    if (stat(s_filename.c_str(), &st) != 0) {
      // we can't find the file, so search DYLD_LIBRARY_PATH
      string paths = getenv("DYLD_LIBRARY_PATH");

      size_t i = 0;
      bool found = false;

      while ((i = paths.find_first_of(':')) != paths.npos) {
        string s = paths.substr(0, i) + '/' + filename;
        paths = paths.substr(i + 1);

        if (stat(s.c_str(), &st) == 0) {
          s_filename = s;
          found = true;
          break;
        }
      }

      if (!found) {
              throw flx_link_failure_t(filename, "stat",
                string("cannot find file: ") + filename);
      }
    }

    res = NSCreateObjectFileImageFromFile(s_filename.c_str(), &bndl_img);

    if(NSObjectFileImageSuccess != res)
      throw flx_link_failure_t(filename, "NSCreateObjectFileImageFromFile",
              "failure to open library");

    // don't merge globals with loader's, load programmatically
    // return on error allows us to continue without being terminated

    unsigned long link_flags;
    link_flags = NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR;
    library = NSLinkModule(bndl_img, filename.c_str(), link_flags);

    // even if link failed, we do this
    NSDestroyObjectFileImage(bndl_img);

    // more info can be gleaned about link errors from NSLinkEditError
    if(FLX_CHECK_NOLIBRARY(library))
      throw flx_link_failure_t(filename, "NSLinkModule", "failed to link");

  #else
    library = dlopen(filename.c_str(),RTLD_NOW);
    if(FLX_CHECK_NOLIBRARY(library))
      throw flx_link_failure_t(filename,"dlopen",dlerror());
  #endif
#endif
#endif
  return library;
}

LIBHANDLE
flx_load_module(const std::string& filename)
{
  return flx_load_library(filename + FLX_LIB_EXTENSION);
}

void flx_dynlink_t::link(const std::string& fname) throw(flx_link_failure_t)
{
  filename=fname;
  library = flx_load_library(fname);
  //fprintf(stderr,"File %s dlopened at %p ok\n",fname.c_str(),library);

  thread_frame_creator = (thread_frame_creator_t)
    DLSYM(library,create_thread_frame);
  if(!thread_frame_creator) 
    throw flx_link_failure_t(filename,"dlsym","create_thread_frame");

  //fprintf(stderr,"Thread frame creator found at %p\n",thread_frame_creator);

  start_sym = (start_t)DLSYM(library,flx_start);
  if(!start_sym) 
    throw flx_link_failure_t(filename,"dlsym","flx_start");

  main_sym = (main_t)DLSYM(library,flx_main);

  //fprintf(stderr,"Start symbol found at %p\n",start_sym);
  //fprintf(stderr,"main symbol found at %p\n",main_sym);
  
  refcnt = 1L;

  //fprintf(stderr,"Set refcnt to 1\n");
  try { usr_link(); }
  catch (flx_link_failure_t &) { throw; }
  catch (...) { 
    throw flx_link_failure_t
    (
      filename,
      "usr_link()",
      "Unknown user exception"
    );
  }
}

void flx_dynlink_t::unlink()
{
  --refcnt;
  if(refcnt == 0) {
    //fprintf(stderr,"closing library\n");
#ifndef FLX_STATIC_LINK
//#if FLX_WIN32 || FLX_CYGWIN
#if FLX_WIN32
    //FreeLibrary(library);
#else
  #if FLX_MACOSX_NODLCOMPAT
    //NSUnLinkModule(library, NSUNLINKMODULE_OPTION_NONE);
  #else
    //dlclose(library);
  #endif
#endif
#endif
  }
}

void flx_dynlink_t::usr_link(){}

flx_libinit_t::~flx_libinit_t(){}
flx_libinit_t::flx_libinit_t() :
  thread_frame (NULL),
  start_proc (NULL),
  main_proc (NULL),
  lib (NULL),
  gcp(NULL) 
{}

flx_libinit_t::flx_libinit_t(flx_libinit_t const&){}
void flx_libinit_t::operator=(flx_libinit_t const&){}

void flx_libinit_t::create
(
  flx_dynlink_t *lib_a, 
  flx::gc::generic::gc_profile_t *gcp_a,
  main_t main_sym,
  int argc,
  char **argv,
  FILE *stdin_,
  FILE *stdout_,
  FILE *stderr_
)
{
  lib = lib_a;
  gcp = gcp_a;
  //fprintf(stderr, "Creating thread frame\n");
  thread_frame = lib->thread_frame_creator(
    gcp 
  );
  //fprintf(stderr, "thread frame CREATED\n");
  //fprintf(stderr,"Incrementing refcnt\n");
  ++lib->refcnt;
  gcp->collector->add_root(thread_frame);
  //fprintf(stderr, "CREATING start_proc\n");
  start_proc = lib->start_sym(thread_frame, argc, argv, stdin_,stdout_,stderr_);
  //fprintf(stderr, "start_proc CREATED\n");
  //fprintf(stderr, "CREATING main_proc\n");
  main_proc = main_sym?main_sym(thread_frame):0;
  //fprintf(stderr, "main_proc CREATED\n");
  usr_create();
}

void flx_libinit_t::usr_create(){ 
  //fprintf(stderr,"libinit done\n"); 
}

void flx_libinit_t::destroy () {
  usr_destroy();
  gcp->collector->remove_root(thread_frame);
  //fprintf(stderr,"[flx_libinit::destroy()] Removed thread frame %p as root\n", thread_frame);
  //fprintf(stderr,"Decrementing refcnt\n");
  //fprintf(stderr,"Start        Ref cnt=%ld\n",lib->refcnt);
  --lib->refcnt;
  //fprintf(stderr,"After decr:  Ref cnt=%ld\n",lib->refcnt);
}

void flx_libinit_t::usr_destroy (){}

con_t *flx_libinit_t::bind_proc(void *fn, void *data) {
  typedef con_t *(*binder_t)(void *,void*);
  return ((binder_t)fn)(thread_frame,data);
}

}} // namespaces
@doc()

@select(tangler("rtl/flx_sync.hpp"))
#ifndef __FLX_SYNC_H__
#define __FLX_SYNC_H__

#include "flx_gc.hpp"
#include "flx_dynlink.hpp"
#include "flx_rtl.hpp"
#include <list>

namespace flx { namespace run {

enum fstate_t { terminated, blocked, delegated };
enum fpc_t { next_fthread_pos, next_request_pos };

RTL_EXTERN char const * get_fstate_desc(fstate_t);
RTL_EXTERN char const * get_fpc_desc(fpc_t);

struct RTL_EXTERN sync_state_t {
  bool debug_driver;
  flx::gc::generic::gc_profile_t *gcp;
  std::list<flx::rtl::fthread_t*> *active;
  flx::rtl::fthread_t *ft;
  flx::rtl::_uctor_ *request;
  fpc_t pc;
  fstate_t fs;
  sync_state_t (
    bool debug_driver_,
    flx::gc::generic::gc_profile_t *gcp_,
    std::list<flx::rtl::fthread_t*> *active_
  );
  void frun();
};

}}

#endif
@doc()

@select(tangler("rtl/flx_sync.cpp"))
#include "flx_sync.hpp"
using namespace flx::rtl;

namespace flx { namespace run {

RTL_EXTERN char const *get_fstate_desc(fstate_t fs)
{
  switch(fs)
  {
    case terminated: return "terminated";
    case blocked: return "blocked";
    case delegated: return "delegated";
    default: return "Illegal fstate_t";
  }
}

RTL_EXTERN char const *get_fpc_desc(fpc_t fpc)
{
  switch(fpc)
  {
    case next_fthread_pos: return "Next fthread pos";
    case next_request_pos: return "Next request pos";
    default: return "Illegal fpc_t";
  }
}


sync_state_t::sync_state_t (
  bool debug_driver_,
  flx::gc::generic::gc_profile_t *gcp_,
  std::list<fthread_t*> *active_
) : 
  debug_driver(debug_driver_),
  gcp(gcp_),
  active(active_),
  pc(next_fthread_pos)
{}

void sync_state_t::frun()
{
  // local copies are faster
  flx::gc::generic::collector_t *collector = gcp->collector;

  // dispatch
  if (pc == next_request_pos) goto next_request;
  if (pc == next_fthread_pos) goto next_fthread;
  fprintf(stderr,"BUG -- unreachable code in frun\n");
  abort();

next_fthread:
  if (active->size() == 0) {
    fs = blocked; 
    pc = next_fthread_pos;
    return; 
  }
  ft = active->front();
  active->pop_front();

next_request:
  request = ft->run();
  if(request != 0) goto check_collect;

forget_fthread:
  if(debug_driver)fprintf(stderr,"unrooting fthread %p\n",ft);
  collector->remove_root(ft);
  goto next_fthread;

delegate:
  pc = next_request_pos;
  fs = delegated;
  return;

check_collect:  
  //gcp->gc_counter++;
  //if(gcp->gc_counter == gcp->gc_freq)
  //{
  //  gcp->gc_counter = 0;
  //  gcp->collections++;
  //  unsigned long n = collector->collect();
  //  if(gcp->debug_collections)fprintf(stderr,"collected %ld objects\n",n);
  //}
    
  switch(request->variant)
  {
    case svc_yield: 
    {
      if(debug_driver)fprintf(stderr,"yield");
      active->push_back(ft);
    }
    goto next_fthread;

    case svc_spawn_detached:
    {
      fthread_t *ftx = *(fthread_t**)request->data;
      if(debug_driver)fprintf(stderr,"Spawn thread %p\n",ftx);
      collector->add_root(ftx);
      active->push_front(ftx);
    }
    goto next_request;

    case svc_sread:
    {
      readreq_t * pr = (readreq_t*)request->data;
      schannel_t *chan = pr->chan;
      if(debug_driver)fprintf(stderr,"Request to read on channel %p\n",chan);
    svc_read_next:
      {
        fthread_t *writer= chan->pop_writer();
        if(writer == 0) goto svc_read_none;       // no writers
        if(writer->cc == 0) goto svc_read_next;   // killed
        {
          readreq_t * pr = (readreq_t*)request->data;
          readreq_t * pw = (readreq_t*)writer->get_svc()->data;
          if(debug_driver)fprintf(stderr,"Writer @%p=%p, read into %p\n", pw->variable,*(void**)pw->variable, pr->variable);
          *(void**)pr->variable = *(void**)pw->variable;
          active->push_front(writer);
          collector->add_root(writer);
        }
      }
      goto next_request;

    svc_read_none:
      if(debug_driver)fprintf(stderr,"No writers on channel %p: BLOCKING\n",chan);
      chan->push_reader(ft);
    }
    goto forget_fthread;

    case svc_swrite:
    {
      readreq_t * pr = (readreq_t*)request->data;
      schannel_t *chan = pr->chan;
      if(debug_driver)fprintf(stderr,"Request to write on channel %p\n",chan);
    svc_write_next:
      {
        fthread_t *reader= chan->pop_reader();
        if(reader == 0) goto svc_write_none;     // no readers
        if(reader->cc == 0) goto svc_write_next; // killed
        {
          readreq_t * pw = (readreq_t*)request->data;
          readreq_t * pr = (readreq_t*)reader->get_svc()->data;
          if(debug_driver)fprintf(stderr,"Writer @%p=%p, read into %p\n", pw->variable,*(void**)pw->variable, pr->variable);
          *(void**)pr->variable = *(void**)pw->variable;
          active->push_front(reader);
          collector->add_root(reader);
        }
      }
      goto next_request;

    svc_write_none:
      if(debug_driver)fprintf(stderr,"No readers on channel %p: BLOCKING\n",chan);
      chan->push_writer(ft);
    }
    goto forget_fthread;
    
    case svc_kill:
    {
      fthread_t *ftx = *(fthread_t**)request->data;
      if(debug_driver)fprintf(stderr,"Request to kill fthread %p\n",ftx);
      ftx -> kill();
    }
    goto next_request;

    default:  goto delegate;
  } 
  fprintf(stderr,"BUG unreachable code executed\n");
  abort();
}

}}
@doc()

@head(2,'Universal Program Driver')
This driver runs stand alone Felix programs.
It invokes the library routine 'start'.
No messages are dispatched, the Felix
program must not read any messages.

@p()
For statically linked programs,
command line arguments are passed directly,
the debugging switch isn't supported.

@p()
For dynamically loaded programs, the name of the
driver and optional --debug switch given before the
shared library name are not passed.

@select(tangler('rtl/flx_async.hpp','hpp'))
#ifndef __FLX_ASYNC_H__
#define __FLX_ASYNC_H__
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"

#ifdef BUILD_ASYNC
#define ASYNC_EXTERN FLX_EXPORT
#else
#define ASYNC_EXTERN FLX_IMPORT
#endif

// GLOBAL NAMESPACE!

class ASYNC_EXTERN async_hooker {
public:
  virtual flx::rtl::fthread_t *dequeue()=0;
  virtual void handle_request(void *data, flx::rtl::fthread_t *ss)=0;
  virtual ~async_hooker();
};

typedef 
async_hooker *
create_async_hooker_t
(
  int n0,   // bound on resumable thread queue
  int n1,   // bound on general input job queue
  int m1,   // number of threads in job pool
  int n2,   // bound on async fileio job queue
  int m2    // number of threads doing async fileio
);

extern "C" {
ASYNC_EXTERN async_hooker *
create_async_hooker
(
  int n0,   // bound on resumable thread queue
  int n1,   // bound on general input job queue
  int m1,   // number of threads in job pool
  int n2,   // bound on async fileio job queue
  int m2    // number of threads doing async fileio
);
}

#endif
@doc()

@select(tangler('rtl/flx_async.cpp','cpp'))
#include "flx_async.hpp"
#include "pthread_sleep_queue.hpp"
#include "flx_rtl.hpp"
#include "demux_demuxer.hpp"
#include "faio_asyncio.hpp"
#include "pthread_thread.hpp"

using namespace flx::rtl;
using namespace flx::demux;
using namespace flx::pthread;
using namespace flx::faio;


class async_hooker_impl : public async_hooker {
public:
  void handle_request(void *data,fthread_t *ss);
  virtual sleep_queue_t *get_ready_queue()=0;
  ~async_hooker_impl();
};


#include "faio_asyncio.hpp"

async_hooker::~async_hooker(){ 
 //fprintf(stderr,"Deleted async_hooker\n"); 
}

async_hooker_impl::~async_hooker_impl(){ 
  //fprintf(stderr,"Deleted async_hooker_impl\n"); 
}

void async_hooker_impl::handle_request(void *data,fthread_t *ft)
{
  flx::faio::flx_driver_request_base* dreq = 
        (flx::faio::flx_driver_request_base*)data
  ;

  //fprintf(stderr,"Request object at %p\n",dreq);
  // RF hates the flag this function returns .. might
  // mask a race condition, get rid of it

  finote_t *fn = new wakeup_fthread_t(get_ready_queue(),ft);
  //fprintf(stderr,"async hooker dispatching request %p, fn = %p\n",dreq,fn);
  dreq->start_async_op(fn);
}

class proto_async : public async_hooker_impl
{
    sleep_queue_t async_active;

public:
   proto_async(int n0, int n1, int m1, int n2, int m2) : 
     async_active(n0)
   {
   }

  ~proto_async(){ 
    //fprintf(stderr,"Deleting proto async\n"); 
  }
  sleep_queue_t *get_ready_queue() { return &async_active; }
  fthread_t* dequeue() 
  { 
    return (fthread_t*)async_active.dequeue(); 
  }
};

async_hooker *create_async_hooker(int n0,int n1,int m1,int n2,int m2) {
  return new proto_async(n0,n1,m1,n2,m2);
}
@doc()

@select(tangler('rtl/flx_eh.hpp'))
#ifndef __FLX_EH_H__
#define __FLX_EH_H__
#include "flx_rtl_config.hpp"
#include "flx_exceptions.hpp"

namespace flx { namespace rtl {
int RTL_EXTERN std_exception_handler (std::exception *e);
int RTL_EXTERN flx_exception_handler (flx::rtl::flx_exception_t *e);
}}

#endif

@select(tangler('rtl/flx_eh.cpp'))
#include <stdio.h>
#include "flx_rtl.hpp"
#include "flx_dynlink.hpp"
#include "flx_exceptions.hpp"
#include "flx_eh.hpp"
using namespace flx::rtl;


int flx::rtl::std_exception_handler (std::exception *e)
{
  fprintf(stderr,"C++ STANDARD EXCEPTION %s\n",e->what());
  return 4;
}

int flx::rtl::flx_exception_handler (flx_exception_t *e)
{
  if (flx_halt_t *x = dynamic_cast<flx_halt_t*>(e))
  {
    fprintf(stderr,"Halt: %s \n",x->reason.data());
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  if (flx_link_failure_t *x = dynamic_cast<flx_link_failure_t*>(e))
  {
    fprintf(stderr,"Dynamic linkage error\n");
    fprintf(stderr,"filename: %s\n",x->filename.data());
    fprintf(stderr,"operation: %s\n",x->operation.data());
    fprintf(stderr,"what: %s\n",x->what.data());
    return 2;
  }
  else
  if (flx_exec_failure_t *x = dynamic_cast<flx_exec_failure_t*>(e))
  {
    fprintf(stderr,"Execution error\n");
    fprintf(stderr,"filename: %s\n",x->filename.data());
    fprintf(stderr,"operation: %s\n",x->operation.data());
    fprintf(stderr,"what: %s\n",x->what.data());
    return 3;
  }
  else
  if (flx_assert_failure_t *x = dynamic_cast<flx_assert_failure_t*>(e))
  {
    fprintf(stderr,"Assertion Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  if (flx_assert2_failure_t *x = dynamic_cast<flx_assert2_failure_t*>(e))
  {
    fprintf(stderr,"Assertion2 Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    print_loc(stderr,x->flx_loc2,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  if (flx_match_failure_t *x = dynamic_cast<flx_match_failure_t*>(e))
  {
    fprintf(stderr,"Match Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  if (flx_range_failure_t *x = dynamic_cast<flx_range_failure_t*>(e))
  {
    fprintf(stderr,"Range Check Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  if (dynamic_cast<flx_out_of_memory_t*>(e))
  {
    fprintf(stderr,"Felix Out of Malloc or Specified Max allocation Exceeded");
    return 3;
  }
  else
  {
    fprintf(stderr,"Unknown EXCEPTION!\n");
    return 5;
  }
}
@doc()

@select(tangler('rtl/flx_run.include','cpp'))
#include <cstdlib>
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <cstring>
#include <cassert>

#include <string>
//#include <unistd.h>

#include "flx_rtl.hpp"
#include "flx_async.hpp"
#include "flx_ts_collector.hpp"
#include "flx_dynlink.hpp"
#include "flx_sync.hpp"
#include "pthread_thread.hpp"
#include "pthread_counter.hpp"
#include "flx_eh.hpp"

using namespace std;
using namespace flx::rtl;
using namespace flx::pthread;
using namespace flx::run;

#if FLX_HAVE_GNU_X86
register void *sp __asm__("esp");
#elif FLX_HAVE_GNU_X86_64
register void *sp __asm__("rsp");
#else
static void *sp = 0;
#endif

// non async drivers aren't don't depend on faio<-demux<-winsock
// and so aren't linked with mswsock and ws2_32
#if FLX_WIN32 && FLX_SUPPORT_ASYNC
  #include "demux_iocp_demuxer.hpp"
  // needed to perform win socket io (calls WSAInit). Must happen
  // before iocp_demuxer is instantiated and (I assume) happen
  // only once.
  // JS: No, it can be called any number of times, provided
  // the destructor WSACleanup is called same number of times
  // Use of this RAII object ensures WSAinit/Cleanup calls balance.
  // RF: Still has to happen before any socket calls. Putting it in
  // the async object which is created on command is already too late.
  // If that's a problem then any socket creation calls would have to
  // gratuitously make async calls.
  flx::demux::winsock_initer wsinit;
#endif


int do_final_cleanup(
  bool debug_driver, 
  flx::gc::generic::gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
);

struct doflx_data 
{
  bool debug_driver;
  flx::gc::generic::gc_profile_t *gcp;
  std::list<fthread_t*> *active;
  flx::pthread::thread_control_t *thread_control;
  doflx_data(bool d, flx::gc::generic::gc_profile_t *g, std::list<fthread_t*> *a, flx::pthread::thread_control_t *tc)
   : debug_driver(d), gcp(g), active(a), thread_control(tc) {}
};

static
create_async_hooker_t *ptr_create_async_hooker = NULL;

void doflx (void *data) {
  doflx_data *d = (doflx_data*)data;
  bool debug_driver = d->debug_driver;
  flx::gc::generic::gc_profile_t *gcp = d-> gcp;
  std::list<fthread_t*> *active = d->active;
  flx::pthread::thread_control_t *thread_control=d->thread_control;
  delete d;

  unsigned long async_count = 0;
  async_hooker* async = NULL;

  try 
  {
    sync_state_t ss(debug_driver, gcp, active);

  process_active:
    if(debug_driver)fprintf(stderr,"Process active ..");

    if(debug_driver)
      fprintf(stderr,"Before running: Sync state is %s/%s\n",
        get_fstate_desc(ss.fs),get_fpc_desc(ss.pc));

    ss.frun();

    if(debug_driver)
      fprintf(stderr,"After running: Sync state is %s/%s\n",
        get_fstate_desc(ss.fs),get_fpc_desc(ss.pc));

    if (ss.fs == terminated) goto cleanup;

    //fprintf(stderr, "Thread yielding ..");
    //thread_control->yield();
    //fprintf(stderr, "..Thread resuming!\n");

    if (ss.fs == blocked) goto do_async;

    if (ss.fs == delegated) 
    switch (ss.request->variant)
    {
      case svc_collect:
      {
          gcp->actually_collect();
      }
      goto process_active;

      case svc_spawn_pthread:
      {
        fthread_t *ftx = *(fthread_t**)ss.request->data;
        if(debug_driver)fprintf(stderr,"Spawn pthread %p\n",ftx);
        gcp->collector->add_root(ftx);
        std::list<fthread_t*> *pactive =new std::list<fthread_t*>;
        pactive->push_front(ftx);
        void *data = new doflx_data(debug_driver, gcp, pactive, thread_control);
        flx_detached_thread_t dummy;
        if(debug_driver)
          fprintf(stderr,"Starting new pthread, thread counter= %ld\n",thread_control->thread_count());
        {
          flx_mutex_t spawner_lock;
          flx_condv_t spawner_cond;
          bool spawner_flag = false;
          flx_mutex_locker_t locktite(spawner_lock);
          dummy.init( doflx,data, thread_control, 
            &spawner_lock, &spawner_cond,
            &spawner_flag
          );
          if(debug_driver)
            fprintf(stderr,"Thread %p waiting for spawned thread to register itself\n", get_current_native_thread());
          while (!spawner_flag)
            spawner_cond.wait(&spawner_lock);
          if (debug_driver)
            fprintf(stderr,"Thread %p notes spawned thread has registered itself\n", get_current_native_thread());
        }
      }
      goto process_active;

      case svc_general:
      {
        if(debug_driver)
          fprintf(stderr,"svc_general from fthread=%p\n",ss.ft);
        if( !async )
        {
          if (ptr_create_async_hooker == NULL)
          {
#if !FLX_SUPPORT_ASYNC
             ptr_create_async_hooker = 0;
#else
             ptr_create_async_hooker = create_async_hooker;
  #ifndef FLX_STATIC_LINK
             LIBHANDLE async_lib = flx_load_module("libflx_async_dynamic");
             if (async_lib == NULL)
             {
               fprintf(stderr,"Unable to find module 'libflx_async_dynamic'\n");
               exit(1);
             }
             // debug only ..
             else { 
               if(debug_driver) 
                 fprintf(stderr, "module 'libflx_async_dynamic' loaded!\n"); 
             }
             ptr_create_async_hooker = (create_async_hooker_t*)
               DLSYM(async_lib,create_async_hooker)
             ;
             if (ptr_create_async_hooker == NULL)
             {
               fprintf(stderr,"Unable to find symbol 'create_async_hooker' in module 'libflx_async_dynamic'\n");
               exit(1);
             }
             // debug only
             else {
               if(debug_driver)
                 fprintf(stderr, "found 'create_async_hooker'!\n"); 
             }
  #endif          
#endif
          }
          if (ptr_create_async_hooker == NULL)
          {
            fprintf(stderr,"Unable to initialise async I/O system: terminating\n");
            exit(1);
          }
          async = (*ptr_create_async_hooker)(
            20000, // bound on resumable thread queue
            50,    // bound on general input job queue
            2,     // number of threads in job pool
            50,    // bound on async fileio job queue
            1      // number of threads doing async fileio
          );
        }
        ++async_count;
        void *dreq =  *(void**)ss.request->data;

        // requests are now ALWAYS considered asynchronous
        // even if the request handler reschedules them immediately
        async->handle_request(dreq, ss.ft);
        ss.pc = next_fthread_pos;
      }
      goto process_active;

      default:
        fprintf(stderr,"Unknown service request code 0x%4x\n",ss.request->variant);
        abort();
    }
    fprintf(stderr,"Unknown frun return status 0x%4x\n",ss.fs);
    abort();

  do_async:
    // ran out of active threads - are there any in the async queue?
    if(debug_driver){
      fprintf(stderr, "out of active synchronous threads, trying async, count=%ld\n",async_count);
    }

    if(async && async_count > 0){
      // STILL A ROOT
      fthread_t* ftp = async->dequeue();
      if(debug_driver)
        fprintf(stderr,"Async Retrieving fthread %p\n",ftp);
      active->push_front(ftp);
      --async_count;
      ss.pc = next_fthread_pos;
      goto process_active;
    }

    if(debug_driver)fprintf(stderr,"Out of jobs\n");
  cleanup:;
  }
  catch (flx_exception_t &x) { flx_exception_handler (&x); }
  catch (std::exception &x) { std_exception_handler (&x); }
  catch (...) { fprintf(stderr,"Unknown exception in thread!\n"); }

  try
  {
    if(debug_driver)fprintf(stderr,"Terminating Felix subsystem\n");
    delete async;
    delete active;
  }
  catch (...) { fprintf(stderr,"Unknown exception deleting async!\n"); }

}

// RUN A FELIX INSTANCE IN THE CURRENT PTHREAD
//
// CURRENTLY ONLY CALLED ONCE IN MAIN THREAD

static void *get_stack_pointer() { unsigned long x; return &x; }

void run_felix_pthread(
  bool debug_driver, 
  flx::gc::generic::gc_profile_t *gcp,
  flx::pthread::thread_control_t *thread_control,
  flx_dynlink_t *library,
  flx_libinit_t *instance
)
{    
   //fprintf(stderr,"run_felix_pthread -- the MAIN THREAD\n");
   flx::gc::generic::collector_t *collector = gcp->collector;
   std::list<fthread_t*> *active =new std::list<fthread_t*>;

  fthread_t *flx_main = NULL;
  {
    con_t *top = instance->main_proc;
    if(top)
    {
      flx_main = new (*gcp,_fthread_ptr_map,false) fthread_t(top);
      collector->add_root(flx_main);
      active->push_front(flx_main);
    }
  }

  {
    con_t *top = instance->start_proc;
    fthread_t *ft = new (*gcp,_fthread_ptr_map,false) fthread_t(top);
    collector->add_root(ft);
    active->push_front(ft);
  }

  {
   
    doflx(new doflx_data(debug_driver, gcp, active, thread_control)); // deletes active for us!
  
    if(debug_driver)fprintf(stderr,"MAIN THREAD FINISHED: waiting for other threads\n");
    thread_control->join_all();
    if(debug_driver)fprintf(stderr,"ALL THREADS DEAD: mainline cleanup!\n");

    if(debug_driver){
      unsigned long uncollected = collector->get_allocation_count();
      unsigned long roots = collector->get_root_count();
      fprintf(stderr,
        "program finished, %ld collections, %ld uncollected objects, roots %ld\n",
        gcp->collections,uncollected,roots);
    }
  }

  if(gcp->finalise)
    do_final_cleanup(debug_driver, gcp, library, instance);
}

// terminates process! 
// Not called by default (let the OS clean up)
// 
// NEEDS TO BE SPLIT UP so that destroying
// a program instance is separated from unloading
// the library

int do_final_cleanup(
  bool debug_driver, 
  flx::gc::generic::gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
)
{
  flx::gc::generic::collector_t *collector = gcp->collector;

  // garbage collect application objects
  {
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Finalisation: pass 1 Data collection starts ..\n");
    unsigned long n = collector->collect();
    unsigned long a = collector->get_allocation_count();
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"flx_run collected %ld objects, %ld left\n",n,a);
  }

  // Destroy program instance/ thread frame object

  if(debug_driver)
    fprintf(stderr,"Destroying program instance\n");
  instance->destroy();

  // garbage collect system objects

  {
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Finalisation: pass 2 Final collection starts ..\n");
    collector->free_all_mem();
    unsigned long a = collector->get_allocation_count();
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Remaining %ld objects (should be 0)\n",a);
    if(a!=0){
      fprintf(stderr,"flx_run %ld uncollected objects, should be zero!!\n",a);
      return 5;
    }
  }

  // dump the DLL

  if(debug_driver)
    fprintf(stderr,"Libref cnt = %ld\n",library->refcnt);
  if(library->refcnt >0)
  {
    if(debug_driver)
      fprintf(stderr,"flx_run %p library still referenced %ld times\n",
        library->library,library->refcnt
      );
  }
  if(debug_driver)
    fprintf(stderr,"Unlinking library ..\n");
  library->unlink();
  return 0;
}

// MAINLINE, ONLY DONE ONCE
int run_felix(
  bool debug_driver, 
  flx::gc::generic::gc_profile_t *gcp,
  flx::pthread::thread_control_t *thread_control,
  char *filename, 
  int flx_argc, 
  char **flx_argv
)
{
  try 
  {
    if(debug_driver)
      fprintf(stderr,"flx_run driver begins %s\n",flx_argv[0]);
    flx_dynlink_t library;
    flx_libinit_t instance;
    library.link(filename);

    flx::gc::generic::collector_t *collector = gcp->collector;

    void *stack_base = get_stack_pointer();
    thread_control->add_thread(stack_base);
    instance.create(&library, gcp,library.main_sym,flx_argc,flx_argv,stdin,stdout,stderr);
    
    if(debug_driver)
    {
      fprintf(stderr,"loaded library %s at %p\n",filename,library.library);
      fprintf(stderr,"thread frame at %p\n",instance.thread_frame);
      fprintf(stderr,"initial continuation at %p\n",instance.start_proc);
      fprintf(stderr,"main continuation at %p\n",instance.main_proc);
    } 
    //fprintf(stderr,"Calling run_felix_pthread\n");
    run_felix_pthread(debug_driver,gcp,thread_control,&library,&instance);
    thread_control->remove_thread();

    if(gcp->finalise)
    {
      if(library.refcnt >0)
      {
        fprintf(stderr,"flx_run %p library still referenced %ld times?!\n",library.library,library.refcnt);
        return 6;
      }
      if(debug_driver)
        fprintf(stderr,"flx_run driver ends with finalisation complete\n");
    }
    else 
    {
      if(debug_driver || gcp->debug_collections)
      {
        unsigned long a = collector->get_allocation_count();
        fprintf(stderr,"flx_run driver ends with finalisation skipped, %ld uncollected objects\n",a);
      }
    }
  }
  catch (flx_exception_t &x)
  {
    return flx_exception_handler(&x);
  }
  catch (...)
  {
    fprintf(stderr,"flx_run driver ends with unknown EXCEPTION\n");
    return 4;
  }
  return 0;
}

static double egetv(char const *name, double dflt)
{
  char *env = std::getenv(name);
  double val = env?atof(env):dflt;
  return val;
}

int main(int argc, char** argv)
{
  int error_exit_code = 0;
#ifndef FLX_STATIC_LINK  
  bool static_link = false;
  if (argc<2) 
  {
    printf("usage: flx_run [--debug] dll_filename options ..\n");
    printf("  environment variables:\n");
    printf("  FLX_DEBUG               # enable debugging traces (default off)\n");
    printf("  FLX_DEBUG_ALLOCATIONS   # enable debugging allocator (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_COLLECTIONS   # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_THREADS       # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_DRIVER        # enable debugging driver (default FLX_DEBUG)\n");
    printf("  FLX_FINALISE            # whether to cleanup on termination (default NO)\n");
    printf("  FLX_GC_FREQ=n           # how often to call garbage collector (default 1000)\n");
    printf("  FLX_ALLOW_COLLECTION_ANYWHERE # (default no, will be yes soon)\n");
    return 1;
  }
  char *filename = argv[1];
  char **flx_argv = argv+1;
  int flx_argc = argc-1;
  bool debug = (argc > 1) && (strcmp(argv[1],"--debug")==0);
  if(debug)
  {
    if(argc<3)
    {
      printf("usage: flx_run [--debug] dll_filename options ..\n");
      return 1;
    }
    filename = argv[2];
    --flx_argc;
    ++flx_argv;
  }
#else
  bool static_link = true;
  char *filename = argv[0];
  char **flx_argv = argv;
  int flx_argc = argc;
  bool debug = false;

//  printf("Statically linked Felix program running\n");
#endif
  debug = egetv("FLX_DEBUG",debug);
  if(debug)
  {
    fprintf(stderr,"[FLX_DEBUG] Debug enabled for %s link program\n",static_link?"static":"dynamic");
  }

  bool debug_threads = egetv("FLX_DEBUG_THREADS",debug);
  if(debug_threads)
  {
    fprintf(stderr,"[FLX_DEBUG_THREADS] Threads debug enabled\n");
  }

  bool debug_allocations = egetv("FLX_DEBUG_ALLOCATIONS",debug);
  if(debug_allocations)
  {
    fprintf(stderr,"[FLX_DEBUG_ALLOCATIONS] Allocation debug enabled\n");
  }

  bool debug_collections = egetv("FLX_DEBUG_COLLECTIONS",debug);
  if(debug_collections)
  {
    fprintf(stderr,"[FLX_DEBUG_COLLECTIONS] Collection debug enabled\n");
  }


  bool debug_driver = egetv("FLX_DEBUG_DRIVER",debug);
  if(debug_driver)
  {
    fprintf(stderr,"[FLX_DEBUG_DRIVER] Driver debug enabled\n");
  }

  bool finalise = egetv("FLX_FINALISE", 0);
  if(debug) 
    fprintf(stderr,"[FLX_FINALISE] Finalisation %s\n",finalise? "Enabled" : "Disabled");

  unsigned long gc_freq = egetv("FLX_GC_FREQ",1000);
  if (gc_freq < 1) gc_freq = 1;
  if(debug)
    fprintf(stderr,"[FLX_GC_FREQ] call gc every %lu iterations\n",gc_freq);

  // default min mem is 10 Meg
  unsigned long min_mem = egetv("FLX_MIN_MEM",10) * 1000000.0;
  if (min_mem < 0) min_mem = 0;
  if(debug)
    fprintf(stderr,"[FLX_MIN_MEM] call gc only if more than %lu Meg heap used\n",min_mem/1000000);

  // default max mem is unlimited
  unsigned long max_mem = egetv("FLX_MAX_MEM",-1) * 1000000.0;
  if (max_mem <= 0) max_mem = (unsigned long)-1;
  if(debug)
    fprintf(stderr,"[FLX_MAX_MEM] terminate if more than %lu Meg heap used\n",max_mem/1000000);

  // default free factor is 10%, this is also the minimum allowed
  double free_factor = egetv("FLX_FREE_FACTOR",1.1);
  if (free_factor < 1.1) free_factor = 1.1;
  if(debug)
    fprintf(stderr,"[FLX_FREE_FACTOR] reset gc trigger %4.2f times heap used after collection\n",free_factor);

  // experimental flag to allow collection anywhere
  // later, we default this one to true if we can 
  // find all the thread stacks, which should be possible
  // with gcc and probably msvc++

  bool allow_collection_anywhere = egetv("FLX_ALLOW_COLLECTION_ANYWHERE",0);
  if(debug)
    fprintf(stderr,"[FLX_ALLOW_COLLECTION_ANYWHERE] %s\n",allow_collection_anywhere?"True":"False");


#if FLX_HAVE_GNU
    if(debug)fprintf(stderr, "Compiled by g++\n");
    static void *init_sp = sp;
    static void *init_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *init_ret = __builtin_return_address(0);
    if(debug)fprintf(stderr, "Stack pointer = %p, frame=%p, return=%p\n",sp,init_fframe,init_ret);
#endif
  if(debug)
    for(int i=0; i<flx_argc; ++i) 
    fprintf(stderr,"flx_argv[%d]->%s\n",i,flx_argv[i]);
    
  flx::gc::generic::allocator_t *allocator = 
    new flx::gc::collector::malloc_free()
  ;
  allocator->set_debug(debug_allocations);

  flx::pthread::thread_control_t thread_control(debug_threads);

  flx::gc::collector::flx_collector_t *collector =
    new flx::gc::collector::flx_ts_collector_t(allocator, &thread_control)
  ;
  collector->set_debug(debug_collections);
  flx::gc::generic::gc_profile_t *gcp = new flx::gc::generic::gc_profile_t(
    debug_allocations, 
    debug_collections, 
    allow_collection_anywhere,
    gc_freq,
    min_mem,
    max_mem,
    free_factor,
    finalise,
    collector
  );
  error_exit_code = run_felix(
    debug_driver,
    gcp,
    &thread_control,
    filename,flx_argc,flx_argv
  );

  delete gcp;
  delete collector;
  delete allocator;

#if FLX_HAVE_GNU
    // check the frame pointer isn't corrupted
    static void *fin_sp = sp;
    static void *fin_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *fin_ret = __builtin_return_address(0);
    if (init_sp != fin_sp ) {
      fprintf(stderr,"g++: STACK POINTER ERROR %p != %p\n",init_sp,fin_sp);
    }
// I have to comment this out, because it only applies if the
// gcc compiler is using the frame pointer.. it doesn't if you
// say -fomit-frame-pointer, for example .. I don't know if there
// is a way to tell inside the code ..
#if 0
    if (init_fframe != fin_fframe) {
      fprintf(stderr,"g++: FRAME POINTER ERROR %p != %p\n",init_fframe,fin_fframe);
    }
#endif
    else if (init_ret != fin_ret) {
      fprintf(stderr,"g++: RETURN ADDRESS ERROR %p != %p\n",init_ret,fin_ret);
    }
#endif
  if(debug)fprintf(stderr,"flx_run driver ends code=%d\n",error_exit_code);
  return error_exit_code;
}
@doc()

@select(tangler('rtl/flx_run.cxx','cpp'))
#define FLX_SUPPORT_ASYNC 0

#include "flx_run.include"
@doc()

@select(tangler('rtl/flx_arun.cxx','cpp'))
#define FLX_SUPPORT_ASYNC 1

#include "flx_run.include"
@doc()

@select(tangler('rtl/flx_main.cpp','cpp'))
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"
// THIS IS A DO NOTHING MAINLINE FOR USE WHEN STATICALLY LINKING
extern "C" flx::rtl::con_t *flx_main( void *p){ return 0; }
@doc()

@select(tangler('test/drivers/mickey_mouse.cxx','cpp'))
#include <stdio.h>
#include "flx_rtl.hpp"
#include "flx_collector.hpp"
#include "flx_dynlink.hpp"

using namespace std;
using namespace flx;

int main(int argc, char** argv)
{
  rtl::flx_dynlink_t library;
  rtl::flx_libinit_t instance;
  library.link(argc>1?argv[1]:"<static>");
  gc::collector::malloc_free allocator;
  gc::collector::flx_collector_t collector(&allocator, NULL);
  gc::generic::gc_profile_t *gcp = new flx::gc::generic::gc_profile_t(
    false, 
    false, 
    false,
    0,
    -1,
    -1,
    0.2,
    true,
    &collector
  );
  instance.create(&library, gcp,library.main_sym,argc,argv,stdin,stdout,stderr);
  rtl::con_t *top = instance.start_proc;
  while( top ) top = top->resume();
  return 0;
}
@doc()

@select(tangler('rtl/flx_i18n.hpp'))
#ifndef __FLX_I18N_H__
#define __FLX_I18N_H__
#include <string>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace i18n {
   RTL_EXTERN std::string utf8(unsigned long);
}}}
#endif
@doc()

@select(tangler('rtl/flx_i18n.cpp'))
#include "flx_i18n.hpp"
namespace flx { namespace rtl { namespace i18n {
  std::string utf8(unsigned long i) 
  {
    char s[6];
    if (i < 0x80UL ) 
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL ) 
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL ) 
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL ) 
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL ) 
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else 
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}}
@doc()

@select(tangler('rtl/flx_ioutil.hpp'))
#ifndef FLX_IOUTIL
#define FLX_IOUTIL
#include <string>
#include <cstdio>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace ioutil {
  RTL_EXTERN std::string load_file (std::FILE *);
  RTL_EXTERN std::string load_file (std::string);
  RTL_EXTERN std::string readln(std::FILE*);
  RTL_EXTERN void write (std::FILE *, std::string);
  RTL_EXTERN void writeln (std::FILE *, std::string);
}}}
#endif
@doc()

@select(tangler('rtl/flx_ioutil.cpp'))
#include <cstdio>
#include <string>
#include "flx_ioutil.hpp"
namespace flx { namespace rtl { namespace ioutil {
  using namespace std;

  string load_file (FILE *fi)
  {
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  string load_file (string f)
  {
    char const *fname = f.data();
    FILE *fi = fopen(fname,"rt");
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  // includes ewline if present
  // null string indicates end of file
  string readln (FILE *fi)
  {
    if(fi)
    {
      string x = "";
      char buffer[513];
      buffer[512]='\0';
      int n;
      while 
      ( 
        !(
          (n=x.size()) && 
          x[n-1]=='\n'
        ) 
        &&
        fgets(buffer,512,fi)
      )
        x = x + string(buffer);
      return x;
    }
    else return "";
  }

  void write (FILE *fi, string s)
  {
    fwrite(s.data(),s.size(),1,fi);
  }

  void writeln (FILE *fi, string s)
  {
    static char *eol = "\n";
    static int n = 0;
    if(n==0)n=strlen(eol);
    fwrite(s.data(),s.size(),1,fi);
    fwrite(eol,n,1,fi);
  }

}}}
@doc()

@select(tangler('rtl/flx_strutil.hpp'))
#include <string>
#include <sstream>
#include <stdarg.h>

#include "flx_rtl_config.hpp"

//RF: was only to commented out to fix macosx problem,
//but lets see what happens to all the other builds.
//#ifndef MACOSX
//template class RTL_EXTERN std::basic_string<char>;
//#endif

namespace flx { namespace rtl { namespace strutil {
  using namespace std;
  template<class T>
  basic_string<T> mul(basic_string<T> s, int n) {
    basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  basic_string<T> substr(basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }

  template<class T>
  T subscript(basic_string<T> const &s, int i)
  {
    int n = s.size();
    if(i<0)  i=i+n;
    return i<0 || i >= n ? T(0) : s[i];
  }

  template<class T>
  string str(T const &t) {
    std::ostringstream x;
    x << t;
    return x.str();
  }

  RTL_EXTERN string atostr(char const *a);
  RTL_EXTERN string flx_asprintf(char const *fmt,...);

}}}
@doc()

@select(tangler('rtl/flx_strutil.cpp'))
#include "flx_strutil.hpp"

namespace flx { namespace rtl { namespace strutil {

  string atostr(char const *a) {
    if(a) return a;
    else return "";
  }

#ifdef FLX_HAVE_VSNPRINTF  
  string flx_asprintf(char const *fmt,...){
    va_list ap;
    va_start(ap,fmt);
    //printf("vsnprintf TRIAL\n");
    int n = vsnprintf(NULL,0,fmt,ap);
    //printf("vsnprintf size=%d\n",n);
    va_end(ap);
    char *res = (char*)malloc(n+1);
    va_start(ap,fmt);
    vsnprintf(res,n+1,fmt,ap);
    va_end(ap);
    string s = string(res);
    free(res);
    return s;
  }
#else
  // THIS IS UNSAFE .. but Windows sucks.
  // It documents vsnprintf .. but doesn't provide it
  string flx_asprintf(char const *fmt,...){
    //printf("vsnprintf EMULATION!\n");
    va_list ap;
    int n = 10000; // hack, WILL crash if not enough
    char *res = (char*)malloc(n+1);
    va_start(ap,fmt);
    vsprintf(res,fmt,ap);
    va_end(ap);
    string s = string(res);
    free(res);
    return s;
  }
#endif

}}}
@doc()


@select(tangler('rtl/flx_executil.hpp'))
#ifndef FLX_EXECUTIL
#define FLX_EXECUTIL
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"

namespace flx { namespace rtl { namespace executil {
  RTL_EXTERN void run(flx::rtl::con_t *c);
}}}
#endif
@doc()

@select(tangler('rtl/flx_executil.cpp'))
#include "flx_executil.hpp"
namespace flx { namespace rtl { namespace executil {
void run(flx::rtl::con_t *p)
{
  while(p) 
  {
    try { p=p->resume(); }
    catch (flx::rtl::con_t *x) { p = x; }
  }
}

}}}

