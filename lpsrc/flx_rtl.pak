@head(1,"Run time driver support library")

@execfile('config'+os.sep+'flx_data.py')

This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@select(tangler('spkgs/flx_exceptions.py'))
cpp_cpps = [
  "src/rtl/flx_exceptions",
]

rtl_interfaces = [
  'src/rtl/flx_exceptions_config.hpp',
  'src/rtl/flx_exceptions.hpp',
]

pkg_requires = ['flx_rtl_config']
provides_lib = "libflx_exceptions"
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "FLX_EXCEPTIONS"
weaver_directory = 'doc/rtl/flx_exceptions/'
xfiles = [
  'src/rtl/flx_exceptions.hpp',
  'src/rtl/flx_exceptions.cpp',
  ]
@doc()

@select(tangler('spkgs/flx_rtl.py'))
RTL_CPPS = [
  "src/rtl/flx_rtl",
  "src/rtl/flx_dynlink",
  "src/rtl/flx_sync",
  "src/rtl/flx_eh",
  "src/rtl/flx_i18n",
  "src/rtl/flx_ioutil",
  "src/rtl/flx_strutil",
  "src/rtl/flx_executil",
  "src/rtl/flx_main",
]

RTL_INTERFACES = [
  "src/rtl/flx_rtl.hpp",
  'src/rtl/flx_compiler_support_headers.hpp',
  'src/rtl/flx_compiler_support_bodies.hpp',
  'src/rtl/flx_dynlink.hpp',
  'src/rtl/flx_i18n.hpp',
  'src/rtl/flx_ioutil.hpp',
  'src/rtl/flx_strutil.hpp',
  'src/rtl/flx_executil.hpp',
]

cpp_cpps = RTL_CPPS
rtl_interfaces = RTL_INTERFACES
provides_lib = "libflx"
lib_requires = ['libflx_exceptions','libflx_gc','libflx_judy','libflx_pthread']
pkg_requires = ['flx_exceptions','flx_gc','flx_pthread']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "RTL"
weaver_directory = 'doc/rtl/flx_rtl/'
xfiles = [
  'src/rtl/flx_arun.cxx',
  'src/rtl/flx_async.cpp',
  'src/rtl/flx_async.hpp',
  'src/rtl/flx_compiler_support_bodies.hpp',
  'src/rtl/flx_compiler_support_headers.hpp',
  'src/rtl/flx_dynlink.cpp',
  'src/rtl/flx_dynlink.hpp',
  'src/rtl/flx_eh.cpp',
  'src/rtl/flx_eh.hpp',
  'src/rtl/flx_executil.cpp',
  'src/rtl/flx_executil.hpp',
  'src/rtl/flx_i18n.cpp',
  'src/rtl/flx_i18n.hpp',
  'src/rtl/flx_ioutil.cpp',
  'src/rtl/flx_ioutil.hpp',
  'src/rtl/flx_main.cpp',
  'src/rtl/flx_rtl.cpp',
  'src/rtl/flx_rtl.hpp',
  'src/rtl/flx_run.cxx',
  'src/rtl/flx_run.include',
  'src/rtl/flx_strutil.cpp',
  'src/rtl/flx_strutil.hpp',
  'src/rtl/flx_sync.cpp',
  'src/rtl/flx_sync.hpp',
  'src/rtl/plat_linux.cpp',
  'src/rtl/plat_linux.hpp',
  ]

@doc()

@select(tangler('spkgs/flx.py'))
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','flx_gc','flx_pthread','demux','faio','flx_stdlib']
@doc()

@select(tangler('spkgs/flx_async.py'))
cpp_cpps = ['src/rtl/flx_async']
provides_lib = "libflx_async"
pkg_requires = ['faio','demux','flx_pthread','flx_rtl','flx_gc']
lib_requires = ['libfaio','libdemux','libflx_pthread','libflx','libflx_gc','libflx_judy', 'libflx_exceptions']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "ASYNC"
@doc()

@select(tangler('spkgs/flx_drivers.py'))
STATIC_DRIVERS = [
  ('src/rtl/flx_run', 'lib/rtl'),
  ('test/drivers/flx_perf_drv1', ''),
  ('test/drivers/mickey_mouse', ''),
]

DYNAMIC_DRIVERS = [
  ('src/rtl/flx_run','bin/flx_run'),
  ('test/drivers/flx_perf_drv1','test/drivers/flx_perf_drv1'),
  ('test/drivers/mickey_mouse','bin/mickey_mouse'),
]

DRLIBS = [
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  'libflx_judy',
  ]

static_drivers = STATIC_DRIVERS
dynamic_drivers = DYNAMIC_DRIVERS
drivers_require_libs = DRLIBS
pkg_requires = ['flx_rtl','flx_pthread','flx_gc', 'flx_exceptions']
lib_requires = ['libdemux','libflx_pthread','libflx','libflx_judy', 'libflx_exceptions']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('spkgs/flx_async_drivers.py'))
STATIC_DRIVERS = [
  ('src/rtl/flx_arun',''),
]

DYNAMIC_DRIVERS = [
  ('src/rtl/flx_arun','bin/flx_arun'),
]

DRLIBS = [
  'libflx_async',
  'libfaio',
  'libdemux',
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  'libflx_judy',
  'libflx_exceptions',
  ]

static_drivers = STATIC_DRIVERS
dynamic_drivers = DYNAMIC_DRIVERS
drivers_require_libs = DRLIBS
pkg_requires = ['flx_gc','flx_rtl','flx_pthread','flx_async','demux','faio']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('config/flx_exceptions.fpc', 'data'))
Name: flx
Description: Felix exceptions 
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_exceptions_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_exceptions_static")
 else:
   tangle("provides_dlib: -lflx_exceptions_dynamic")
   tangle("provides_slib: -lflx_exceptions_static")
@doc()

@select(tangler('config/flx.fpc', 'data'))
Name: flx
Description: Felix core runtime support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_static")
 else:
   tangle("provides_dlib: -lflx_dynamic")
   tangle("provides_slib: -lflx_static")
Requires: flx_gc flx_exceptions
@doc()

@select(tangler('config/flx_arun.fpc', 'data'))
Name: flx_arun
Description: Felix standard driver, async support
Version: $Id$
Requires: flx_async faio demux flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_run.fpc', 'data'))
Name: flx_run
Description: Felix standard driver, no async support
Version: $Id$
Requires: flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_async.fpc', 'data'))
Name: flx_async
Description: Async hook
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_async_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_async_static")
 else:
   tangle("provides_dlib: -lflx_async_dynamic")
   tangle("provides_slib: -lflx_async_static")

Requires: faio demux flx_pthread flx flx_gc
@doc()

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@h=tangler('config/target/flx_exceptions_config.hpp')
@select(h)
#ifndef __FLX_EXCEPTIONS_CONFIG_H__
#define __FLX_EXCEPTIONS_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FLX_EXCEPTIONS
#define FLX_EXCEPTIONS_EXTERN FLX_EXPORT
#else
#define FLX_EXCEPTIONS_EXTERN FLX_IMPORT
#endif
#endif

@select(tangler("config/target/flx_meta.hpp"))
#ifndef __FLX_META_H__
#define __FLX_META_H__
// taken from BOOST
@if HAVE_INCLASS_MEMBER_INITIALIZATION:
  tangle('#define FLX_HAVE_INCLASS_MEMBER_INITIALIZATION 1')
 else:
  tangle('#define FLX_HAVE_INCLASS_MEMBER_INITIALIZATION 0')

#if FLX_HAVE_INCLASS_MEMBER_INITIALIZATION
#  define FLX_STATIC_CONSTANT(type, assignment) static const type assignment
#else
#  define FLX_STATIC_CONSTANT(type, assignment) enum { assignment }
#endif

#include <cstddef>

template <std::size_t> struct type_with_alignment;
@for k in flx_aligns.keys():
  t = flx_aligns[k]
  tangle('template <> struct type_with_alignment<'+str(k)+'>{ typedef '+t+' type; };')

template <typename T> struct alignment_of;

template <typename T>
struct alignment_of_hack
{
  char c;
  T t;
  alignment_of_hack();
};

template <unsigned A, unsigned S>
struct alignment_logic
{
  FLX_STATIC_CONSTANT(std::size_t, value = A < S ? A : S);
};

template< typename T >
struct alignment_of
{
  FLX_STATIC_CONSTANT(std::size_t, value =
    (alignment_logic<
      sizeof(alignment_of_hack<T>) - sizeof(T),
      sizeof(T)
    >::value));
};

template<std::size_t L, std::size_t A>
struct aligned_storage
{
  union type
  {
    unsigned char data_[ L ];
    typename type_with_alignment<A>::type align_;
  };
};

template<typename T>
struct store_of
{
  typedef typename aligned_storage<sizeof(T), alignment_of<T>::value>::type type;
};

// convert an rvalue to an lvalue
template<typename T>
T const &lvalue(T const &x)
{
  return x;
}

// this reinterpret cast works with rvalues too
template<typename T, typename U>
T &reinterpret(U const &x) {
  return reinterpret_cast<T&>(const_cast<U&>(x));
}

template<typename T> void destroy(T *p){ p->T::~T(); }

#endif
@doc()

@select(tangler("config/host/flx_host_config.hpp"))
#ifndef __FLX_HOST_CONFIG_H__
#define __FLX_HOST_CONFIG_H__

@if HOST_CXX.options.WIN32:
  tangle('#define FLX_WIN32 1')
 else:
  tangle('#define FLX_WIN32 0')

@if HOST_CXX.options.HAVE_BOOL:
  tangle('#define FLX_HAVE_BOOL 1')
 else:
  tangle('#define FLX_HAVE_BOOL 0')

@if HOST_CXX.options.HAVE_LONGLONG:
  tangle('#define FLX_HAVE_LONGLONG 1')
 else:
  tangle('#define FLX_HAVE_LONGLONG 0')

@if HOST_CXX.options.HAVE_LONGDOUBLE:
  tangle('#define FLX_HAVE_LONGDOUBLE 1')
 else:
  tangle('#define FLX_HAVE_LONGDOUBLE 0')

#if !defined(FLX_STATIC_LINK) && FLX_WIN32
#define FLX_EXPORT __declspec(dllexport)
#define FLX_IMPORT __declspec(dllimport)
#else
#define FLX_EXPORT
#define FLX_IMPORT
#endif


@def cal_raw_address():
  if HOST_CXX.options.SIZEOF_INT == HOST_CXX.options.SIZEOF_VOIDP: return "unsigned"
  if HOST_CXX.options.SIZEOF_LONG == HOST_CXX.options.SIZEOF_VOIDP: return "unsigned long"
  if HOST_CXX.options.SIZEOF_LONGLONG == HOST_CXX.options.SIZEOF_VOIDP: return "unsigned long long"
  raise "Cannot find an int the size of a void pointer"

@tangle("#define FLX_RAWADDRESS "+cal_raw_address())
@tangle('#define FLX_MAX_ALIGN '+str(HOST_CXX.options.MAX_ALIGN))

#if FLX_WIN32
#define _WIN32_WINNT 0x500 // Require Windows NT5 (2K, XP, 2K3)
#endif


#endif

@select(tangler("config/target/flx_rtl_config.hpp"))
#ifndef __FLX_RTL_CONFIG_H__
#define __FLX_RTL_CONFIG_H__

@if HAVE_VSNPRINTF:
  tangle('#define FLX_HAVE_VSNPRINTF 1')
 else:
  tangle('#define FLX_HAVE_VSNPRINTF 0')

@if TARGET_CXX.options.HAVE_BOOL:
  tangle('#define FLX_HAVE_BOOL 1')
 else:
  tangle('#define FLX_HAVE_BOOL 0')

@if HAVE_LONGLONG:
  tangle('#define FLX_HAVE_LONGLONG 1')
 else:
  tangle('#define FLX_HAVE_LONGLONG 0')

@if HAVE_LONGDOUBLE:
  tangle('#define FLX_HAVE_LONGDOUBLE 1')
 else:
  tangle('#define FLX_HAVE_LONGDOUBLE 0')

@if HAVE_GNU:
  tangle('#define FLX_HAVE_GNU 1')
 else:
  tangle('#define FLX_HAVE_GNU 0')

@if HAVE_GNU_X86:
  tangle('#define FLX_HAVE_GNU_X86 1')
 else:
  tangle('#define FLX_HAVE_GNU_X86 0')

@if HAVE_GNU_X86_64:
  tangle('#define FLX_HAVE_GNU_X86_64 1')
 else:
  tangle('#define FLX_HAVE_GNU_X86_64 0')

@if HAVE_GNU_BUILTIN_EXPECT:
  # only use these with proper predicates!
  tangle('#define FLX_UNLIKELY(x) __builtin_expect(long(x),0)')
  tangle('#define FLX_LIKELY(x) !__builtin_expect(!long(x),0)')
 else:
  tangle('#define FLX_UNLIKELY(x) x')
  tangle('#define FLX_LIKELY(x) x')

@if HAVE_CGOTO:
  tangle("#define FLX_HAVE_CGOTO 1")
 else:
  tangle("#define FLX_HAVE_CGOTO 0")

@if USE_REGPARM3:
  tangle("#define FLX_USE_REGPARM3 1")
 else:
  tangle("#define FLX_USE_REGPARM3 0")
  
@if HAVE_ASM_LABELS:
  tangle("#define FLX_HAVE_ASM_LABELS 1")
 else:
  tangle("#define FLX_HAVE_ASM_LABELS 0")

@if HAVE_DLOPEN:
  tangle("#define FLX_HAVE_DLOPEN 1")
 else:
  tangle("#define FLX_HAVE_DLOPEN 0")

@if WIN32:
  tangle('#define FLX_WIN32 1')
 else:
  tangle('#define FLX_WIN32 0')

@if MACOSX:
  tangle("#define FLX_MACOSX 1")
 else:
  tangle("#define FLX_MACOSX 0")

@if LINUX:
  tangle("#define FLX_LINUX 1")
 else:
  tangle("#define FLX_LINUX 0")

@if WIN32:
  tangle("#define FLX_WIN32 1")
 else:
  tangle("#define FLX_WIN32 0")

@if WIN64:
  tangle("#define FLX_WIN64 1")
 else:
  tangle("#define FLX_WIN64 0")

@if CYGWIN:
  tangle("#define FLX_CYGWIN 1")
 else:
  tangle("#define FLX_CYGWIN 0")

@if POSIX:
  tangle("#define FLX_POSIX 1")
 else:
  tangle("#define FLX_POSIX 0")

@if SOLARIS:
  tangle("#define FLX_SOLARIS 1")
 else:
  tangle("#define FLX_SOLARIS 0")

@if HAVE_MSVC:
  tangle("#define FLX_HAVE_MSVC 1")
 else:
  tangle("#define FLX_HAVE_MSVC 0")

@if HAVE_KQUEUE_DEMUXER:
  tangle("#define FLX_HAVE_KQUEUE_DEMUXER 1")
 else:
  tangle("#define FLX_HAVE_KQUEUE_DEMUXER 0")

@if HAVE_POLL:
  tangle("#define FLX_HAVE_POLL 1")
 else:
  tangle("#define FLX_HAVE_POLL 0")

@if HAVE_EPOLL:
  tangle("#define FLX_HAVE_EPOLL 1")
 else:
  tangle("#define FLX_HAVE_EPOLL 0")

@if HAVE_EVTPORTS:
  tangle("#define FLX_HAVE_EVTPORTS 1")
 else:
  tangle("#define FLX_HAVE_EVTPORTS 0")

//
#if FLX_HAVE_CGOTO && FLX_HAVE_ASM_LABELS
#define FLX_CGOTO 1
#else
#define FLX_CGOTO 0
#endif

#if FLX_WIN32
#define _WIN32_WINNT 0x0600 // Require Windows NT5 (2K, XP, 2K3)
#define WINVER 0x0600 // Require Windows NT5 (2K, XP, 2K3)
// vs windows.h just LOVES to include winsock version 1 headers by default.
// that's bad for everyone, so quit it.
#define _WINSOCKAPI_
#endif


#if !defined(FLX_STATIC_LINK) && FLX_WIN32
#define FLX_EXPORT __declspec(dllexport)
#define FLX_IMPORT __declspec(dllimport)
#else
#define FLX_EXPORT
#define FLX_IMPORT
#endif


#ifdef BUILD_RTL
#define RTL_EXTERN FLX_EXPORT
#else
#define RTL_EXTERN FLX_IMPORT
#endif

#if FLX_MACOSX && !FLX_HAVE_DLOPEN
#define FLX_MACOSX_NODLCOMPAT 1
#else
#define FLX_MACOSX_NODLCOMPAT 0
#endif

#if FLX_HAVE_GNU
#define FLX_ALWAYS_INLINE __attribute__ ((always_inline))
#define FLX_NOINLINE __attribute__ ((noinline))
#define FLX_CONST __attribute__ ((const))
#define FLX_PURE __attribute__ ((pure))
#define FLX_GXX_PARSER_HACK (void)0,
#define FLX_UNUSED __attribute__((unused))
#else
#define FLX_ALWAYS_INLINE
#define FLX_NOINLINE 
#define FLX_CONST
#define FLX_PURE 
#define FLX_GXX_PARSER_HACK
#define FLX_UNUSED
#endif

@def cal_raw_address():
  if SIZEOF_INT == SIZEOF_VOIDP: return "unsigned"
  if SIZEOF_LONG == SIZEOF_VOIDP: return "unsigned long"
  if SIZEOF_LONGLONG == SIZEOF_VOIDP: return "unsigned long long"
  raise "Cannot find an int the size of a void pointer"

@tangle("#define FLX_RAWADDRESS "+cal_raw_address())
@tangle('#define FLX_MAX_ALIGN '+str(MAX_ALIGN))
#endif
@doc()


@select(tangler('test/drivers/mickey_mouse.cxx','cpp'))
#include <stdio.h>
#include "flx_rtl.hpp"
#include "flx_collector.hpp"
#include "flx_dynlink.hpp"

using namespace std;
using namespace flx;

int main(int argc, char** argv)
{
  rtl::flx_dynlink_t library;
  rtl::flx_libinit_t instance;
  library.link(argc>1?argv[1]:"<static>");
  gc::collector::malloc_free allocator;
  gc::collector::flx_collector_t collector(&allocator, NULL);
  gc::generic::gc_profile_t *gcp = new flx::gc::generic::gc_profile_t(
    false, 
    false, 
    false,
    0,
    -1,
    -1,
    0.2,
    true,
    &collector
  );
  instance.create(&library, gcp,library.main_sym,argc,argv,stdin,stdout,stderr);
  rtl::con_t *top = instance.start_proc;
  while( top ) top = top->resume();
  return 0;
}
@doc()


