@import config

@head(1,"Run time driver support library")

This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@select(tangler('spkgs/flx_exceptions.py'))
import os

cpp_cpps = [
  "src/exceptions/flx_exceptions",
]

rtl_interfaces = [
  'config/target/flx_exceptions_config.hpp',
  'src/exceptions/flx_exceptions.hpp',
]

pkg_requires = ['flx_rtl_config']
provides_lib = "libflx_exceptions"
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "FLX_EXCEPTIONS"
weaver_directory = 'doc/rtl/flx_exceptions/'
xfiles = [os.path.join('src', 'exceptions', '*')]
@doc()

@select(tangler('spkgs/flx_rtl.py'))
import os

cpp_cpps = [
  "src/rtl/flx_rtl",
  "src/rtl/flx_dynlink",
  "src/rtl/flx_sync",
  "src/rtl/flx_eh",
  "src/rtl/flx_i18n",
  "src/rtl/flx_ioutil",
  "src/rtl/flx_strutil",
  "src/rtl/flx_executil",
  "src/rtl/flx_main",
]

rtl_interfaces = [
  "src/rtl/flx_rtl.hpp",
  'src/rtl/flx_compiler_support_headers.hpp',
  'src/rtl/flx_compiler_support_bodies.hpp',
  'src/rtl/flx_dynlink.hpp',
  'src/rtl/flx_i18n.hpp',
  'src/rtl/flx_ioutil.hpp',
  'src/rtl/flx_strutil.hpp',
  'src/rtl/flx_executil.hpp',
]

provides_lib = "libflx"
lib_requires = ['libflx_exceptions','libflx_gc','libflx_judy','libflx_pthread']
pkg_requires = ['flx_exceptions','flx_gc','flx_pthread']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "RTL"
weaver_directory = 'doc/rtl/flx_rtl/'
xfiles = [os.path.join('src', 'rtl', '*')]
@doc()

@select(tangler('spkgs/flx.py'))
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','flx_gc','flx_pthread','demux','faio','flx_stdlib']
@doc()

@select(tangler('spkgs/flx_async.py'))
cpp_cpps = ['src/flx_async/flx_async']
provides_lib = "libflx_async"
pkg_requires = ['faio','demux','flx_pthread','flx_rtl','flx_gc']
lib_requires = ['libfaio','libdemux','libflx_pthread','libflx','libflx_gc','libflx_judy', 'libflx_exceptions']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "ASYNC"
@doc()

@select(tangler('spkgs/flx_drivers.py'))
static_drivers = [('src/flx_drivers/flx_run', 'lib/rtl')]
dynamic_drivers = [('src/flx_drivers/flx_run', 'bin')]

include_path = ['src/rtl']

drivers_require_libs = [
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  'libflx_judy',
]

pkg_requires = ['flx_rtl','flx_pthread','flx_gc', 'flx_exceptions']
lib_requires = ['libdemux','libflx_pthread','libflx','libflx_judy', 'libflx_exceptions']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('spkgs/flx_async_drivers.py'))
static_drivers = [('src/flx_drivers/flx_arun','lib/rtl')]
dynamic_drivers = [('src/flx_drivers/flx_arun','bin')]

include_path = ['src/rtl']

drivers_require_libs = [
  'libflx_async',
  'libfaio',
  'libdemux',
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  'libflx_judy',
  'libflx_exceptions',
]

pkg_requires = ['flx_gc','flx_rtl','flx_pthread','flx_async','demux','faio']
iscr_source = ['lpsrc/flx_rtl.pak']
@doc()

@select(tangler('config/flx_exceptions.fpc', 'data'))
Name: flx
Description: Felix exceptions
@if config.HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_exceptions_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_exceptions_static")
 else:
   tangle("provides_dlib: -lflx_exceptions_dynamic")
   tangle("provides_slib: -lflx_exceptions_static")
@doc()
includes: "flx_exceptions.hpp"

@select(tangler('config/flx.fpc', 'data'))
Name: flx
Description: Felix core runtime support
Version: $Id$
@if config.HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_static")
 else:
   tangle("provides_dlib: -lflx_dynamic")
   tangle("provides_slib: -lflx_static")
Requires: flx_gc flx_exceptions
includes: "flx_rtl.hpp" "flx_strutil.hpp" "flx_i18n.hpp"  <iostream> <cstdio> <cstddef> <cassert> <climits> <string>
@doc()

@select(tangler('config/flx_arun.fpc', 'data'))
Name: flx_arun
Description: Felix standard driver, async support
Version: $Id$
Requires: flx_async faio demux flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_run.fpc', 'data'))
Name: flx_run
Description: Felix standard driver, no async support
Version: $Id$
Requires: flx_pthread flx flx_gc
@doc()

@select(tangler('config/flx_async.fpc', 'data'))
Name: flx_async
Description: Async hook
Version: $Id$
@if config.HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_async_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_async_static")
 else:
   tangle("provides_dlib: -lflx_async_dynamic")
   tangle("provides_slib: -lflx_async_static")

Requires: faio demux flx_pthread flx flx_gc
@doc()

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@h=tangler('config/target/flx_exceptions_config.hpp')
@select(h)
#ifndef __FLX_EXCEPTIONS_CONFIG_H__
#define __FLX_EXCEPTIONS_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FLX_EXCEPTIONS
#define FLX_EXCEPTIONS_EXTERN FLX_EXPORT
#else
#define FLX_EXCEPTIONS_EXTERN FLX_IMPORT
#endif
#endif
