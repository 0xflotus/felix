@head(1,"Run time driver support library")
$Log$
Revision 1.22  2006/03/08 07:15:54  skaller
Async channels now working

Revision 1.21  2006/03/07 09:07:17  skaller
Add --lparchive option to specify where LP source .paks
live

Revision 1.20  2006/03/07 04:22:36  skaller
Termination in presence of spawned pthreads should now
be working, using new ts_locker class. Exception handling
on per thread basis not implemented yet.

Revision 1.19  2006/03/06 23:24:39  rfistman
added conditional winsock initialisation back to flx_run. it's too late
once a win32 flx app executes an async call.

Revision 1.18  2006/03/06 15:08:08  skaller
Cygwin and MinGW builds.

Revision 1.17  2006/03/06 13:16:17  skaller
Fix library builds so exports and imports are properly
distinguished on a library by library basis.

Revision 1.16  2006/03/06 06:30:18  idadesub
added a forward declaration of do_final_cleanup, and fixed arguments being
passed in the wrong order

Revision 1.15  2006/03/06 03:28:52  skaller
Win32 detached threads (same as joinable ones really)

Revision 1.14  2006/03/06 01:29:29  skaller
spawn_pthread: init works

Revision 1.13  2006/03/05 07:52:41  skaller
Add detached threads, to be used for job queues.

Revision 1.12  2006/03/05 00:50:52  skaller
Fix flx_async to depend on libfaio, libdemux, etc.

Revision 1.11  2006/03/05 00:14:15  rfistman
using new demux selecter logic (suckit'n'see)

Revision 1.10  2006/03/04 21:07:36  rfistman
MACOSX != Kqueues.

Revision 1.9  2006/03/04 09:50:42  rfistman
added "suck it and see" for kqueues.

Revision 1.8  2006/03/04 07:28:20  skaller
Decouple flx_run from faio and demux, except for hook creator.

Revision 1.7  2006/03/04 04:26:41  rfistman
making demux configure more "suck it and see". temporarily disabled kqueues
whilst fixing osx 10.2 build.

Revision 1.6  2006/03/02 20:42:06  skaller
Nocygwin build, flx_pkgconfig.

Revision 1.5  2006/03/02 17:52:52  skaller
Fix flx_pkgconfig to handle linker switches

Revision 1.4  2006/02/28 02:07:13  skaller
Refactor demux into demux + pthread.

Revision 1.3  2006/02/26 06:39:36  skaller
Fix flx_pkgconfig to conform to new spec.

Revision 1.2  2006/02/23 19:33:01  skaller
More fiddling with build system

Revision 1.1  2006/02/22 17:36:49  skaller
Rename some files.. more coming. Make RTL modules full .paks

Revision 1.116  2006/02/20 10:50:16  skaller
Mingw static tests

Revision 1.115  2006/02/19 16:04:57  skaller
Win32 build changes..seems to work now

Revision 1.114  2006/02/16 23:59:10  rfistman
switched mac build back to kqueues, was using thread safe select

Revision 1.113  2006/02/16 23:39:11  rfistman
fixed cygwin hang in posix tests. cygwin wakes select with an error flag
when you shutdown a socket. other impls seem to wake select, but with no
error.

Revision 1.112  2006/02/16 15:36:04  skaller
Fix flx_sync to not use ts_collector (only needs gc).

Revision 1.111  2006/02/16 15:19:28  skaller
MSVC++ fixes

Revision 1.110  2006/02/16 07:51:40  skaller
Replace pkg-config with a Felix program flx_pkgconfig.
Make sure to build it in a timely manner, since flx script
now depends on it.

Revision 1.109  2006/02/15 10:54:09  skaller
Build time packaging system.

Revision 1.108  2006/02/15 04:10:56  rfistman
working on thread safe select demuxer (ts_select_demuxer). that should
fix cygwin probs. and as yet other undiscovered problems.

Revision 1.107  2006/02/13 20:12:53  skaller
Add chain thru shape objects to allow collector to specialise
allocations on a type basis.

Revision 1.106  2006/02/13 03:30:38  skaller
Change top level calling structure in flx_run in preparation
for launching detached pthreads which can run Felix.

Revision 1.105  2006/02/12 04:25:40  skaller
Fix long standing cygwin build problem (workaround for libstdc++ bug).

Revision 1.104  2006/02/10 21:55:34  skaller
Sdl examples now run on Windows

Revision 1.103  2006/02/10 04:40:26  skaller
Win32 rtl patches

Revision 1.102  2006/02/09 21:05:33  skaller
Fixed sdl to use polling.

Revision 1.101  2006/02/08 16:19:43  skaller
Changed flx_run so it executes an exported flx_main procedure
after thread frame initialisation blocks (and thus before
async wakes up any fthreads)

Revision 1.100  2006/02/06 06:50:01  skaller
Added pthread_cond_timedwait and pthread_cond_uswait functions
to condition variables. The latter is my own invention, it waits
for a specific interval in micro-seconds. The later is more
efficient on Windows when you want to wait for an interval,
since this is the native method. Otherwise you need to first
obtain the time of day, do a nasty calculation .. and then
the timedwait function will undo that, resulting in two
unnecessary and expensive system calls.

Revision 1.99  2006/02/04 11:34:36  skaller
Portable demux stuff, Win32 version

Revision 1.98  2006/02/04 10:35:55  skaller
Portable thread sync stuff

Revision 1.97  2006/02/02 15:29:32  skaller
Factor flx_run.

Revision 1.96  2006/02/02 08:30:17  rfistman
got rid of annoying debug output/note to self regarding sigpipe on osx/bsd.
made flx_rtl create async structure on demand, if only to avoid all that
debug output in the simpler tests.

Revision 1.95  2006/02/02 06:19:23  skaller
Factor flx_run more.

Revision 1.94  2006/01/30 08:58:19  skaller
Add package support to flx script

Revision 1.93  2006/01/29 05:58:08  rfistman
fixed windows build (ming nocygwin) after merge

Revision 1.92  2006/01/29 02:53:17  rfistman
fixed missing epoll header for linux.:w

Revision 1.91  2006/01/29 02:17:29  rfistman
using latest demux, added epoll to flx_run (for linux). bugs fixed.

Revision 1.90  2006/01/27 11:44:13  skaller
Fix bug in schannel shape object.

Revision 1.89  2006/01/27 08:40:11  skaller
Moved main driver loop out of mainline in preparation for
librar-ising it. Added separate debug switches for allocation,
collection, and driver diagnostics.

Revision 1.88  2006/01/25 18:39:55  skaller
Add mutex to protect SDL event source. Deploy in sdl110.
Fix bug in rtl, was allocating an slist_t but telling the
gc the shape was an slist_node_t, gc now runs and checks in sdl110.

Revision 1.87  2006/01/24 19:15:49  skaller
Add openGL test sdl110. Currently crashes in gc.
Add async request counter to driver.
Add configuration hack for openGL.

Revision 1.86  2006/01/19 17:26:44  skaller
Add sound to SDL example. Fix serious bug in synchronous
channel I/O operations.

Revision 1.85  2006/01/18 01:50:25  skaller
Fix bug in root_ptr_t class with overloads of operator->

Revision 1.84  2006/01/11 04:30:45  rfistman
added portable sleep

Revision 1.83  2006/01/05 09:43:46  skaller
Compile procedures down to plain C functions if possible.
Optimisation may be a bit optimistic.

Revision 1.82  2006/01/03 16:15:10  skaller
Changed all print functions to fprint, which requires an
ostream as first argument. Provide macro print to support
existing code. Note overloads on print will not work.
Procedures objects can now be created on the stack,
such procedures have no resume method.

Revision 1.81  2006/01/03 04:29:21  rfistman
fixed win32 tests by a) initing winsock in flx_run and using
the correct return value.

Revision 1.80  2006/01/01 09:04:55  rfistman
made a few solaris style changes (own demuxer and a few build
incompatibilities fixed)

Revision 1.79  2005/12/29 18:16:04  skaller
Namespaces and modules added ..

Revision 1.78  2005/12/29 13:52:07  skaller
Added log to rtl and faio.

This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@execfile('config'+os.sep+'flx_data.py')
@include_file ('flx_gc.ipk')
@include_file ('flx_lib.ipk')
@include_file ('flx_lex_lib.ipk')


@h = tangler('spkgs/flx.py')
@select(h)

pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','flx_pthread','demux','faio']

@h = tangler('spkgs/flx_async.py')
@select(h)
cpp_cpps = ['rtl/flx_async']
provide_lib = "libflx_async"
pkg_requires = ['faio','demux','flx_pthread','flx_rtl']
lib_requires = ['libfaio','libdemux','libflx_pthread','libflx']
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "ASYNC"

@h = tangler('spkgs/flx_rtl.py')
@select(h)
RTL_CPPS = [
  "rtl/flx_gc",
  "rtl/flx_collector",
  "rtl/flx_rtl",
  "rtl/flx_dynlink",
  "rtl/flx_sync",
  "rtl/flx_i18n",
  "rtl/flx_ioutil",
  "rtl/flx_main",
]

cpp_cpps = RTL_CPPS
provide_lib = "libflx"
iscr_source = ['lpsrc/flx_rtl.pak']
build_macro = "RTL"

@h = tangler('spkgs/flx_drivers.py')
@select(h)

DRIVERS = [
  ('rtl/flx_run','bin/flx_run'),
  ('test/flx_perf_drv1','test/flx_perf_drv1'),
  ('test/micky_mouse','bin/micky_mouse'),
]

DRLIBS = [
  'libflx_async',
  'libfaio',
  'libdemux',
  'libflx_pthread',
  'libflx'
  ]

drivers = DRIVERS
drivers_require_libs = DRLIBS
pkg_requires = ['flx_async','flx_rtl','flx_pthread']
iscr_source = ['lpsrc/flx_rtl.pak']

@h = tangler('config/flx.fpc')
@select(h)
Name: flx
Description: Felix core runtime support
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_static")
 else:
   tangle("provides_dlib: -lflx_dynamic")
   tangle("provides_slib: -lflx_static")

@h = tangler('config/flx_run.fpc')
@select(h)
Name: flx_run
Description: Felix standard driver
Version: $Id$
Requires: flx_async faio demux flx_pthread flx

@h = tangler('config/flx_async.fpc')
@select(h)
Name: flx_async
Description: Async hook
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_async_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_async_static")
 else:
   tangle("provides_dlib: -lflx_async_dynamic")
   tangle("provides_slib: -lflx_async_static")

Requires: faio demux flx_pthread flx

@h = tangler("rtl/flx_meta.hpp")
@select(h)
#ifndef FLX_META
#define FLX_META
// taken from BOOST
@if HAVE_INCLASS_MEMBER_INITIALIZATION:
  tangle('#define FLX_HAVE_INCLASS_MEMBER_INITIALIZATION')
#ifdef FLX_HAVE_INCLASS_MEMBER_INITIALIZATION
#  define FLX_STATIC_CONSTANT(type, assignment) static const type assignment
#else
#  define FLX_STATIC_CONSTANT(type, assignment) enum { assignment }
#endif

#include <cstddef>

template <std::size_t> struct type_with_alignment;
@for k in flx_aligns.keys():
  t = flx_aligns[k]
  tangle('template <> struct type_with_alignment<'+str(k)+'>{ typedef '+t+' type; };')

template <typename T> struct alignment_of;

template <typename T>
struct alignment_of_hack
{
  char c;
  T t;
  alignment_of_hack();
};

template <unsigned A, unsigned S>
struct alignment_logic
{
  FLX_STATIC_CONSTANT(std::size_t, value = A < S ? A : S);
};

template< typename T >
struct alignment_of
{
  FLX_STATIC_CONSTANT(std::size_t, value =
    (alignment_logic<
      sizeof(alignment_of_hack<T>) - sizeof(T),
      sizeof(T)
    >::value));
};

template<std::size_t L, std::size_t A> 
struct aligned_storage
{
  union type
  {
    unsigned char data_[ L ];
    typename type_with_alignment<A>::type align_;
  };
};

template<typename T>
struct store_of 
{
  typedef typename aligned_storage<sizeof(T), alignment_of<T>::value>::type type;
};

// convert an rvalue to an lvalue
template<typename T> 
T const &lvalue(T const &x) 
{ 
  return x; 
}

// this reinterpret cast works with rvalues too
template<typename T, typename U>
T &reinterpret(U const &x) {
  return reinterpret_cast<T&>(const_cast<U&>(x));
}
#endif

@h = tangler("rtl/flx_rtl_config.hpp")
@select(h)
#ifndef FLX_RTL_CONFIG
#define FLX_RTL_CONFIG

#ifdef _WIN32
#define _WIN32_WINNT 0x500
#endif

#ifndef FLX_RTL_GNU
@if HAVE_ISNAN_IN_IEEEFP:
  tangle('#define HAVE_ISNAN_IN_IEEEFP')

@if HAVE_GXX:
  tangle('#define HAVE_GXX')

@if HAVE_GXX_X86:
  tangle('#define HAVE_GXX_X86')

@if HAVE_GXX_X86_64:
  tangle('#define HAVE_GXX_X86_64')

@if HAVE_CGOTO:
  tangle("#define FLX_HAVE_CGOTO")

@if USE_REGPARM3:
  tangle("#define FLX_USE_REGPARM3")
  
@if HAVE_ASM_LABELS:
  tangle("#define FLX_HAVE_ASM_LABELS")

@if HAVE_DLOPEN:
  tangle("#define HAVE_DLOPEN")

@if MACOSX:
  tangle("#define MACOSX")

@if LINUX:
  tangle("#define FLX_LINUX")


@if SOLARIS:
  tangle("#define SOLARIS")

@if HAVE_MSVC:
  tangle("#define HAVE_MSVC")

@if HAVE_KQUEUE_DEMUXER:
  tangle("#define HAVE_KQUEUE_DEMUXER")

//
#if defined(FLX_HAVE_CGOTO) && defined(FLX_HAVE_ASM_LABELS)
#define FLX_CGOTO
#endif

#if  !defined(FLX_STATIC_LINK) && (defined(_WIN32))
#define FLX_EXPORT __declspec(dllexport)
#define FLX_IMPORT __declspec(dllexport)
#else
#define FLX_EXPORT
#define FLX_IMPORT
#endif


#ifdef BUILD_RTL
#define RTL_EXTERN FLX_EXPORT
#else
#define RTL_EXTERN FLX_IMPORT
#endif

#if defined(MACOSX) && !defined(HAVE_DLOPEN)
#define MACOSX_NODLCOMPAT
#endif

#ifdef HAVE_GXX
#define FLX_ALWAYS_INLINE __attribute__ ((always_inline))
#define FLX_NOINLINE __attribute__ ((noinline))
#define FLX_CONST __attribute__ ((const))
#define FLX_PURE __attribute__ ((pure))
#define GXX_PARSER_HACK (void)0,
#define FLX_UNUSED __attribute__((unused))
#else
#define FLX_ALWAYS_INLINE
#define FLX_NOINLINE 
#define FLX_CONST
#define FLX_PURE 
#define GXX_PARSER_HACK
#define FLX_UNUSED
#endif
#endif

@def cal_raw_address():
  if SIZEOF_INT == SIZEOF_VOIDP: return "unsigned"
  if SIZEOF_LONG == SIZEOF_VOIDP: return "unsigned long"
  if SIZEOF_LONGLONG == SIZEOF_VOIDP: return "unsigned long long"
  raise "Cannot find an int the size of a void pointer"

@tangle("#define FLX_RAWADDRESS "+cal_raw_address())
@tangle('#define FLX_MAX_ALIGN '+str(MAX_ALIGN))


#endif

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@h = tangler("rtl/flx_rtl.hpp")
@select(h)
#ifndef FLX_RTL
#define FLX_RTL
#include "flx_rtl_config.hpp"
#include "flx_meta.hpp"
#ifndef FLX_GC
#include "flx_gc.hpp"
#endif
#include <string>
#include <functional>

#if defined(FLX_PTF_STATIC_STRUCT)
#define PTF ptf.
#elif defined(FLX_PTF_STATIC_POINTER)
#define PTF ptf->
#else
#define PTF ptf->
#endif

// for declarations in header file 
#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t ptf;
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t *ptf;
#else
#define FLX_FMEM_DECL thread_frame_t *ptf;
#define FLX_FPAR_DECL_ONLY thread_frame_t *_ptf
#define FLX_FPAR_DECL thread_frame_t *_ptf,
#define FLX_APAR_DECL_ONLY thread_frame_t *ptf
#define FLX_APAR_DECL thread_frame_t *ptf,
#define FLX_DCL_THREAD_FRAME
#endif

namespace flx { namespace rtl {

// ********************************************************
// Felix system classes
// ********************************************************

struct RTL_EXTERN con_t;     // continuation
struct RTL_EXTERN thread_t; // f-thread
struct RTL_EXTERN _ref_;     // pointer/reference
struct RTL_EXTERN _uctor_;   // union constructor
struct RTL_EXTERN schannel_t;   // synchronous channel type
struct RTL_EXTERN slist_t;   // singly linked list of void*
struct RTL_EXTERN _root_ptr_t;   // singly linked list of void*

struct RTL_EXTERN unit {};   // unit 
  // INLINE DEFINITION, PROBLEMATIC!!

// ********************************************************
// Shape (RTTI) objects for system classes 
// con_t is only an abstract base, so has no fixed shape
// shapes for instance types generated by Felix compiler
// we provide a shape for C 'int' type as well
// ********************************************************

extern RTL_EXTERN flx::gc::generic::gc_shape_t schannel_ptr_map;
extern RTL_EXTERN flx::gc::generic::gc_shape_t _fthread_ptr_map;
extern RTL_EXTERN flx::gc::generic::gc_shape_t _ref_ptr_map;
extern RTL_EXTERN flx::gc::generic::gc_shape_t _uctor_ptr_map;
extern RTL_EXTERN flx::gc::generic::gc_shape_t _int_ptr_map;
extern RTL_EXTERN flx::gc::generic::gc_shape_t unit_ptr_map;
extern RTL_EXTERN flx::gc::generic::gc_shape_t slist_ptr_map;
extern RTL_EXTERN flx::gc::generic::gc_shape_t _root_ptr_ptr_map;

// ********************************************************
// Standard C++ Exceptions
// ********************************************************

struct RTL_EXTERN flx_exception_t;
struct RTL_EXTERN flx_exec_failure_t;
struct RTL_EXTERN flx_range_srcref_t;
struct RTL_EXTERN flx_match_failure_t;
struct RTL_EXTERN flx_assert_failure_t;
struct RTL_EXTERN flx_switch_failure_t;
// ********************************************************
/// CONTINUATION.
// ********************************************************

struct RTL_EXTERN con_t ///< abstract base for mutable continuations
{
#ifdef FLX_CGOTO
  void *pc;                 ///< interior program counter
#else
   int pc;
#endif

  _uctor_ *p_svc;           ///< pointer to service request

  con_t();                  ///< initialise pc, p_svc to 0
  virtual con_t *resume()=0;///< method to perform a computational step
  virtual ~con_t();
  con_t * _caller;          ///< callers continuation (return address)
};

// ********************************************************
/// SLIST. singly linked lists: SHARABLE and COPYABLE
/// SLIST manages pointers to memory managed by the collector
// ********************************************************

struct RTL_EXTERN slist_t {
  gc::generic::collector_t *gc;
  struct slist_node_t *head;

  slist_t (gc::generic::collector_t *); ///< create empty list
  slist_t (slist_t const &);            ///< shallow copy

  void push(void *data);                ///< push a gc pointer
  void *pop();                          ///< pop a gc pointer
  bool isempty()const;
};

// ********************************************************
/// FTHREAD. Felix threads
// ********************************************************

struct RTL_EXTERN fthread_t // fthread abstraction
{
  con_t *cc;                    ///< current continuation

  fthread_t();                  ///< dead thread, suitable for assignment
  fthread_t(con_t*);            ///< make thread from a continuation
  _uctor_ *run();               ///< run until dead or driver service request
  void kill();                  ///< kill by detaching the continuation
  _uctor_ *get_svc()const;      ///< get current service request of waiting thread
private: // uncopyable
  fthread_t(fthread_t const&); 
  void operator=(fthread_t const&);
};

// ********************************************************
/// SCHANNEL. Synchronous channels
// ********************************************************

struct RTL_EXTERN schannel_t 
{
  slist_t *waiting_to_read;             ///< fthreads waiting for a writer
  slist_t *waiting_to_write;            ///< fthreads waiting for a reader
  schannel_t(gc::generic::collector_t*);
  void push_reader(fthread_t *);        ///< add a reader
  fthread_t *pop_reader();              ///< pop a reader, NULL if none
  void push_writer(fthread_t *);        ///< add a writer
  fthread_t *pop_writer();              ///< pop a writer, NULL if none
private: // uncopyable
  schannel_t(schannel_t const&); 
  void operator= (schannel_t const&); 
};

// ********************************************************
/// REFERENCE. Felix pointer type
/// note: non-polymorphic, so ctor can be inline
/// This type is used to represent pointers to variables.
/// It has two components: a frame pointer and offset.
/// A whole frame is refered to by setting the offset to 0.
/// A non-collectable pointer is refered to by setting the frame to 0
/// References are first class values: they can copied, assigned,
/// and default constructed. Holding a reference in a location
/// known to the gc ensures the target variable is not collected:
/// Such references cannot dangle.
/// The frame/offset representation was chosen since it fits
/// well with a copying collector: the price is that finding
/// the interior pointer requires adding the offset to the frame
/// pointer. Note that 'frame' points to the CLIENTDATA address
/// of a frame where user data starts: this is not the lowest
/// machine address of the frame's allocated memory or FRAME
/// address, despite the name.
// ********************************************************

struct RTL_EXTERN _ref_
{
  void *frame;      ///< Heap frame pointer
  std::ptrdiff_t offset;   ///< Client Data offset

  _ref_() : frame(0),offset(0) {} ///< NULL reference
  _ref_(void *f, void *d): 
    frame(f), offset((unsigned char*)d-(unsigned char*)f) {} 
      ///< init from interior pointer d of a collectable frame f
  
  _ref_(void *f, std::ptrdiff_t d): 
    frame(f), offset(d) {} ///< init from collectable frame f and offset d

  _ref_(_ref_ const& r) : frame(r.frame), offset(r.offset) {} 
    ///< copy constructor

  void operator = (_ref_ const& r); ///< assignment operator

  void *get_data()const { return (unsigned char*)frame + offset; } 
    ///< get interior pointer
    
  void set_data(void *p) 
    { offset = (unsigned char*)p - (unsigned char*)frame; } 
    ///< set interior pointer into same frame

  void set(void *f, void *p) 
  { frame = f; offset = (unsigned char*)p - (unsigned char*)f; } ///< set from frame f and interior pointer
};


// ********************************************************
/// VARIANTS. Felix union type
/// note: non-polymorphic, so ctor can be inline
// ********************************************************

struct RTL_EXTERN _uctor_
{
  int variant;  ///< Variant code
  void *data;   ///< Heap variant constructor data
  _uctor_() : variant(-1), data(0) {}
  _uctor_(int i, void *d) : variant(i), data(d) {}
};

// ********************************************************
/// ROOT POINTER.
/// Use to chain pseudo roots together. Generally scannable
/// but not collectable. 
// ********************************************************

struct RTL_EXTERN _root_ptr_t
{
  _root_ptr_t();
  _root_ptr_t(void *x);
  _root_ptr_t(_root_ptr_t const&);
  void operator=(_root_ptr_t const&);
  ~_root_ptr_t();

  _root_ptr_t *next;
  _root_ptr_t *prev;
  void *data;

private:
  void insert_after (_root_ptr_t*);
  void erase();
};

// INLINE! All casts
template<class T>
struct root_ptr_t : _root_ptr_t {
  root_ptr_t(){}
  root_ptr_t(root_ptr_t<T> const&){}
  root_ptr_t<T>& operator=(root_ptr_t<T> const &a){
    return reinterpret_cast<root_ptr_t<T>&>(_root_ptr_t::operator=(a));
  }
 ~root_ptr_t(){}

  root_ptr_t(T const *a) : _root_ptr_t (const_cast<T*>(a)) {}
  
  T *operator->() { return (T*)data; }
  T const *operator->() const { return (T const*)data; }
  T &operator*() { return *(T*)data; }
  T const &operator*() const { return *(T const*)data; }
};

template<class T>
bool operator == (root_ptr_t<T> a, root_ptr_t<T> b)
{
  return a-> data == b->data;
}

template<class T>
bool operator != (root_ptr_t<T> a, root_ptr_t<T> b)
{
  return a-> data != b->data;
}

template<class T>
bool operator < (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::less<void const*>()(a-> data, b->data);
}

template<class T>
bool operator <= (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::less_equal<void const*>()(a-> data, b->data);
}

template<class T>
bool operator > (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::greater<void const*>()(a-> data, b->data);
}

template<class T>
bool operator >= (root_ptr_t<T> const &a, root_ptr_t<T> const &b)
{
  // we use this because it enforces a total order
  return std::greater_equal<void const*>()(a-> data, b->data);
}


// ********************************************************
/// EXCEPTION: Felix exception base abstraction.
/// Mainly used to convert catches into subroutine
/// calls which then dispatch on RTTI manually.
// ********************************************************

struct RTL_EXTERN flx_exception_t {
  virtual ~flx_exception_t()=0;
};

// ********************************************************
/// EXCEPTION: EXEC protocol failure.
/// Thrown when trying to run a dead procedure
// ********************************************************

struct RTL_EXTERN flx_exec_failure_t : flx_exception_t {
  std::string filename;  ///< dll filename
  std::string operation; ///< faulty operation
  std::string what;      ///< error description
  flx_exec_failure_t(std::string f, std::string o, std::string w);
  virtual ~flx_exec_failure_t();
};

// ********************************************************
/// SOURCE REFERENCE: to track places in user source code.
// ********************************************************

struct RTL_EXTERN flx_range_srcref_t {
  char *filename;  ///< source file name
  int startline;   ///< first line (1 origin)
  int startcol;    ///< first column (1 origin)
  int endline;     ///< last line
  int endcol;      ///< last column
  flx_range_srcref_t(char *f,int sl, int sc, int el, int ec);
};

// ********************************************************
/// EXCEPTION: MATCH failure.
/// Thrown when no match cases match the argument of a match,
/// regmatch, or reglex
// ********************************************************

struct RTL_EXTERN flx_match_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char *cxx_srcfile;          ///< C++ file name
  int cxx_srcline;            ///< C++ line number
  flx_match_failure_t(flx_range_srcref_t ff, char *cf, int cl);
  virtual ~flx_match_failure_t();
};

// ********************************************************
/// EXCEPTION: ASSERT failure.
/// Thrown when user assertion fails
// ********************************************************

struct RTL_EXTERN flx_assert_failure_t : flx_exception_t {
  flx_range_srcref_t flx_loc; ///< location in Felix file
  char *cxx_srcfile;          ///< C++ file
  int cxx_srcline;            ///< __LINE__ macro
  flx_assert_failure_t(flx_range_srcref_t ff, char *cf, int cl);
  virtual ~flx_assert_failure_t();
};

// ********************************************************
/// EXCEPTION: SWITCH failure. this is a system failure!
// ********************************************************

struct RTL_EXTERN flx_switch_failure_t : flx_exception_t {
  virtual ~flx_switch_failure_t();
};


// ********************************************************
// SERVICE REQUEST CODE
// THESE VALUES MUST SYNCH WITH THE STANDARD LIBRARY
// ********************************************************

enum svc_t               // what the dispatch should do
{                        // when the resume callback returns
  svc_yield = 0,
  svc_get_fthread=1,
  svc_read=2,
  svc_general=3,         // temporary hack by RF
  svc_reserved=4,
  svc_spawn_pthread=5,
  svc_spawn_detached=6,
  svc_sread=7,           // synchronous read
  svc_swrite=8,          // synchronous write
  svc_kill=9,           // kill fthread
  svc_compact=10,        // run compactor
  svc_collect=11,        // run collector
  svc_collect_and_compact=12,        // run collector and compactor
  svc_end
};

struct readreq_t {
  schannel_t *chan;
  _ref_ variable;
};

}} // namespaces

#define FLX_MATCH_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_match_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

#define FLX_ASSERT_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_assert_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

// for generated code in body file
#define INIT_PC pc=0;

#ifdef FLX_CGOTO
  #define FLX_START_SWITCH if(pc)goto *pc;
  #define FLX_SET_PC(x) pc=&&case_##x;
  #define FLX_CASE_LABEL(x) case_##x:;
  #define FLX_DECLARE_LABEL(n,i,x) \
    extern void f##i##_##n##_##x(void) __asm__("l"#i"_"#n"_"#x);
  #define FLX_LABEL(n,i,x) x:\
    __asm__(".global l"#i"_"#n"_"#x);\
    __asm__("l"#i"_"#n"_"#x":");\
    __asm__(""::"g"(&&x));
  #define FLX_FARTARGET(n,i,x) (void*)&f##i##_##n##_##x
  #define FLX_END_SWITCH
#else
  #define FLX_START_SWITCH switch(pc){case 0:;
  #define FLX_SET_PC(x) pc=x;
  #define FLX_CASE_LABEL(x) case x:;
  #define FLX_DECLARE_LABEL(n,i,x)
  #define FLX_LABEL(n,i,x) case n: x:;
  #define FLX_FARTARGET(n,i,x) n
  #define FLX_END_SWITCH default: throw flx_switch_failure_t(); }
#endif

#define FLX_RETURN \
{ \
  con_t *tmp = _caller; \
  _caller = 0; \
  return tmp; \
}

#define FLX_NEWP(x) new(*PTF gc,x##_ptr_map)x

#define FLX_FINALISER(x) \
static void x##_finaliser(collector_t *, void *p){\
  ((x*)p)->~x();\
}

#if defined(FLX_USE_REGPARM3) && defined(HAVE_GXX_X86)
#define FLX_REGPARM __attribute__((regparm(3)))
#else
#define FLX_REGPARM
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define FLX_APAR_PASS_ONLY
#define FLX_APAR_PASS
#define _PTF _ptf.
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT_PTF(x)
#define FLX_DEF_THREAD_FRAME thread_frame_t ptf;
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define FLX_APAR_PASS_ONLY
#define FLX_APAR_PASS
#define _PTF _ptf->
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT
#define FLX_DEF_THREAD_FRAME thread_frame_t *ptf=0;
#else
#define FLX_FMEM_INIT_ONLY : ptf(_ptf)
#define FLX_FMEM_INIT : ptf(_ptf),
#define FLX_FPAR_PASS_ONLY ptf
#define FLX_FPAR_PASS ptf,
#define FLX_APAR_PASS_ONLY _ptf
#define FLX_APAR_PASS _ptf,
#define _PTF _ptf->
#define _PTFV _ptf
#define FLX_PASS_PTF 1
#define FLX_EAT_PTF(x) x
#define FLX_DEF_THREAD_FRAME
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  ptf.gc = gc;\
  return &ptf;\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  mname::thread_frame_t *p = new(*gc,mname::thread_frame_t_ptr_map) mname::thread_frame_t(gc);\
  ptf = p;\
  return p;\
}
#else
#define FLX_FRAME_WRAPPERS(mname) \
extern "C" FLX_EXPORT mname::thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  mname::thread_frame_t *p = new(*gc,mname::thread_frame_t_ptr_map) mname::thread_frame_t(gc);\
  return p;\
}
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,mname::x##_ptr_map) \
    mname::x()) ->call(0);\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,mname::x##_ptr_map) \
    mname::x()) ->call(0);\
}
#else 
#define FLX_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,mname::x##_ptr_map) \
    mname::x(ptf)) ->call(0);\
}
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x().stack_call();\
  return 0;\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x().stack_call();\
  return 0;\
}
#else 
#define FLX_STACK_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x(ptf).stack_call();\
  return 0;\
}
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x();\
  return 0;\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x();\
  return 0;\
}
#else 
#define FLX_C_START_WRAPPER(mname,x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  mname::thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  mname::x(ptf);\
  return 0;\
}
#endif

#endif

@h = tangler("rtl/flx_rtl.cpp")
@select(h)
#include "flx_rtl.hpp"
#include <cstdio>
#include <cassert>

namespace flx { namespace rtl {

// ********************************************************
// con_t implementation
// ********************************************************

con_t::con_t() : pc(0), p_svc(0), _caller(0) { 
#ifdef FLX_DEBUG_CONT
 fprintf(stderr,"Constructing %p\n",this);
#endif
}
con_t::~con_t(){
#ifdef FLX_DEBUG_CONT
  fprintf(stderr,"Destroying %p\n",this);
#endif
}

// ********************************************************
// slist implementation
// ********************************************************

// PRIVATE to the slist_t class!
struct slist_node_t {
  slist_node_t *next;
  void *data;
  slist_node_t(slist_node_t *n, void *d) : next(n), data(d) {}
};

//OFFSETS for slist_node_t
static std::size_t slist_node_offsets[2]={
    offsetof(slist_node_t,next),
    offsetof(slist_node_t,data)
};

flx::gc::generic::gc_shape_t slist_node_ptr_map(
  NULL,
  "slist_node_t",
  1,sizeof(slist_node_t),
  0, // no finaliser,
  2,
  slist_node_offsets
);


slist_t::slist_t(gc::generic::collector_t *_gc) : gc (_gc), head(0) {}
slist_t::slist_t(slist_t const &r) : gc (r.gc), head(r.head) {}

bool slist_t::isempty()const { return head == 0; }

void slist_t::push(void *data) 
{
  head = new(*gc,slist_node_ptr_map) slist_node_t(head,data);
}

// note: never fails, return NULL pointer if the list is empty
void *slist_t::pop()
{
  if(head) { 
    void *data = head->data; 
    head=head->next; 
    return data; 
  }
  else return 0;
}

//OFFSETS for slist_t
static std::size_t slist_offsets[1]={
    offsetof(slist_t,head)
};

flx::gc::generic::gc_shape_t slist_ptr_map(
  &slist_node_ptr_map,
  "slist_t",
  1,sizeof(slist_t),
  0, // no finaliser
  1,
  slist_offsets
);

// ********************************************************
// _root_ptr_t implementation
// ********************************************************

_root_ptr_t::_root_ptr_t() : next(0), prev(0), data(0) {}
_root_ptr_t::_root_ptr_t(void *x) : next(0), prev(0), data(x) {}
_root_ptr_t::~_root_ptr_t() { erase(); }

void _root_ptr_t::insert_after(_root_ptr_t *a) {
  prev = a;
  next = prev->next;
  prev->next = this;
  if(next)next->prev = this;
  data = next->data;
}

_root_ptr_t::_root_ptr_t(_root_ptr_t const &a) {
  insert_after(const_cast<_root_ptr_t*>(&a));
}

void _root_ptr_t::operator=(_root_ptr_t const &a) {
  if (&a != this)
  {
    erase(); 
    insert_after(const_cast<_root_ptr_t*>(&a));
  }
}

//OFFSETS for root_ptr_t
static std::size_t _root_ptr_offsets[3]={
    offsetof(_root_ptr_t,next),
    offsetof(_root_ptr_t,prev),
    offsetof(_root_ptr_t,data)
};

flx::gc::generic::gc_shape_t _root_ptr_ptr_map(
  &slist_ptr_map,
  "_root_ptr_t",
  1,sizeof(_root_ptr_t),
  0, // no finaliser
  1,
  _root_ptr_offsets
);

void _root_ptr_t::erase() {
  next->prev = prev;
  prev->next = next;
  next = 0; prev = 0;
  data = 0;
}

// ********************************************************
// fthread_t implementation
// ********************************************************

fthread_t::fthread_t() : cc(0) {}
fthread_t::fthread_t(con_t *a) : cc(a) {}

// uncopyable object but implementation needed for linker
fthread_t::fthread_t(fthread_t const&){ assert(false); }
void fthread_t::operator=(fthread_t const&){ assert(false); }

void fthread_t::kill() { cc = 0; }

_uctor_ *fthread_t::get_svc()const { return cc?cc->p_svc:0; }

_uctor_ *fthread_t::run() {
  if(!cc) return 0; // dead
restep:
  cc->p_svc = 0;
step:  
  //fprintf(stderr,"cc=%p->",cc);
  try { cc = cc->resume(); }
  catch (con_t *x) { cc = x; }

  //fprintf(stderr,"->%p\n",cc);
  if(!cc) return 0; // died

  if(cc->p_svc)
  {
    switch(cc->p_svc->variant)
    {
      case svc_get_fthread: 
        **(fthread_t***)(cc->p_svc->data) = this;
        goto restep;      // handled
        
      //case svc_yield: 
      //  goto restep;

      // we don't know what to do with the request,
      // so pass the buck to the driver
      default:
        return cc->p_svc;
    }
  }
  goto step;
}


//OFFSETS for fthread_t
static std::size_t _fthread_offsets[1]={
    offsetof(fthread_t,cc)
};

flx::gc::generic::gc_shape_t _fthread_ptr_map(
  &_root_ptr_ptr_map,
  "fthread_t",
  1,sizeof(fthread_t),
  0,
  1,
  _fthread_offsets,
  gc::generic::gc_flags_immobile
);

// ********************************************************
// schannel_t implementation
// ********************************************************

schannel_t::schannel_t (gc::generic::collector_t *gc) : 
  waiting_to_read(0), waiting_to_write(0) 
{
  waiting_to_read = new (*gc, slist_ptr_map) slist_t(gc);
  waiting_to_write = new (*gc, slist_ptr_map) slist_t(gc);
}

// uncopyable object but implementation needed for linker
schannel_t::schannel_t(schannel_t const&) { assert(false); }
void schannel_t::operator=(schannel_t const&) { assert(false); }

void schannel_t::push_reader(fthread_t *r)
{
  waiting_to_read->push(r);
}

void schannel_t::push_writer(fthread_t *w)
{
  waiting_to_write->push(w);
}

fthread_t *schannel_t::pop_reader()
{
  return (fthread_t*)waiting_to_read->pop();
}

fthread_t *schannel_t::pop_writer()
{
  return (fthread_t*)waiting_to_write->pop();
}

//OFFSETS for schannel_t
static std::size_t schannel_offsets[2]={
    offsetof(schannel_t,waiting_to_read),
    offsetof(schannel_t,waiting_to_write)
};

flx::gc::generic::gc_shape_t schannel_ptr_map(
  &_fthread_ptr_map,
  "schannel_t",
  1,sizeof(schannel_t),
  0, // no finaliser
  2,
  schannel_offsets
);

// ********************************************************
// _ref_ implementation
// ********************************************************

void _ref_::operator = (_ref_ const& r)
{
  if (frame != r.frame || offset != r.offset)
  {
    frame = r.frame;
    offset = r.offset;
  }
}

//OFFSETS for _ref_
static std::size_t _ref_offsets[1]={
    offsetof(_ref_,frame)
};

flx::gc::generic::gc_shape_t _ref_ptr_map(
  &schannel_ptr_map,
  "_ref_",
  1,sizeof(_ref_),
  0, // no finaliser
  1,
  _ref_offsets
);

// ********************************************************
// _uctor_ implementation
// ********************************************************

//OFFSETS for _uctor_
static std::size_t _uctor_offsets[1]= { 
  offsetof(_uctor_,data) 
};

flx::gc::generic::gc_shape_t _uctor_ptr_map (
  &_ref_ptr_map,
  "_uctor_",
  1,
  sizeof(_uctor_),
  0,
  1,
  _uctor_offsets
);

// ********************************************************
// int implementation
// ********************************************************

flx::gc::generic::gc_shape_t _int_ptr_map (
  &_uctor_ptr_map,
  "int",
  1,
  sizeof(int),
  0,
  0,
  0
);

// ********************************************************
// unit implementation
// ********************************************************

flx::gc::generic::gc_shape_t unit_ptr_map (
  &_int_ptr_map,
  "unit",
  1,
  sizeof(unit),
  0,
  0,
  0
);
                                                                                
// ********************************************************
// standard exceptions -- implementation
// ********************************************************
flx_exception_t::~flx_exception_t(){}

flx_exec_failure_t::flx_exec_failure_t(std::string f, std::string o, std::string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_exec_failure_t::~flx_exec_failure_t(){}

flx_range_srcref_t::flx_range_srcref_t(char *f,int sl, int sc, int el, int ec) :
    filename(f),startline(sl),startcol(sc),endline(el),endcol(ec){}
flx_match_failure_t::flx_match_failure_t(flx_range_srcref_t ff, char *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_match_failure_t::~flx_match_failure_t(){}
flx_assert_failure_t::flx_assert_failure_t(flx_range_srcref_t ff, char *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_assert_failure_t::~flx_assert_failure_t(){}
flx_switch_failure_t::~flx_switch_failure_t(){}

}}

@head(2,"Unix Dynamic linker")
This is a Unix specific module, which uses dlopen
and friends to dynamically attach a shared file
representing a felix top level module to an 
application, and extract the standard 
symbols from it.
@p()
The link routine links the following symbols,
which must be present in all felix libraries.

@begin_displayed_code()
  create_thread_frame
  start
@end_displayed_code()

The unlink routine is called to unlink the library.
@p()
Note that felix never generates variables of static,
storage class, however felix has no control over
used C/C++ code embedded in Felix library modules.
DO NOT use static storage class for variables,
or even constants which require dynamic initialisation.

@h = tangler("rtl/flx_dynlink.hpp")
@select(h)
#ifndef FLX_DYNLINK
#define FLX_DYNLINK
#ifndef FLX_RTL
#include "flx_rtl.hpp"
#include "flx_gc.hpp"
#endif
#include <string>
using namespace std;

// define the type of a library handle: needed even for static linkage
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
#include <windows.h>
typedef HMODULE LIBHANDLE;
#else
  #ifdef MACOSX_NODLCOMPAT
     #include <mach-o/dyld.h>
     typedef NSModule LIBHANDLE;
   #else
     typedef void *LIBHANDLE;
   #endif
#endif

#ifndef FLX_STATIC_LINK
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
#define DLSYM(x,y) (void*)GetProcAddress(x,#y) 
#define SDLSYM(x,y) (void*)GetProcAddress(x,y) 
#else
  #ifdef MACOSX_NODLCOMPAT
    //#include <mach-o/dyld.h>
    #define DLSYM(x, y) flx::rtl::getmachosym(x,"_"#y)
    #define SDLSYM(x, y) flx::rtl::getmachosym(x,(string("_")+string(y)).data())
  #else
    #include <dlfcn.h>
    #define DLSYM(x,y) dlsym(x,#y)
    #define SDLSYM(x,y) dlsym(x,y)
  #endif
#endif

#else
#define DLSYM(x,y) (void*)&y
#define SDLSYM(x,y) (throw flx::rtl::link_failure_t("<static link>",y,"dlsym with static link requires name not string")
#endif
// Utilities to make dynamic linkage and
// initialisation of Felix modules easier
//
// We provide a standard exception to report
// link failure (missing symbol).
//
// We provide a class flx_dynlink_t which
// opens a Felix shared library given a filename,
// and links the mandatory symbols
// The user may derive from this class to add
// linkage for extra symbols
//
// We provide a class flx_libinit_t which
// initialises and terminates a Felix module
// The user may derive from this class to add
// extra initialisation or termination processing.
//
// [Note: the virtuals are *deliberately* private. 
// Be sure to make your overrides private too,
// so they cannot be called:
// they're dispatched automatically by wrappers
// defined in the base]

// must be at global scope, because the users' is
struct thread_frame_t;

namespace flx { namespace rtl {

struct RTL_EXTERN flx_link_failure_t;
struct RTL_EXTERN flx_dynlink_t;
struct RTL_EXTERN flx_libinit_t;

/// Dynamic linkage failure.

struct RTL_EXTERN flx_link_failure_t {
  string filename;
  string operation;
  string what;
  flx_link_failure_t(string f, string o, string w);
  virtual ~flx_link_failure_t();
};

/// frame creators.

typedef thread_frame_t *(*thread_frame_creator_t)
(
  flx::gc::generic::collector_t*
);

/// library initialisation routine.

typedef con_t *(*start_t)
(
  thread_frame_t*,
  int,
  char **,
  FILE*,
  FILE*,
  FILE*
  
);

typedef con_t *(*main_t)(thread_frame_t*);

/// dynamic object loader.

struct RTL_EXTERN flx_dynlink_t
{
  // data
  LIBHANDLE library;
  string filename;
  thread_frame_creator_t thread_frame_creator;
  start_t start_sym;
  main_t main_sym;
  long refcnt;

  // routines
  void link(char const *filename) throw(flx_link_failure_t);
  void unlink();
  virtual ~flx_dynlink_t();
  flx_dynlink_t();

private:
  // the user should override this procedure to
  // link any extra symbols.
  // on error, throw a flx_link_failure_t,
  // otherwise your exception will be dishonoured
  // and a generic link_failure_t thrown anyhow

  flx_dynlink_t(flx_dynlink_t const&); // uncopyable
  void operator=(flx_dynlink_t const&); // uncopyable
  virtual void usr_link();
    // called after mandatory symbols are linked
};

/// Thread Frame Initialisation.

struct RTL_EXTERN flx_libinit_t 
{
  thread_frame_t *thread_frame;
  con_t *start_proc;
  con_t *main_proc;
  flx_dynlink_t *lib;
  flx::gc::generic::collector_t *collector;
  void create
  (
    flx_dynlink_t *lib_a, 
    flx::gc::generic::collector_t *collector_a,
    main_t main_sym,
    int argc,
    char **argv,
    FILE *stdin_,
    FILE *stdout_,
    FILE *stderr_
  );

  void destroy ();

  con_t *bind_proc(void *fn, void *data);
  virtual ~flx_libinit_t();
  flx_libinit_t();
  
private:
  flx_libinit_t(flx_libinit_t const&);
  void operator=(flx_libinit_t const&);
  // the user can override these procedures
  // to perform any additional initialisation
  // and termination required.
  
  virtual void usr_create(); 
    // called after standard init completes
    
  virtual void usr_destroy(); 
    // called before standard destroy starts
};

#ifdef MACOSX_NODLCOMPAT
void* getmachosym(LIBHANDLE, const char*);
#endif

}} // namespaces
#endif

@h = tangler("rtl/flx_dynlink.cpp")
@select(h)
#include "flx_dynlink.hpp"
#ifdef FLX_STATIC_LINK
extern "C" void *create_thread_frame;
extern "C" void *flx_start;
extern "C" void *flx_main;
#endif

namespace flx { namespace rtl {

#ifdef MACOSX_NODLCOMPAT
void*
getmachosym(NSModule library, const char* symname)
{
    NSSymbol    sym = NSLookupSymbolInModule(library, symname);
    if(sym)
        return NSAddressOfSymbol(sym);
    return 0;
}

#endif

flx_link_failure_t::flx_link_failure_t(string f, string o, string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_link_failure_t::~flx_link_failure_t(){}

flx_dynlink_t::~flx_dynlink_t() {}
flx_dynlink_t::flx_dynlink_t(flx_dynlink_t const&) {} // no copy hack
void flx_dynlink_t::operator=(flx_dynlink_t const&) {} // no copy hack
 
flx_dynlink_t::flx_dynlink_t() :
  library(0),
  filename(""), 
  thread_frame_creator(NULL),
  start_sym(NULL),
  main_sym(NULL),
  refcnt(0)
{}


void flx_dynlink_t::link(char const *fname) throw(flx_link_failure_t)
{
  filename=fname;
#ifndef FLX_STATIC_LINK
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
  SetErrorMode(SEM_NOOPENFILEERRORBOX);  // stop windows showing err dialogues
  library = LoadLibrary(fname);
  if(!library) 
    throw flx_link_failure_t(filename,"LoadLibrary","Cannot find dll");
#else
  #ifdef MACOSX_NODLCOMPAT
    NSObjectFileImage            bndl_img;
    NSObjectFileImageReturnCode  res;

    res = NSCreateObjectFileImageFromFile(fname, &bndl_img);

	if(NSObjectFileImageSuccess != res)
      throw flx_link_failure_t(filename, "NSCreateObjectFileImageFromFile",
              "failure to open library");

    // don't merge globals with loader's, load programmatically
    // return on error allows us to continue without being terminated

    unsigned long                link_flags;
    link_flags = NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR;
    library = NSLinkModule(bndl_img, fname, link_flags);

    // even if link failed, we do this
    NSDestroyObjectFileImage(bndl_img);

    // more info can be gleaned about link errors from NSLinkEditError
    if(!library)
      throw flx_link_failure_t(filename, "NSLinkModule", "failed to link");

  #else
  library = dlopen(fname,RTLD_NOW);
  if(!library) 
    throw flx_link_failure_t(filename,"dlopen",dlerror());
  #endif
#endif
#endif

  //fprintf(stderr,"File %s dlopened at %p ok\n",fname,library);

  thread_frame_creator = (thread_frame_creator_t)
    DLSYM(library,create_thread_frame);
  if(!thread_frame_creator) 
    throw flx_link_failure_t(filename,"dlsym","create_thread_frame");

  //fprintf(stderr,"Thread frame creator found at %p\n",thread_frame_creator);

  start_sym = (start_t)DLSYM(library,flx_start);
  if(!start_sym) 
    throw flx_link_failure_t(filename,"dlsym","flx_start");

  main_sym = (main_t)DLSYM(library,flx_main);

  //fprintf(stderr,"Start symbol found at %p\n",start_sym);
  //fprintf(stderr,"main symbol found at %p\n",main_sym);
  
  refcnt = 1L;

  //fprintf(stderr,"Set refcnt to 1\n");
  try { usr_link(); }
  catch (flx_link_failure_t &) { throw; }
  catch (...) { 
    throw flx_link_failure_t
    (
      filename,
      "usr_link()",
      "Unknown user exception"
    );
  }
}

void flx_dynlink_t::unlink()
{
  --refcnt;
  if(refcnt == 0) {
    //fprintf(stderr,"closing library\n");
#ifndef FLX_STATIC_LINK
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
    FreeLibrary(library);
#else
  #ifdef MACOSX_NODLCOMPAT
    NSUnLinkModule(library, NSUNLINKMODULE_OPTION_NONE);
  #else
    dlclose(library);
  #endif
#endif
#endif
  }
}

void flx_dynlink_t::usr_link(){}

flx_libinit_t::~flx_libinit_t(){}
flx_libinit_t::flx_libinit_t() :
  thread_frame (NULL),
  start_proc (NULL),
  main_proc (NULL),
  lib (NULL),
  collector(NULL) 
{}

flx_libinit_t::flx_libinit_t(flx_libinit_t const&){}
void flx_libinit_t::operator=(flx_libinit_t const&){}

void flx_libinit_t::create
(
  flx_dynlink_t *lib_a, 
  flx::gc::generic::collector_t *collector_a,
  main_t main_sym,
  int argc,
  char **argv,
  FILE *stdin_,
  FILE *stdout_,
  FILE *stderr_
)
{
  lib = lib_a;
  collector = collector_a;
  thread_frame = lib->thread_frame_creator(
    collector 
  );
  //fprintf(stderr,"Incrementing refcnt\n");
  ++lib->refcnt;
  collector->add_root(thread_frame);
  start_proc = lib->start_sym(thread_frame, argc, argv, stdin_,stdout_,stderr_);
  main_proc = main_sym?main_sym(thread_frame):0;
  usr_create();
}

void flx_libinit_t::usr_create(){}

void flx_libinit_t::destroy () {
  usr_destroy();
  collector->remove_root(thread_frame);
  //fprintf(stderr,"Decrementing refcnt\n");
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
  --lib->refcnt;
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
}

void flx_libinit_t::usr_destroy (){}

con_t *flx_libinit_t::bind_proc(void *fn, void *data) {
  typedef con_t *(*binder_t)(void *,void*);
  return ((binder_t)fn)(thread_frame,data);
}

}} // namespaces

@h = tangler("rtl/flx_sync.hpp")
@select(h)
#ifndef _FLX_SYNC
#define _FLX_SYNC

#include "flx_gc.hpp"
#include "flx_dynlink.hpp"
#include "flx_rtl.hpp"
#include <list>

namespace flx { namespace run {

enum fstate_t { terminated, blocked, delegated };
enum fpc_t { next_fthread_pos, next_request_pos };

RTL_EXTERN char const * get_fstate_desc(fstate_t);
RTL_EXTERN char const * get_fpc_desc(fpc_t);

struct RTL_EXTERN gc_profile_t {
  bool debug_allocations;
  bool debug_collections; 
  unsigned long compact; 
  unsigned long gc_freq;
  unsigned long gc_counter;
  unsigned long collections;
  bool finalise;
  flx::gc::generic::collector_t *collector;

  gc_profile_t (
    bool debug_allocations_, 
    bool debug_collections_, 
    unsigned long compact_, 
    unsigned long gc_freq_,
    bool finalise_,
    flx::gc::generic::collector_t *collector
  );
  ~gc_profile_t();
};

struct RTL_EXTERN sync_state_t {
  bool debug_driver;
  gc_profile_t *gcp;
  std::list<flx::rtl::fthread_t*> *active;
  flx::rtl::fthread_t *ft;
  flx::rtl::_uctor_ *request;
  fpc_t pc;
  fstate_t fs;
  sync_state_t (
    bool debug_driver_,
    gc_profile_t *gcp_,
    std::list<flx::rtl::fthread_t*> *active_
  );
  void frun();
};

}}

#endif

@h = tangler("rtl/flx_sync.cpp")
@select(h)
#include "flx_sync.hpp"
using namespace flx::rtl;

namespace flx { namespace run {

RTL_EXTERN char const *get_fstate_desc(fstate_t fs)
{
  switch(fs)
  {
    case terminated: return "terminated";
    case blocked: return "blocked";
    case delegated: return "delegated";
    default: return "Illegal fstate_t";
  }
}

RTL_EXTERN char const *get_fpc_desc(fpc_t fpc)
{
  switch(fpc)
  {
    case next_fthread_pos: return "Next fthread pos";
    case next_request_pos: return "Next request pos";
    default: return "Illegal fpc_t";
  }
}


gc_profile_t::gc_profile_t (
  bool debug_allocations_, 
  bool debug_collections_, 
  unsigned long compact_, 
  unsigned long gc_freq_,
  bool finalise_,
  flx::gc::generic::collector_t *collector_
) :
  debug_allocations(debug_allocations_),
  debug_collections(debug_collections_),
  compact(compact_),
  gc_freq(gc_freq_),
  gc_counter(0),
  collections(0),
  finalise(finalise_),
  collector(collector_)
{
}

gc_profile_t::~gc_profile_t() { }

sync_state_t::sync_state_t (
  bool debug_driver_,
  gc_profile_t *gcp_,
  std::list<fthread_t*> *active_
) : 
  debug_driver(debug_driver_),
  gcp(gcp_),
  active(active_),
  pc(next_fthread_pos)
{}

void sync_state_t::frun()
{
  // local copies are faster
  flx::gc::generic::collector_t *collector = gcp->collector;

  // dispatch
  if (pc == next_request_pos) goto next_request;
  if (pc == next_fthread_pos) goto next_fthread;
  fprintf(stderr,"BUG -- unreachable code in frun\n");
  abort();

next_fthread:
  if (active->size() == 0) {
    fs = blocked; 
    pc = next_fthread_pos;
    return; 
  }
  ft = active->front();
  active->pop_front();

next_request:
  request = ft->run();
  if(request != 0) goto check_collect;

forget_fthread:
  if(debug_driver)fprintf(stderr,"unrooting fthread %p\n",ft);
  collector->remove_root(ft);
  goto next_fthread;

delegate:
  pc = next_request_pos;
  fs = delegated;
  return;

check_collect:  
  gcp->gc_counter++;
  if(gcp->gc_counter == gcp->gc_freq)
  {
    gcp->gc_counter = 0;
    gcp->collections++;
    unsigned long n = collector->collect();
    if(gcp->compact) collector->compact(true);
    if(gcp->debug_collections)fprintf(stderr,"collected %ld objects\n",n);
  }
    
  switch(request->variant)
  {
    case svc_yield: 
    {
      if(debug_driver)fprintf(stderr,"yield");
      active->push_back(ft);
    }
    goto next_fthread;

    case svc_spawn_detached:
    {
      fthread_t *ftx = *(fthread_t**)request->data;
      if(debug_driver)fprintf(stderr,"Spawn thread %p\n",ftx);
      collector->add_root(ftx);
      active->push_front(ftx);
    }
    goto next_request;

    case svc_sread:
    {
      readreq_t * pr = (readreq_t*)request->data;
      schannel_t *chan = pr->chan;
      if(debug_driver)fprintf(stderr,"Request to read on channel %p\n",chan);
    svc_read_next:
      {
        fthread_t *writer= chan->pop_writer();
        if(writer == 0) goto svc_read_none;       // no writers
        if(writer->cc == 0) goto svc_read_next;   // killed
        {
          readreq_t * pr = (readreq_t*)request->data;
          readreq_t * pw = (readreq_t*)writer->get_svc()->data;
          if(debug_driver)fprintf(stderr,"Writer @%p=%p, read into %p\n", pw->variable.get_data(),*(void**)pw->variable.get_data(), pr->variable.get_data());
          *(void**)pr->variable.get_data() = *(void**)pw->variable.get_data();
          active->push_front(writer);
          collector->add_root(writer);
        }
      }
      goto next_request;

    svc_read_none:
      if(debug_driver)fprintf(stderr,"No writers on channel %p: BLOCKING\n",chan);
      chan->push_reader(ft);
    }
    goto forget_fthread;

    case svc_swrite:
    {
      readreq_t * pr = (readreq_t*)request->data;
      schannel_t *chan = pr->chan;
      if(debug_driver)fprintf(stderr,"Request to write on channel %p\n",chan);
    svc_write_next:
      {
        fthread_t *reader= chan->pop_reader();
        if(reader == 0) goto svc_write_none;     // no readers
        if(reader->cc == 0) goto svc_write_next; // killed
        {
          readreq_t * pw = (readreq_t*)request->data;
          readreq_t * pr = (readreq_t*)reader->get_svc()->data;
          if(debug_driver)fprintf(stderr,"Writer @%p=%p, read into %p\n", pw->variable.get_data(),*(void**)pw->variable.get_data(), pr->variable.get_data());
          *(void**)pr->variable.get_data() = *(void**)pw->variable.get_data();
          active->push_front(reader);
          collector->add_root(reader);
        }
      }
      goto next_request;

    svc_write_none:
      if(debug_driver)fprintf(stderr,"No readers on channel %p: BLOCKING\n",chan);
      chan->push_writer(ft);
    }
    goto forget_fthread;
    
    case svc_kill:
    {
      fthread_t *ftx = *(fthread_t**)request->data;
      if(debug_driver)fprintf(stderr,"Request to kill fthread %p\n",ftx);
      ftx -> kill();
    }
    goto next_request;

    case svc_compact:
    {
      // requires fthreads to be immobile
      if(debug_driver)fprintf(stderr,"svc compact\n");
      collector->compact(false);
    }
    goto next_request;

    case svc_collect:
    {
      // requires fthreads to be immobile
      if(debug_driver)fprintf(stderr,"svc collect\n");
      collector->collect();
    }
    goto next_request;

    case svc_collect_and_compact:
    {
      // requires fthreads to be immobile
      if(debug_driver)fprintf(stderr,"svc collect and compact\n");
      collector->collect();
      collector->compact(true);
    }
    goto next_request;

    default:  goto delegate;
  } 
  fprintf(stderr,"BUG unreachable code executed\n");
  abort();
}

}}

@head(2,'Universal Program Driver')
This driver runs stand alone Felix programs.
It invokes the library routine 'start'.
No messages are dispatched, the Felix
program must not read any messages.
@p()
For statically linked programs,
command line arguments are passed directly,
the debugging switch isn't supported.
@p()
For dynamically loaded programs, the name of the
driver and optional --debug switch given before the
shared library name are not passed.

@h = tangler('rtl/flx_async.hpp','hpp')
@select(h)
#ifndef __FLX_ASYNC__
#define __FLX_ASYNC__
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"

class RTL_EXTERN async_hooker {
public:
  virtual flx::rtl::fthread_t *dequeue()=0;
  virtual bool handle_request(void *data, flx::rtl::fthread_t *ss)=0;
  virtual ~async_hooker();
};

RTL_EXTERN async_hooker *
create_async_hooker(
  int n0,   // bound on resumable thread queue
  int n1,   // bound on general input job queue
  int m1,   // number of threads in job pool
  int n2,   // bound on async fileio job queue
  int m2    // number of threads doing async fileio
);

#endif

@h = tangler('rtl/flx_async.cpp','cpp')
@select(h)
#include "flx_async.hpp"
#include "pthread_sleep_queue.hpp"
#include "flx_rtl.hpp"
#include "demux_demuxer.hpp"
#include "faio_drv.hpp"

using namespace flx::rtl;
using namespace flx::demux;
using namespace flx::faio;
using namespace flx::pthread;


class async_hooker_impl : public async_hooker {
  virtual flx::faio::flx_drv *get_driver()=0;
  virtual flx::demux::demuxer *get_demuxer()=0;
public:
  bool handle_request(void *data,fthread_t *ss);
  ~async_hooker_impl();
};


#ifdef _WIN32
 #include "demux_iocp_demuxer.hpp"
 #include "faio_wdrv.hpp"
 typedef flx::demux::iocp_demuxer flx_demuxer;
#elif defined(HAVE_KQUEUE_DEMUXER)
 #include "demux_kqueue_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::kqueue_demuxer flx_demuxer;
#elif defined(SOLARIS)
 #include "demux_evtport_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::evtport_demuxer flx_demuxer;
#elif defined(FLX_LINUX)
 #include "demux_epoll_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::epoll_demuxer flx_demuxer;
#else
 #include "demux_ts_select_demuxer.hpp"
 #include "faio_pdrv.hpp"
 typedef flx::demux::ts_select_demuxer flx_demuxer;  // thread safe!
#endif

#include "faio_asyncio.hpp"

async_hooker::~async_hooker(){ fprintf(stderr,"Deleted sync_hooker\n"); }
async_hooker_impl::~async_hooker_impl(){ fprintf(stderr,"Deleted sync_hooker_impl\n"); }

bool async_hooker_impl::handle_request(void *data,fthread_t *ft)
{
  flx::faio::flx_driver_request_base* dreq = 
        (flx::faio::flx_driver_request_base*)data
  ;

  //fprintf(stderr,"Request object at %p\n",dreq);
  // RF hates the flag this function returns .. might
  // mask a race condition, get rid of it

  bool result =dreq->start_async_op(
   *get_demuxer(), 
   get_driver(), 
  ft)
  ;
  return result;
}

class proto_async : public async_hooker_impl
{
   flx_demuxer demux;

    sleep_queue_t async_active;
    flx_thread_t ethread;

#ifdef _WIN32
    wflx_drv driver;
    static DWORD pthread_thread(LPVOID udat);
#else
    pflx_drv driver;
    static void* pthread_thread(void* udat);
#endif

public:
   proto_async(int n0, int n1, int m1, int n2, int m2) : 
     async_active(n0), driver(async_active,n1,m1,n2,m2) 
   {
     // start waiting thread
#if _WIN32
     // cast callback to itself. go figure.
     if(ethread.init((LPTHREAD_START_ROUTINE)pthread_thread, &demux) == -1) throw -1;
#else
     if(ethread.init(pthread_thread, &demux) == -1) throw -1;
#endif
   }

  ~proto_async(){ fprintf(stderr,"Deleted proto async\n"); }
  flx_drv *get_driver() { return &driver; }
  demuxer *get_demuxer(){ return &demux; }
  fthread_t* dequeue() 
  { 
    return (fthread_t*)async_active.dequeue(); 
  }
};

#ifdef _WIN32
DWORD
proto_async::pthread_thread(LPVOID udat)
#else
void*
proto_async::pthread_thread(void* udat)
#endif
{
    demuxer*    d = (demuxer*)udat;

    while(1)                // cancellation? what's that?
    {
        d->wait();          // this does it
    }
    return 0;
}

async_hooker *create_async_hooker(int n0,int n1,int m1,int n2,int m2) {
  return new proto_async(n0,n1,m1,n2,m2);
}

@h = tangler('rtl/flx_run.cxx','cpp')
@select(h)
#include <cstdlib>
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <cstring>
#include <cassert>

#include <string>
//#include <unistd.h>
#include "flx_rtl.hpp"

#include "flx_async.hpp"

#include "flx_ts_collector.hpp"
#include "flx_dynlink.hpp"
#include "flx_sync.hpp"
#include "pthread_thread.hpp"
#include "pthread_counter.hpp"

using namespace std;
using namespace flx::rtl;
using namespace flx::pthread;
using namespace flx::run;

#ifdef HAVE_GXX_X86
register void *sp __asm__("esp");
#else
#ifdef HAVE_GXX_X86_64
register void *sp __asm__("rsp");
#else
static void *sp = 0;
#endif
#endif

#ifdef _WIN32
  #include "demux_iocp_demuxer.hpp"
  // needed to perform win socket io (calls WSAInit). Must happen
  // before iocp_demuxer is instantiated and (I assume) happen
  // only once.
  // JS: No, it can be called any number of times, provided
  // the destructor WSACleanup is called same number of times
  // Use of this RAII object ensures WSAinit/Cleanup calls balance.
  // RF: Still has to happen before any socket calls. Putting it in
  // the async object which is created on command is already too late.
  // If that's a problem then any socket creation calls would have to
  // gratuitously make async calls.
  flx::demux::winsock_initer wsinit;
#endif


int do_final_cleanup(
  bool debug_driver, 
  gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
);

void print_loc(FILE *ef,flx_range_srcref_t x,char *cf, int cl)
{
  fprintf(ef,"Felix location: %s %d[%d]-%d[%d]\n",
    x.filename,
    x.startline,
    x.startcol,
    x.endline,
    x.endcol
  );
  fprintf(ef,"C++ location  : %s %d\n", cf, cl);
}

struct doflx_data 
{
  bool debug_driver;
  gc_profile_t *gcp;
  std::list<fthread_t*> *active;
  flx_ts_counter_t *thread_counter;
  doflx_data(bool d, gc_profile_t *g, std::list<fthread_t*> *a, flx_ts_counter_t *tc)
   : debug_driver(d), gcp(g), active(a), thread_counter(tc) {}
};

int flx_exception_handler (flx_exception_t *e)
{
  if (flx_link_failure_t *x = dynamic_cast<flx_link_failure_t*>(e))
  {
    fprintf(stderr,"Dynamic linkage error\n");
    fprintf(stderr,"filename: %s\n",x->filename.data());
    fprintf(stderr,"operation: %s\n",x->operation.data());
    fprintf(stderr,"what: %s\n",x->what.data());
    return 2;
  }
  else
  if (flx_exec_failure_t *x = dynamic_cast<flx_exec_failure_t*>(e))
  {
    fprintf(stderr,"Execution error\n");
    fprintf(stderr,"filename: %s\n",x->filename.data());
    fprintf(stderr,"operation: %s\n",x->operation.data());
    fprintf(stderr,"what: %s\n",x->what.data());
    return 3;
  }
  else
  if (flx_assert_failure_t *x = dynamic_cast<flx_assert_failure_t*>(e))
  {
    fprintf(stderr,"Assertion Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  if (flx_match_failure_t *x = dynamic_cast<flx_match_failure_t*>(e))
  {
    fprintf(stderr,"Match Failure\n");
    print_loc(stderr,x->flx_loc,x->cxx_srcfile, x->cxx_srcline);
    return 3;
  }
  else
  {
    fprintf(stderr,"Unknown EXCEPTION!\n");
    return 4;
  }
}


#ifdef _WIN32
DWORD
#else
void*
#endif
doflx (void *data) {
  doflx_data *d = (doflx_data*)data;
  bool debug_driver = d->debug_driver;
  gc_profile_t *gcp = d-> gcp;
  std::list<fthread_t*> *active = d->active;
  flx_ts_counter_t *thread_counter=d->thread_counter;
  delete d;

  unsigned long async_count = 0;
  async_hooker* async = NULL;

  try 
  {
    sync_state_t ss(debug_driver, gcp, active);

  process_active:
    if(debug_driver)
      fprintf(stderr,"Process active ..");

    if(debug_driver)
      fprintf(stderr,"Before running: Sync state is %s/%s\n",
        get_fstate_desc(ss.fs),get_fpc_desc(ss.pc));

    ss.frun();

    if(debug_driver)
      fprintf(stderr,"After running: Sync state is %s/%s\n",
        get_fstate_desc(ss.fs),get_fpc_desc(ss.pc));

    if (ss.fs == terminated) goto cleanup;
    if (ss.fs == blocked) goto do_async;

    if (ss.fs == delegated) 
    switch (ss.request->variant)
    {
      case svc_spawn_pthread:
      {
        fthread_t *ftx = *(fthread_t**)ss.request->data;
        if(debug_driver)fprintf(stderr,"Spawn pthread %p\n",ftx);
        gcp->collector->add_root(ftx);
        std::list<fthread_t*> *pactive =new std::list<fthread_t*>;
        pactive->push_front(ftx);
        void *data = new doflx_data(debug_driver, gcp, pactive, thread_counter);
        flx_detached_thread_t dummy;
        fprintf(stderr,"Starting new pthread, thread counter= %p\n",thread_counter);
        thread_counter->pre_incr();
        //++*thread_counter;
        fprintf(stderr,"pthread counter %p incremented\n",thread_counter);
        dummy.init(
  #ifdef _WIN32
    (LPTHREAD_START_ROUTINE)
  #endif
          doflx,data);
      }
      goto process_active;

      case svc_general:
      {
        if(debug_driver)
          fprintf(stderr,"svc_general from fthread=%p\n",ss.ft);
        if( !async ) async = create_async_hooker(
            20000, // bound on resumable thread queue
            50,    // bound on general input job queue
            2,     // number of threads in job pool
            50,    // bound on async fileio job queue
            1      // number of threads doing async fileio
         );

        ++async_count;
        void *dreq =  (((_ref_*)(ss.request->data))->get_data());

        //fprintf(stderr,"Request object at %p\n",dreq);
        // RF hates the flag this function returns .. might
        // mask a race condition, get rid of it
        if(!async->handle_request(dreq, ss.ft))
        {
          ss.pc = next_fthread_pos;
        } 
        else {
          --async_count;
          ss.pc = next_request_pos;
        }
      }
      goto process_active;

      default:
        fprintf(stderr,"Unknown service request code 0x%4x\n",ss.request->variant);
        abort();
    }
    fprintf(stderr,"Unknown frun return status 0x%4x\n",ss.fs);
    abort();

  do_async:
    // ran out of active threads - are there any in the async queue?
    if(debug_driver){
      fprintf(stderr, "out of active synchronous threads, trying async, count=%ld\n",async_count);
    }

    if(async && async_count > 0){
      // STILL A ROOT
      fthread_t* ftp = async->dequeue();
      if(debug_driver)
        fprintf(stderr,"Async Retrieving fthread %p\n",ftp);
      active->push_front(ftp);
      --async_count;
      ss.pc = next_fthread_pos;
      goto process_active;
    }

    if(debug_driver)fprintf(stderr,"Out of jobs\n");
  cleanup:;
  }
  catch (flx_exception_t &x) { flx_exception_handler (&x); }
  catch (...) { fprintf(stderr,"Unknown exception in thread!\n"); }

  try
  {
    if(debug_driver)fprintf(stderr,"Terminating Felix subsystem\n");
    delete async;
    delete active;
  }
  catch (...) { fprintf(stderr,"Unknown exception deleting async!\n"); }

  // if this fails the whole system is corrupted
  --*thread_counter;
  return 0;
}

// RUN A FELIX INSTANCE IN THE CURRENT PTHREAD

int run_felix_pthread(
  bool debug_driver, 
  gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
)
{    
   flx::gc::generic::collector_t *collector = gcp->collector;
   std::list<fthread_t*> *active =new std::list<fthread_t*>;

  fthread_t *flx_main = NULL;
  {
    con_t *top = instance->main_proc;
    if(top)
    {
      flx_main = new (*collector,_fthread_ptr_map) fthread_t(top);
      collector->add_root(flx_main);
      active->push_front(flx_main);
    }
  }

  {
    con_t *top = instance->start_proc;
    fthread_t *ft = new (*collector,_fthread_ptr_map) fthread_t(top);
    collector->add_root(ft);
    active->push_front(ft);
  }

  {
    flx_ts_counter_t thread_counter;
    ++thread_counter;
    doflx(new doflx_data(debug_driver, gcp, active, &thread_counter)); // deletes active for us!

    if(debug_driver){
      unsigned long uncollected = collector->get_allocation_count();
      unsigned long roots = collector->get_root_count();
      fprintf(stderr,
        "program finished, %ld collections, %ld uncollected objects, roots %ld\n",
        gcp->collections,uncollected,roots);
    }
  }

  if(gcp->finalise)
    do_final_cleanup(debug_driver, gcp, library, instance);
  return 0;
}

// terminates process! 
// Not called by default (let the OS clean up)
// 
// NEEDS TO BE SPLIT UP so that destroying
// a program instance is separated from unloading
// the library

int do_final_cleanup(
  bool debug_driver, 
  gc_profile_t *gcp,
  flx_dynlink_t *library,
  flx_libinit_t *instance
)
{
  flx::gc::generic::collector_t *collector = gcp->collector;

  // garbage collect application objects
  {
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Finalisation: pass 1 Data collection starts ..\n");
    unsigned long n = collector->collect();
    unsigned long a = collector->get_allocation_count();
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"flx_run collected %ld objects, %ld left\n",n,a);
  }

  // Destroy program instance/ thread frame object

  if(debug_driver)
    fprintf(stderr,"Destroying program instance\n");
  instance->destroy();

  // garbage collect system objects

  {
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Finalisation: pass 2 Final collection starts ..\n");
    unsigned long n = collector->collect();
    unsigned long a = collector->get_allocation_count();
    if(debug_driver || gcp->debug_collections)
      fprintf(stderr,"Collected %ld objects, %ld left (should be 0)\n",n,a);
    if(a!=0){
      fprintf(stderr,"flx_run %ld uncollected objects, should be zero!!\n",a);
      return 5;
    }
  }

  // dump the DLL

  if(debug_driver)
    fprintf(stderr,"Libref cnt = %ld\n",library->refcnt);
  if(library->refcnt >0)
  {
    if(debug_driver)
      fprintf(stderr,"flx_run %p library still referenced %ld times\n",
        library->library,library->refcnt
      );
  }
  if(debug_driver)
    fprintf(stderr,"Unlinking library ..\n");
  library->unlink();
  return 0;
}

// MAINLINE, ONLY DONE ONCE
int run_felix(
  bool debug_driver, 
  gc_profile_t *gcp,
  char *filename, 
  int flx_argc, 
  char **flx_argv
)
{
  try 
  {
    if(debug_driver)
      fprintf(stderr,"flx_run driver begins %s\n",flx_argv[0]);
    flx_dynlink_t library;
    flx_libinit_t instance;
    library.link(filename);

    flx::gc::generic::collector_t *collector = gcp->collector;

    instance.create(&library, collector,library.main_sym,flx_argc,flx_argv,stdin,stdout,stderr);

    if(debug_driver){
      fprintf(stderr,"loaded library %s at %p\n",filename,library.library);
      fprintf(stderr,"thread frame at %p\n",instance.thread_frame);
      fprintf(stderr,"initial continuation at %p\n",instance.start_proc);
      fprintf(stderr,"main continuation at %p\n",instance.main_proc);
    } 
    run_felix_pthread(debug_driver,gcp,&library,&instance);

    if(gcp->finalise)
    {
      if(library.refcnt >0)
      {
        fprintf(stderr,"flx_run %p library still referenced %ld times?!\n",library.library,library.refcnt);
        return 6;
      }
      if(debug_driver)
        fprintf(stderr,"flx_run driver ends with finalisation complete\n");
    }
    else 
    {
      if(debug_driver || gcp->debug_collections)
      {
        unsigned long a = collector->get_allocation_count();
        fprintf(stderr,"flx_run driver ends with finalisation skipped, %ld uncollected objects\n",a);
      }
    }
  }
  catch (flx_exception_t &x)
  {
    return flx_exception_handler(&x);
  }
  catch (...)
  {
    fprintf(stderr,"flx_run driver ends with unknown EXCEPTION\n");
    return 4;
  }
  return 0;
}

int main(int argc, char** argv)
{
#ifndef FLX_STATIC_LINK  
  bool static_link = false;
  if (argc<2) 
  {
    printf("usage: flx_run [--debug] dll_filename options ..\n");
    printf("  environment variables:\n");
    printf("  FLX_DEBUG               # enable debugging traces (default off)\n");
    printf("  FLX_DEBUG_ALLOCATIONS   # enable debugging allocator (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_COLLECTIONS   # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_DRIVER        # enable debugging driver (default FLX_DEBUG)\n");
    printf("  FLX_FINALISE            # whether to cleanup on termination (default NO)\n");
    printf("  FLX_COMPACT=n           # size of compaction arena, 0 to disable (default)\n");
    printf("  FLX_GC_FREQ=n           # how often to call garbage collector (default 1000)\n");
    return 1;
  }
  char *filename = argv[1];
  char **flx_argv = argv+1;
  int flx_argc = argc-1;
  bool debug = (argc > 1) && (strcmp(argv[1],"--debug")==0);
  if(debug)
  {
    if(argc<3)
    {
      printf("usage: flx_run [--debug] dll_filename options ..\n");
      return 1;
    }
    filename = argv[2];
    --flx_argc;
    ++flx_argv;
  }
#else
  bool static_link = true;
  char *filename = argv[0];
  char **flx_argv = argv;
  int flx_argc = argc;
  bool debug = false;
//  printf("Statically linked Felix program running\n");
#endif
  char *debug_env = std::getenv("FLX_DEBUG");
  debug = debug || debug_env != 0;
  if(debug)
  {
    fprintf(stderr,"[FLX_DEBUG] Debug enabled for %s link program\n",static_link?"static":"dynamic");
  }

  bool debug_allocations = debug || std::getenv("FLX_DEBUG_ALLOCATIONS") !=0;
  if(debug_allocations)
  {
    fprintf(stderr,"[FLX_DEBUG_ALLOCATIONS] Allocation debug enabled\n");
  }

  bool debug_collections = debug || std::getenv("FLX_DEBUG_COLLECTIONS") !=0;
  if(debug_collections)
  {
    fprintf(stderr,"[FLX_DEBUG_COLLECTIONS] Collection debug enabled\n");
  }


  bool debug_driver = debug || std::getenv("FLX_DEBUG_DRIVER") !=0;
  if(debug_driver)
  {
    fprintf(stderr,"[FLX_DEBUG_DRIVER] Driver debug enabled\n");
  }


  char *finalise_env= std::getenv("FLX_FINALISE");
  bool finalise = finalise_env != 0;

  if(debug) 
    fprintf(stderr,"[FLX_FINALISE] Finalisation %s\n",finalise? "Enabled" : "Disabled");

  char *compact_env= std::getenv("FLX_COMPACT");
  unsigned long compact = compact_env?atol(compact_env):0;
  if(debug)
  {
    if(compact)
      fprintf(stderr,"[FLX_COMPACT] Compacting with arena minimum size = %ldK\n",compact);
    else
      fprintf(stderr,"[FLX_COMPACT] Compaction initially OFF\n");
  }
  compact = compact * 1024;

  char *gc_freq_env= std::getenv("FLX_GC_FREQ");
  unsigned long gc_freq = gc_freq_env?atol(gc_freq_env):1000;
  if (gc_freq < 1) gc_freq = 1;
  if(debug)
    fprintf(stderr,"[FLX_GC_FREQ] call gc every %lu iterations\n",gc_freq);

#ifdef HAVE_GXX
    if(debug)fprintf(stderr, "Compiled by g++\n");
    static void *init_sp = sp;
    static void *init_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *init_ret = __builtin_return_address(0);
    if(debug)fprintf(stderr, "Stack pointer = %p, frame=%p, return=%p\n",sp,init_fframe,init_ret);
#endif
  if(debug)
    for(int i=0; i<flx_argc; ++i) 
    fprintf(stderr,"flx_argv[%d]->%s\n",i,flx_argv[i]);
    
  flx::gc::generic::allocator_t *allocator = 
    new flx::gc::collector::malloc_free()
  ;
  allocator->set_debug(debug_allocations);

  flx::gc::collector::flx_collector_t *collector =
    new flx::gc::collector::flx_ts_collector_t(allocator)
  ;
  collector->set_debug(debug_collections);
  if(compact)
  {
    collector->set_min_arena_size(compact);
    collector->compact(false);
  }


  gc_profile_t *gcp = new gc_profile_t(
    debug_allocations, 
    debug_collections, 
    compact, 
    gc_freq,
    finalise,
    collector
  );
  run_felix(
    debug_driver,
    gcp,
    filename,flx_argc,flx_argv
  );

  delete gcp;
  delete collector;
  delete allocator;

#ifdef HAVE_GXX
    // check the frame pointer isn't corrupted
    static void *fin_sp = sp;
    static void *fin_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *fin_ret = __builtin_return_address(0);
    if (init_sp != fin_sp ) {
      fprintf(stderr,"g++: STACK POINTER ERROR %p != %p\n",init_sp,fin_sp);
    }
// I have to comment this out, because it only applies if the
// gcc compiler is using the frame pointer.. it doesn't if you
// say -fomit-frame-pointer, for example .. I don't know if there
// is a way to tell inside the code ..
#if 0
    if (init_fframe != fin_fframe) {
      fprintf(stderr,"g++: FRAME POINTER ERROR %p != %p\n",init_fframe,fin_fframe);
    }
#endif
    else if (init_ret != fin_ret) {
      fprintf(stderr,"g++: RETURN ADDRESS ERROR %p != %p\n",init_ret,fin_ret);
    }
#endif
  if(debug)fprintf(stderr,"flx_run driver ends OK\n");
  return 0;
}

@h = tangler('rtl/flx_main.cpp','cpp')
@select(h)
#include "flx_rtl_config.hpp"
#include "flx_rtl.hpp"
// THIS IS A DO NOTHING MAINLINE FOR USE WHEN STATICALLY LINKING
extern "C" flx::rtl::con_t *flx_main( void *p){ return 0; }


@h = tangler('test/micky_mouse.cxx','cpp')
@select(h)
#include <stdio.h>
#include "flx_rtl.hpp"
#include "flx_collector.hpp"
#include "flx_dynlink.hpp"

using namespace std;
using namespace flx;

int main(int argc, char** argv)
{
  rtl::flx_dynlink_t library;
  rtl::flx_libinit_t instance;
  library.link(argc>1?argv[1]:"<static>");
  gc::collector::malloc_free allocator;
  gc::collector::flx_collector_t collector(&allocator);
  instance.create(&library, &collector,library.main_sym,argc,argv,stdin,stdout,stderr);
  rtl::con_t *top = instance.start_proc;
  while( top ) top = top->resume();
  return 0;
}


@select(tangler('rtl/flx_i18n.hpp'))
#ifndef FLX_I18N
#define FLX_I18N
#include <string>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace i18n {
   RTL_EXTERN std::string utf8(unsigned long);
}}}
#endif

@select(tangler('rtl/flx_i18n.cpp'))
#include "flx_i18n.hpp"
namespace flx { namespace rtl { namespace i18n {
  std::string utf8(unsigned long i) 
  {
    char s[6];
    if (i < 0x80UL ) 
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL ) 
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL ) 
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL ) 
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL ) 
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else 
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}}

