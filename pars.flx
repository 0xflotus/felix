// Grammar

// A simple parser for BNF

union Sym =
  | Term of string
  | Nonterm of string
;

instance Str[Sym] {
  fun str: Sym -> string =
  | Term s => '"' + s + '"'
  | Nonterm s => s
  ;
}

typedef prod_t = (nt:string, rhs: list[Sym]);

union token_t =
  | Name of string
  | Strng of string
  | Semi
  | Produces // ::=
  | Eof
;

instance Str[token_t] {
  fun str : token_t -> string =
  | Name s => "Name " + s
  | Strng s => "String " + s
  | Semi => ";"
  | Produces => "::="
  | Eof => "EOF"
  ;
}

struct Buffer 
{
  s: StringPiece;
  i: size;
  fun atend => self.i >= self.s.len;
  fun get => 
    if self.atend then char "" 
    else *(self.s.data+self.i)
  ;
  proc next  { 
    if self*.i < self*.s.len perform pre_incr self.i;
  }
}

instance Str[Buffer] {
  fun str (x:Buffer) => "@"+x.i.str;
}

ctor Buffer (s:&string) =>
  Buffer (StringPiece s, 0uz)
;

gen tokenise (b:&Buffer) : token_t = 
{
skipwhite:>
  if b*.get == char "" return Eof;

  if b*.get.ord <= " ".char.ord do
    b.next;
    goto skipwhite;
  done

  if isidstart b*.get do
    var id = "" + b*.get;
    b.next;
    while iscidcont b*.get do
      id += b*.get;
      b.next;
    done
    return Name id;

  elif b*.get == char ";" do
    b.next;
    return Semi;

  elif b*.get == char ":" do
    b.next;
    if b*.get != char ":" do
      println$ "Expected : to follow :";
      System::exit 1;
    done
    b.next;
    if b*.get != char "=" do
      println$ "Expected = to follow ::";
      System::exit 1;
    done
    b.next;
    return Produces;

  elif b*.get == char '"' do
    b.next;
    var s = "";
    while b*.get != char '"' do // add escapes later
      s += b*.get;
      b.next;
    done
    b.next;
    return Strng s;

  else 
    println$ "Error char " + b*.get + " at pos " + b*.i.str;
    System::exit 1;
  done

}

chip tsrc (b: &Buffer)
  connector tif
    pin out : %>token_t
{
  while not b*.atend do
    var token = tokenise b;
    write (tif.out,token);
  done
}

chip ptoks 
  connector tif
    pin inp : %<token_t
{
  while true do
    var token = read tif.inp;
    print$ token.str;
    match token with
    | Eof
    | Semi => println$ "";
    | _ => print " ";
    endmatch;
  done 
}

// test

var sample = """Grammar::=Prods;
  Prods ::= Prod ;
  Prods ::= Prod Prods;
  Prod ::= Name "::=" Syms ;
  Syms ::= Sym ;
  Syms ::= Sym Syms ;
  Sym ::= Terminal ;
  Sym ::= Name ;
  Terminal ::= "::=" ;
  Terminal ::= ";";
  Name ::= "Grammar";
  Name ::= "Prods";
  Name ::= "Prod";
  Name ::= "Syms";
  Name ::= "Sym";
  Name ::= "Terminal";
  Name ::= "Name";
""";


begin
  println$ "TEST 1, tokenision";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, ptoks.inp
  endcircuit
end

chip parseprod
  connector tif
    pin inp : %<token_t
    pin out: %>opt[prod_t]
{
restart:>
   var token = read tif.inp;
   match token with
   | Eof => 
     write(tif.out, None[prod_t]); 
     return;

   | Name s =>
     var name = s;
     goto l2;

   | _ => 
     println$ "Error, expected name on LHS of production";
     return; // suicide
   endmatch;

l2:>
   token = read tif.inp;
   match token with
   | Produces =>
     goto l3;
   | _ =>
     println$ "Error, expected ::= after LHS of production";
     return;
   endmatch;

l3:>
   var symbols =  Empty[Sym];
l4:>
   token = read tif.inp;
   match token with
   | Semi => 
     write (tif.out, Some (nt = name, rhs = rev symbols));
     goto restart;
   | Name s =>
     symbols = Nonterm s ! symbols;
     goto l4;
   | Strng s =>
     symbols = Term s ! symbols;
     goto l4;
   | _ => 
     println$ "Error, expected Name, String, or Semicolon in RHS of production";
     return;
   endmatch;
}

chip printprod
  connector pr
    pin inp : %<opt[prod_t]
{
  while true do
    var p = read pr.inp;
    match p with
    | None => println$ "Eof";
    | Some p => 
      println$ p.nt + " ::= " + catmap " " (str of Sym) p.rhs + ";"; 
    endmatch;
  done 
}

begin
  println$ "TEST 2, parsing";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, parseprod.inp 
    connect parseprod.out, printprod.inp
  endcircuit
end

typedef alts_t = list[list[Sym]];
typedef grammar_t = string * strdict[alts_t];

chip collate
  connector pr
    pin inp : %<opt[prod_t]
    pin out : %>grammar_t
{
nextg:>
  var start = "";
  var g = strdict[alts_t]();
nextp:>
  var p = read pr.inp;
  match p with 
  | None => 
    write(pr.out,(start,g));
    goto nextg;

  | Some p =>
    if start == "" perform start = p.nt;
    var alts = get_dflt g (p.nt, Empty[list[Sym]]);
    add g p.nt (p.rhs ! alts);
    goto nextp;
  endmatch;
}

chip pgram 
  connector gr
    pin inp : %<grammar_t
{
  while true do
    var g = read gr.inp;
    println$ g.str;
  done
}

begin
  println$ "TEST 3, collation";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, parseprod.inp
    connect parseprod.out, collate.inp 
    connect collate.out, pgram.inp
  endcircuit
end

chip check_closure
  connector gr
   pin inp : %<grammar_t
   pin out : %>grammar_t
{
  var ok = true;
  var start,g = read gr.inp;
  for alt in g 
    for prod in alt.1 
      for sym in prod do
        match sym with
        | Term _ => ;
        | Nonterm s =>
          if not (haskey g s) do
            println$ "Nontermial " + s + " not defined";
            ok = false;
          done
        endmatch;
      done
  if ok call
    write (gr.out, (start,g));
}

begin
  println$ "TEST 4, closure";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, parseprod.inp
    connect parseprod.out, collate.inp 
    connect collate.out, check_closure.inp
    connect check_closure.out, pgram.inp
  endcircuit
end

// upgrade to skip C++ comments later
chip skip_white 
  connector buf
    pin inp : %<Buffer
    pin out : %>Buffer
{
  var b = read buf.inp;
  while b.get <= char ' ' and b.get != char "" perform b&.next;
  write (buf.out, b);
}

chip parse_strng (var s:string) 
  connector buf
    pin inp : %<Buffer
    pin out : %>Buffer
{
  println$ "parse_strng: matcher for '"+s+"'";;
  while true do
    var b = read buf.inp;
  println$ "parse_strng: Trying to match '"+s+"' at pos " + b.i.str;
    for ch in s do
      if ch != b.get return;
      &b.next;
    done
    println$ "parse_string: string "+s+"  matched";
    write (buf.out, b); 
  done
}

chip parse_regex (re:RE2)
  connector buf
    pin inp : %<Buffer
    pin out : %>Buffer 
{
  var b = read buf.inp;
  var v = StringPiece "";
  var result = Match (re, b.s, b.i.int, ANCHOR_START, (+&v), 1);
  if result do 
    println$ "Re matched " + v.str;
    b&.i <- b.i + v.len;
    write (buf.out, b); 
  done
}

chip sendbuf (b:Buffer)
  connector buf
    pin out: %>Buffer
{
  write (buf.out,b);
}

chip showbuf 
  connector buf
    pin inp: %<Buffer
{
  while true do
    var b = read buf.inp;
    println$ "Buffer pos = " + b.i.str;
  done
}

// test white, string, re matching
// forced sequence protocol
begin
  println$ "TEST 5, white, string, re matches, manual sequence";
  var b = Buffer (&sample);

  device bsrc = sendbuf b;
  device white1 = skip_white;
  device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
  device white2 = skip_white;
  device produces = parse_strng ("::=");
  device white3 = skip_white;
  device hello = parse_strng('Prods');
  circuit
     connect bsrc.out, white1.inp
     connect white1.out, identifier.inp
     connect identifier.out, white2.inp
     connect white2.out, produces.inp
     connect produces.out, white3.inp
     connect white3.out, hello.inp
     connect hello.out, showbuf.inp
  endcircuit
end

chip pipeline[T] (v: varray [(inp:%<T, out:%>T) -> 1 -> 0])  
  connector io
    pin inp: %<T
    pin out: %>T
{
  var input = io.inp;
  for i in 0..(v.len.int - 2) do
    var nextinp,out = mk_ioschannel_pair[T]();
    spawn_fthread (v.i (inp=input,out=out));
    input = nextinp;
  done
  spawn_fthread (v.(v.len.int - 1) (inp=input, out=io.out));
//println$ "Pipeline length " + v.len.str + " created";
}

begin
  println$ "TEST 6, pipeline";
  var b = Buffer (&sample);
  device bsrc = sendbuf b;

  device white1 = skip_white;
  device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
  device white2 = skip_white;
  device produces = parse_strng ("::=");
  device white3 = skip_white;
  device hello = parse_strng('Prods');
  var seq = varray( white1, identifier,white2,produces, white3,hello);
  device p = pipeline seq;
  circuit
    connect bsrc.out, p.inp
    connect p.out, showbuf.inp
  endcircuit
end


chip send_each[T,U with Str[T]] (v: varray [(inp:%<T, out: %>U) -> 1 -> 0])
  connector io
    pin inp: %<T
    pin out: %>U
{
  var n = v.len;

  // make an array of communication channels
  var iochans = varray[%<T * %>T] (n,n,(fun (i:size)=>mk_ioschannel_pair[T]()));
  // launch each machine, connected to one input channel from the array
  // this is trick, because Felix captures variables by reference!
  noinline proc spawner (var i: int)
  {
    --i;
//println$ "Spawn_each: " + i.str + " machine at address " + (v.i).C_hack::cast[address].str;
    var cls = (v.i (inp=iochans.i.0, out=io.out));
    spawn_fthread cls;
//println$ "Spawned " + i.str;
    if i>0 call spawner i;
  }

  spawner n.int;
 
/*
  for i in 0 ..< n.int do
    call spawner i;
  done
*/
  // now repeatedly read a  value and write it to each device
  while true do
    var inp = read io.inp;
//println$ "Send Each writing '" +inp.str+ "' devices";
    for i in 0..<n.int do 
      //println$ "Write #" + (i+1).str+"/"+n.str;
      write (iochans.i.1,inp);
    done
  done
}
 
begin
  println$ "TEST 7, alternatives";
  var b = Buffer (&sample);
  device bsrc = sendbuf b;

  with
    device white1 = skip_white;
    device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
    device white2 = skip_white;
    device produces = parse_strng ("::=");
    device white3 = skip_white;
    device hello = parse_strng('Prods');
    var seq = varray( white1, identifier,white2,produces, white3,hello);
  do
    device p1 = pipeline seq;
  done

  with
    device white1 = skip_white;
    device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
    device white2 = skip_white;
    device produces = parse_strng ("::=");
    device white3 = skip_white;
    device hello = parse_strng('"Bye"');
    var seq = varray( white1, identifier,white2,produces, white3,hello);
  do
    device p2 = pipeline seq;
  done

  var alts = varray (p1,p2);
  device talts = send_each alts;
  circuit 
   connect bsrc.out, talts.inp
   connect talts.out, showbuf.inp
  endcircuit
end

// THE FUN BIT!!


// This chip is interesting! It translates a Sym
// into a recognizer chip for that Sym!
//
// We do this so we can feed a sequence of Syms to it,
// and get back a sequence of chips we can pipeline
// together which is then a parser for that sequence of Syms!

typedef recognizer_t = (inp: %<Buffer, out: %>Buffer) -> 1 -> 0;

chip parse_nonterm (gmach:gmach_t) (s:string)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  var start,g = gmach;
  while true do
    var b = read io.inp;
    println$ "Invoking parser for nonterminal " + s;
    println$ "Input buffer position " + b.i.str;
    var maybe_machine = get g s;
    match maybe_machine with
    | None => 
      println$ "Can't find channels to talk to machine for nonterminal " + s;
      System::exit 1;
    | Some (ou,inp) =>
      //println$ "Found channels to talk to machine for nonterminal " + s;
      write (ou,b);
      var resul : Buffer = read inp;
      println$ "Got result from machine! " + resul.i.str; 
      write (io.out,resul);
    endmatch;
  done 
}

chip xlat_Sym  (g:gmach_t)
  connector io
    pin inp: %<Sym
    pin out: %>recognizer_t
{
  while true do
    var sym = read io.inp;
    match sym with
    | Term s =>
//println$ "xlat_Sym constructing matcher for Terminal '" + s + "'";
      device d = parse_strng s;
      write (io.out, d);

    | Nonterm s =>
//println$ "xlat_Sym constructing matcher for Nonterminal " + s;
      // NOTE: LAZY! VITAL!
      device p = parse_nonterm g s;
      write (io.out, p);
    endmatch;
  done
}

chip xlat_prod (g:gmach_t) 
  connector io
    pin inp: %<list[Sym]
    pin out: %>varray[recognizer_t]
{
  while true do
    var syms = read io.inp;
    var v = varray[recognizer_t] (syms.len);
//println$ "Xlat prod, varray at " + v.C_hack::cast[address].str;
    var isym,osym = mk_ioschannel_pair[Sym]();
    var irek,orek = mk_ioschannel_pair[recognizer_t]();
    device xlat = xlat_Sym g;
    circuit
      wire isym to xlat.inp
      wire orek to xlat.out 
    endcircuit
    for sym in syms do
//println$ "Calling xlat_sym to make matcher for " + sym.str;
      write (osym, sym);
      var r = read irek;
      push_back(v,r);
    done
//println$ "Got product matchers in varray len " + v.len.str;
    write (io.out, v);
  done
}

typedef gmach_t = string * strdict[%>Buffer * %<Buffer];

chip xlat_gram
  connector io
    pin inp: %<grammar_t
    pin out: %>gmach_t
{

  var gram = read io.inp;
  var start,g = gram;
  var gmach = strdict[%>Buffer * %<Buffer] ();
 
  // circuit to convert list of Sym into a varray of recognizers
  var ils,ols = mk_ioschannel_pair[list[Sym]]();
  var ivr,ovr = mk_ioschannel_pair[varray[recognizer_t]]();
  device xlp = xlat_prod (start,gmach);
  circuit
    wire ils to xlp.inp
    wire ovr to xlp.out
  endcircuit


  for ntdef in g do
    match ntdef with
    | nt,alts =>
      println$ nt + " ::= " ;
      var newalts = varray[recognizer_t] (alts.len);
      for prod in alts do
        println$ "  |  " + prod.str;
        write (ols, prod);
        var r = read ivr;
        //println$ "Product array length " + r.len.str;
        device p = pipeline r; 
        push_back (newalts,p);
        //println$ "Added production pipeline to varray of alternatives, now length " + newalts.len.str;
      done
      //println$ "Combining " + newalts.len.str + " alternatives into recognizer for non-terminal " + nt;
      device rk = send_each newalts;
      var ibin,obin = mk_ioschannel_pair[Buffer] (); // send buffer to recognizer
      var ibout,obout = mk_ioschannel_pair[Buffer] (); // read result buffer from recognizer
      circuit
        wire ibin to rk.inp
        wire obout to rk.out
      endcircuit
      var chans = obin, ibout; // write to chan0, read result from chan1
      add gmach nt chans;
      println$ "Added recognizer for " + nt;
    endmatch;
  done
  write (io.out,(start,gmach));
}

begin
  println$ "TEST 8, grammar";
  var b = Buffer (&sample);

  device tsamp  = tsrc &b;
  var gram_in, gram_out = mk_ioschannel_pair[grammar_t]();
  circuit
    connect tsamp.out, parseprod.inp
    connect parseprod.out, collate.inp 
    connect collate.out, check_closure.inp
    wire gram_out to check_closure.out
  endcircuit
  var g = read gram_in;
  println$ "GRAMMAR " + g.str;

  var gi,go = mk_ioschannel_pair[gmach_t]();
  circuit
    wire gram_in to xlat_gram.inp
    wire go to xlat_gram.out
  endcircuit
  write (gram_out,g);
  var start,machine = read gi;
  println$ "Read grammar machine with nonterminals: ";
  for kv in machine do
    match kv with
    | k,_ =>
     println$ "Nonterminal " + k;
    endmatch;
  done
  // now, run the machine ..
  // find the io channels
  b = Buffer (&sample);
  println$ "Starting Parse ..";
  match get machine start with
  | None => 
    println$ "Can't find start symbol " + start + " in machine";
    System::exit 1;
  | Some (start_out,result_inp) =>
    println$ "Off we go  ..";
    write (start_out,b);
    var result = read result_inp;
    println$ "Parse completed with buffer pos = " + result.i.str;
  endmatch;
end
