// Grammar

// A simple parser for BNF

union Sym =
  | Term of string
  | Nonterm of string
;

instance Str[Sym] {
  fun str: Sym -> string =
  | Term s => '"' + s + '"'
  | Nonterm s => s
  ;
}

typedef prod_t = (nt:string, rhs: list[Sym]);

union token_t =
  | Name of string
  | Strng of string
  | Semi
  | Produces // ::=
  | Eof
;

instance Str[token_t] {
  fun str : token_t -> string =
  | Name s => "Name " + s
  | Strng s => "String " + s
  | Semi => ";"
  | Produces => "::="
  | Eof => "EOF"
  ;
}

struct Buffer 
{
  s: StringPiece;
  i: size;
  fun atend => self.i >= self.s.len;
  fun get => 
    if self.atend then char "" 
    else *(self.s.data+self.i)
  ;
  proc next  { 
    if self*.i < self*.s.len perform pre_incr self.i;
  }
}

ctor Buffer (s:&string) =>
  Buffer (StringPiece s, 0uz)
;

gen tokenise (b:&Buffer) : token_t = 
{
skipwhite:>
  if b*.get == char "" return Eof;

  if b*.get.ord <= " ".char.ord do
    b.next;
    goto skipwhite;
  done

  if isidstart b*.get do
    var id = "" + b*.get;
    b.next;
    while iscidcont b*.get do
      id += b*.get;
      b.next;
    done
    return Name id;

  elif b*.get == char ";" do
    b.next;
    return Semi;

  elif b*.get == char ":" do
    b.next;
    if b*.get != char ":" do
      println$ "Expected : to follow :";
      System::exit 1;
    done
    b.next;
    if b*.get != char "=" do
      println$ "Expected = to follow ::";
      System::exit 1;
    done
    b.next;
    return Produces;

  elif b*.get == char '"' do
    b.next;
    var s = "";
    while b*.get != char '"' do // add escapes later
      s += b*.get;
      b.next;
    done
    b.next;
    return Strng s;

  else 
    println$ "Error char " + b*.get + " at pos " + b*.i.str;
    System::exit 1;
  done

}

chip tsrc (b: &Buffer)
  connector tif
    pin out : %>token_t
{
  while not b*.atend do
    var token = tokenise b;
    write (tif.out,token);
  done
}

chip ptoks 
  connector tif
    pin inp : %<token_t
{
  while true do
    var token = read tif.inp;
    print$ token.str;
    match token with
    | Eof
    | Semi => println$ "";
    | _ => print " ";
    endmatch;
  done 
}

// test

var sample = """
  Grammar ::= Prods ;
  Prods ::= Prod ;
  Prods ::= Prod Prods;
  Prod ::= Name "::=" Syms ;
  Syms ::= Sym ;
  Syms ::= Sym Syms ;
  Sym ::= Terminal ;
  Sym ::= Name ;
  Terminal ::= "::=" ;
  Terminal ::= ";";
  Name ::= "Grammar";
  Name ::= "Prods";
  Name ::= "Prod";
  Name ::= "Syms";
  Name ::= "Sym";
  Name ::= "Terminal";
  Name ::= "Name";
""";


begin
  println$ "TEST 1, tokenision";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, ptoks.inp
  endcircuit
end

chip parseprod
  connector tif
    pin inp : %<token_t
    pin out: %>opt[prod_t]
{
restart:>
   var token = read tif.inp;
   match token with
   | Eof => 
     write(tif.out, None[prod_t]); 
     return;

   | Name s =>
     var name = s;
     goto l2;

   | _ => 
     println$ "Error, expected name on LHS of production";
     return; // suicide
   endmatch;

l2:>
   token = read tif.inp;
   match token with
   | Produces =>
     goto l3;
   | _ =>
     println$ "Error, expected ::= after LHS of production";
     return;
   endmatch;

l3:>
   var symbols =  Empty[Sym];
l4:>
   token = read tif.inp;
   match token with
   | Semi => 
     write (tif.out, Some (nt = name, rhs = rev symbols));
     goto restart;
   | Name s =>
     symbols = Nonterm s ! symbols;
     goto l4;
   | Strng s =>
     symbols = Term s ! symbols;
     goto l4;
   | _ => 
     println$ "Error, expected Name, String, or Semicolon in RHS of production";
     return;
   endmatch;
}

chip printprod
  connector pr
    pin inp : %<opt[prod_t]
{
  while true do
    var p = read pr.inp;
    match p with
    | None => println$ "Eof";
    | Some p => 
      println$ p.nt + " ::= " + catmap " " (str of Sym) p.rhs + ";"; 
    endmatch;
  done 
}

begin
  println$ "TEST 2, parsing";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, parseprod.inp 
    connect parseprod.out, printprod.inp
  endcircuit
end

typedef alts_t = list[list[Sym]];
typedef grammar_t = string * strdict[alts_t];

chip collate
  connector pr
    pin inp : %<opt[prod_t]
    pin out : %>grammar_t
{
nextg:>
  var start = "";
  var g = strdict[alts_t]();
nextp:>
  var p = read pr.inp;
  match p with 
  | None => 
    write(pr.out,(start,g));
    goto nextg;

  | Some p =>
    if start == "" perform start = p.nt;
    var alts = get_dflt g (p.nt, Empty[list[Sym]]);
    add g p.nt (p.rhs ! alts);
    goto nextp;
  endmatch;
}

chip pgram 
  connector gr
    pin inp : %<grammar_t
{
  while true do
    var g = read gr.inp;
    println$ g.str;
  done
}

begin
  println$ "TEST 3, collation";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, parseprod.inp
    connect parseprod.out, collate.inp 
    connect collate.out, pgram.inp
  endcircuit
end

chip check_closure
  connector gr
   pin inp : %<grammar_t
   pin out : %>grammar_t
{
  var ok = true;
  var start,g = read gr.inp;
  for alt in g 
    for prod in alt.1 
      for sym in prod do
        match sym with
        | Term _ => ;
        | Nonterm s =>
          if not (haskey g s) do
            println$ "Nontermial " + s + " not defined";
            ok = false;
          done
        endmatch;
      done
  if ok call
    write (gr.out, (start,g));
}

begin
  println$ "TEST 4, closure";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  circuit
    connect tsamp.out, parseprod.inp
    connect parseprod.out, collate.inp 
    connect collate.out, check_closure.inp
    connect check_closure.out, pgram.inp
  endcircuit
end

// upgrade to skip C++ comments later
chip skip_white 
  connector buf
    pin inp : %<Buffer
    pin out : %>Buffer
{
  var b = read buf.inp;
  while b.get <= char ' ' and b.get != char "" perform b&.next;
  write (buf.out, b);
}

chip parse_strng (s:string)
  connector buf
    pin inp : %<Buffer
    pin out : %>Buffer 
{
  var b = read buf.inp;
  for ch in s do
    if ch != b.get return;
    &b.next;
  done
  println$ "string "+s+"  matched";
  write (buf.out, b); 
}

chip parse_regex (re:RE2)
  connector buf
    pin inp : %<Buffer
    pin out : %>Buffer 
{
  var b = read buf.inp;
  var v = StringPiece "";
  var result = Match (re, b.s, b.i.int, ANCHOR_START, (+&v), 1);
  if result do 
    println$ "Re matched " + v.str;
    b&.i <- b.i + v.len;
    write (buf.out, b); 
  done
}

chip sendbuf (b:Buffer)
  connector buf
    pin out: %>Buffer
{
  write (buf.out,b);
}

chip showbuf 
  connector buf
    pin inp: %<Buffer
{
  while true do
    var b = read buf.inp;
    println$ "Buffer pos = " + b.i.str;
  done
}

// test white, string, re matching
// forced sequence protocol
begin
  println$ "TEST 5, white, string, re matches, manual sequence";
  var b = Buffer (&sample);

  device bsrc = sendbuf b;
  device white1 = skip_white;
  device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
  device white2 = skip_white;
  device produces = parse_strng ("::=");
  device white3 = skip_white;
  device hello = parse_strng('"Hello"');
  circuit
     connect bsrc.out, white1.inp
     connect white1.out, identifier.inp
     connect identifier.out, white2.inp
     connect white2.out, produces.inp
     connect produces.out, white3.inp
     connect white3.out, hello.inp
     connect hello.out, showbuf.inp
  endcircuit
end

chip pipeline[T] (v: varray [(inp:%<T, out:%>T) -> 1 -> 0]) 
  connector io
    pin inp: %<T
    pin out: %>T
{
  var input = io.inp;
  for i in 0..(v.len.int - 2) do
    var nextinp,out = mk_ioschannel_pair[T]();
    spawn_fthread (v.i (inp=input,out=out));
    input = nextinp;
  done
  spawn_fthread (v.(v.len.int - 1) (inp=input, out=io.out));
}

begin
  println$ "TEST 6, pipeline";
  var b = Buffer (&sample);
  device bsrc = sendbuf b;

  device white1 = skip_white;
  device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
  device white2 = skip_white;
  device produces = parse_strng ("::=");
  device white3 = skip_white;
  device hello = parse_strng('"Hello"');
  var seq = varray( white1, identifier,white2,produces, white3,hello);
  device p = pipeline seq;
  circuit
    connect bsrc.out, p.inp
    connect p.out, showbuf.inp
  endcircuit
end

// latch reads a value and writes to all
// connected readers
chip latch[T] 
  connector lat
    pin inp: %<T
    pin out: %>T
{
  var x = read lat.inp;
  while true do
    write (lat.out,x);
  done
}

chip tee[T,U] (v: varray [(inp:%<T, out: %>U) -> 1 -> 0])
  connector io
    pin inp: %<T
    pin out: %>U
{
   device l = latch[T];
   var lread,lout = mk_ioschannel_pair[T]();
   circuit 
     wire io.inp to l.inp
     wire lout to l.out
   endcircuit

   for p in v do
     spawn_pthread (p (inp=lread, out=io.out));
   done
}

begin
  println$ "TEST 7, alternatives";
  var b = Buffer (&sample);
  device bsrc = sendbuf b;

  with
    device white1 = skip_white;
    device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
    device white2 = skip_white;
    device produces = parse_strng ("::=");
    device white3 = skip_white;
    device hello = parse_strng('"Hello"');
    var seq = varray( white1, identifier,white2,produces, white3,hello);
  do
    device p1 = pipeline seq;
  done

  with
    device white1 = skip_white;
    device identifier = parse_regex (RE2 "[A-Za-z][A-Za-z0-9]*");
    device white2 = skip_white;
    device produces = parse_strng ("::=");
    device white3 = skip_white;
    device hello = parse_strng('"Bye"');
    var seq = varray( white1, identifier,white2,produces, white3,hello);
  do
    device p2 = pipeline seq;
  done

  var alts = varray (p1,p2);
  device talts = tee alts;
  circuit 
   connect bsrc.out, talts.inp
   connect talts.out, showbuf.inp
  endcircuit
end

// This chip is interesting! It translates a Sym
// into a recognizer chip for that Sym!
//
// We do this so we can feed a sequence of Syms to it,
// and get back a sequence of chips we can pipeline
// together which is then a parser for that sequence of Syms!

typedef recognizer_t = (inp: %<Buffer, out: %>Buffer) -> 1 -> 0;

chip parse_nonterm (g:grammar_t) (s:string)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
}

chip xlat_Sym  (g:grammar_t)
  connector io
    pin inp: %<Sym
    pin out: %>recognizer_t
{
  while true do
    var sym = read io.inp;
    match sym with
    | Term s =>
      device d = parse_strng s;
      write (io.out, d);

    | Nonterm s =>
      // NOTE: LAZY! VITAL!
      device p = parse_nonterm g s;
      write (io.out, p);
    endmatch;
  done
}

chip xlat_prod (g:grammar_t) 
  connector io
    pin inp: %<list[Sym]
    pin out: %>varray[recognizer_t]
{
  var syms = read io.inp;
  var v = varray[recognizer_t] (syms.len);
  var isym,osym = mk_ioschannel_pair[Sym]();
  var irek,orek = mk_ioschannel_pair[recognizer_t]();
  device xlat = xlat_Sym g;
  circuit
    wire isym to xlat.inp
    wire orek to xlat.out 
  endcircuit
  for sym in syms do
    write (osym, sym);
    var r = read irek;
    push_back(v,r);
  done
  write (io.out, v);
}


chip parse (gram:grammar_t) 
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  var start, g = gram;
  var b = read io.inp;
  var maybe_alts = get g start;
  match maybe_alts with 
  | None => println$ "Error, can't find start symbol " + start;
  | Some alts =>
    println$ "Got alternatives for start symbol " + start;
    for alt in alts do
      println$ alt;
    done
   // Each alternative is a list of Sym
   // We have to translate each alternative to a varray of chips
   for alt in alts do
     for sym in alt do
     done
   done
  endmatch;
}

begin
  println$ "TEST 8, grammar";
  var b = Buffer (&sample);
  device tsamp  = tsrc &b;
  var gram_in, gram_out = mk_ioschannel_pair[grammar_t]();
  circuit
    connect tsamp.out, parseprod.inp
    connect parseprod.out, collate.inp 
    connect collate.out, check_closure.inp
    wire gram_out to check_closure.out
  endcircuit

  var g = read gram_in;
  println$ "GRAMMAR " + g.str;
  device parser = parse g;
  device bsrc = sendbuf b;
  circuit
    connect bsrc.out, parser.inp
    connect parser.out, showbuf.inp
  endcircuit 
end
